{"0": "Programming PythonFOURTH EDITION\nProgramming Python\nMark Lutz\nBeijing \u2022 Cambridge \u2022 Farnham \u2022 K\u00f6ln \u2022 Sebastopol \u2022 TokyoProgramming Python, Fourth Edition\nby Mark Lutz\nCopyright \u00a9 2011 Mark Lutz. All rights reserved.\nPrinted in the United States of America.\nPublished by O\u2019Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA 95472.\nO\u2019Reilly books may be purchased for educational, business, or sales promotional use. Online editions\nare also available for most titles (http://my.safaribooksonline.com). For more information, contact our\ncorporate/institutional sales department: (800) 998-9938 or corporate@oreilly.com.\nEditor: Julie Steele\nProduction Editor: Teresa Elsey\nProofreader: Teresa Elsey\nIndexer: Lucie Haskins\nCover Designer: Karen Montgomery\nInterior Designer: David Futato\nIllustrator: Robert Romano\nPrinting History:\nOctober 1996:\nFirst Edition. \nMarch 2001:\nSecond Edition. \nAugust 2006:\nThird Edition. \nDecember 2010:\nFourth Edition. \nNutshell Handbook, the Nutshell Handbook logo, and the O\u2019Reilly logo are registered trademarks of\nO\u2019Reilly Media, Inc. Programming Python, the image of an African rock python, and related trade dress\nare trademarks of O\u2019Reilly Media, Inc.\nMany of the designations used by manufacturers and sellers to distinguish their products are claimed as\ntrademarks. Where those designations appear in this book, and O\u2019Reilly Media, Inc., was aware of a\ntrademark claim, the designations have been printed in caps or initial caps.\nWhile every precaution has been taken in the preparation of this book, the publisher and author assume\nno responsibility for errors or omissions, or for damages resulting from the use of the information con-\ntained herein.\nISBN: 978-0-596-15810-1\n[QG]\n1292258056Table of Contents\nPreface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  xxiii\nPart I. The Beginning \n1. A Sneak Preview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3\n\u201cProgramming Python: The Short Story\u201d\n3\nThe Task\n4\nStep 1: Representing Records\n4\nUsing Lists\n4\nUsing Dictionaries\n9\nStep 2: Storing Records Persistently\n14\nUsing Formatted Files\n14\nUsing Pickle Files\n19\nUsing Per-Record Pickle Files\n22\nUsing Shelves\n23\nStep 3: Stepping Up to OOP\n26\nUsing Classes\n27\nAdding Behavior\n29\nAdding Inheritance\n29\nRefactoring Code\n31\nAdding Persistence\n34\nOther Database Options\n36\nStep 4: Adding Console Interaction\n37\nA Console Shelve Interface\n37\nStep 5: Adding a GUI\n40\nGUI Basics\n40\nUsing OOP for GUIs\n42\nGetting Input from a User\n44\nA GUI Shelve Interface\n46\nStep 6: Adding a Web Interface\n52\nCGI Basics\n52\nvRunning a Web Server\n55\nUsing Query Strings and urllib\n57\nFormatting Reply Text\n59\nA Web-Based Shelve Interface\n60\nThe End of the Demo\n69\nPart II. System Programming \n2. System Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  73\n\u201cThe os.path to Knowledge\u201d\n73\nWhy Python Here?\n73\nThe Next Five Chapters\n74\nSystem Scripting Overview\n75\nPython System Modules\n76\nModule Documentation Sources\n77\nPaging Documentation Strings\n78\nA Custom Paging Script\n79\nString Method Basics\n80\nOther String Concepts in Python 3.X: Unicode and bytes\n82\nFile Operation Basics\n83\nUsing Programs in Two Ways\n84\nPython Library Manuals\n85\nCommercially Published References\n86\nIntroducing the sys Module\n86\nPlatforms and Versions\n86\nThe Module Search Path\n87\nThe Loaded Modules Table\n88\nException Details\n89\nOther sys Module Exports\n90\nIntroducing the os Module\n90\nTools in the os Module\n90\nAdministrative Tools\n91\nPortability Constants\n92\nCommon os.path Tools\n92\nRunning Shell Commands from Scripts\n94\nOther os Module Exports\n100\n3. Script Execution Context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  103\n\u201cI\u2019d Like to Have an Argument, Please\u201d\n103\nCurrent Working Directory\n104\nCWD, Files, and Import Paths\n104\nCWD and Command Lines\n106\nvi | Table of ContentsCommand-Line Arguments\n106\nParsing Command-Line Arguments\n107\nShell Environment Variables\n109\nFetching Shell Variables\n110\nChanging Shell Variables\n111\nShell Variable Fine Points: Parents, putenv, and getenv\n112\nStandard Streams\n113\nRedirecting Streams to Files and Programs\n114\nRedirected Streams and User Interaction\n119\nRedirecting Streams to Python Objects\n123\nThe io.StringIO and io.BytesIO Utility Classes\n126\nCapturing the stderr Stream\n127\nRedirection Syntax in Print Calls\n127\nOther Redirection Options: os.popen and subprocess Revisited\n128\n4. File and Directory Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  135\n\u201cErase Your Hard Drive in Five Easy Steps!\u201d\n135\nFile Tools\n135\nThe File Object Model in Python 3.X\n136\nUsing Built-in File Objects\n137\nBinary and Text Files\n146\nLower-Level File Tools in the os Module\n155\nFile Scanners\n160\nDirectory Tools\n163\nWalking One Directory\n164\nWalking Directory Trees\n168\nHandling Unicode Filenames in 3.X: listdir, walk, glob\n172\n5. Parallel System Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  177\n\u201cTelling the Monkeys What to Do\u201d\n177\nForking Processes\n179\nThe fork/exec Combination\n182\nThreads\n186\nThe _thread Module\n189\nThe threading Module\n199\nThe queue Module\n204\nPreview: GUIs and Threads\n208\nMore on the Global Interpreter Lock\n211\nProgram Exits\n213\nsys Module Exits\n214\nos Module Exits\n215\nShell Command Exit Status Codes\n216\nProcess Exit Status and Shared State\n219\nTable of Contents | viiThread Exits and Shared State\n220\nInterprocess Communication\n222\nAnonymous Pipes\n224\nNamed Pipes (Fifos)\n234\nSockets: A First Look\n236\nSignals\n240\nThe multiprocessing Module\n243\nWhy multiprocessing?\n243\nThe Basics: Processes and Locks\n245\nIPC Tools: Pipes, Shared Memory, and Queues\n248\nStarting Independent Programs\n254\nAnd Much More\n256\nWhy multiprocessing? The Conclusion\n257\nOther Ways to Start Programs\n258\nThe os.spawn Calls\n258\nThe os.startfile call on Windows\n261\nA Portable Program-Launch Framework\n263\nOther System Tools Coverage\n268\n6. Complete System Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  271\n\u201cThe Greps of Wrath\u201d\n271\nA Quick Game of \u201cFind the Biggest Python File\u201d\n272\nScanning the Standard Library Directory\n272\nScanning the Standard Library Tree\n273\nScanning the Module Search Path\n274\nScanning the Entire Machine\n276\nPrinting Unicode Filenames\n279\nSplitting and Joining Files\n282\nSplitting Files Portably\n283\nJoining Files Portably\n286\nUsage Variations\n289\nGenerating Redirection Web Pages\n292\nPage Template File\n293\nPage Generator Script\n294\nA Regression Test Script\n297\nRunning the Test Driver\n299\nCopying Directory Trees\n304\nComparing Directory Trees\n308\nFinding Directory Differences\n309\nFinding Tree Differences\n311\nRunning the Script\n314\nVerifying Backups\n316\nReporting Differences and Other Ideas\n317\nviii | Table of ContentsSearching Directory Trees\n319\nGreps and Globs and Finds\n320\nRolling Your Own find Module\n321\nCleaning Up Bytecode Files\n324\nA Python Tree Searcher\n327\nVisitor: Walking Directories \u201c++\u201d\n330\nEditing Files in Directory Trees (Visitor)\n334\nGlobal Replacements in Directory Trees (Visitor)\n336\nCounting Source Code Lines (Visitor)\n338\nRecoding Copies with Classes (Visitor)\n339\nOther Visitor Examples (External)\n341\nPlaying Media Files\n343\nThe Python webbrowser Module\n347\nThe Python mimetypes Module\n348\nRunning the Script\n350\nAutomated Program Launchers (External)\n351\nPart III. GUI Programming \n7. Graphical User Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 355\n\u201cHere\u2019s Looking at You, Kid\u201d\n355\nGUI Programming Topics\n355\nRunning the Examples\n357\nPython GUI Development Options\n358\ntkinter Overview\n363\ntkinter Pragmatics\n363\ntkinter Documentation\n364\ntkinter Extensions\n364\ntkinter Structure\n366\nClimbing the GUI Learning Curve\n368\n\u201cHello World\u201d in Four Lines (or Less)\n368\ntkinter Coding Basics\n369\nMaking Widgets\n370\nGeometry Managers\n370\nRunning GUI Programs\n371\ntkinter Coding Alternatives\n372\nWidget Resizing Basics\n373\nConfiguring Widget Options and Window Titles\n375\nOne More for Old Times\u2019 Sake\n376\nPacking Widgets Without Saving Them\n377\nAdding Buttons and Callbacks\n379\nWidget Resizing Revisited: Expansion\n380\nTable of Contents | ixAdding User-Defined Callback Handlers\n382\nLambda Callback Handlers\n383\nDeferring Calls with Lambdas and Object References\n384\nCallback Scope Issues\n385\nBound Method Callback Handlers\n391\nCallable Class Object Callback Handlers\n392\nOther tkinter Callback Protocols\n393\nBinding Events\n394\nAdding Multiple Widgets\n395\nWidget Resizing Revisited: Clipping\n396\nAttaching Widgets to Frames\n397\nLayout: Packing Order and Side Attachments\n397\nThe Packer\u2019s Expand and Fill Revisited\n398\nUsing Anchor to Position Instead of Stretch\n399\nCustomizing Widgets with Classes\n400\nStandardizing Behavior and Appearance\n401\nReusable GUI Components with Classes\n403\nAttaching Class Components\n405\nExtending Class Components\n407\nStandalone Container Classes\n408\nThe End of the Tutorial\n410\nPython/tkinter for Tcl/Tk Converts\n412\n8. A tkinter Tour, Part 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  415\n\u201cWidgets and Gadgets and GUIs, Oh My!\u201d\n415\nThis Chapter\u2019s Topics\n415\nConfiguring Widget Appearance\n416\nTop-Level Windows\n419\nToplevel and Tk Widgets\n421\nTop-Level Window Protocols\n422\nDialogs\n426\nStandard (Common) Dialogs\n426\nThe Old-Style Dialog Module\n438\nCustom Dialogs\n439\nBinding Events\n443\nOther bind Events\n447\nMessage and Entry\n448\nMessage\n448\nEntry\n449\nLaying Out Input Forms\n451\ntkinter \u201cVariables\u201d and Form Layout Alternatives\n454\nCheckbutton, Radiobutton, and Scale\n457\nCheckbuttons\n457\nx | Table of ContentsRadio Buttons\n462\nScales (Sliders)\n467\nRunning GUI Code Three Ways\n471\nAttaching Frames\n471\nIndependent Windows\n476\nRunning Programs\n478\nImages\n484\nFun with Buttons and Pictures\n487\nViewing and Processing Images with PIL\n491\nPIL Basics\n491\nDisplaying Other Image Types with PIL\n493\nCreating Image Thumbnails with PIL\n496\n9. A tkinter Tour, Part 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  507\n\u201cOn Today\u2019s Menu: Spam, Spam, and Spam\u201d\n507\nMenus\n507\nTop-Level Window Menus\n508\nFrame- and Menubutton-Based Menus\n512\nWindows with Both Menus and Toolbars\n517\nListboxes and Scrollbars\n522\nProgramming Listboxes\n524\nProgramming Scroll Bars\n525\nPacking Scroll Bars\n526\nText\n528\nProgramming the Text Widget\n530\nAdding Text-Editing Operations\n533\nUnicode and the Text Widget\n538\nAdvanced Text and Tag Operations\n548\nCanvas\n550\nBasic Canvas Operations\n550\nProgramming the Canvas Widget\n551\nScrolling Canvases\n554\nScrollable Canvases and Image Thumbnails\n557\nUsing Canvas Events\n560\nGrids\n564\nWhy Grids?\n564\nGrid Basics: Input Forms Revisited\n565\nComparing grid and pack\n566\nCombining grid and pack\n568\nMaking Gridded Widgets Expandable\n570\nLaying Out Larger Tables with grid\n574\nTime Tools, Threads, and Animation\n582\nUsing Threads with tkinter GUIs\n584\nTable of Contents | xiUsing the after Method\n585\nSimple Animation Techniques\n588\nOther Animation Topics\n593\nThe End of the Tour\n595\nOther Widgets and Options\n595\n10. GUI Coding Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  597\n\u201cBuilding a Better Mousetrap\u201d\n597\nGuiMixin: Common Tool Mixin Classes\n598\nWidget Builder Functions\n598\nMixin Utility Classes\n599\nGuiMaker: Automating Menus and Toolbars\n603\nSubclass Protocols\n607\nGuiMaker Classes\n608\nGuiMaker Self-Test\n608\nBigGui: A Client Demo Program\n609\nShellGui: GUIs for Command-Line Tools\n613\nA Generic Shell-Tools Display\n613\nApplication-Specific Tool Set Classes\n615\nAdding GUI Frontends to Command Lines\n617\nGuiStreams: Redirecting Streams to Widgets\n623\nUsing Redirection for the Packing Scripts\n627\nReloading Callback Handlers Dynamically\n628\nWrapping Up Top-Level Window Interfaces\n630\nGUIs, Threads, and Queues\n635\nPlacing Data on Queues\n636\nPlacing Callbacks on Queues\n640\nMore Ways to Add GUIs to Non-GUI Code\n646\nPopping Up GUI Windows on Demand\n647\nAdding a GUI As a Separate Program: Sockets (A Second Look)\n649\nAdding a GUI As a Separate Program: Command Pipes\n654\nThe PyDemos and PyGadgets Launchers\n662\nPyDemos Launcher Bar (Mostly External)\n662\nPyGadgets Launcher Bar\n667\n11. Complete GUI Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 671\n\u201cPython, Open Source, and Camaros\u201d\n671\nExamples in Other Chapters\n672\nThis Chapter\u2019s Strategy\n673\nPyEdit: A Text Editor Program/Object\n674\nRunning PyEdit\n675\nPyEdit Changes in Version 2.0 (Third Edition)\n682\nPyEdit Changes in Version 2.1 (Fourth Edition)\n684\nxii | Table of ContentsPyEdit Source Code\n693\nPyPhoto: An Image Viewer and Resizer\n716\nRunning PyPhoto\n717\nPyPhoto Source Code\n719\nPyView: An Image and Notes Slideshow\n727\nRunning PyView\n727\nPyView Source Code\n732\nPyDraw: Painting and Moving Graphics\n738\nRunning PyDraw\n738\nPyDraw Source Code\n738\nPyClock: An Analog/Digital Clock Widget\n747\nA Quick Geometry Lesson\n747\nRunning PyClock\n751\nPyClock Source Code\n754\nPyToe: A Tic-Tac-Toe Game Widget\n762\nRunning PyToe\n762\nPyToe Source Code (External)\n763\nWhere to Go from Here\n766\nPart IV. Internet Programming \n12. Network Scripting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  771\n\u201cTune In, Log On, and Drop Out\u201d\n771\nInternet Scripting Topics\n772\nRunning Examples in This Part of the Book\n775\nPython Internet Development Options\n777\nPlumbing the Internet\n780\nThe Socket Layer\n781\nThe Protocol Layer\n782\nPython\u2019s Internet Library Modules\n785\nSocket Programming\n787\nSocket Basics\n788\nRunning Socket Programs Locally\n794\nRunning Socket Programs Remotely\n795\nSpawning Clients in Parallel\n798\nTalking to Reserved Ports\n801\nHandling Multiple Clients\n802\nForking Servers\n803\nThreading Servers\n815\nStandard Library Server Classes\n818\nMultiplexing Servers with select\n820\nSummary: Choosing a Server Scheme\n826\nTable of Contents | xiiiMaking Sockets Look Like Files and Streams\n827\nA Stream Redirection Utility\n828\nA Simple Python File Server\n840\nRunning the File Server and Clients\n842\nAdding a User-Interface Frontend\n843\n13. Client-Side Scripting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 853\n\u201cSocket to Me!\u201d\n853\nFTP: Transferring Files over the Net\n854\nTransferring Files with ftplib\n854\nUsing urllib to Download Files\n857\nFTP get and put Utilities\n860\nAdding a User Interface\n867\nTransferring Directories with ftplib\n874\nDownloading Site Directories\n874\nUploading Site Directories\n880\nRefactoring Uploads and Downloads for Reuse\n884\nTransferring Directory Trees with ftplib\n892\nUploading Local Trees\n893\nDeleting Remote Trees\n895\nDownloading Remote Trees\n899\nProcessing Internet Email\n899\nUnicode in Python 3.X and Email Tools\n900\nPOP: Fetching Email\n901\nMail Configuration Module\n902\nPOP Mail Reader Script\n905\nFetching Messages\n906\nFetching Email at the Interactive Prompt\n909\nSMTP: Sending Email\n910\nSMTP Mail Sender Script\n911\nSending Messages\n913\nSending Email at the Interactive Prompt\n919\nemail: Parsing and Composing Mail Content\n921\nMessage Objects\n922\nBasic email Package Interfaces in Action\n924\nUnicode, Internationalization, and the Python 3.1 email Package\n926\nA Console-Based Email Client\n947\nRunning the pymail Console Client\n952\nThe mailtools Utility Package\n956\nInitialization File\n957\nMailTool Class\n958\nMailSender Class\n959\nMailFetcher Class\n967\nxiv | Table of ContentsMailParser Class\n976\nSelf-Test Script\n983\nUpdating the pymail Console Client\n986\nNNTP: Accessing Newsgroups\n991\nHTTP: Accessing Websites\n994\nThe urllib Package Revisited\n997\nOther urllib Interfaces\n999\nOther Client-Side Scripting Options\n1002\n14. The PyMailGUI Client . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1005\n\u201cUse the Source, Luke\u201d\n1005\nSource Code Modules and Size\n1006\nWhy PyMailGUI?\n1008\nRunning PyMailGUI\n1010\nPresentation Strategy\n1010\nMajor PyMailGUI Changes\n1011\nNew in Version 2.1 and 2.0 (Third Edition)\n1011\nNew in Version 3.0 (Fourth Edition)\n1012\nA PyMailGUI Demo\n1019\nGetting Started\n1020\nLoading Mail\n1025\nThreading Model\n1027\nLoad Server Interface\n1030\nOffline Processing with Save and Open\n1031\nSending Email and Attachments\n1033\nViewing Email and Attachments\n1037\nEmail Replies and Forwards and Recipient Options\n1043\nDeleting Email\n1049\nPOP Message Numbers and Synchronization\n1051\nHandling HTML Content in Email\n1053\nMail Content Internationalization Support\n1055\nAlternative Configurations and Accounts\n1059\nMultiple Windows and Status Messages\n1060\nPyMailGUI Implementation\n1062\nPyMailGUI: The Main Module\n1063\nSharedNames: Program-Wide Globals\n1066\nListWindows: Message List Windows\n1067\nViewWindows: Message View Windows\n1085\nmessagecache: Message Cache Manager\n1095\npopuputil: General-Purpose GUI Pop Ups\n1098\nwraplines: Line Split Tools\n1100\nhtml2text: Extracting Text from HTML (Prototype, Preview)\n1102\nmailconfig: User Configurations\n1105\nTable of Contents | xvtextConfig: Customizing Pop-Up PyEdit Windows\n1110\nPyMailGUIHelp: User Help Text and Display\n1111\naltconfigs: Configuring for Multiple Accounts\n1114\nIdeas for Improvement\n1116\n15. Server-Side Scripting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1125\n\u201cOh, What a Tangled Web We Weave\u201d\n1125\nWhat\u2019s a Server-Side CGI Script?\n1126\nThe Script Behind the Curtain\n1126\nWriting CGI Scripts in Python\n1128\nRunning Server-Side Examples\n1130\nWeb Server Options\n1130\nRunning a Local Web Server\n1131\nThe Server-Side Examples Root Page\n1133\nViewing Server-Side Examples and Output\n1134\nClimbing the CGI Learning Curve\n1135\nA First Web Page\n1135\nA First CGI Script\n1141\nAdding Pictures and Generating Tables\n1146\nAdding User Interaction\n1149\nUsing Tables to Lay Out Forms\n1157\nAdding Common Input Devices\n1163\nChanging Input Layouts\n1166\nPassing Parameters in Hardcoded URLs\n1170\nPassing Parameters in Hidden Form Fields\n1172\nSaving State Information in CGI Scripts\n1174\nURL Query Parameters\n1176\nHidden Form Input Fields\n1176\nHTTP \u201cCookies\u201d\n1177\nServer-Side Databases\n1181\nExtensions to the CGI Model\n1182\nCombining Techniques\n1183\nThe Hello World Selector\n1183\nChecking for Missing and Invalid Inputs\n1190\nRefactoring Code for Maintainability\n1192\nStep 1: Sharing Objects Between Pages\u2014A New Input Form\n1193\nStep 2: A Reusable Form Mock-Up Utility\n1196\nStep 3: Putting It All Together\u2014A New Reply Script\n1199\nMore on HTML and URL Escapes\n1201\nURL Escape Code Conventions\n1202\nPython HTML and URL Escape Tools\n1203\nEscaping HTML Code\n1203\nEscaping URLs\n1204\nxvi | Table of ContentsEscaping URLs Embedded in HTML Code\n1205\nTransferring Files to Clients and Servers\n1209\nDisplaying Arbitrary Server Files on the Client\n1211\nUploading Client Files to the Server\n1218\nMore Than One Way to Push Bits over the Net\n1227\n16. The PyMailCGI Server . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1229\n\u201cThings to Do When Visiting Chicago\u201d\n1229\nThe PyMailCGI Website\n1230\nImplementation Overview\n1230\nNew in This Fourth Edition (Version 3.0)\n1233\nNew in the Prior Edition (Version 2.0)\n1235\nPresentation Overview\n1236\nRunning This Chapter\u2019s Examples\n1237\nThe Root Page\n1239\nConfiguring PyMailCGI\n1240\nSending Mail by SMTP\n1241\nThe Message Composition Page\n1242\nThe Send Mail Script\n1242\nError Pages\n1246\nCommon Look-and-Feel\n1246\nUsing the Send Mail Script Outside a Browser\n1247\nReading POP Email\n1249\nThe POP Password Page\n1250\nThe Mail Selection List Page\n1251\nPassing State Information in URL Link Parameters\n1254\nSecurity Protocols\n1257\nThe Message View Page\n1259\nPassing State Information in HTML Hidden Input Fields\n1262\nEscaping Mail Text and Passwords in HTML\n1264\nProcessing Fetched Mail\n1266\nReply and Forward\n1267\nDelete\n1268\nDeletions and POP Message Numbers\n1272\nUtility Modules\n1276\nExternal Components and Configuration\n1276\nPOP Mail Interface\n1277\nPOP Password Encryption\n1278\nCommon Utilities Module\n1286\nWeb Scripting Trade-Offs\n1291\nPyMailCGI Versus PyMailGUI\n1292\nThe Web Versus the Desktop\n1293\nOther Approaches\n1296\nTable of Contents | xviiPart V. Tools and Techniques \n17. Databases and Persistence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1303\n\u201cGive Me an Order of Persistence, but Hold the Pickles\u201d\n1303\nPersistence Options in Python\n1303\nDBM Files\n1305\nUsing DBM Files\n1305\nDBM Details: Files, Portability, and Close\n1308\nPickled Objects\n1309\nUsing Object Pickling\n1310\nPickling in Action\n1311\nPickle Details: Protocols, Binary Modes, and _pickle\n1314\nShelve Files\n1315\nUsing Shelves\n1316\nStoring Built-in Object Types in Shelves\n1317\nStoring Class Instances in Shelves\n1318\nChanging Classes of Objects Stored in Shelves\n1320\nShelve Constraints\n1321\nPickled Class Constraints\n1323\nOther Shelve Limitations\n1324\nThe ZODB Object-Oriented Database\n1325\nThe Mostly Missing ZODB Tutorial\n1326\nSQL Database Interfaces\n1329\nSQL Interface Overview\n1330\nAn SQL Database API Tutorial with SQLite\n1332\nBuilding Record Dictionaries\n1339\nTying the Pieces Together\n1342\nLoading Database Tables from Files\n1344\nSQL Utility Scripts\n1347\nSQL Resources\n1354\nORMs: Object Relational Mappers\n1354\nPyForm: A Persistent Object Viewer (External)\n1356\n18. Data Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1359\n\u201cRoses Are Red, Violets Are Blue; Lists Are Mutable,\nand So Is Set Foo\u201d\n1359\nImplementing Stacks\n1360\nBuilt-in Options\n1360\nA Stack Module\n1362\nA Stack Class\n1364\nCustomization: Performance Monitors\n1366\nOptimization: Tuple Tree Stacks\n1367\nxviii | Table of ContentsOptimization: In-Place List Modifications\n1369\nTiming the Improvements\n1371\nImplementing Sets\n1373\nBuilt-in Options\n1374\nSet Functions\n1375\nSet Classes\n1377\nOptimization: Moving Sets to Dictionaries\n1378\nAdding Relational Algebra to Sets (External)\n1382\nSubclassing Built-in Types\n1383\nBinary Search Trees\n1385\nBuilt-in Options\n1385\nImplementing Binary Trees\n1386\nTrees with Both Keys and Values\n1388\nGraph Searching\n1390\nImplementing Graph Search\n1390\nMoving Graphs to Classes\n1393\nPermuting Sequences\n1395\nReversing and Sorting Sequences\n1397\nImplementing Reversals\n1398\nImplementing Sorts\n1399\nData Structures Versus Built-ins: The Conclusion\n1400\nPyTree: A Generic Tree Object Viewer\n1402\n19. Text and Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1405\n\u201cSee Jack Hack. Hack, Jack, Hack\u201d\n1405\nStrategies for Processing Text in Python\n1405\nString Method Utilities\n1406\nTemplating with Replacements and Formats\n1408\nParsing with Splits and Joins\n1409\nSumming Columns in a File\n1410\nParsing and Unparsing Rule Strings\n1412\nRegular Expression Pattern Matching\n1415\nThe re Module\n1416\nFirst Examples\n1416\nString Operations Versus Patterns\n1418\nUsing the re Module\n1421\nMore Pattern Examples\n1425\nScanning C Header Files for Patterns\n1427\nXML and HTML Parsing\n1429\nXML Parsing in Action\n1430\nHTML Parsing in Action\n1435\nAdvanced Language Tools\n1438\nCustom Language Parsers\n1440\nTable of Contents | xixThe Expression Grammar\n1440\nThe Parser\u2019s Code\n1441\nAdding a Parse Tree Interpreter\n1449\nParse Tree Structure\n1454\nExploring Parse Trees with the PyTree GUI\n1456\nParsers Versus Python\n1457\nPyCalc: A Calculator Program/Object\n1457\nA Simple Calculator GUI\n1458\nPyCalc\u2014A \u201cReal\u201d Calculator GUI\n1463\n20. Python/C Integration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1483\n\u201cI Am Lost at C\u201d\n1483\nExtending and Embedding\n1484\nExtending Python in C: Overview\n1486\nA Simple C Extension Module\n1487\nThe SWIG Integration Code Generator\n1491\nA Simple SWIG Example\n1491\nWrapping C Environment Calls\n1495\nAdding Wrapper Classes to Flat Libraries\n1499\nWrapping C Environment Calls with SWIG\n1500\nWrapping C++ Classes with SWIG\n1502\nA Simple C++ Extension Class\n1503\nWrapping the C++ Class with SWIG\n1505\nUsing the C++ Class in Python\n1507\nOther Extending Tools\n1511\nEmbedding Python in C: Overview\n1514\nThe C Embedding API\n1515\nWhat Is Embedded Code?\n1516\nBasic Embedding Techniques\n1518\nRunning Simple Code Strings\n1519\nRunning Code Strings with Results and Namespaces\n1522\nCalling Python Objects\n1524\nRunning Strings in Dictionaries\n1526\nPrecompiling Strings to Bytecode\n1528\nRegistering Callback Handler Objects\n1530\nRegistration Implementation\n1531\nUsing Python Classes in C\n1535\nOther Integration Topics\n1538\nxx | Table of ContentsPart VI. The End \n21. Conclusion: Python and the Development Cycle . . . . . . . . . . . . . . . . . . . . . . . . . . . 1543\n\u201cThat\u2019s the End of the Book, Now Here\u2019s the Meaning of Life\u201d\n1544\n\u201cSomething\u2019s Wrong with the Way We Program Computers\u201d\n1544\nThe \u201cGilligan Factor\u201d\n1544\nDoing the Right Thing\n1545\nThe Static Language Build Cycle\n1546\nArtificial Complexities\n1546\nOne Language Does Not Fit All\n1546\nEnter Python\n1547\nBut What About That Bottleneck?\n1548\nPython Provides Immediate Turnaround\n1549\nPython Is \u201cExecutable Pseudocode\u201d\n1550\nPython Is OOP Done Right\n1550\nPython Fosters Hybrid Applications\n1551\nOn Sinking the Titanic\n1552\nSo What\u2019s \u201cPython: The Sequel\u201d?\n1555\nIn the Final Analysis\u2026\n1555\nIndex . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1557\nTable of Contents | xxiPreface\n\u201cAnd Now for Something Completely Different\u2026\u201d\nThis book explores ways to apply the Python programming language in common ap-\nplication domains and realistically scaled tasks. It\u2019s about what you can do with the \nlanguage once you\u2019ve mastered its fundamentals.\nThis book assumes you are relatively new to each of the application domains it covers\u2014 \nGUIs, the Internet, databases, systems programming, and so on\u2014and presents each \nfrom the ground up, in tutorial fashion. Along the way, it focuses on commonly used \ntools and libraries, rather than language fundamentals. The net result is a resource that \nprovides readers with an in-depth understanding of Python\u2019s roles in practical, real-\nworld programming work.\nAs a subtheme, this book also explores Python\u2019s relevance as a software development \ntool\u2014a role that many would classify as well beyond those typically associated with \n\u201cscripting.\u201d In fact, many of this book\u2019s examples are scaled specifically for this pur-\npose; among these, we\u2019ll incrementally develop email clients that top out at thousands \nof lines of code. Programming at this full scale will always be challenging work, but \nwe\u2019ll find that it\u2019s also substantially quicker and easier when done with Python.\nThis Fourth Edition has been updated to present the language, libraries, and practice \nof Python 3.X. Specifically, its examples use Python 3.1\u2014the most recent version of \nPython at the time of writing\u2014and its major examples were tested successfully under \nthe third alpha release of Python 3.2 just prior to publication, but they reflect the version \nof the language common to the entire 3.X line. This edition has also been reorganized \nin ways that both streamline some of its former material and allow for coverage of newly \nemerged tools and topics.\nBecause this edition\u2019s readership will include both newcomers as well as prior edition \nveterans, I want to use this Preface to expand on this book\u2019s purpose and scope before \nwe jump into code.\nxxiiiAbout This Book\nThis book is a tutorial introduction to using Python in common application domains\nand tasks. It teaches how to apply Python for system administration, GUIs, and the\nWeb, and explores its roles in networking, databases, frontend scripting layers, text\nprocessing, and more. Although the Python language is used along the way, this book\u2019s\nfocus is on application to real-world tasks instead of language fundamentals.\nThis Book\u2019s Ecosystem\nBecause of its scope, this book is designed to work best as the second of a two-volume\nset, and to be supplemented by a third. Most importantly, this book is an applications\nprogramming follow-up to the core language book Learning Python, whose subjects\nare officially prerequisite material here. Here\u2019s how the three books are related:\n\u2022 Learning Python covers the fundamentals of Python programming in depth. It fo-\ncuses on the core Python language, and its topics are prerequisite to this book.\n\u2022 Programming Python, this book, covers the application of Python to real-world\nprogramming tasks. It focuses on libraries and tools, and it assumes you already\nknow Python fundamentals.\n\u2022 Python Pocket Reference provides a quick reference to details not listed exhaustively\nhere. It doesn\u2019t teach much, but it allows you to look up details fast.\nIn some sense, this book is to application programming what Learning Python is to the\ncore language\u2014a gradual tutorial, which makes almost no assumptions about your\nbackground and presents each topic from the ground up. By studying this book\u2019s cov-\nerage of Web basics, for example, you\u2019ll be equipped to build simple websites, and you\nwill be able to make sense of more advanced frameworks and tools as your needs evolve.\nGUIs are similarly taught incrementally, from basic to advanced.\nIn addition, this book is designed to be supplemented by the quick-reference book\nPython Pocket Reference, which provides the small details finessed here and serves as\na resource for looking up the fine points. That book is reference only, and is largely\nvoid of both examples and narrative, but it serves to augment and complement both\nLearning Python\u2019s fundamentals and Programming Python\u2019s applications. Because its\ncurrent Fourth Edition gives both Python 2.X and 3.X versions of the tools it covers,\nthat book also serves as a resource for readers transitioning between the two Python\nlines (more on this in a moment).*\n* Disclosure: I am the author of all three books mentioned in this section, which affords me the luxury of tightly\ncontrolling their scopes in order to avoid overlap. It also means that as an author, I try to avoid commenting\non the many other Python books available, some of which are very good and may cover topics not addressed\nin any of my own books. Please see the Web for other Python resources. All three of my books reflect my 13\nyears on the Python training trail and stem from the original Programming Python written back in 1995 <insert\ngrizzled prospector photo here>.\nxxiv | PrefaceWhat This Book Is Not\nBecause of the scopes carved out by the related books I just mentioned, this book\u2019s\nscope follows two explicit constraints:\n\u2022 It does not cover Python language fundamentals\n\u2022 It is not intended as a language reference\nThe former of these constraints reflects the fact that core language topics are the ex-\nclusive domain of Learning Python, and I encourage you to consult that book before\ntackling this one if you are completely new to the Python language, as its topics are\nassumed here. Some language techniques are shown by example in this book too, of\ncourse, and the larger examples here illustrate how core concepts come together into\nrealistic programs. OOP, for example, is often best sampled in the context of the larger\nprograms we\u2019ll write here. Officially, though, this book assumes you already know\nenough Python fundamentals to understand its example code. Our focus here is mostly\non libraries and tools; please see other resources if the basic code we\u2019ll use in that role\nis unclear.\nThe latter of the two constraints listed above reflects what has been a common mis-\nconception about this book over the years (indeed, this book might have been better\ntitled Applying Python had we been more clairvoyant in 1995). I want to make this as\nclear as I can: this is not a reference book. It is a tutorial. Although you can hunt for\nsome details using the index and table of contents, this book is not designed for that\npurpose. Instead, Python Pocket Reference provides the sort of quick reference to details\nthat you\u2019ll find useful once you start writing nontrivial code on your own. There are\nother reference-focused resources available, including other books and Python\u2019s own\nreference manuals set. Here, the goal is a gradual tutorial that teaches you how to apply\nPython to common tasks but does not document minute details exhaustively.\nAbout This Fourth Edition\nIf this is the first edition of this book you\u2019ve seen, you\u2019re probably less interested in\nrecent changes, and you should feel free to skip ahead past this section. For readers of\nprior editions, though, this Fourth Edition of this book has changed in three important\nways:\n\u2022 It\u2019s been updated to cover Python 3.X (only).\n\u2022 It\u2019s been slimmed down to sharpen its focus and make room for new topics.\n\u2022 It\u2019s been updated for newly emerged topics and tools in the Python world.\nThe first of these is probably the most significant\u2014this edition employs the Python 3.X\nlanguage, its version of the standard library, and the common practice of its users. To\nbetter explain how this and the other two changes take shape in this edition, though,\nI need to fill in a few more details.\nPreface | xxvSpecific Changes in This Edition\nBecause the prior versions of this book were widely read, here is a quick rundown of\nsome of the most prominent specific changes in this edition:\nIts existing material was shortened to allow for new topics\nThe prior edition of this book was also a 1600-page volume, which didn\u2019t allow\nmuch room for covering new Python topics (Python 3.X\u2019s Unicode orientation\nalone implies much new material). Luckily, recent changes in the Python world\nhave allowed us to pare down some less critical existing material this time around,\nin order to free up room for new coverage.\nDepth was not sacrificed in the process, of course, and this is still just as substantial\na book as before. In general, though, avoiding new growth was a primary goal of\nthis update; many of the other specific changes and removals I'll mention below\nwere made, in part, to help accommodate new topics.\nIt covers 3.X (only)\nThis book\u2019s examples and narrative have been updated to reflect and use the 3.X\nversion of Python. Python 2.X is no longer supported here, except where 3.X and\n2.X Pythons overlap. Although the overlap is large enough to make this of use to\n2.X readers too, this is now officially a 3.X-only text.\nThis turns out to be a major factor behind the lack of growth in this edition. By\nrestricting our scope to Python 3.X\u2014the incompatible successor to the Python 2.X\nline, and considered to be Python\u2019s future\u2014we were able to avoid doubling the\ncoverage size in places where the two Python lines differ. This version limit is es-\npecially important in a book like this that is largely about more advanced examples,\nwhich can be listed in only one version\u2019s style.\nFor readers who still straddle the 2.X and 3.X worlds, I\u2019ll say more about Python\n3.X changes later in this Preface. Probably the most significant 3.X-related change\ndescribed there is the new Internationalization support in PyEdit and PyMailGUI;\nthough 2.X had Unicode too, its new prominence in 3.X almost forces such systems\nto rethink their former ASCII-only ways.\nInclusion of newly emerged libraries and tools\nSince the prior edition, a variety of new libraries and tools have either come online\nor risen in popularity, and they get new mention here. This includes new standard\nlibrary tools such as subprocess (in Chapters 2 and 3) and multiprocessing (in\nChapter 5), as well as new third-party web frameworks and ORM database toolkits.\nMost of these are not covered extensively (many popular third-party extensions\nare complex systems in their own right and are best covered by dedicated books),\nbut they are at the least introduced in summary form here.\nFor example, Python 3.1\u2019s new tkinter.ttk Tk themed widget set shows up in\nChapter 7 now, but only briefly; as a rule, this edition prefers to mention such\nextensions in passing, rather than attempting to show you code without adequate\nexplanation.\nxxvi | PrefaceThis Preface was tightened up\nI\u2019ve removed all the instructions for using and running program examples. Instead,\nplease consult the README file in the examples distribution for example usage details.\nMoreover, most of the original acknowledgments are gone here because they are\nredundant with those in Learning Python; since that book is now considered a\nprerequisite, duplication of material here is unwarranted. A description of book\ncontents was also deleted; please see the table of contents for a preview of this\nbook\u2019s structure.\nThe initial Python overview chapter is gone\nI\u2019ve removed the prior edition\u2019s \u201cmanagerial summary\u201d chapter which introduced\nPython\u2019s strong points, prominent users, philosophies, and so on. Proselytizing\ndoes play an important role in a field that sometimes asks the \u201cwhy\u201d questions less\noften than it should. Indeed, if advocacy had not been part of the Python experi-\nence, we\u2019d probably all be using Perl or shell languages today!\nHowever, this chapter has now grown completely redundant with a similar chapter\nin Learning Python. Since that book is a precursor to this one, I opted to not devote\nspace to restating \u201cPythonista\u201d propaganda here (fun as it may be). Instead, this\nbook assumes you already know why Python is worth using, and we jump right\ninto applying it here.\nThe conclusion\u2019s postscripts are gone\nThis book\u2019s conclusion comes from the first edition, and it is now 15 years old.\nNaturally, some of it reflects the Python mindset from that period more than that\nof today. For example, its focus on Python\u2019s role in hybrid applications seemed\nmore important in 1995 than in 2010; in today\u2019s much larger Python world, most\nPython users never deal with linked-in C code at all.\nIn prior editions, I added postscripts for each edition to elaborate on and update\nthe ideas presented in the book\u2019s conclusion. These postscripts are gone now, re-\nplaced by a short note at the start of the conclusion. I opted to keep the conclusion\nitself, though, because it\u2019s still relevant to many readers and bears some historic\nvalue. Well, that, plus the jokes\u2026\nThe forewords are gone\nFor reasons similar to those of the prior two points, the accumulated forewords\nfrom the prior three editions were also dropped this time around. You can read all\nabout Python creator Guido van Rossum\u2019s historical rationale for Python\u2019s evolu-\ntion in numerous places on the Web, if you are so inclined. If you are interested in\nhow Python has changed technically over the years, see also the \u201cWhat\u2019s New\u201d\ndocuments that are part of the Python standard manuals set (available at http://\nwww.python.org/doc, and installed alongside Python on Windows and other\nplatforms).\nThe C integration part has been reduced to just one chapter\nI\u2019ve reduced the C extending and embedding part\u2019s material to one shorter chapter\nat the end of the tools part, which briefly introduces the core concepts in this\nPreface | xxviidomain. Only a fraction of Python users must care about linking in C libraries\ntoday, and those who do already have the skills required to read the larger and\nmore compete example of integration present in the source code of Python itself.\nThere is still enough to hint at possibilities here, but vast amounts of C code have\nbeen cut, in deference to the better examples you\u2019ll find in Python\u2019s own code.\nThe systems programming part was condensed and reworked\nThe former two larger system examples chapters have been merged into one shorter\none, with new or greatly rewritten examples. In fact, this part (Part II) was probably\noverhauled the most of any part in the book. It incorporates new tools such as\nsubprocess and multiprocessing, introduces sockets earlier, and removes dated\ntopics and examples still lingering from prior editions. Frankly, a few of the file-\noriented examples here dated back to the 1990s, and were overdue for a general\nrefresh. The initial chapter in this part was also split into two to make its material\neasier to read (shell context, including streams, gets its own chapter now), and a\nfew large program listings here (including the auto-configuring launcher scripts)\nare now external suggested reading.\nSome larger examples were removed (but are available in the examples distribution)\nAlong the same lines, two of the larger GUI examples in the prior edition, PyTree\nand PyForm, have been removed. Instead, their updated code is available in the\nbook\u2019s examples distribution package, as suggested supplemental reading. You\u2019ll\nstill find many larger examples covered and listed in this edition\u2014including both\nGUI- and Web-based renderings of full-featured email clients, along with image\nviewers, calculators, clocks, Unicode-aware text editors, drawing programs, re-\ngression test scripts, and more. However, because the code of the examples re-\nmoved doesn\u2019t add much to what is already covered, and because they were already\nlargely self-study examples anyhow, I\u2019ve made them optional and external to the\nprinted text in this edition.\nThe advanced Internet topics chapter was replaced by brief summaries\nI\u2019ve cut the advanced Internet topics chapter completely, leaving only simple sum-\nmaries at the start of the Internet part (intentionally mirroring the GUI option\nsummaries at the start of the GUI part). This includes prior coverage for tools such\nas the ZOPE web framework, COM, Windows active scripting and ASP,\nHTMLgen, Python Server Pages (PSP), Jython, and the now very dated Grail sys-\ntem. Some of these systems still receive honorable mention in the summaries, but\nnone are now presented in any sort of detail. Summaries of new tools (including\nmany of those listed in the following paragraph) were added to this set, but again,\nin brief fashion with no example code.\nDespite authors\u2019 best attempts to foresee the future, the Web domain evolves faster\nthan books like this can. For instance, Web frameworks like Django, Google\u2019s App\nEngine, TurboGears, pylons, and web2py are now popular alternatives to ZOPE.\nSimilarly, the .NET framework supersedes much of COM on Windows;\nIronPython now provides the same type of integration for .NET as Jython did first\nxxviii | Prefacefor Java; and active scripting has been eclipsed by AJAX and JavaScript-oriented\nframeworks on the client such as Flex, Silverlight, and pyjamas (generally known\ntoday as rich Internet applications, RIAs). Culture shift aside, the examples for-\nmerly presented in this category were by themselves also insufficient to either teach\nor do justice to the subject tools.\nRather than including incomplete (and nearly useless) coverage of tools that are\nprone to both evolution and demise during this edition\u2019s expected lifespan, I now\nprovide only brief overviews of the current hot topics in the Web domain, and I\nencourage readers to search the Web for more details. More to the point, the goal\nof the book you\u2019re reading is to impart the sort of in-depth knowledge of Internet\nand Web fundamentals that will allow you to use more advanced systems well,\nwhen you\u2019re ready to take the leap.\nOne exception here: the XML material of this prior chapter was spared and relo-\ncated in expanded form to the text processing chapter (where it probably belonged\nall along). In a related vein, the coverage of ZOPE\u2019s ZODB object-oriented database\nwas retained, although it was shortened radically to allow new coverage of ORMs\nsuch as SQLObject and SQLAlchemy (again, in overview form).\nUse of tools available for 3.X today\nAt this writing, Python 3.X is still in its adoption phase, and some of the third-party\ntools that this book formerly employed in its examples are still available in Python\n2.X form only. To work around this temporary flux, I\u2019ve changed some code to\nuse alternatives that already support 3.X today.\nThe most notable of these is the SQL database section\u2014this now uses the in-\nprocess SQLite library, which is a standard part of Python and already in 3.X form,\nrather than the enterprise-level MySQL interface which is still at 2.X today. Luckily,\nthe Python portable database API allows scripts to work largely the same on both,\nso this is a minor pragmatic sacrifice.\nOf special note, the PIL extension used to display JPEGs in the GUI part was ported\nto 3.1 just when it was needed for this update, thanks to Fredrik Lundh. It\u2019s still\nnot officially released in 3.X form as I submit the final draft of this book in July\n2010, but it should be soon, and 3.X patches are provided in the book examples\npackage as a temporary measure.\nAdvanced core language topics are not covered here\nMore advanced Python language tools such as descriptors, properties, decorators,\nmetaclasses, and Unicode text processing basics are all part of the core Python\nlanguage. Because of that, they are covered in the Fourth Edition of Learning Py-\nthon, not here. For example, Unicode text and the changes it implies for files,\nfilenames, sockets, and much more are discussed as encountered here, but the\nfundamentals of Unicode itself are not presented in complete depth. Some of the\ntopics in this category are arguably application-level related too (or at least of in-\nterest to tool builders and API developers in general), but their coverage in Learning\nPreface | xxixPython allows us to avoid additional growth here. Please see that book for more\non these subjects.\nOther random bits\nNaturally, there were additional smaller changes made along the way. For example,\ntkinter\u2019s grid method is used instead of pack for layout of most input forms, because\nit yields a more consistent layout on platforms where label font sizes don\u2019t match\nup with entry widget height (including on a Windows 7 netbook laptop, this edi-\ntion\u2019s development machine). There\u2019s also new material scattered throughout, in-\ncluding a new exploration of redirecting streams to sockets in the Internet part; a\nnew threaded and Unicode-aware \u201cgrep\u201d dialog and process-wide change tests on\nexit in the PyEdit example; and other things you are probably better off uncovering\nalong the way than reading further about in this Preface.\nI also finally replaced some remaining \u201c#\u201d comment blocks at the top of source\nfiles with docstrings (even, for consistency, in scripts not meant to be imported,\nthough some \u201c#\u201d lines are retained in larger examples to offset the text); changed\na few lingering \u201cwhile 1\u201d to \u201cwhile True\u201d; use += more often; and cleaned up a few\nother cases of now-dated coding patterns. Old habits may die hard, but such up-\ndates make the examples both more functional and more representative of com-\nmon practice today.\nAlthough new topics were added, all told, four chapters were cut outright (the non-\ntechnical introduction, one of the system example chapters, advanced Internet topics,\nand one integration chapter), some additional examples and material were trimmed\n(including PyForm and PyTree), and focus was deliberately restricted to Python 3.X\nand application fundamentals to conserve space.\nWhat\u2019s Left, Then?\nThe combined effect of all the changes just outlined is that this edition more concisely\nand sharply reflects its core focus\u2014that of a tutorial introduction to ways to apply\nPython in common programming domains. Nevertheless, as you can tell from this\nbook\u2019s page count, it is still a substantial and in-depth book, designed to be a first step\non your path to mastering realistic applications of Python.\nContrary to recent trends (and at some risk of being branded a heretic), I firmly believe\nthat the job of books like this one is to elevate their readers, not pander to them. Low-\nering the intellectual bar does a disservice both to readers and to the fields in which\nthey hope to work. While that means you won\u2019t find as many cartoons in this book as\nin some, this book also won\u2019t insult you by emphasizing entertainment at the expense\nof technical depth. Instead, the goal of my books is to impart sophisticated concepts\nin a satisfying and substantive way and to equip you with the tools you\u2019ll need in the\nreal world of software development.\nxxx | PrefaceThere are many types of learners, of course, and no one book can ever satisfy every\npossible audience. In fact, that\u2019s why the original version of this book later became two,\nwith language basics delegated to Learning Python. Moreover, one can make a case for\na distinction between programmers, who must acquire deep software development\nskills, and scripters, who do not. For some, a rudimentary knowledge of programming\nmay be enough to leverage a system or library that solves the problem at hand. That is,\nuntil their coding forays start encroaching on the realm of full-scale software engineer-\ning\u2014a threshold that can inspire disappointment at worst, but a better appreciation\nof the challenging nature of this field at best.\nNo matter which camp you\u2019re from, it\u2019s important to understand this book\u2019s intent up-\nfront. If you\u2019re looking for a shortcut to proficiency that\u2019s light on technical content,\nyou probably won\u2019t be happy with this book (or the software field in general). If your\ngoal is to master programming Python well, though, and have some fun along the way,\nyou\u2019ll probably find this book to be an important piece of your learning experience.\nAt the end of the day, learning to program well is much more demanding than implied\nby some contemporary media. If you\u2019re willing to invest the focus and effort required,\nthough, you\u2019ll find that it\u2019s also much more rewarding. This is especially true for those\nwho equip themselves for the journey with a programmer-friendly tool like Python.\nWhile no book or class can turn you into a Python \u201cMaster of the Universe\u201d by itself,\nthis book\u2019s goal is to help you get there, by shortening your start-up time and providing\na solid foundation in Python\u2019s most common application domains.\nPython 3.X Impacts on This Book\nAs mentioned, this edition now covers Python 3.X only. Python 3.X is an incompatible\nversion of the language. The 3.X core language itself is very similar to Python 2.X, but\nthere are substantial changes in both the language and its many standard libraries.\nAlthough some readers with no prior background in 2.X may be able to bypass the\ndifferences, the changes had a big impact on the content of this edition. For the still\nvery large existing Python 2.X user base, this section documents the most noteworthy\nchanges in this category.\nIf you\u2019re interested in 2.X differences, I also suggest finding a copy of the Fourth Edition\nof the book Python Pocket Reference described earlier. That book gives both 2.X and\n3.X versions of core language structures, built-in functions and exceptions, and many\nof the standard library modules and tools used in this book. Though not designed to\nbe a reference or version translator per se, the Fourth Edition of Learning Python sim-\nilarly covers both 2.X and 3.X, and as stated, is prerequisite material to this book. The\ngoal of this 3.X-only Programming Python is not to abandon the current vast 2.X user\nbase in favor of a still imaginary one for 3.X; it is to help readers with the migration,\nand avoid doubling the size of an already massive book.\nPreface | xxxiSpecific 3.X Changes\nLuckily, many of the 2.X/3.X differences that impact this book\u2019s presentation are trivial.\nFor instance, the tkinter GUI toolkit, used extensively in this book, is shown under its\n3.X tkinter name and package structure only; its 2.X Tkinter module incarnation is\nnot described. This mostly boils down to different import statements, but only their\nPython 3 versions are given here. Similarly, to satisfy 3.X module naming conventions,\n2.X\u2019s anydbm, Queue, thread, StringIO.StringIO, and urllib.open become dbm, queue,\n_thread, io.StringIO, and urllib.request.urlopen, respectively, in both Python 3.X\nand this edition. Other tools are similarly renamed.\nOn the other hand, 3.X implies broader idiomatic changes which are, of course, more\nradical. For example, Python 3.X\u2019s new Unicode awareness has inspired fully Interna-\ntionalized versions of the PyEdit text editor and the PyMailGUI email client examples\nin this edition (more on this in a moment). Furthermore: the replacement of\nos.popen2 with the subprocess module required new examples; the demise of\nos.path.walk in favor of os.walk allowed some examples to be trimmed; the new Uni-\ncode and binary dichotomy of files and strings impacted a host of additional existing\nexamples and material; and new modules such as multiprocessing offer new options\ncovered in this edition.\nBeyond such library changes, core language changes in Python 3 are also reflected in\nthis book\u2019s example code. For instance, changes to 2.X\u2019s print, raw_input, keys,\nhas_key, map, and apply all required changes here. In addition, 3.X\u2019s new package-\nrelative import model impacted a few examples including mailtools and expression\nparsers, and its different flavor of division forced some minor math updates in canvas-\nbased GUI examples such as PyClock, PyDraw, and PyPhoto.\nOf note here, I did not change all % string formatting expressions to use the new\nstr.format, since both forms are supported in Python 3.1, and it now appears that they\nwill be either indefinitely or forever. In fact, per a \u201cgrep\u201d we\u2019ll build and run in Chap-\nter 11\u2019s PyEdit example, it seems that this expression still appears over 3,000 times in\nPython 3.1\u2019s own library code. Since I cannot predict Python evolution completely, see\nthe first chapter for more on this if it ever requires updates in an unexpected future.\nAlso because of the 3.X scope, this edition is unable to use some third-party packages\nthat are still in 2.X form only, as described earlier. This includes the leading MySQL\ninterface, ZODB, PyCrypto, and others; as also mentioned, PIL was ported to 3.1 for\nuse in this book, but this required a special patch and an official 3.X release is still\npresently pending. Many of these may be available in 3.X form by the time you read\nthese words, assuming the Python world can either break some of the current cross\ndependencies in 2.X packages or adopt new 3.X-only tools.\nxxxii | PrefaceLanguage Versus Library: Unicode\nAs a book focused on applications instead of core language fundamentals, language\nchanges are not always obtrusive here. Indeed, in retrospect the book Learning Py-\nthon may have been affected by 3.X core language changes more than this book. In\nmost cases here, more example changes were probably made in the name of clarity or\nfunctionality than in support of 3.X itself.\nOn the other hand, Python 3.X does impact much code, and the impacts can be subtle\nat times. Readers with Python 2.X backgrounds will find that while 3.X core language\nchanges are often simple to apply, updates required for changes in the 3.X standard\nlibrary are sometimes more far reaching.\nChief among these, Python 3.X\u2019s Unicode strings have had broad ramifications. Let\u2019s\nbe honest: to people who have spent their lives in an ASCII world, the impacts of the\n3.X Unicode model can be downright aggravating at times! As we\u2019ll see in this book, it\naffects file content; file names; pipe descriptors; sockets; text in GUIs; Internet proto-\ncols such as FTP and email; CGI scripts; and even some persistence tools. For better\nor worse, once we reach the world of applications programming as covered in this book,\nUnicode is no longer an optional topic for many or most Python 3.X programmers.\nOf course, Unicode arguably never should have been entirely optional for many pro-\ngrammers in the first place. Indeed, we\u2019ll find that things that may have appeared to\nwork in 2.X never really did\u2014treating text as raw byte strings can mask issues such as\ncomparison results across encodings (see the grep utility of Chapter 11\u2019s PyEdit for a\nprime example of code that should fail in the face of Unicode mismatches). Python 3.X\nelevates such issues to potentially every programmer\u2019s panorama.\nStill, porting nontrivial code to 3.X is not at all an insurmountable task. Moreover,\nmany readers of this edition have the luxury of approaching Python 3.X as their first\nPython and need not deal with existing 2.X code. If this is your case, you\u2019ll find Python\n3.X to be a robust and widely applicable scripting and programming language, which\naddresses head-on many issues that once lurked in the shadows in 2.X.\nPython 3.1 Limitations: Email, CGI\nThere\u2019s one exception that I should call out here because of its impact on major book\nexamples. In order to make its code relevant to the widest possible audience, this book\u2019s\nmajor examples are related to Internet email and have much new support in this edition\nfor Internationalization and Unicode in this domain. Chapter 14\u2019s PyMailGUI and\nChapter 16\u2019s PyMailCGI, and all the prior examples they reuse, fall into this category.\nThis includes the PyEdit text editor\u2014now Unicode-aware for files, display, and greps.\nOn this front, there is both proverbial good news and bad. The good news is that in\nthe end, we will be able to develop the feature-rich and fully Internationalized PyMail-\nGUI email client in this book, using the email package as it currently exists. This will\ninclude support for arbitrary encodings in both text content and message headers, for\nPreface | xxxiiiboth viewing and composing messages. The less happy news is that this will come at\nsome cost in workaround complexity in Python 3.1.\nUnfortunately, as we\u2019ll learn in Chapter 13, the email package in Python 3.1 has a\nnumber of issues related to str/bytes combinations in Python 3.X. For example, there\u2019s\nno simple way to guess the encoding needed to convert mail bytes returned by the\npoplib module to the str expected by the email parser. Moreover, the email package\nis currently broken altogether for some types of messages, and it has uneven or type-\nspecific support for some others.\nThis situation appears to be temporary. Some of the issues encountered in this book\nare already scheduled to be repaired (in fact, one such fix in 3.2 required a last-minute\npatch to one of this book\u2019s 3.1 workarounds in Chapter 13). Furthermore, a new version\nof email is being developed to accommodate the 3.X Unicode/bytes dichotomy more\naccurately, but it won\u2019t materialize until long after this book is published, and it might\nbe backward-incompatible with the current package\u2019s API, much like Python 3.X itself.\nBecause of that, this book both codes workarounds and makes some assumption along\nthe way, but please watch its website (described ahead) for required updates in future\nPythons. One upside here is that the dilemmas posed neatly reflect those common in\nrealistic programming\u2014an underlying theme of this text.\nThese issues in the email package are also inherited by the cgi module for CGI file\nuploads, which are in large measure broken in 3.1. CGI scripts are a basic technique\neclipsed by many web frameworks today, but they still serve as an entry-level way to\nlearn Web fundamentals and are still at the heart of many larger toolkits. A future fix\nseems likely for this 3.1 flaw as well, but we have to make do with nonbinary CGI file\nuploads for this edition in Chapters 15 and 16, and limited email attachments in Py-\nMailCGI. This seems less than ideal nearly two years after 3.0\u2019s release, but such is life\nin the dynamic worlds of both software development at large and books that aim to\nlead the curve instead of following it.\nUsing Book Examples\nBecause this book\u2019s examples form much of its content, I want to say a few words about\nthem up front.\nWhere to Look for Examples and Updates\nAs before, examples, updates, corrections, and supplements for this book will be main-\ntained at the author\u2019s website, which lives officially at the following URL:\nhttp://www.rmi.net/~lutz/about-pp4e.html\nThis page at my book support website will contain links to all supplemental information\nrelated to this version of the book. Because I don\u2019t own that domain name, though, if\nxxxiv | Prefacethat link ceases to be during this book\u2019s shelf life, try the following alternative site as a\nfallback option:\nhttp://learning-python.com/books/about-pp4e.html (alternative location)\nIf neither of those links work, try a general web search (which, of course, is what most\nreaders will probably try first anyhow).\nWherever it may live, this website (as well as O\u2019Reilly\u2019s, described in the next section)\nis where you can fetch the book examples distribution package\u2014an archive file con-\ntaining all of the book\u2019s examples, as well as some extras that are mentioned but not\nlisted in the book itself. To work along without having to type the examples manually,\ndownload the package, unpack it, and consult its README.txt file for usage details.\nI\u2019ll describe how example labels and system prompts in this book imply file locations\nin the package when we use our first script in the first chapter.\nAs for the first three editions, I will also be maintaining an informal \u201cblog\u201d on this\nwebsite that describes Python changes over time and provides general book-related\nnotes and updates that you should consider a supplemental appendix to this text.\nO\u2019Reilly\u2019s website for this book, described later in this Preface, also has an errata report\nsystem, and you can report issues at either my site or O\u2019Reilly\u2019s. I tend to keep my book\nwebsites more up to date, but it\u2019s not impossible that O\u2019Reilly\u2019s errata page may su-\npersede mine for this edition. In any event, you should consider the union of these two\nlists to be the official word on book corrections and updates.\nExample Portability\nThe examples in this book were all developed, tested, and run under Windows 7, and\nPython 3.1. The book\u2019s major examples were all tested and ran successfully on the\nupcoming Python 3.2, too (its alpha 3 release), just before the book went to the printer,\nso most or all of this book applies to Python 3.2 as well. In addition, the C code of\nChapter 20 and a handful of parallel programming examples were run under Cygwin\non Windows to emulate a Unix environment.\nAlthough Python and its libraries are generally platform neutral, some of this book\u2019s\ncode may require minor changes to run on other platforms, such as Mac OS X, Linux,\nand other Unix variants. The tkinter GUI examples, as well as some systems program-\nming scripts, may be especially susceptible to platform differences. Some portability\nissues are pointed out along the way, but others may not be explicitly noted.\nSince I had neither time nor budget to test on and accommodate all possible machines\nthat readers might use over the lifespan of this book, updates for platform-specific\nbehaviors will have to fall into the suggested exercises category. If you find a platform\ndependency and wish to submit a patch for it, though, please see the updates site listed\nearlier; I\u2019ll be happy to post any platform patches from readers there.\nPreface | xxxvDemo Launchers\nThe book examples package described earlier also includes portable example demo\nlauncher scripts named PyDemos and PyGadgets, which provide a quick look at some\nof this book\u2019s major GUI- and Web-based examples. These scripts and their launchers,\nlocated at the top of the examples tree, can be run to self-configure program and module\nsearch paths, and so can generally be run immediately on compatible platforms, in-\ncluding Windows. See the package\u2019s README files as well as the overviews near the\nend of Chapters 6 and 10 for more on these scripts.\nCode Reuse Policies\nWe now interrupt this Preface for a word from the legal department. This book is here\nto help you get your job done. In general, you may use the code in this book in your\nprograms and documentation. You do not need to contact us for permission unless\nyou\u2019re reproducing a significant portion of the code. For example, writing a program\nthat uses several chunks of code from this book does not require permission. Selling or\ndistributing a CD-ROM of examples from O\u2019Reilly books does require permission.\nAnswering a question by citing this book and quoting example code does not require\npermission. Incorporating a significant amount of example code from this book into\nyour product\u2019s documentation does require permission.\nWe appreciate, but do not require, attribution. An attribution usually includes the title,\nauthor, publisher, and ISBN. For example: \u201cProgramming Python, Fourth Edition, by\nMark Lutz (O\u2019Reilly). Copyright 2011 Mark Lutz, 978-0-596-15810-1.\u201d\nContacting O\u2019Reilly\nI described my own examples and updates sites in the prior section. In addition to that\nadvice, you can also address comments and questions about this book to the publisher:\nO\u2019Reilly Media, Inc.\n1005 Gravenstein Highway North\nSebastopol, CA 95472\n800-998-9938 (in the United States and Canada)\n707-827-7000 (international/local)\n707-829-0104 (fax)\nAs mentioned, O\u2019Reilly maintains a web page for this book, which lists errata, exam-\nples, and any additional information. You can access this page at:\nhttp://oreilly.com/catalog/9780596158101\nTo comment or ask technical questions about this book, send email to:\nbookquestions@oreilly.com\nxxxvi | PrefaceFor more information about books, conferences, software, Resource Centers, and the\nO\u2019Reilly Network, see the O\u2019Reilly website at:\nhttp://www.oreilly.com\nConventions Used in This Book\nThe following font conventions are used in this book:\nItalic\nUsed for file and directory names, to emphasize new terms when first introduced,\nand for some comments within code sections\nConstant width\nUsed for code listings and to designate modules, methods, options, classes, func-\ntions, statements, programs, objects, and HTML tags\nConstant width bold\nUsed in code sections to show user input\nConstant width italic\nUsed to mark replaceables\nThis icon designates a note related to the nearby text.\nThis icon designates a warning related to the nearby text.\nAcknowledgments\nI acknowledged numerous people in the preface of Learning Python, Fourth Edition,\nless than a year ago; because that book is a precursor to this one, and because the set\nis largely the same, I won\u2019t repeat the list in its entirety here. In short, though, I\u2019m\ngrateful to:\n\u2022 O\u2019Reilly, for promoting Python, and publishing \u201cmeaty\u201d books in the Open Source\ndomain\n\u2022 The Python community, which has occupied sizeable portions of my world\nsince 1992\n\u2022 The thousands of students who attended the 250 Python classes I\u2019ve taught\nsince 1997\nPreface | xxxvii\u2022 The hundreds of thousands who read the 12 editions of the three Python books\nI\u2019ve written since 1995\n\u2022 Monty Python, Python\u2019s namesake, for so many great bits to draw from (more in\nthe next chapter)\nAlthough writing is ultimately a solitary task, the ideas that spring forth owe much to\nthe input of many. I\u2019m thankful for all the feedback I\u2019ve been fortunate to receive over\nthe last 18 years, both from classes and from readers. Students really are the best teach-\ners of teachers.\nOn the (overly) personal front, I\u2019d like to thank my brothers and sister for old days, as\nwell as my children, Michael, Samantha, and Roxanne, for bragging rights.\nAnd I\u2019m especially thankful for my wife, Vera, who somehow managed to append very\ngood things to this otherwise immutable object.\n\u2014Mark Lutz, July 2010\nxxxviii | PrefaceSo, What\u2019s Python?\nAs discussed, this book won\u2019t devote much space to Python fundamentals, and we\u2019ll\ndefer an abstract discussion of Python roles until the Conclusion, after you\u2019ve had a\nchance to see it in action firsthand. If you are looking for a concise definition of this\nbook\u2019s topic, though, try this:\nPython is a general-purpose, open source computer programming language. It is opti-\nmized for software quality, developer productivity, program portability, and compo-\nnent integration. Python is used by at least hundreds of thousands of developers around\nthe world in areas such as Internet scripting, systems programming, user interfaces,\nproduct customization, numeric programming, and more. It is generally considered to\nbe among the top four or five most widely-used programming languages in the world\ntoday.\nAs a popular language focused on shrinking development time, Python is deployed in\na wide variety of products and roles. Counted among its current user base are Google,\nYouTube, Industrial Light & Magic, ESRI, the BitTorrent file sharing system, NASA\u2019s\nJet Propulsion Lab, the game Eve Online, and the National Weather Service. Python\u2019s\napplication domains range from system administration, website development, cell\nphone scripting, and education to hardware testing, investment analysis, computer\ngames, and spacecraft control.\nAmong other things, Python sports a remarkably simple, readable, and maintainable\nsyntax; integration with external components coded in other languages; a multi-\nparadigm design, with OOP, functional, and modular structures; and a vast collection\nof precoded interfaces and utilities. Its tool set makes it a flexible and agile language,\nideal for both quick tactical tasks as well as longer-range strategic application devel-\nopment efforts. Although it is a general-purpose language, Python is often called a\nscripting language because it makes it easy to utilize and direct other software\ncomponents.\nPerhaps Python\u2019s best asset, though, is simply that it makes software development more\nrapid and enjoyable. There is a class of people for whom programming is an end in\nitself. They enjoy the challenge. They write software for the pure pleasure of doing so\nand often view commercial or career reward as secondary consequence. This is the class\nthat largely invented the Internet, open source, and Python. This is also the class that\nhas historically been a primary audience for this book. As they\u2019ve often relayed, with\na tool like Python, programming can be just plain fun.\nTo truly understand how, read on; though something of a side effect, much of this book\nserves as a demonstration of Python\u2019s ideals in action in real-world code. As we\u2019ll see,\nespecially when combined with toolkits for GUIs, websites, systems programming, and\nso on, Python serves as enabling technology.\nPreface | xxxixPART I\nThe Beginning\nThis part of the book gets things started by taking us on a quick tour that reviews Python \nfundamental prerequisites and introduces some of the most common ways it is applied.\nChapter 1 \nThis chapter kicks things off by using a simple example\u2014recording information \nabout people\u2014to briefly introduce some of the major Python application domains \nwe\u2019ll be studying in this book. We\u2019ll migrate the same example through multiple \nsteps. Along the way, we\u2019ll meet databases, GUIs, websites, and more. This is \nsomething of a demo chapter, designed to pique your interest. We won\u2019t learn the \nfull story here, but we\u2019ll have a chance to see Python in action before digging into \nthe details. This chapter also serves as a review of some core language ideas you \nshould be familiar with before starting this book, such as data representation and \nobject-oriented programming (OOP).\nThe point of this part of the book is not to give you an in-depth look at Python, but \njust to let you sample its application and to provide you with a quick look at some of \nPython\u2019s broader goals and purposes.CHAPTER 1\nA Sneak Preview\n\u201cProgramming Python: The Short Story\u201d\nIf you are like most people, when you pick up a book as large as this one, you\u2019d like to \nknow a little about what you\u2019re going to be learning before you roll up your sleeves. \nThat\u2019s what this chapter is for\u2014it provides a demonstration of some of the kinds of \nthings you can do with Python, before getting into the details. You won\u2019t learn the full \nstory here, and if you\u2019re looking for complete explanations of the tools and techniques \napplied in this chapter, you\u2019ll have to read on to later parts of the book. The point here \nis just to whet your appetite, review a few Python basics, and preview some of the topics \nto come.\nTo do this, I\u2019ll pick a fairly simple application task\u2014constructing a database of \nrecords\u2014and migrate it through multiple steps: interactive coding, command-line \ntools, console interfaces, GUIs, and simple web-based interfaces. Along the way, we\u2019ll \nalso peek at concepts such as data representation, object persistence, and object-\noriented programming (OOP); explore some alternatives that we\u2019ll revisit later in the \nbook; and review some core Python ideas that you should be aware of before reading \nthis book. Ultimately, we\u2019ll wind up with a database of Python class instances, which \ncan be browsed and changed from a variety of interfaces.\nI\u2019ll cover additional topics in this book, of course, but the techniques you will see here \nare representative of some of the domains we\u2019ll explore later. And again, if you don\u2019t \ncompletely understand the programs in this chapter, don\u2019t worry because you \nshouldn\u2019t\u2014not yet anyway. This is just a Python demo. We\u2019ll fill in the rest of the \ndetails soon enough. For now, let\u2019s start off with a bit of fun.\n3", "1": "CHAPTER 1\nA Sneak Preview\n\u201cProgramming Python: The Short Story\u201d\nIf you are like most people, when you pick up a book as large as this one, you\u2019d like to \nknow a little about what you\u2019re going to be learning before you roll up your sleeves. \nThat\u2019s what this chapter is for\u2014it provides a demonstration of some of the kinds of \nthings you can do with Python, before getting into the details. You won\u2019t learn the full \nstory here, and if you\u2019re looking for complete explanations of the tools and techniques \napplied in this chapter, you\u2019ll have to read on to later parts of the book. The point here \nis just to whet your appetite, review a few Python basics, and preview some of the topics \nto come.\nTo do this, I\u2019ll pick a fairly simple application task\u2014constructing a database of \nrecords\u2014and migrate it through multiple steps: interactive coding, command-line \ntools, console interfaces, GUIs, and simple web-based interfaces. Along the way, we\u2019ll \nalso peek at concepts such as data representation, object persistence, and object-\noriented programming (OOP); explore some alternatives that we\u2019ll revisit later in the \nbook; and review some core Python ideas that you should be aware of before reading \nthis book. Ultimately, we\u2019ll wind up with a database of Python class instances, which \ncan be browsed and changed from a variety of interfaces.\nI\u2019ll cover additional topics in this book, of course, but the techniques you will see here \nare representative of some of the domains we\u2019ll explore later. And again, if you don\u2019t \ncompletely understand the programs in this chapter, don\u2019t worry because you \nshouldn\u2019t\u2014not yet anyway. This is just a Python demo. We\u2019ll fill in the rest of the \ndetails soon enough. For now, let\u2019s start off with a bit of fun.\n3Readers of the Fourth Edition of Learning Python might recognize some\naspects of the running example used in this chapter\u2014the characters here\nare similar in spirit to those in the OOP tutorial chapter in that book,\nand the later class-based examples here are essentially a variation on a\ntheme. Despite some redundancy, I\u2019m revisiting the example here for\nthree reasons: it serves its purpose as a review of language fundamentals;\nsome readers of this book haven\u2019t read Learning Python; and the exam-\nple receives expanded treatment here, with the addition of GUI and Web\ninterfaces. That is, this chapter picks up where Learning Python left off,\npushing this core language example into the realm of realistic applica-\ntions\u2014which, in a nutshell, reflects the purpose of this book.\nThe Task\nImagine, if you will, that you need to keep track of information about people for some\nreason. Maybe you want to store an address book on your computer, or perhaps you\nneed to keep track of employees in a small business. For whatever reason, you want to\nwrite a program that keeps track of details about these people. In other words, you\nwant to keep records in a database\u2014to permanently store lists of people\u2019s attributes\non your computer.\nNaturally, there are off-the-shelf programs for managing databases like these. By writ-\ning a program for this task yourself, however, you\u2019ll have complete control over its\noperation. You can add code for special cases and behaviors that precoded software\nmay not have anticipated. You won\u2019t have to install and learn to use yet another data-\nbase product. And you won\u2019t be at the mercy of a software vendor to fix bugs or add\nnew features. You decide to write a Python program to manage your people.\nStep 1: Representing Records\nIf we\u2019re going to store records in a database, the first step is probably deciding what\nthose records will look like. There are a variety of ways to represent information about\npeople in the Python language. Built-in object types such as lists and dictionaries are\noften sufficient, especially if we don\u2019t initially care about processing the data we store.\nUsing Lists\nLists, for example, can collect attributes about people in a positionally ordered way.\nStart up your Python interactive interpreter and type the following two statements:\n>>> bob = ['Bob Smith', 42, 30000, 'software']\n>>> sue = ['Sue Jones', 45, 40000, 'hardware']\n4 | Chapter 1:\u2002A Sneak PreviewWe\u2019ve just made two records, albeit simple ones, to represent two people, Bob and Sue\n(my apologies if you really are Bob or Sue, generically or otherwise*). Each record is a\nlist of four properties: name, age, pay, and job fields. To access these fields, we simply\nindex by position; the result is in parentheses here because it is a tuple of two results:\n>>> bob[0], sue[2]             # fetch name, pay\n('Bob Smith', 40000)\nProcessing records is easy with this representation; we just use list operations. For\nexample, we can extract a last name by splitting the name field on blanks and grabbing\nthe last part, and we can give someone a raise by changing their list in-place:\n>>> bob[0].split()[-1]         # what's bob's last name?\n'Smith'\n>>> sue[2] *= 1.25             # give sue a 25% raise\n>>> sue\n['Sue Jones', 45, 50000.0, 'hardware']\nThe last-name expression here proceeds from left to right: we fetch Bob\u2019s name, split\nit into a list of substrings around spaces, and index his last name (run it one step at a\ntime to see how).\nStart-up pointers\nSince this is the first code in this book, here are some quick pragmatic pointers for\nreference:\n\u2022 This code may be typed in the IDLE GUI; after typing python at a shell prompt (or\nthe full directory path to it if it\u2019s not on your system path); and so on.\n\u2022 The >>> characters are Python\u2019s prompt (not code you type yourself).\n\u2022 The informational lines that Python prints when this prompt starts up are usually\nomitted in this book to save space.\n\u2022 I\u2019m running all of this book\u2019s code under Python 3.1; results in any 3.X release\nshould be similar (barring unforeseeable Python changes, of course).\n\u2022 Apart from some system and C integration code, most of this book\u2019s examples are\nrun under Windows 7, though thanks to Python portability, it generally doesn\u2019t\nmatter unless stated otherwise.\nIf you\u2019ve never run Python code this way before, see an introductory resource such as\nO\u2019Reilly\u2019s Learning Python for help with getting started. I\u2019ll also have a few words to\nsay about running code saved in script files later in this chapter.\n* No, I\u2019m serious. In the Python classes I teach, I had for many years regularly used the name \u201cBob Smith,\u201d\nage 40.5, and jobs \u201cdeveloper\u201d and \u201cmanager\u201d as a supposedly fictitious database record\u2014until a class in\nChicago, where I met a student named Bob Smith, who was 40.5 and was a developer and manager. The\nworld is stranger than it seems.\nStep 1: Representing Records | 5A database list\nOf course, what we\u2019ve really coded so far is just two variables, not a database; to collect\nBob and Sue into a unit, we might simply stuff them into another list:\n>>> people = [bob, sue]                        # reference in list of lists\n>>> for person in people:\n        print(person)\n['Bob Smith', 42, 30000, 'software']\n['Sue Jones', 45, 50000.0, 'hardware']\nNow the people list represents our database. We can fetch specific records by their\nrelative positions and process them one at a time, in loops:\n>>> people[1][0]\n'Sue Jones'\n>>> for person in people:\n        print(person[0].split()[-1])           # print last names\n        person[2] *= 1.20                      # give each a 20% raise\nSmith\nJones\n>>> for person in people: print(person[2])     # check new pay\n36000.0\n60000.0\nNow that we have a list, we can also collect values from records using some of Python\u2019s\nmore powerful iteration tools, such as list comprehensions, maps, and generator\nexpressions:\n>>> pays = [person[2] for person in people]    # collect all pay\n>>> pays\n[36000.0, 60000.0]\n>>> pays = map((lambda x: x[2]), people)       # ditto (map is a generator in 3.X)\n>>> list(pays)\n[36000.0, 60000.0]\n>>> sum(person[2] for person in people)       # generator expression, sum built-in\n96000.0\nTo add a record to the database, the usual list operations, such as append and extend,\nwill suffice:\n>>> people.append(['Tom', 50, 0, None])\n>>> len(people)\n3\n>>> people[-1][0]\n'Tom'\nLists work for our people database, and they might be sufficient for some programs,\nbut they suffer from a few major flaws. For one thing, Bob and Sue, at this point, are\n6 | Chapter 1:\u2002A Sneak Previewjust fleeting objects in memory that will disappear once we exit Python. For another,\nevery time we want to extract a last name or give a raise, we\u2019ll have to repeat the kinds\nof code we just typed; that could become a problem if we ever change the way those\noperations work\u2014we may have to update many places in our code. We\u2019ll address these\nissues in a few moments.\nField labels\nPerhaps more fundamentally, accessing fields by position in a list requires us to mem-\norize what each position means: if you see a bit of code indexing a record on magic\nposition 2, how can you tell it is extracting a pay? In terms of understanding the code,\nit might be better to associate a field name with a field value.\nWe might try to associate names with relative positions by using the Python range built-\nin function, which generates successive integers when used in iteration contexts (such\nas the sequence assignment used initially here):\n>>> NAME, AGE, PAY = range(3)                # 0, 1, and 2\n>>> bob = ['Bob Smith', 42, 10000]\n>>> bob[NAME]\n'Bob Smith'\n>>> PAY, bob[PAY]\n(2, 10000)\nThis addresses readability: the three uppercase variables essentially become field\nnames. This makes our code dependent on the field position assignments, though\u2014\nwe have to remember to update the range assignments whenever we change record\nstructure. Because they are not directly associated, the names and records may become\nout of sync over time and require a maintenance step.\nMoreover, because the field names are independent variables, there is no direct map-\nping from a record list back to its field\u2019s names. A raw record list, for instance, provides\nno way to label its values with field names in a formatted display. In the preceding\nrecord, without additional code, there is no path from value 42 to label AGE:\nbob.index(42) gives 1, the value of AGE, but not the name AGE itself.\nWe might also try this by using lists of tuples, where the tuples record both a field name\nand a value; better yet, a list of lists would allow for updates (tuples are immutable).\nHere\u2019s what that idea translates to, with slightly simpler records:\n>>> bob = [['name', 'Bob Smith'], ['age', 42], ['pay', 10000]]\n>>> sue = [['name', 'Sue Jones'], ['age', 45], ['pay', 20000]]\n>>> people = [bob, sue]\nThis really doesn\u2019t fix the problem, though, because we still have to index by position\nin order to fetch fields:\n>>> for person in people:\n        print(person[0][1], person[2][1])     # name, pay\nStep 1: Representing Records | 7Bob Smith 10000\nSue Jones 20000\n>>> [person[0][1] for person in people]       # collect names\n['Bob Smith', 'Sue Jones']\n>>> for person in people:\n        print(person[0][1].split()[-1])       # get last names\n        person[2][1] *= 1.10                  # give a 10% raise\nSmith\nJones\n>>> for person in people: print(person[2])\n['pay', 11000.0]\n['pay', 22000.0]\nAll we\u2019ve really done here is add an extra level of positional indexing. To do better, we \nmight inspect field names in loops to find the one we want (the loop uses tuple assign-\nment here to unpack the name/value pairs):\n>>> for person in people:\n        for (name, value) in person:\n            if name == 'name': print(value)   # find a specific field\nBob Smith\nSue Jones\nBetter yet, we can code a fetcher function to do the job for us: \n>>> def field(record, label):\n        for (fname, fvalue) in record:\n            if fname == label:                # find any field by name\n                return fvalue\n>>> field(bob, 'name')\n'Bob Smith'\n>>> field(sue, 'pay')\n22000.0\n>>> for rec in people:\n        print(field(rec, 'age'))              # print all ages\n42\n45\nIf we proceed down this path, we\u2019ll eventually wind up with a set of record interface \nfunctions that generically map field names to field data. If you\u2019ve done any Python \ncoding in the past, though, you probably already know that there is an easier way to \ncode this sort of association, and you can probably guess where we\u2019re headed in the \nnext section.\n8 | Chapter 1:\u2002A Sneak PreviewUsing Dictionaries\nThe list-based record representations in the prior section work, though not without\nsome cost in terms of performance required to search for field names (assuming you\nneed to care about milliseconds and such). But if you already know some Python, you\nalso know that there are more efficient and convenient ways to associate property\nnames and values. The built-in dictionary object is a natural:\n>>> bob = {'name': 'Bob Smith', 'age': 42, 'pay': 30000, 'job': 'dev'}\n>>> sue = {'name': 'Sue Jones', 'age': 45, 'pay': 40000, 'job': 'hdw'}\nNow, Bob and Sue are objects that map field names to values automatically, and they\nmake our code more understandable and meaningful. We don\u2019t have to remember what\na numeric offset means, and we let Python search for the value associated with a field\u2019s\nname with its efficient dictionary indexing:\n>>> bob['name'], sue['pay']            # not bob[0], sue[2]\n('Bob Smith', 40000)\n>>> bob['name'].split()[-1]\n'Smith'\n>>> sue['pay'] *= 1.10\n>>> sue['pay']\n44000.0\nBecause fields are accessed mnemonically now, they are more meaningful to those who\nread your code (including you).\nOther ways to make dictionaries\nDictionaries turn out to be so useful in Python programming that there are even more\nconvenient ways to code them than the traditional literal syntax shown earlier\u2014e.g.,\nwith keyword arguments and the type constructor, as long as the keys are all strings:\n>>> bob = dict(name='Bob Smith', age=42, pay=30000, job='dev')\n>>> sue = dict(name='Sue Jones', age=45, pay=40000, job='hdw')\n>>> bob\n{'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}\n>>> sue\n{'pay': 40000, 'job': 'hdw', 'age': 45, 'name': 'Sue Jones'}\nby filling out a dictionary one field at a time (recall that dictionary keys are pseudo-\nrandomly ordered):\n>>> sue = {}\n>>> sue['name'] = 'Sue Jones'\n>>> sue['age']  = 45\n>>> sue['pay']  = 40000\n>>> sue['job']  = 'hdw'\n>>> sue\n{'job': 'hdw', 'pay': 40000, 'age': 45, 'name': 'Sue Jones'}\nStep 1: Representing Records | 9and by zipping together name/value lists:\n>>> names  = ['name', 'age', 'pay', 'job']\n>>> values = ['Sue Jones', 45, 40000, 'hdw']\n>>> list(zip(names, values))\n[('name', 'Sue Jones'), ('age', 45), ('pay', 40000), ('job', 'hdw')]\n>>> sue = dict(zip(names, values))\n>>> sue\n{'job': 'hdw', 'pay': 40000, 'age': 45, 'name': 'Sue Jones'}\nWe can even make dictionaries from a sequence of key values and an optional starting\nvalue for all the keys (handy to initialize an empty dictionary):\n>>> fields = ('name', 'age', 'job', 'pay')\n>>> record = dict.fromkeys(fields, '?')\n>>> record\n{'job': '?', 'pay': '?', 'age': '?', 'name': '?'}\nLists of dictionaries\nRegardless of how we code them, we still need to collect our dictionary-based records\ninto a database; a list does the trick again, as long as we don\u2019t require access by key at\nthe top level:\n>>> bob\n{'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}\n>>> sue\n{'job': 'hdw', 'pay': 40000, 'age': 45, 'name': 'Sue Jones'}\n>>> people = [bob, sue]                                   # reference in a list\n>>> for person in people:\n        print(person['name'], person['pay'], sep=', ')    # all name, pay\nBob Smith, 30000\nSue Jones, 40000\n>>> for person in people:\n        if person['name'] == 'Sue Jones':                 # fetch sue's pay\n            print(person['pay'])\n40000\nIteration tools work just as well here, but we use keys rather than obscure positions (in\ndatabase terms, the list comprehension and map in the following code project the da-\ntabase on the \u201cname\u201d field column):\n>>> names = [person['name'] for person in people]         # collect names\n>>> names\n['Bob Smith', 'Sue Jones']\n>>> list(map((lambda x: x['name']), people))              # ditto, generate\n['Bob Smith', 'Sue Jones']\n>>> sum(person['pay'] for person in people)               # sum all pay\n70000\n10 | Chapter 1:\u2002A Sneak PreviewInterestingly, tools such as list comprehensions and on-demand generator expressions\ncan even approach the utility of SQL queries here, albeit operating on in-memory\nobjects:\n>>> [rec['name'] for rec in people if rec['age'] >= 45]   # SQL-ish query\n['Sue Jones']\n>>> [(rec['age'] ** 2 if rec['age'] >= 45 else rec['age']) for rec in people]\n[42, 2025]\n>>> G = (rec['name'] for rec in people if rec['age'] >= 45)\n>>> next(G)\n'Sue Jones'\n>>> G = ((rec['age'] ** 2 if rec['age'] >= 45 else rec['age']) for rec in people)\n>>> G.__next__()\n42\nAnd because dictionaries are normal Python objects, these records can also be accessed\nand updated with normal Python syntax:\n>>> for person in people:\n        print(person['name'].split()[-1])                 # last name\n        person['pay'] *= 1.10                             # a 10% raise\nSmith\nJones\n>>> for person in people: print(person['pay'])\n33000.0\n44000.0\nNested structures\nIncidentally, we could avoid the last-name extraction code in the prior examples by\nfurther structuring our records. Because all of Python\u2019s compound datatypes can be\nnested inside each other and as deeply as we like, we can build up fairly complex in-\nformation structures easily\u2014simply type the object\u2019s syntax, and Python does all the\nwork of building the components, linking memory structures, and later reclaiming their\nspace. This is one of the great advantages of a scripting language such as Python.\nThe following, for instance, represents a more structured record by nesting a dictionary,\nlist, and tuple inside another dictionary:\n>>> bob2 = {'name': {'first': 'Bob', 'last': 'Smith'},\n            'age':  42,\n            'job':  ['software', 'writing'],\n            'pay':  (40000, 50000)}\nStep 1: Representing Records | 11Because this record contains nested structures, we simply index twice to go two levels\ndeep:\n>>> bob2['name']                            # bob's full name\n{'last': 'Smith', 'first': 'Bob'}\n>>> bob2['name']['last']                    # bob's last name\n'Smith'\n>>> bob2['pay'][1]                          # bob's upper pay\n50000\nThe name field is another dictionary here, so instead of splitting up a string, we simply\nindex to fetch the last name. Moreover, people can have many jobs, as well as minimum\nand maximum pay limits. In fact, Python becomes a sort of query language in such\ncases\u2014we can fetch or change nested data with the usual object operations:\n>>> for job in bob2['job']: print(job)      # all of bob's jobs\nsoftware\nwriting\n>> bob2['job'][-1]                          # bob's last job\n'writing'\n>>> bob2['job'].append('janitor')           # bob gets a new job\n>>> bob2\n{'job': ['software', 'writing', 'janitor'], 'pay': (40000, 50000), 'age': 42, 'name':\n{'last': 'Smith', 'first': 'Bob'}}\nIt\u2019s OK to grow the nested list with append, because it is really an independent object.\nSuch nesting can come in handy for more sophisticated applications; to keep ours sim-\nple, we\u2019ll stick to the original flat record structure.\nDictionaries of dictionaries\nOne last twist on our people database: we can get a little more mileage out of diction-\naries here by using one to represent the database itself. That is, we can use a dictionary\nof dictionaries\u2014the outer dictionary is the database, and the nested dictionaries are\nthe records within it. Rather than a simple list of records, a dictionary-based database\nallows us to store and retrieve records by symbolic key:\n>>> bob = dict(name='Bob Smith', age=42, pay=30000, job='dev')\n>>> sue = dict(name='Sue Jones', age=45, pay=40000, job='hdw')\n>>> bob\n{'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}\n>>> db = {}\n>>> db['bob'] = bob                      # reference in a dict of dicts\n>>> db['sue'] = sue\n>>>\n>>> db['bob']['name']                    # fetch bob's name\n'Bob Smith'\n>>> db['sue']['pay'] = 50000             # change sue's pay\n>>> db['sue']['pay']                     # fetch sue's pay\n50000\n12 | Chapter 1:\u2002A Sneak PreviewNotice how this structure allows us to access a record directly instead of searching for\nit in a loop\u2014we get to Bob\u2019s name immediately by indexing on key bob. This really is\na dictionary of dictionaries, though you won\u2019t see all the gory details unless you display\nthe database all at once (the Python pprint pretty-printer module can help with legi-\nbility here):\n>>> db\n{'bob': {'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}, 'sue':\n{'pay': 50000, 'job': 'hdw', 'age': 45, 'name': 'Sue Jones'}}\n>>> import pprint\n>>> pprint.pprint(db)\n{'bob': {'age': 42, 'job': 'dev', 'name': 'Bob Smith', 'pay': 30000},\n 'sue': {'age': 45, 'job': 'hdw', 'name': 'Sue Jones', 'pay': 50000}}\nIf we still need to step through the database one record at a time, we can now rely on\ndictionary iterators. In recent Python releases, a dictionary iterator produces one key\nin a for loop each time through (for compatibility with earlier releases, we can also call\nthe db.keys method explicitly in the for loop rather than saying just db, but since\nPython 3\u2019s keys result is a generator, the effect is roughly the same):\n>>> for key in db:\n        print(key, '=>', db[key]['name'])\nbob => Bob Smith\nsue => Sue Jones\n>>> for key in db:\n        print(key, '=>', db[key]['pay'])\nbob => 30000\nsue => 50000\nTo visit all records, either index by key as you go:\n>>> for key in db:\n        print(db[key]['name'].split()[-1])\n        db[key]['pay'] *= 1.10\nSmith\nJones\nor step through the dictionary\u2019s values to access records directly:\n>>> for record in db.values(): print(record['pay'])\n33000.0\n55000.0\n>>> x = [db[key]['name'] for key in db]\n>>> x\n['Bob Smith', 'Sue Jones']\n>>> x = [rec['name'] for rec in db.values()]\nStep 1: Representing Records | 13>>> x\n['Bob Smith', 'Sue Jones']\nAnd to add a new record, simply assign it to a new key; this is just a dictionary, after all:\n>>> db['tom'] = dict(name='Tom', age=50, job=None, pay=0)\n>>>\n>>> db['tom']\n{'pay': 0, 'job': None, 'age': 50, 'name': 'Tom'}\n>>> db['tom']['name']\n'Tom'\n>>> list(db.keys())\n['bob', 'sue', 'tom']\n>>> len(db)\n3\n>>> [rec['age'] for rec in db.values()]\n[42, 45, 50]\n>>> [rec['name'] for rec in db.values() if rec['age'] >= 45]     # SQL-ish query\n['Sue Jones', 'Tom']\nAlthough our database is still a transient object in memory, it turns out that this\ndictionary-of-dictionaries format corresponds exactly to a system that saves objects\npermanently\u2014the shelve (yes, this should probably be shelf, grammatically speaking,\nbut the Python module name and term is shelve). To learn how, let\u2019s move on to the\nnext section.\nStep 2: Storing Records Persistently\nSo far, we\u2019ve settled on a dictionary-based representation for our database of records,\nand we\u2019ve reviewed some Python data structure concepts along the way. As mentioned,\nthough, the objects we\u2019ve seen so far are temporary\u2014they live in memory and they go\naway as soon as we exit Python or the Python program that created them. To make our\npeople persistent, they need to be stored in a file of some sort.\nUsing Formatted Files\nOne way to keep our data around between program runs is to write all the data out to\na simple text file, in a formatted way. Provided the saving and loading tools agree on\nthe format selected, we\u2019re free to use any custom scheme we like.\nTest data script\nSo that we don\u2019t have to keep working interactively, let\u2019s first write a script that initi-\nalizes the data we are going to store (if you\u2019ve done any Python work in the past, you\nknow that the interactive prompt tends to become tedious once you leave the realm of\nsimple one-liners). Example 1-1 creates the sort of records and database dictionary\nwe\u2019ve been working with so far, but because it is a module, we can import it repeatedly\nwithout having to retype the code each time. In a sense, this module is a database itself,\nbut its program code format doesn\u2019t support automatic or end-user updates as is.\n14 | Chapter 1:\u2002A Sneak PreviewExample 1-1. PP4E\\Preview\\initdata.py\n# initialize data to be stored in files, pickles, shelves\n# records\nbob = {'name': 'Bob Smith', 'age': 42, 'pay': 30000, 'job': 'dev'}\nsue = {'name': 'Sue Jones', 'age': 45, 'pay': 40000, 'job': 'hdw'}\ntom = {'name': 'Tom',       'age': 50, 'pay': 0,     'job': None}\n# database\ndb = {}\ndb['bob'] = bob\ndb['sue'] = sue\ndb['tom'] = tom\nif __name__ == '__main__':       # when run as a script\n    for key in db:\n        print(key, '=>\\n  ', db[key])\nAs usual, the __name__ test at the bottom of Example 1-1 is true only when this file is\nrun, not when it is imported. When run as a top-level script (e.g., from a command\nline, via an icon click, or within the IDLE GUI), the file\u2019s self-test code under this test\ndumps the database\u2019s contents to the standard output stream (remember, that\u2019s what\nprint function-call statements do by default).\nHere is the script in action being run from a system command line on Windows. Type\nthe following command in a Command Prompt window after a cd to the directory where\nthe file is stored, and use a similar console window on other types of computers:\n...\\PP4E\\Preview> python initdata.py\nbob =>\n   {'job': 'dev', 'pay': 30000, 'age': 42, 'name': 'Bob Smith'}\nsue =>\n   {'job': 'hdw', 'pay': 40000, 'age': 45, 'name': 'Sue Jones'}\ntom =>\n   {'job': None, 'pay': 0, 'age': 50, 'name': 'Tom'}\nFile name conventions\nSince this is our first source file (a.k.a. \u201cscript\u201d), here are three usage notes for this\nbook\u2019s examples:\n\u2022 The text ...\\PP4E\\Preview> in the first line of the preceding example listing stands\nfor your operating system\u2019s prompt, which can vary per platform; you type just the\ntext that follows this prompt (python initdata.py).\n\u2022 Like all examples in this book, the system prompt also gives the directory in the\ndownloadable book examples package where this command should be run. When\nrunning this script using a command-line in a system shell, make sure the shell\u2019s\ncurrent working directory is PP4E\\Preview. This can matter for examples that use\nfiles in the working directory.\nStep 2: Storing Records Persistently | 15\u2022 Similarly, the label that precedes every example file\u2019s code listing tells you where\nthe source file resides in the examples package. Per the Example 1-1 listing label\nshown earlier, this script\u2019s full filename is PP4E\\Preview\\initdata.py in the\nexamples tree.\nWe\u2019ll use these conventions throughout the book; see the Preface for more on getting\nthe examples if you wish to work along. I occasionally give more of the directory path\nin system prompts when it\u2019s useful to provide the extra execution context, especially\nin the system part of the book (e.g., a \u201cC:\\\u201d prefix from Windows or more directory\nnames).\nScript start-up pointers\nI gave pointers for using the interactive prompt earlier. Now that we\u2019ve started running\nscript files, here are also a few quick startup pointers for using Python scripts in general:\n\u2022 On some platforms, you may need to type the full directory path to the Python\nprogram on your machine; if Python isn\u2019t on your system path setting on Windows,\nfor example, replace python in the command with C:\\Python31\\python (this as-\nsumes you\u2019re using Python 3.1).\n\u2022 On most Windows systems you also don\u2019t need to type python on the command\nline at all; just type the file\u2019s name to run it, since Python is registered to open \u201c.py\u201d\nscript files.\n\u2022 You can also run this file inside Python\u2019s standard IDLE GUI (open the file and\nuse the Run menu in the text edit window), and in similar ways from any of the\navailable third-party Python IDEs (e.g., Komodo, Eclipse, NetBeans, and the Wing\nIDE).\n\u2022 If you click the program\u2019s file icon to launch it on Windows, be sure to add an\ninput() call to the bottom of the script to keep the output window up. On other\nsystems, icon clicks may require a #! line at the top and executable permission via\na chmod command.\nI\u2019ll assume here that you\u2019re able to run Python code one way or another. Again, if you\u2019re\nstuck, see other books such as Learning Python for the full story on launching Python\nprograms.\nData format script\nNow, all we have to do is store all of this in-memory data in a file. There are a variety\nof ways to accomplish this; one of the most basic is to write one piece of data at a time,\nwith separators between each that we can use when reloading to break the data apart.\nExample 1-2 shows one way to code this idea.\n16 | Chapter 1:\u2002A Sneak PreviewExample 1-2. PP4E\\Preview\\make_db_file.py\n\"\"\"\nSave in-memory database object to a file with custom formatting;\nassume 'endrec.', 'enddb.', and '=>' are not used in the data;\nassume db is dict of dict;  warning: eval can be dangerous - it\nruns strings as code;  could also eval() record dict all at once;\ncould also dbfile.write(key + '\\n') vs print(key, file=dbfile);\n\"\"\"\ndbfilename = 'people-file'\nENDDB  = 'enddb.'\nENDREC = 'endrec.'\nRECSEP = '=>'\ndef storeDbase(db, dbfilename=dbfilename):\n    \"formatted dump of database to flat file\"\n    dbfile = open(dbfilename, 'w')\n    for key in db:\n        print(key, file=dbfile)\n        for (name, value) in db[key].items():\n            print(name + RECSEP + repr(value), file=dbfile)\n        print(ENDREC, file=dbfile)\n    print(ENDDB, file=dbfile)\n    dbfile.close()\ndef loadDbase(dbfilename=dbfilename):\n    \"parse data to reconstruct database\"\n    dbfile = open(dbfilename)\n    import sys\n    sys.stdin = dbfile\n    db = {}\n    key = input()\n    while key != ENDDB:\n        rec = {}\n        field = input()\n        while field != ENDREC:\n            name, value = field.split(RECSEP)\n            rec[name] = eval(value)\n            field = input()\n        db[key] = rec\n        key = input()\n    return db\nif __name__ == '__main__':\n    from initdata import db\n    storeDbase(db)\nThis is a somewhat complex program, partly because it has both saving and loading\nlogic and partly because it does its job the hard way; as we\u2019ll see in a moment, there\nare better ways to get objects into files than by manually formatting and parsing them.\nFor simple tasks, though, this does work; running Example 1-2 as a script writes the\ndatabase out to a flat file. It has no printed output, but we can inspect the database file\ninteractively after this script is run, either within IDLE or from a console window where\nStep 2: Storing Records Persistently | 17you\u2019re running these examples (as is, the database file shows up in the current working\ndirectory):\n...\\PP4E\\Preview> python make_db_file.py\n...\\PP4E\\Preview> python\n>>> for line in open('people-file'):\n...     print(line, end='')\n...\nbob\njob=>'dev'\npay=>30000\nage=>42\nname=>'Bob Smith'\nendrec.\nsue\njob=>'hdw'\npay=>40000\nage=>45\nname=>'Sue Jones'\nendrec.\ntom\njob=>None\npay=>0\nage=>50\nname=>'Tom'\nendrec.\nenddb.\nThis file is simply our database\u2019s content with added formatting. Its data originates\nfrom the test data initialization module we wrote in Example 1-1 because that is the\nmodule from which Example 1-2\u2019s self-test code imports its data. In practice, Exam-\nple 1-2 itself could be imported and used to store a variety of databases and files.\nNotice how data to be written is formatted with the as-code repr call and is re-created\nwith the eval call, which treats strings as Python code. That allows us to store and re-\ncreate things like the None object, but it is potentially unsafe; you shouldn\u2019t use eval if\nyou can\u2019t be sure that the database won\u2019t contain malicious code. For our purposes,\nhowever, there\u2019s probably no cause for alarm.\nUtility scripts\nTo test further, Example 1-3 reloads the database from a file each time it is run.\nExample 1-3. PP4E\\Preview\\dump_db_file.py\nfrom make_db_file import loadDbase\ndb = loadDbase()\nfor key in db:\n    print(key, '=>\\n  ', db[key])\nprint(db['sue']['name'])\nAnd Example 1-4 makes changes by loading, updating, and storing again.\n18 | Chapter 1:\u2002A Sneak PreviewExample 1-4. PP4E\\Preview\\update_db_file.py\nfrom make_db_file import loadDbase, storeDbase\ndb = loadDbase()\ndb['sue']['pay'] *= 1.10\ndb['tom']['name'] = 'Tom Tom'\nstoreDbase(db)\nHere are the dump script and the update script in action at a system command line;\nboth Sue\u2019s pay and Tom\u2019s name change between script runs. The main point to notice\nis that the data stays around after each script exits\u2014our objects have become persistent\nsimply because they are mapped to and from text files:\n...\\PP4E\\Preview> python dump_db_file.py\nbob =>\n   {'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}\nsue =>\n   {'pay': 40000, 'job': 'hdw', 'age': 45, 'name': 'Sue Jones'}\ntom =>\n   {'pay': 0, 'job': None, 'age': 50, 'name': 'Tom'}\nSue Jones\n...\\PP4E\\Preview> python update_db_file.py\n...\\PP4E\\Preview> python dump_db_file.py\nbob =>\n   {'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}\nsue =>\n   {'pay': 44000.0, 'job': 'hdw', 'age': 45, 'name': 'Sue Jones'}\ntom =>\n   {'pay': 0, 'job': None, 'age': 50, 'name': 'Tom Tom'}\nSue Jones\nAs is, we\u2019ll have to write Python code in scripts or at the interactive command line for\neach specific database update we need to perform (later in this chapter, we\u2019ll do better\nby providing generalized console, GUI, and web-based interfaces instead). But at a basic\nlevel, our text file is a database of records. As we\u2019ll learn in the next section, though, it\nturns out that we\u2019ve just done a lot of pointless work.\nUsing Pickle Files\nThe formatted text file scheme of the prior section works, but it has some major limi-\ntations. For one thing, it has to read the entire database from the file just to fetch one\nrecord, and it must write the entire database back to the file after each set of updates.\nAlthough storing one record\u2019s text per file would work around this limitation, it would\nalso complicate the program further.\nFor another thing, the text file approach assumes that the data separators it writes out\nto the file will not appear in the data to be stored: if the characters => happen to appear\nin the data, for example, the scheme will fail. We might work around this by generating\nXML text to represent records in the text file, using Python\u2019s XML parsing tools, which\nwe\u2019ll meet later in this text, to reload; XML tags would avoid collisions with actual\nStep 2: Storing Records Persistently | 19data\u2019s text, but creating and parsing XML would complicate the program substantially\ntoo.\nPerhaps worst of all, the formatted text file scheme is already complex without being\ngeneral: it is tied to the dictionary-of-dictionaries structure, and it can\u2019t handle anything\nelse without being greatly expanded. It would be nice if a general tool existed that could\ntranslate any sort of Python data to a format that could be saved in a file in a single step.\nThat is exactly what the Python pickle module is designed to do. The pickle module\ntranslates an in-memory Python object into a serialized byte stream\u2014a string of bytes\nthat can be written to any file-like object. The pickle module also knows how to re-\nconstruct the original object in memory, given the serialized byte stream: we get back\nthe exact same object. In a sense, the pickle module replaces proprietary data formats\n\u2014its serialized format is general and efficient enough for any program. With pickle,\nthere is no need to manually translate objects to data when storing them persistently,\nand no need to manually parse a complex format to get them back. Pickling is similar\nin spirit to XML representations, but it\u2019s both more Python-specific, and much simpler\nto code.\nThe net effect is that pickling allows us to store and fetch native Python objects as they\nare and in a single step\u2014we use normal Python syntax to process pickled records.\nDespite what it does, the pickle module is remarkably easy to use. Example 1-5 shows\nhow to store our records in a flat file, using pickle.\nExample 1-5. PP4E\\Preview\\make_db_pickle.py\nfrom initdata import db\nimport pickle\ndbfile = open('people-pickle', 'wb')               # use binary mode files in 3.X\npickle.dump(db, dbfile)                            # data is bytes, not str\ndbfile.close()\nWhen run, this script stores the entire database (the dictionary of dictionaries defined\nin Example 1-1) to a flat file named people-pickle in the current working directory. The\npickle module handles the work of converting the object to a string. Example 1-6 shows\nhow to access the pickled database after it has been created; we simply open the file\nand pass its content back to pickle to remake the object from its serialized string.\nExample 1-6. PP4E\\Preview\\dump_db_pickle.py\nimport pickle\ndbfile = open('people-pickle', 'rb')               # use binary mode files in 3.X\ndb = pickle.load(dbfile)\nfor key in db:\n    print(key, '=>\\n  ', db[key])\nprint(db['sue']['name'])\nHere are these two scripts at work, at the system command line again; naturally, they\ncan also be run in IDLE, and you can open and inspect the pickle file by running the\nsame sort of code interactively as well:\n20 | Chapter 1:\u2002A Sneak Preview...\\PP4E\\Preview> python make_db_pickle.py\n...\\PP4E\\Preview> python dump_db_pickle.py\nbob =>\n   {'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}\nsue =>\n   {'pay': 40000, 'job': 'hdw', 'age': 45, 'name': 'Sue Jones'}\ntom =>\n   {'pay': 0, 'job': None, 'age': 50, 'name': 'Tom'}\nSue Jones\nUpdating with a pickle file is similar to a manually formatted file, except that Python\nis doing all of the formatting work for us. Example 1-7 shows how.\nExample 1-7. PP4E\\Preview\\update-db-pickle.py\nimport pickle\ndbfile = open('people-pickle', 'rb')\ndb = pickle.load(dbfile)\ndbfile.close()\ndb['sue']['pay'] *= 1.10\ndb['tom']['name'] = 'Tom Tom'\ndbfile = open('people-pickle', 'wb')\npickle.dump(db, dbfile)\ndbfile.close()\nNotice how the entire database is written back to the file after the records are changed\nin memory, just as for the manually formatted approach; this might become slow for\nvery large databases, but we\u2019ll ignore this for the moment. Here are our update and\ndump scripts in action\u2014as in the prior section, Sue\u2019s pay and Tom\u2019s name change\nbetween scripts because they are written back to a file (this time, a pickle file):\n...\\PP4E\\Preview> python update_db_pickle.py\n...\\PP4E\\Preview> python dump_db_pickle.py\nbob =>\n   {'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}\nsue =>\n   {'pay': 44000.0, 'job': 'hdw', 'age': 45, 'name': 'Sue Jones'}\ntom =>\n   {'pay': 0, 'job': None, 'age': 50, 'name': 'Tom Tom'}\nSue Jones\nAs we\u2019ll learn in Chapter 17, the Python pickling system supports nearly arbitrary object\ntypes\u2014lists, dictionaries, class instances, nested structures, and more. There, we\u2019ll also\nlearn about the pickler\u2019s text and binary storage protocols; as of Python 3, all protocols\nuse bytes objects to represent pickled data, which in turn requires pickle files to be\nopened in binary mode for all protocols. As we\u2019ll see later in this chapter, the pickler\nand its data format also underlie shelves and ZODB databases, and pickled class in-\nstances provide both data and behavior for objects stored.\nIn fact, pickling is more general than these examples may imply. Because they accept\nany object that provides an interface compatible with files, pickling and unpickling may\nStep 2: Storing Records Persistently | 21be used to transfer native Python objects to a variety of media. Using a network socket,\nfor instance, allows us to ship pickled Python objects across a network and provides\nan alternative to larger protocols such as SOAP and XML-RPC.\nUsing Per-Record Pickle Files\nAs mentioned earlier, one potential disadvantage of this section\u2019s examples so far is\nthat they may become slow for very large databases: because the entire database must\nbe loaded and rewritten to update a single record, this approach can waste time. We\ncould improve on this by storing each record in the database in a separate flat file. The\nnext three examples show one way to do so; Example 1-8 stores each record in its own\nflat file, using each record\u2019s original key as its filename with a .pkl appended (it creates\nthe files bob.pkl, sue.pkl, and tom.pkl in the current working directory).\nExample 1-8. PP4E\\Preview\\make_db_pickle_recs.py\nfrom initdata import bob, sue, tom\nimport pickle\nfor (key, record) in [('bob', bob), ('tom', tom), ('sue', sue)]:\n    recfile = open(key + '.pkl', 'wb')\n    pickle.dump(record, recfile)\n    recfile.close()\nNext, Example 1-9 dumps the entire database by using the standard library\u2019s glob \nmodule to do filename expansion and thus collect all the files in this directory with\na .pkl extension. To load a single record, we open its file and deserialize with pickle;\nwe must load only one record file, though, not the entire database, to fetch one record.\nExample 1-9. PP4E\\Preview\\dump_db_pickle_recs.py\nimport pickle, glob\nfor filename in glob.glob('*.pkl'):         # for 'bob','sue','tom'\n    recfile = open(filename, 'rb')\n    record  = pickle.load(recfile)\n    print(filename, '=>\\n  ', record)\nsuefile = open('sue.pkl', 'rb')\nprint(pickle.load(suefile)['name'])         # fetch sue's name\nFinally, Example 1-10 updates the database by fetching a record from its file, changing\nit in memory, and then writing it back to its pickle file. This time, we have to fetch and\nrewrite only a single record file, not the full database, to update.\nExample 1-10. PP4E\\Preview\\update_db_pickle_recs.py\nimport pickle\nsuefile = open('sue.pkl', 'rb')\nsue = pickle.load(suefile)\nsuefile.close()\n22 | Chapter 1:\u2002A Sneak Previewsue['pay'] *= 1.10\nsuefile = open('sue.pkl', 'wb')\npickle.dump(sue, suefile)\nsuefile.close()\nHere are our file-per-record scripts in action; the results are about the same as in the\nprior section, but database keys become real filenames now. In a sense, the filesystem\nbecomes our top-level dictionary\u2014filenames provide direct access to each record.\n...\\PP4E\\Preview> python make_db_pickle_recs.py\n...\\PP4E\\Preview> python dump_db_pickle_recs.py\nbob.pkl =>\n   {'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}\nsue.pkl =>\n   {'pay': 40000, 'job': 'hdw', 'age': 45, 'name': 'Sue Jones'}\ntom.pkl =>\n   {'pay': 0, 'job': None, 'age': 50, 'name': 'Tom'}\nSue Jones\n...\\PP4E\\Preview> python update_db_pickle_recs.py\n...\\PP4E\\Preview> python dump_db_pickle_recs.py\nbob.pkl =>\n   {'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}\nsue.pkl =>\n   {'pay': 44000.0, 'job': 'hdw', 'age': 45, 'name': 'Sue Jones'}\ntom.pkl =>\n   {'pay': 0, 'job': None, 'age': 50, 'name': 'Tom'}\nSue Jones\nUsing Shelves\nPickling objects to files, as shown in the preceding section, is an optimal scheme in\nmany applications. In fact, some applications use pickling of Python objects across\nnetwork sockets as a simpler alternative to network protocols such as the SOAP and\nXML-RPC web services architectures (also supported by Python, but much heavier than\npickle).\nMoreover, assuming your filesystem can handle as many files as you\u2019ll need, pickling\none record per file also obviates the need to load and store the entire database for each\nupdate. If we really want keyed access to records, though, the Python standard library\noffers an even higher-level tool: shelves.\nShelves automatically pickle objects to and from a keyed-access filesystem. They behave\nmuch like dictionaries that must be opened, and they persist after each program exits.\nBecause they give us key-based access to stored records, there is no need to manually\nmanage one flat file per record\u2014the shelve system automatically splits up stored re-\ncords and fetches and updates only those records that are accessed and changed. In\nthis way, shelves provide utility similar to per-record pickle files, but they are usually\neasier to code.\nStep 2: Storing Records Persistently | 23The shelve interface is just as simple as pickle: it is identical to dictionaries, with extra\nopen and close calls. In fact, to your code, a shelve really does appear to be a persistent\ndictionary of persistent objects; Python does all the work of mapping its content to and\nfrom a file. For instance, Example 1-11 shows how to store our in-memory dictionary\nobjects in a shelve for permanent keeping.\nExample 1-11. PP4E\\Preview\\make_db_shelve.py\nfrom initdata import bob, sue\nimport shelve\ndb = shelve.open('people-shelve')\ndb['bob'] = bob\ndb['sue'] = sue\ndb.close()\nThis script creates one or more files in the current directory with the name people-\nshelve as a prefix (in Python 3.1 on Windows, people-shelve.bak, people-shelve.dat, and\npeople-shelve.dir). You shouldn\u2019t delete these files (they are your database!), and you\nshould be sure to use the same base name in other scripts that access the shelve.\nExample 1-12, for instance, reopens the shelve and indexes it by key to fetch its stored\nrecords.\nExample 1-12. PP4E\\Preview\\dump_db_shelve.py\nimport shelve\ndb = shelve.open('people-shelve')\nfor key in db:\n    print(key, '=>\\n  ', db[key])\nprint(db['sue']['name'])\ndb.close()\nWe still have a dictionary of dictionaries here, but the top-level dictionary is really a\nshelve mapped onto a file. Much happens when you access a shelve\u2019s keys\u2014it uses\npickle internally to serialize and deserialize objects stored, and it interfaces with a\nkeyed-access filesystem. From your perspective, though, it\u2019s just a persistent dictionary.\nExample 1-13 shows how to code shelve updates.\nExample 1-13. PP4E\\Preview\\update_db_shelve.py\nfrom initdata import tom\nimport shelve\ndb = shelve.open('people-shelve')\nsue = db['sue']                       # fetch sue\nsue['pay'] *= 1.50\ndb['sue'] = sue                       # update sue\ndb['tom'] = tom                       # add a new record\ndb.close()\nNotice how this code fetches sue by key, updates in memory, and then reassigns to the\nkey to update the shelve; this is a requirement of shelves by default, but not always of\nmore advanced shelve-like systems such as ZODB, covered in Chapter 17. As we\u2019ll see\n24 | Chapter 1:\u2002A Sneak Previewlater, shelve.open also has a newer writeback keyword argument, which, if passed\nTrue, causes all records loaded from the shelve to be cached in memory, and automat-\nically written back to the shelve when it is closed; this avoids manual write backs on\nchanges, but can consume memory and make closing slow.\nAlso note how shelve files are explicitly closed. Although we don\u2019t need to pass mode\nflags to shelve.open (by default it creates the shelve if needed, and opens it for reads\nand writes otherwise), some underlying keyed-access filesystems may require a close\ncall in order to flush output buffers after changes.\nFinally, here are the shelve-based scripts on the job, creating, changing, and fetching\nrecords. The records are still dictionaries, but the database is now a dictionary-like\nshelve which automatically retains its state in a file between program runs:\n...\\PP4E\\Preview> python make_db_shelve.py\n...\\PP4E\\Preview> python dump_db_shelve.py\nbob =>\n   {'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}\nsue =>\n   {'pay': 40000, 'job': 'hdw', 'age': 45, 'name': 'Sue Jones'}\nSue Jones\n...\\PP4E\\Preview> python update_db_shelve.py\n...\\PP4E\\Preview> python dump_db_shelve.py\nbob =>\n   {'pay': 30000, 'job': 'dev', 'age': 42, 'name': 'Bob Smith'}\nsue =>\n   {'pay': 60000.0, 'job': 'hdw', 'age': 45, 'name': 'Sue Jones'}\ntom =>\n   {'pay': 0, 'job': None, 'age': 50, 'name': 'Tom'}\nSue Jones\nWhen we ran the update and dump scripts here, we added a new record for key tom\nand increased Sue\u2019s pay field by 50 percent. These changes are permanent because the\nrecord dictionaries are mapped to an external file by shelve. (In fact, this is a particularly\ngood script for Sue\u2014something she might consider scheduling to run often, using a\ncron job on Unix, or a Startup folder or msconfig entry on Windows\u2026)\nWhat\u2019s in a Name?\nThough it\u2019s a surprisingly well-kept secret, Python gets its name from the 1970s British\nTV comedy series Monty Python\u2019s Flying Circus. According to Python folklore, Guido \nvan Rossum, Python\u2019s creator, was watching reruns of the show at about the same time\nhe needed a name for a new language he was developing. And as they say in show\nbusiness, \u201cthe rest is history.\u201d\nBecause of this heritage, references to the comedy group\u2019s work often show up in ex-\namples and discussion. For instance, the name Brian appears often in scripts; the words\nspam, lumberjack, and shrubbery have a special connotation to Python users; and pre-\nsentations are sometimes referred to as The Spanish Inquisition. As a rule, if a Python\nuser starts using phrases that have no relation to reality, they\u2019re probably borrowed\nStep 2: Storing Records Persistently | 25from the Monty Python series or movies. Some of these phrases might even pop up in\nthis book. You don\u2019t have to run out and rent The Meaning of Life or The Holy Grail\nto do useful work in Python, of course, but it can\u2019t hurt.\nWhile \u201cPython\u201d turned out to be a distinctive name, it has also had some interesting\nside effects. For instance, when the Python newsgroup, comp.lang.python, came online\nin 1994, its first few weeks of activity were almost entirely taken up by people wanting\nto discuss topics from the TV show. More recently, a special Python supplement in the\nLinux Journal magazine featured photos of Guido garbed in an obligatory \u201cnice red\nuniform.\u201d\nPython\u2019s news list still receives an occasional post from fans of the show. For instance,\none early poster innocently offered to swap Monty Python scripts with other fans. Had\nhe known the nature of the forum, he might have at least mentioned whether they were\nportable or not.\nStep 3: Stepping Up to OOP\nLet\u2019s step back for a moment and consider how far we\u2019ve come. At this point, we\u2019ve\ncreated a database of records: the shelve, as well as per-record pickle file approaches\nof the prior section suffice for basic data storage tasks. As is, our records are represented\nas simple dictionaries, which provide easier-to-understand access to fields than do lists\n(by key, rather than by position). Dictionaries, however, still have some limitations that\nmay become more critical as our program grows over time.\nFor one thing, there is no central place for us to collect record processing logic. Ex-\ntracting last names and giving raises, for instance, can be accomplished with code like\nthe following:\n>>> import shelve\n>>> db = shelve.open('people-shelve')\n>>> bob = db['bob']\n>>> bob['name'].split()[-1]             # get bob's last name\n'Smith'\n>>> sue = db['sue']\n>>> sue['pay'] *= 1.25                  # give sue a raise\n>>> sue['pay']\n75000.0\n>>> db['sue'] = sue\n>>> db.close()\nThis works, and it might suffice for some short programs. But if we ever need to change\nthe way last names and raises are implemented, we might have to update this kind of\ncode in many places in our program. In fact, even finding all such magical code snippets\ncould be a challenge; hardcoding or cutting and pasting bits of logic redundantly like\nthis in more than one place will almost always come back to haunt you eventually.\nIt would be better to somehow hide\u2014that is, encapsulate\u2014such bits of code. Functions\nin a module would allow us to implement such operations in a single place and thus\n26 | Chapter 1:\u2002A Sneak Previewavoid code redundancy, but still wouldn\u2019t naturally associate them with the records\nthemselves. What we\u2019d like is a way to bind processing logic with the data stored in\nthe database in order to make it easier to understand, debug, and reuse.\nAnother downside to using dictionaries for records is that they are difficult to expand\nover time. For example, suppose that the set of data fields or the procedure for giving\nraises is different for different kinds of people (perhaps some people get a bonus each\nyear and some do not). If we ever need to extend our program, there is no natural way\nto customize simple dictionaries. For future growth, we\u2019d also like our software to\nsupport extension and customization in a natural way.\nIf you\u2019ve already studied Python in any sort of depth, you probably already know that\nthis is where its OOP support begins to become attractive:\nStructure\nWith OOP, we can naturally associate processing logic with record data\u2014classes\nprovide both a program unit that combines logic and data in a single package and\na hierarchy that allows code to be easily factored to avoid redundancy.\nEncapsulation\nWith OOP, we can also wrap up details such as name processing and pay increases\nbehind method functions\u2014i.e., we are free to change method implementations\nwithout breaking their users.\nCustomization\nAnd with OOP, we have a natural growth path. Classes can be extended and cus-\ntomized by coding new subclasses, without changing or breaking already working\ncode.\nThat is, under OOP, we program by customizing and reusing, not by rewriting. OOP\nis an option in Python and, frankly, is sometimes better suited for strategic than for\ntactical tasks. It tends to work best when you have time for upfront planning\u2014some-\nthing that might be a luxury if your users have already begun storming the gates.\nBut especially for larger systems that change over time, its code reuse and structuring\nadvantages far outweigh its learning curve, and it can substantially cut development\ntime. Even in our simple case, the customizability and reduced redundancy we gain\nfrom classes can be a decided advantage.\nUsing Classes\nOOP is easy to use in Python, thanks largely to Python\u2019s dynamic typing model. In fact,\nit\u2019s so easy that we\u2019ll jump right into an example: Example 1-14 implements our data-\nbase records as class instances rather than as dictionaries.\nExample 1-14. PP4E\\Preview\\person_start.py\nclass Person:\n    def __init__(self, name, age, pay=0, job=None):\nStep 3: Stepping Up to OOP | 27self.name = name\n        self.age  = age\n        self.pay  = pay\n        self.job  = job\nif __name__ == '__main__':\n    bob = Person('Bob Smith', 42, 30000, 'software')\n    sue = Person('Sue Jones', 45, 40000, 'hardware')\n    print(bob.name, sue.pay)\n    print(bob.name.split()[-1])\n    sue.pay *= 1.10\n    print(sue.pay)\nThere is not much to this class\u2014just a constructor method that fills out the instance\nwith data passed in as arguments to the class name. It\u2019s sufficient to represent a database\nrecord, though, and it can already provide tools such as defaults for pay and job fields\nthat dictionaries cannot. The self-test code at the bottom of this file creates two in-\nstances (records) and accesses their attributes (fields); here is this file\u2019s output when\nrun under IDLE (a system command-line works just as well):\nBob Smith 40000\nSmith\n44000.0\nThis isn\u2019t a database yet, but we could stuff these objects into a list or dictionary as\nbefore in order to collect them as a unit:\n>>> from person_start import Person\n>>> bob = Person('Bob Smith', 42)\n>>> sue = Person('Sue Jones', 45, 40000)\n>>> people = [bob, sue]                          # a \"database\" list\n>>> for person in people:\n        print(person.name, person.pay)\nBob Smith 0\nSue Jones 40000\n>>> x = [(person.name, person.pay) for person in people]\n>>> x\n[('Bob Smith', 0), ('Sue Jones', 40000)]\n>>> [rec.name for rec in people if rec.age >= 45]     # SQL-ish query\n['Sue Jones']\n>>> [(rec.age ** 2 if rec.age >= 45 else rec.age) for rec in people]\n[42, 2025]\nNotice that Bob\u2019s pay defaulted to zero this time because we didn\u2019t pass in a value for\nthat argument (maybe Sue is supporting him now?). We might also implement a class\nthat represents the database, perhaps as a subclass of the built-in list or dictionary types,\nwith insert and delete methods that encapsulate the way the database is implemented.\nWe\u2019ll abandon this path for now, though, because it will be more useful to store these\n28 | Chapter 1:\u2002A Sneak Previewrecords persistently in a shelve, which already encapsulates stores and fetches behind\nan interface for us. Before we do, though, let\u2019s add some logic.\nAdding Behavior\nSo far, our class is just data: it replaces dictionary keys with object attributes, but it\ndoesn\u2019t add much to what we had before. To really leverage the power of classes, we\nneed to add some behavior. By wrapping up bits of behavior in class method functions,\nwe can insulate clients from changes. And by packaging methods in classes along with\ndata, we provide a natural place for readers to look for code. In a sense, classes combine\nrecords and the programs that process those records; methods provide logic that in-\nterprets and updates the data (we say they are object-oriented, because they always\nprocess an object\u2019s data).\nFor instance, Example 1-15 adds the last-name and raise logic as class methods; meth-\nods use the self argument to access or update the instance (record) being processed.\nExample 1-15. PP4E\\Preview\\person.py\nclass Person:\n    def __init__(self, name, age, pay=0, job=None):\n        self.name = name\n        self.age  = age\n        self.pay  = pay\n        self.job  = job\n    def lastName(self):\n        return self.name.split()[-1]\n    def giveRaise(self, percent):\n        self.pay *= (1.0 + percent)\nif __name__ == '__main__':\n    bob = Person('Bob Smith', 42, 30000, 'software')\n    sue = Person('Sue Jones', 45, 40000, 'hardware')\n    print(bob.name, sue.pay)\n    print(bob.lastName())\n    sue.giveRaise(.10)\n    print(sue.pay)\nThe output of this script is the same as the last, but the results are being computed by\nmethods now, not by hardcoded logic that appears redundantly wherever it is required:\nBob Smith 40000\nSmith\n44000.0\nAdding Inheritance\nOne last enhancement to our records before they become permanent: because they are\nimplemented as classes now, they naturally support customization through the inher-\nitance search mechanism in Python. Example 1-16, for instance, customizes the last\nStep 3: Stepping Up to OOP | 29section\u2019s Person class in order to give a 10 percent bonus by default to managers when-\never they receive a raise (any relation to practice in the real world is purely coincidental).\nExample 1-16. PP4E\\Preview\\manager.py\nfrom person import Person\nclass Manager(Person):\n    def giveRaise(self, percent, bonus=0.1):\n        self.pay *= (1.0 + percent + bonus)\nif __name__ == '__main__':\n    tom = Manager(name='Tom Doe', age=50, pay=50000)\n    print(tom.lastName())\n    tom.giveRaise(.20)\n    print(tom.pay)\nWhen run, this script\u2019s self-test prints the following:\nDoe\n65000.0\nHere, the Manager class appears in a module of its own, but it could have been added\nto the person module instead (Python doesn\u2019t require just one class per file). It inherits\nthe constructor and last-name methods from its superclass, but it customizes just the\ngiveRaise method (there are a variety of ways to code this extension, as we\u2019ll see later).\nBecause this change is being added as a new subclass, the original Person class, and any\nobjects generated from it, will continue working unchanged. Bob and Sue, for example,\ninherit the original raise logic, but Tom gets the custom version because of the class\nfrom which he is created. In OOP, we program by customizing, not by changing.\nIn fact, code that uses our objects doesn\u2019t need to be at all aware of what the raise\nmethod does\u2014it\u2019s up to the object to do the right thing based on the class from which\nit is created. As long as the object supports the expected interface (here, a method called\ngiveRaise), it will be compatible with the calling code, regardless of its specific type,\nand even if its method works differently than others.\nIf you\u2019ve already studied Python, you may know this behavior as polymorphism; it\u2019s a\ncore property of the language, and it accounts for much of your code\u2019s flexibility. When\nthe following code calls the giveRaise method, for example, what happens depends on\nthe obj object being processed; Tom gets a 20 percent raise instead of 10 percent be-\ncause of the Manager class\u2019s customization:\n>>> from person import Person\n>>> from manager import Manager\n>>> bob = Person(name='Bob Smith', age=42, pay=10000)\n>>> sue = Person(name='Sue Jones', age=45, pay=20000)\n>>> tom = Manager(name='Tom Doe',  age=55, pay=30000)\n>>> db = [bob, sue, tom]\n30 | Chapter 1:\u2002A Sneak Preview>>> for obj in db:\n        obj.giveRaise(.10)         # default or custom\n>>> for obj in db:\n        print(obj.lastName(), '=>', obj.pay)\nSmith => 11000.0\nJones => 22000.0\nDoe => 36000.0\nRefactoring Code\nBefore we move on, there are a few coding alternatives worth noting here. Most of these\nunderscore the Python OOP model, and they serve as a quick review.\nAugmenting methods\nAs a first alternative, notice that we have introduced some redundancy in Exam-\nple 1-16: the raise calculation is now repeated in two places (in the two classes). We\ncould also have implemented the customized Manager class by augmenting the inherited\nraise method instead of replacing it completely:\nclass Manager(Person):\n    def giveRaise(self, percent, bonus=0.1):\n        Person.giveRaise(self, percent + bonus)\nThe trick here is to call back the superclass\u2019s version of the method directly, passing in\nthe self argument explicitly. We still redefine the method, but we simply run the gen-\neral version after adding 10 percent (by default) to the passed-in percentage. This coding\npattern can help reduce code redundancy (the original raise method\u2019s logic appears in\nonly one place and so is easier to change) and is especially handy for kicking off su-\nperclass constructor methods in practice.\nIf you\u2019ve already studied Python OOP, you know that this coding scheme works be-\ncause we can always call methods through either an instance or the class name. In\ngeneral, the following are equivalent, and both forms may be used explicitly:\ninstance.method(arg1, arg2)\nclass.method(instance, arg1, arg2)\nIn fact, the first form is mapped to the second\u2014when calling through the instance,\nPython determines the class by searching the inheritance tree for the method name and\npasses in the instance automatically. Either way, within giveRaise, self refers to the\ninstance that is the subject of the call.\nDisplay format\nFor more object-oriented fun, we could also add a few operator overloading methods\nto our people classes. For example, a __str__ method, shown here, could return a string\nStep 3: Stepping Up to OOP | 31to give the display format for our objects when they are printed as a whole\u2014much\nbetter than the default display we get for an instance:\nclass Person:\n    def __str__(self):\n        return '<%s => %s>' % (self.__class__.__name__, self.name)\ntom = Manager('Tom Jones', 50)\nprint(tom)                               # prints: <Manager => Tom Jones>\nHere __class__ gives the lowest class from which self was made, even though\n__str__ may be inherited. The net effect is that __str__ allows us to print instances\ndirectly instead of having to print specific attributes. We could extend this __str__ to\nloop through the instance\u2019s __dict__ attribute dictionary to display all attributes ge-\nnerically; for this preview we\u2019ll leave this as a suggested exercise.\nWe might even code an __add__ method to make + expressions automatically call the\ngiveRaise method. Whether we should is another question; the fact that a + expression\ngives a person a raise might seem more magical to the next person reading our code\nthan it should.\nConstructor customization\nFinally, notice that we didn\u2019t pass the job argument when making a manager in Ex-\nample 1-16; if we had, it would look like this with keyword arguments:\ntom = Manager(name='Tom Doe', age=50, pay=50000, job='manager')\nThe reason we didn\u2019t include a job in the example is that it\u2019s redundant with the class\nof the object: if someone is a manager, their class should imply their job title. Instead\nof leaving this field blank, though, it may make more sense to provide an explicit con-\nstructor for managers, which fills in this field automatically:\nclass Manager(Person):\n    def __init__(self, name, age, pay):\n        Person.__init__(self, name, age, pay, 'manager')\nNow when a manager is created, its job is filled in automatically. The trick here is to\ncall to the superclass\u2019s version of the method explicitly, just as we did for the\ngiveRaise method earlier in this section; the only difference here is the unusual name\nfor the constructor method.\nAlternative classes\nWe won\u2019t use any of this section\u2019s three extensions in later examples, but to demon-\nstrate how they work, Example 1-17 collects these ideas in an alternative implementa-\ntion of our Person classes.\n32 | Chapter 1:\u2002A Sneak PreviewExample 1-17. PP4E\\Preview\\person_alternative.py\n\"\"\"\nAlternative implementation of person classes, with data, behavior,\nand operator overloading (not used for objects stored persistently)\n\"\"\"\nclass Person:\n    \"\"\"\n    a general person: data+logic\n    \"\"\"\n    def __init__(self, name, age, pay=0, job=None):\n        self.name = name\n        self.age  = age\n        self.pay  = pay\n        self.job  = job\n    def lastName(self):\n        return self.name.split()[-1]\n    def giveRaise(self, percent):\n        self.pay *= (1.0 + percent)\n    def __str__(self):\n        return ('<%s => %s: %s, %s>' %\n               (self.__class__.__name__, self.name, self.job, self.pay))\nclass Manager(Person):\n    \"\"\"\n    a person with custom raise\n    inherits general lastname, str\n    \"\"\"\n    def __init__(self, name, age, pay):\n        Person.__init__(self, name, age, pay, 'manager')\n    def giveRaise(self, percent, bonus=0.1):\n        Person.giveRaise(self, percent + bonus)\nif __name__ == '__main__':\n    bob = Person('Bob Smith', 44)\n    sue = Person('Sue Jones', 47, 40000, 'hardware')\n    tom = Manager(name='Tom Doe', age=50, pay=50000)\n    print(sue, sue.pay, sue.lastName())\n    for obj in (bob, sue, tom):\n        obj.giveRaise(.10)                 # run this obj's giveRaise\n        print(obj)                         # run common __str__ method\nNotice the polymorphism in this module\u2019s self-test loop: all three objects share the\nconstructor, last-name, and printing methods, but the raise method called is dependent\nupon the class from which an instance is created. When run, Example 1-17 prints the\nfollowing to standard output\u2014the manager\u2019s job is filled in at construction, we get the\nnew custom display format for our objects, and the new version of the manager\u2019s raise\nmethod works as before:\n<Person => Sue Jones: hardware, 40000> 40000 Jones\n<Person => Bob Smith: None, 0.0>\n<Person => Sue Jones: hardware, 44000.0>\n<Manager => Tom Doe: manager, 60000.0>\nStep 3: Stepping Up to OOP | 33Such refactoring (restructuring) of code is common as class hierarchies grow and evolve.\nIn fact, as is, we still can\u2019t give someone a raise if his pay is zero (Bob is out of luck);\nwe probably need a way to set pay, too, but we\u2019ll leave such extensions for the next\nrelease. The good news is that Python\u2019s flexibility and readability make refactoring\neasy\u2014it\u2019s simple and quick to restructure your code. If you haven\u2019t used the language\nyet, you\u2019ll find that Python development is largely an exercise in rapid, incremental,\nand interactive programming, which is well suited to the shifting needs of real-world \nprojects.\nAdding Persistence\nIt\u2019s time for a status update. We now have encapsulated in the form of classes custom-\nizable implementations of our records and their processing logic. Making our class-\nbased records persistent is a minor last step. We could store them in per-record pickle\nfiles again; a shelve-based storage medium will do just as well for our goals and is often\neasier to code. Example 1-18 shows how.\nExample 1-18. PP4E\\Preview\\make_db_classes.py\nimport shelve\nfrom person import Person\nfrom manager import Manager\nbob = Person('Bob Smith', 42, 30000, 'software')\nsue = Person('Sue Jones', 45, 40000, 'hardware')\ntom = Manager('Tom Doe',  50, 50000)\ndb = shelve.open('class-shelve')\ndb['bob'] = bob\ndb['sue'] = sue\ndb['tom'] = tom\ndb.close()\nThis file creates three class instances (two from the original class and one from its\ncustomization) and assigns them to keys in a newly created shelve file to store them\npermanently. In other words, it creates a shelve of class instances; to our code, the\ndatabase looks just like a dictionary of class instances, but the top-level dictionary is\nmapped to a shelve file again. To check our work, Example 1-19 reads the shelve and\nprints fields of its records.\nExample 1-19. PP4E\\Preview\\dump_db_classes.py\nimport shelve\ndb = shelve.open('class-shelve')\nfor key in db:\n    print(key, '=>\\n  ', db[key].name, db[key].pay)\nbob = db['bob']\nprint(bob.lastName())\nprint(db['tom'].lastName())\n34 | Chapter 1:\u2002A Sneak PreviewNote that we don\u2019t need to reimport the Person class here in order to fetch its instances\nfrom the shelve or run their methods. When instances are shelved or pickled, the un-\nderlying pickling system records both instance attributes and enough information to\nlocate their classes automatically when they are later fetched (the class\u2019s module simply\nhas to be on the module search path when an instance is loaded). This is on purpose;\nbecause the class and its instances in the shelve are stored separately, you can change\nthe class to modify the way stored instances are interpreted when loaded (more on this\nlater in the book). Here is the shelve dump script\u2019s output just after creating the shelve\nwith the maker script:\nbob =>\n   Bob Smith 30000\nsue =>\n   Sue Jones 40000\ntom =>\n   Tom Doe 50000\nSmith\nDoe\nAs shown in Example 1-20, database updates are as simple as before (compare this to\nExample 1-13), but dictionary keys become attributes of instance objects, and updates\nare implemented by class method calls instead of hardcoded logic. Notice how we still\nfetch, update, and reassign to keys to update the shelve.\nExample 1-20. PP4E\\Preview\\update_db_classes.py\nimport shelve\ndb = shelve.open('class-shelve')\nsue = db['sue']\nsue.giveRaise(.25)\ndb['sue'] = sue\ntom = db['tom']\ntom.giveRaise(.20)\ndb['tom'] = tom\ndb.close()\nAnd last but not least, here is the dump script again after running the update script;\nTom and Sue have new pay values, because these objects are now persistent in the\nshelve. We could also open and inspect the shelve by typing code at Python\u2019s interactive\ncommand line; despite its longevity, the shelve is just a Python object containing Python\nobjects.\nbob =>\n   Bob Smith 30000\nsue =>\n   Sue Jones 50000.0\ntom =>\n   Tom Doe 65000.0\nSmith\nDoe\nStep 3: Stepping Up to OOP | 35Tom and Sue both get a raise this time around, because they are persistent objects in\nthe shelve database. Although shelves can also store simpler object types such as lists\nand dictionaries, class instances allow us to combine both data and behavior for our\nstored items. In a sense, instance attributes and class methods take the place of records\nand processing programs in more traditional schemes.\nOther Database Options\nAt this point, we have a full-fledged database system: our classes simultaneously im-\nplement record data and record processing, and they encapsulate the implementation\nof the behavior. And the Python pickle and shelve modules provide simple ways to\nstore our database persistently between program executions. This is not a relational\ndatabase (we store objects, not tables, and queries take the form of Python object pro-\ncessing code), but it is sufficient for many kinds of programs.\nIf we need more functionality, we could migrate this application to even more powerful\ntools. For example, should we ever need full-blown SQL query support, there are in-\nterfaces that allow Python scripts to communicate with relational databases such as\nMySQL, PostgreSQL, and Oracle in portable ways.\nORMs (object relational mappers) such as SQLObject and SqlAlchemy offer another\napproach which retains the Python class view, but translates it to and from relational\ndatabase tables\u2014in a sense providing the best of both worlds, with Python class syntax\non top, and enterprise-level databases underneath.\nMoreover, the open source ZODB system provides a more comprehensive object da-\ntabase for Python, with support for features missing in shelves, including concurrent\nupdates, transaction commits and rollbacks, automatic updates on in-memory com-\nponent changes, and more. We\u2019ll explore these more advanced third-party tools in\nChapter 17. For now, let\u2019s move on to putting a good face on our system.\n\u201cBuses Considered Harmful\u201d\nOver the years, Python has been remarkably well supported by the volunteer efforts of\nboth countless individuals and formal organizations. Today, the nonprofit Python\nSoftware Foundation (PSF) oversees Python conferences and other noncommercial ac-\ntivities. The PSF was preceded by the PSA, a group that was originally formed in re-\nsponse to an early thread on the Python newsgroup that posed the semiserious question:\n\u201cWhat would happen if Guido was hit by a bus?\u201d\nThese days, Python creator Guido van Rossum is still the ultimate arbiter of proposed\nPython changes. He was officially anointed the BDFL\u2014Benevolent Dictator for Life\u2014\nof Python at the first Python conference and still makes final yes and no decisions on\nlanguage changes (and apart from 3.0\u2019s deliberate incompatibilities, has usually said\nno: a good thing in the programming languages domain, because Python tends to\nchange slowly and in backward-compatible ways).\n36 | Chapter 1:\u2002A Sneak PreviewBut Python\u2019s user base helps support the language, work on extensions, fix bugs, and\nso on. It is a true community project. In fact, Python development is now a completely\nopen process\u2014anyone can inspect the latest source code files or submit patches by\nvisiting a website (see http://www.python.org for details).\nAs an open source package, Python development is really in the hands of a very large\ncast of developers working in concert around the world\u2014so much so that if the BDFL\never does pass the torch, Python will almost certainly continue to enjoy the kind of\nsupport its users have come to expect. Though not without pitfalls of their own, open\nsource projects by nature tend to reflect the needs of their user communities more than\neither individuals or shareholders.\nGiven Python\u2019s popularity, bus attacks seem less threatening now than they once did.\nOf course, I can\u2019t speak for Guido.\nStep 4: Adding Console Interaction\nSo far, our database program consists of class instances stored in a shelve file, as coded\nin the preceding section. It\u2019s sufficient as a storage medium, but it requires us to run\nscripts from the command line or type code interactively in order to view or process its\ncontent. Improving on this is straightforward: simply code more general programs that\ninteract with users, either from a console window or from a full-blown graphical\ninterface.\nA Console Shelve Interface\nLet\u2019s start with something simple. The most basic kind of interface we can code would\nallow users to type keys and values in a console window in order to process the database\n(instead of writing Python program code). Example 1-21, for instance, implements a\nsimple interactive loop that allows a user to query multiple record objects in the shelve\nby key.\nExample 1-21. PP4E\\Preview\\peopleinteract_query.py\n# interactive queries\nimport shelve\nfieldnames = ('name', 'age', 'job', 'pay')\nmaxfield   = max(len(f) for f in fieldnames)\ndb = shelve.open('class-shelve')\nwhile True:\n    key = input('\\nKey? => ')           # key or empty line, exc at eof\n    if not key: break\n    try:\n        record = db[key]                # fetch by key, show in console\nStep 4: Adding Console Interaction | 37except:\n        print('No such key \"%s\"!' % key)\n    else:\n        for field in fieldnames:\n            print(field.ljust(maxfield), '=>', getattr(record, field))\nThis script uses the getattr built-in function to fetch an object\u2019s attribute when given\nits name string, and the ljust left-justify method of strings to align outputs (max\nfield, derived from a generator expression, is the length of the longest field name).\nWhen run, this script goes into a loop, inputting keys from the interactive user (tech-\nnically, from the standard input stream, which is usually a console window) and dis-\nplaying the fetched records field by field. An empty line ends the session. If our shelve\nof class instances is still in the state we left it near the end of the last section:\n...\\PP4E\\Preview> dump_db_classes.py\nbob =>\n   Bob Smith 30000\nsue =>\n   Sue Jones 50000.0\ntom =>\n   Tom Doe 65000.0\nSmith\nDoe\nWe can then use our new script to query the object database interactively, by key:\n...\\PP4E\\Preview> peopleinteract_query.py\nKey? => sue\nname => Sue Jones\nage  => 45\njob  => hardware\npay  => 50000.0\nKey? => nobody\nNo such key \"nobody\"!\nKey? =>\nExample 1-22 goes further and allows interactive updates. For an input key, it inputs\nvalues for each field and either updates an existing record or creates a new object and\nstores it under the key.\nExample 1-22. PP4E\\Preview\\peopleinteract_update.py\n# interactive updates\nimport shelve\nfrom person import Person\nfieldnames = ('name', 'age', 'job', 'pay')\ndb = shelve.open('class-shelve')\nwhile True:\n    key = input('\\nKey? => ')\n    if not key: break\n38 | Chapter 1:\u2002A Sneak Previewif key in db:\n        record = db[key]                      # update existing record\n    else:                                     # or make/store new rec\n        record = Person(name='?', age='?')    # eval: quote strings\n    for field in fieldnames:\n        currval = getattr(record, field)\n        newtext = input('\\t[%s]=%s\\n\\t\\tnew?=>' % (field, currval))\n        if newtext:\n            setattr(record, field, eval(newtext))\n    db[key] = record\ndb.close()\nNotice the use of eval in this script to convert inputs (as usual, that allows any Python\nobject type, but it means you must quote string inputs explicitly) and the use of\nsetattr call to assign an attribute given its name string. When run, this script allows\nany number of records to be added and changed; to keep the current value of a record\u2019s\nfield, press the Enter key when prompted for a new value:\nKey? => tom\n        [name]=Tom Doe\n                new?=>\n        [age]=50\n                new?=>56\n        [job]=None\n                new?=>'mgr'\n        [pay]=65000.0\n                new?=>90000\nKey? => nobody\n        [name]=?\n                new?=>'John Doh'\n        [age]=?\n                new?=>55\n        [job]=None\n                new?=>\n        [pay]=0\n                new?=>None\nKey? =>\nThis script is still fairly simplistic (e.g., errors aren\u2019t handled), but using it is much easier\nthan manually opening and modifying the shelve at the Python interactive prompt,\nespecially for nonprogrammers. Run the query script to check your work after an up-\ndate (we could combine query and update into a single script if this becomes too cum-\nbersome, albeit at some cost in code and user-experience complexity):\nKey? => tom\nname => Tom Doe\nage  => 56\njob  => mgr\npay  => 90000\nKey? => nobody\nname => John Doh\nStep 4: Adding Console Interaction | 39age  => 55\njob  => None\npay  => None\nKey? =>\nStep 5: Adding a GUI\nThe console-based interface approach of the preceding section works, and it may be\nsufficient for some users assuming that they are comfortable with typing commands in\na console window. With just a little extra work, though, we can add a GUI that is more\nmodern, easier to use, less error prone, and arguably sexier.\nGUI Basics\nAs we\u2019ll see later in this book, a variety of GUI toolkits and builders are available for\nPython programmers: tkinter, wxPython, PyQt, PythonCard, Dabo, and more. Of\nthese, tkinter ships with Python, and it is something of a de facto standard.\ntkinter is a lightweight toolkit and so meshes well with a scripting language such as\nPython; it\u2019s easy to do basic things with tkinter, and it\u2019s straightforward to do more\nadvanced things with extensions and OOP-based code. As an added bonus, tkinter\nGUIs are portable across Windows, Linux/Unix, and Macintosh; simply copy the\nsource code to the machine on which you wish to use your GUI. tkinter doesn\u2019t come\nwith all the bells and whistles of larger toolkits such as wxPython or PyQt, but that\u2019s\na major factor behind its relative simplicity, and it makes it ideal for getting started in\nthe GUI domain.\nBecause tkinter is designed for scripting, coding GUIs with it is straightforward. We\u2019ll\nstudy all of its concepts and tools later in this book. But as a first example, the first\nprogram in tkinter is just a few lines of code, as shown in Example 1-23.\nExample 1-23. PP4E\\Preview\\tkinter001.py\nfrom tkinter import *\nLabel(text='Spam').pack()\nmainloop()\nFrom the tkinter module (really, a module package in Python 3), we get screen device\n(a.k.a. \u201cwidget\u201d) construction calls such as Label; geometry manager methods such as\npack; widget configuration presets such as the TOP and RIGHT attachment side hints we\u2019ll\nuse later for pack; and the mainloop call, which starts event processing.\nThis isn\u2019t the most useful GUI ever coded, but it demonstrates tkinter basics and it\nbuilds the fully functional window shown in Figure 1-1 in just three simple lines of\ncode. Its window is shown here, like all GUIs in this book, running on Windows 7; it\nworks the same on other platforms (e.g., Mac OS X, Linux, and older versions of Win-\ndows), but renders in with native look and feel on each.\n40 | Chapter 1:\u2002A Sneak PreviewYou can launch this example in IDLE, from a console command line, or by clicking its\nicon\u2014the same way you can run other Python scripts. tkinter itself is a standard part\nof Python and works out-of-the-box on Windows and others, though you may need\nextra configuration or install steps on some computers (more details later in this book).\nIt\u2019s not much more work to code a GUI that actually responds to a user: Exam-\nple 1-24 implements a GUI with a button that runs the reply function each time it is\npressed.\nExample 1-24. PP4E\\Preview\\ tkinter101.py\nfrom tkinter import *\nfrom tkinter.messagebox import showinfo\ndef reply():\n    showinfo(title='popup', message='Button pressed!')\nwindow = Tk()\nbutton = Button(window, text='press', command=reply)\nbutton.pack()\nwindow.mainloop()\nThis example still isn\u2019t very sophisticated\u2014it creates an explicit Tk main window for\nthe application to serve as the parent container of the button, and it builds the simple\nwindow shown in Figure 1-2 (in tkinter, containers are passed in as the first argument\nwhen making a new widget; they default to the main window). But this time, each time\nyou click the \u201cpress\u201d button, the program responds by running Python code that pops\nup the dialog window in Figure 1-3.\nFigure 1-2. tkinter101.py main window\nNotice that the pop-up dialog looks like it should for Windows 7, the platform on\nwhich this screenshot was taken; again, tkinter gives us a native look and feel that is\nappropriate for the machine on which it is running. We can customize this GUI in many\nways (e.g., by changing colors and fonts, setting window titles and icons, using photos\nFigure 1-1. tkinter001.py window\nStep 5: Adding a GUI | 41on buttons instead of text), but part of the power of tkinter is that we need to set only\nthe options we are interested in tailoring.\nUsing OOP for GUIs\nAll of our GUI examples so far have been top-level script code with a function for\nhandling events. In larger programs, it is often more useful to code a GUI as a subclass\nof the tkinter Frame widget\u2014a container for other widgets. Example 1-25 shows our\nsingle-button GUI recoded in this way as a class.\nExample 1-25. PP4E\\Preview\\tkinter102.py\nfrom tkinter import *\nfrom tkinter.messagebox import showinfo\nclass MyGui(Frame):\n    def __init__(self, parent=None):\n        Frame.__init__(self, parent)\n        button = Button(self, text='press', command=self.reply)\n        button.pack()\n    def reply(self):\n        showinfo(title='popup', message='Button pressed!')\nif __name__ == '__main__':\n    window = MyGui()\n    window.pack()\n    window.mainloop()\nThe button\u2019s event handler is a bound method\u2014self.reply, an object that remembers\nboth self and reply when later called. This example generates the same window and\npop up as Example 1-24 (Figures 1-2 and 1-3); but because it is now a subclass of\nFrame, it automatically becomes an attachable component\u2014i.e., we can add all of the\nwidgets this class creates, as a package, to any other GUI, just by attaching this Frame\nto the GUI. Example 1-26 shows how.\nFigure 1-3. tkinter101.py common dialog pop up\n42 | Chapter 1:\u2002A Sneak PreviewExample 1-26. PP4E\\Preview\\attachgui.py\nfrom tkinter import *\nfrom tkinter102 import MyGui\n# main app window\nmainwin = Tk()\nLabel(mainwin, text=__name__).pack()\n# popup window\npopup = Toplevel()\nLabel(popup, text='Attach').pack(side=LEFT)\nMyGui(popup).pack(side=RIGHT)                   # attach my frame\nmainwin.mainloop()\nThis example attaches our one-button GUI to a larger window, here a Toplevel pop-\nup window created by the importing application and passed into the construction call\nas the explicit parent (you will also get a Tk main window; as we\u2019ll learn later, you always\ndo, whether it is made explicit in your code or not). Our one-button widget package is\nattached to the right side of its container this time. If you run this live, you\u2019ll get the\nscene captured in Figure 1-4; the \u201cpress\u201d button is our attached custom Frame.\nFigure 1-4. Attaching GUIs\nMoreover, because MyGui is coded as a class, the GUI can be customized by the usual\ninheritance mechanism; simply define a subclass that replaces the parts that differ. The\nreply method, for example, can be customized this way to do something unique, as\ndemonstrated in Example 1-27.\nExample 1-27. PP4E\\Preview\\customizegui.py\nfrom tkinter import mainloop\nfrom tkinter.messagebox import showinfo\nfrom tkinter102 import MyGui\nStep 5: Adding a GUI | 43class CustomGui(MyGui):                            # inherit init\n    def reply(self):                               # replace reply\n        showinfo(title='popup', message='Ouch!')\nif __name__ == '__main__':\n    CustomGui().pack()\n    mainloop()\nWhen run, this script creates the same main window and button as the original MyGui\nclass. But pressing its button generates a different reply, as shown in Figure 1-5, because\nthe custom version of the reply method runs.\nFigure 1-5. Customizing GUIs\nAlthough these are still small GUIs, they illustrate some fairly large ideas. As we\u2019ll see\nlater in the book, using OOP like this for inheritance and attachment allows us to reuse\npackages of widgets in other programs\u2014calculators, text editors, and the like can be\ncustomized and added as components to other GUIs easily if they are classes. As we\u2019ll\nalso find, subclasses of widget class can provide a common appearance or standardized\nbehavior for all their instances\u2014similar in spirit to what some observers might call GUI\nstyles or themes. It\u2019s a normal byproduct of Python and OOP.\nGetting Input from a User\nAs a final introductory script, Example 1-28 shows how to input data from the user in\nan Entry widget and display it in a pop-up dialog. The lambda it uses defers the call to\nthe reply function so that inputs can be passed in\u2014a common tkinter coding pattern;\nwithout the lambda, reply would be called when the button is made, instead of when\nit is later pressed (we could also use ent as a global variable within reply, but that makes\nit less general). This example also demonstrates how to change the icon and title of a\ntop-level window; here, the window icon file is located in the same directory as the\nscript (if the icon call in this script fails on your platform, try commenting-out the call;\nicons are notoriously platform specific).\n44 | Chapter 1:\u2002A Sneak PreviewExample 1-28. PP4E\\Preview\\tkinter103.py\nfrom tkinter import *\nfrom tkinter.messagebox import showinfo\ndef reply(name):\n    showinfo(title='Reply', message='Hello %s!' % name)\ntop = Tk()\ntop.title('Echo')\ntop.iconbitmap('py-blue-trans-out.ico')\nLabel(top, text=\"Enter your name:\").pack(side=TOP)\nent = Entry(top)\nent.pack(side=TOP)\nbtn = Button(top, text=\"Submit\", command=(lambda: reply(ent.get())))\nbtn.pack(side=LEFT)\ntop.mainloop()\nAs is, this example is just three widgets attached to the Tk main top-level window; later\nwe\u2019ll learn how to use nested Frame container widgets in a window like this to achieve\na variety of layouts for its three widgets. Figure 1-6 gives the resulting main and pop-\nup windows after the Submit button is pressed. We\u2019ll see something very similar later\nin this chapter, but rendered in a web browser with HTML.\nFigure 1-6. Fetching input from a user\nThe code we\u2019ve seen so far demonstrates many of the core concepts in GUI program-\nming, but tkinter is much more powerful than these examples imply. There are more\nthan 20 widgets in tkinter and many more ways to input data from a user, including\nmultiple-line text, drawing canvases, pull-down menus, radio and check buttons, and\nscroll bars, as well as other layout and event handling mechanisms. Beyond tkinter\nitself, both open source extensions such as PMW, as well as the Tix and ttk toolkits\nnow part of Python\u2019s standard library, can add additional widgets we can use in our\nStep 5: Adding a GUI | 45Python tkinter GUIs and provide an even more professional look and feel. To hint at\nwhat is to come, let\u2019s put tkinter to work on our database of people.\nA GUI Shelve Interface\nFor our database application, the first thing we probably want is a GUI for viewing the\nstored data\u2014a form with field names and values\u2014and a way to fetch records by key.\nIt would also be useful to be able to update a record with new field values given its key\nand to add new records from scratch by filling out the form. To keep this simple, we\u2019ll\nuse a single GUI for all of these tasks. Figure 1-7 shows the window we are going to\ncode as it looks in Windows 7; the record for the key sue has been fetched and displayed\n(our shelve is as we last left it again). This record is really an instance of our class in our\nshelve file, but the user doesn\u2019t need to care.\nFigure 1-7. peoplegui.py main display/input window\nCoding the GUI\nAlso, to keep this simple, we\u2019ll assume that all records in the database have the same\nsets of fields. It would be a minor extension to generalize this for any set of fields (and\ncome up with a general form GUI constructor tool in the process), but we\u2019ll defer such\nevolutions to later in this book. Example 1-29 implements the GUI shown in Figure 1-7.\nExample 1-29. PP4E\\Preview\\peoplegui.py\n\"\"\"\nImplement a GUI for viewing and updating class instances stored in a shelve;\nthe shelve lives on the machine this script runs on, as 1 or more local files;\n\"\"\"\nfrom tkinter import *\nfrom tkinter.messagebox import showerror\nimport shelve\nshelvename = 'class-shelve'\nfieldnames = ('name', 'age', 'job', 'pay')\n46 | Chapter 1:\u2002A Sneak Previewdef makeWidgets():\n    global entries\n    window = Tk()\n    window.title('People Shelve')\n    form = Frame(window)\n    form.pack()\n    entries = {}\n    for (ix, label) in enumerate(('key',) + fieldnames):\n        lab = Label(form, text=label)\n        ent = Entry(form)\n        lab.grid(row=ix, column=0)\n        ent.grid(row=ix, column=1)\n        entries[label] = ent\n    Button(window, text=\"Fetch\",  command=fetchRecord).pack(side=LEFT)\n    Button(window, text=\"Update\", command=updateRecord).pack(side=LEFT)\n    Button(window, text=\"Quit\",   command=window.quit).pack(side=RIGHT)\n    return window\ndef fetchRecord():\n    key = entries['key'].get()\n    try:\n        record = db[key]                      # fetch by key, show in GUI\n    except:\n        showerror(title='Error', message='No such key!')\n    else:\n        for field in fieldnames:\n            entries[field].delete(0, END)\n            entries[field].insert(0, repr(getattr(record, field)))\ndef updateRecord():\n    key = entries['key'].get()\n    if key in db:\n        record = db[key]                      # update existing record\n    else:\n        from person import Person             # make/store new one for key\n        record = Person(name='?', age='?')    # eval: strings must be quoted\n    for field in fieldnames:\n        setattr(record, field, eval(entries[field].get()))\n    db[key] = record\ndb = shelve.open(shelvename)\nwindow = makeWidgets()\nwindow.mainloop()\ndb.close() # back here after quit or window close\nThis script uses the widget grid method to arrange labels and entries, instead of pack;\nas we\u2019ll see later, gridding arranges by rows and columns, and so it is a natural for forms\nthat horizontally align labels with entries well. We\u2019ll also see later that forms can usually\nbe laid out just as nicely using pack with nested row frames and fixed-width labels.\nAlthough the GUI doesn\u2019t handle window resizes well yet (that requires configuration\noptions we\u2019ll explore later), adding this makes the grid and pack alternatives roughly\nthe same in code size.\nStep 5: Adding a GUI | 47Notice how the end of this script opens the shelve as a global variable and starts the\nGUI; the shelve remains open for the lifespan of the GUI (mainloop returns only after\nthe main window is closed). As we\u2019ll see in the next section, this state retention is very\ndifferent from the web model, where each interaction is normally a standalone program.\nAlso notice that the use of global variables makes this code simple but unusable outside\nthe context of our database; more on this later.\nUsing the GUI\nThe GUI we\u2019re building is fairly basic, but it provides a view on the shelve file and\nallows us to browse and update the file without typing any code. To fetch a record from\nthe shelve and display it on the GUI, type its key into the GUI\u2019s \u201ckey\u201d field and click\nFetch. To change a record, type into its input fields after fetching it and click Update;\nthe values in the GUI will be written to the record in the database. And to add a new\nrecord, fill out all of the GUI\u2019s fields with new values and click Update\u2014the new record\nwill be added to the shelve file using the key and field inputs you provide.\nIn other words, the GUI\u2019s fields are used for both display and input. Figure 1-8 shows\nthe scene after adding a new record (via Update), and Figure 1-9 shows an error dialog\npop up issued when users try to fetch a key that isn\u2019t present in the shelve.\nFigure 1-8. peoplegui.py after adding a new persistent object\nFigure 1-9. peoplegui.py common error dialog pop up\n48 | Chapter 1:\u2002A Sneak PreviewNotice how we\u2019re using repr again to display field values fetched from the shelve and\neval to convert field values to Python objects before they are stored in the shelve. As\nmentioned previously, this is potentially dangerous if someone sneaks some malicious\ncode into our shelve, but we\u2019ll finesse such concerns for now.\nKeep in mind, though, that this scheme means that strings must be quoted in input\nfields other than the key\u2014they are assumed to be Python code. In fact, you could type\nan arbitrary Python expression in an input field to specify a value for an update. Typing\n\"Tom\"*3 in the name field, for instance, would set the name to TomTomTom after an update\n(for better or worse!); fetch to see the result.\nEven though we now have a GUI for browsing and changing records, we can still check\nour work by interactively opening and inspecting the shelve file or by running scripts\nsuch as the dump utility in Example 1-19. Remember, despite the fact that we\u2019re now\nviewing records in a GUI\u2019s windows, the database is a Python shelve file containing\nnative Python class instance objects, so any Python code can access it. Here is the dump\nscript at work after adding and changing a few persistent objects in the GUI:\n...\\PP4E\\Preview> python dump_db_classes.py\nsue =>\n   Sue Jones 50000.0\nbill =>\n   bill 9999\nnobody =>\n   John Doh None\ntomtom =>\n   Tom Tom 40000\ntom =>\n   Tom Doe 90000\nbob =>\n   Bob Smith 30000\npeg =>\n   1 4\nSmith\nDoe\nFuture directions\nAlthough this GUI does the job, there is plenty of room for improvement:\n\u2022 As coded, this GUI is a simple set of functions that share the global list of input\nfields (entries) and a global shelve (db). We might instead pass db in to\nmakeWidgets, and pass along both these two objects as function arguments to the\ncallback handlers using the lambda trick of the prior section. Though not crucial in\na script this small, as a rule of thumb, making your external dependencies explicit\nlike this makes your code both easier to understand and reusable in other contexts.\n\u2022 We could also structure this GUI as a class to support attachment and customiza-\ntion (globals would become instance attributes), though it\u2019s unlikely that we\u2019ll need\nto reuse such a specific GUI.\nStep 5: Adding a GUI | 49\u2022 More usefully, we could pass in the fieldnames tuple as an input parameter to the\nfunctions here to allow them to be used for other record types in the future. Code\nat the bottom of the file would similarly become a function with a passed-in shelve\nfilename, and we would also need to pass in a new record construction call to the\nupdate function because Person could not be hardcoded. Such generalization is\nbeyond the scope of this preview, but it makes for a nice exercise if you are so\ninclined. Later, I\u2019ll also point you to a suggested reading example in the book\nexamples package, PyForm, which takes a different approach to generalized form\nconstruction.\n\u2022 To make this GUI more user friendly, it might also be nice to add an index window\nthat displays all the keys in the database in order to make browsing easier. Some\nsort of verification before updates might be useful as well, and Delete and Clear\nbuttons would be simple to code. Furthermore, assuming that inputs are Python\ncode may be more bother than it is worth; a simpler input scheme might be easier\nand safer. (I won\u2019t officially say these are suggested exercises too, but it sounds like\nthey could be.)\n\u2022 We could also support window resizing (as we\u2019ll learn, widgets can grow and shrink\nwith the window) and provide an interface for calling methods available on stored\ninstances\u2019 classes too (as is, the pay field can be updated, but there is no way to\ninvoke the giveRaise method).\n\u2022 If we plan to distribute this GUI widely, we might package it up as a standalone\nexecutable program\u2014a frozen binary in Python terminology\u2014using third-party\ntools such as Py2Exe, PyInstaller, and others (search the Web for pointers). Such\na program can be run directly without installing Python on the receiving end, be-\ncause the Python bytecode interpreter is included in the executable itself.\nI\u2019ll leave all such extensions as points to ponder, and revisit some of them later in this\nbook.\nBefore we move on, two notes. First, I should mention that even more graphical pack-\nages are available to Python programmers. For instance, if you need to do graphics\nbeyond basic windows, the tkinter Canvas widget supports freeform graphics. Third-\nparty extensions such as Blender, OpenGL, VPython, PIL, VTK, Maya, and PyGame\nprovide even more advanced graphics, visualization, and animation tools for use with\nPython scripts. Moreover, the PMW, Tix, and ttk widget kits mentioned earlier extend\ntkinter itself. See Python\u2019s library manual for Tix and ttk, and try the PyPI site or a web\nsearch for third-party graphics extensions.\nAnd in deference to fans of other GUI toolkits such as wxPython and PyQt, I should\nalso note that there are other GUI options to choose from and that choice is sometimes\nvery subjective. tkinter is shown here because it is mature, robust, fully open source,\nwell documented, well supported, lightweight, and a standard part of Python. By most\naccounts, it remains the standard for building portable GUIs in Python.\n50 | Chapter 1:\u2002A Sneak PreviewOther GUI toolkits for Python have pros and cons of their own, discussed later in this\nbook. For example, some exchange code simplicity for richer widget sets. wxPython,\nfor example, is much more feature-rich, but it\u2019s also much more complicated to use.\nBy and large, though, other toolkits are variations on a theme\u2014once you\u2019ve learned\none GUI toolkit, others are easy to pick up. Because of that, we\u2019ll focus on learning one\ntoolkit in its entirety in this book instead of sampling many partially.\nAlthough they are free to employ network access at will, programs written with tradi-\ntional GUIs like tkinter generally run on a single, self-contained machine. Some con-\nsider web pages to be a kind of GUI as well, but you\u2019ll have to read the next and final\nsection of this chapter to judge that for yourself.\nFor a Good Time\u2026\nThere\u2019s much more to the tkinter toolkit than we\u2019ve touched on in this preview, of\ncourse, and we\u2019ll study it in depth in this book. As another quick example to hint at\nwhat\u2019s possible, though, the following script, fungui.py, uses the Python random module\nto pick from a list, makes new independent windows with Toplevel, and uses the tkinter\nafter callback to loop by scheduling methods to run again after a number of\nmilliseconds:\nfrom tkinter import *\nimport random\nfontsize = 30\ncolors = ['red', 'green', 'blue', 'yellow', 'orange', 'cyan', 'purple']\ndef onSpam():\n    popup = Toplevel()\n    color = random.choice(colors)\n    Label(popup, text='Popup', bg='black', fg=color).pack(fill=BOTH)\n    mainLabel.config(fg=color)\ndef onFlip():\n    mainLabel.config(fg=random.choice(colors))\n    main.after(250, onFlip)\ndef onGrow():\n    global fontsize\n    fontsize += 5\n    mainLabel.config(font=('arial', fontsize, 'italic'))\n    main.after(100, onGrow)\nmain = Tk()\nmainLabel = Label(main, text='Fun Gui!', relief=RAISED)\nmainLabel.config(font=('arial', fontsize, 'italic'), fg='cyan',bg='navy')\nmainLabel.pack(side=TOP, expand=YES, fill=BOTH)\nButton(main, text='spam', command=onSpam).pack(fill=X)\nButton(main, text='flip', command=onFlip).pack(fill=X)\nButton(main, text='grow', command=onGrow).pack(fill=X)\nmain.mainloop()\nRun this on your own to see how it works. It creates a main window with a custom\nlabel and three buttons\u2014one button pops up a new window with a randomly colored\nlabel, and the other two kick off potentially independent timer loops, one of which\nStep 5: Adding a GUI | 51keeps changing the color used in the main window, and another that keeps expanding\nthe main window label\u2019s font. Be careful if you do run this, though; the colors flash,\nand the label font gets bigger 10 times per second, so be sure you are able to kill the\nmain window before it gets away from you. Hey\u2014I warned you!\nStep 6: Adding a Web Interface\nGUI interfaces are easier to use than command lines and are often all we need to simplify\naccess to data. By making our database available on the Web, though, we can open it\nup to even wider use. Anyone with Internet access and a web browser can access the\ndata, regardless of where they are located and which machine they are using. Anything\nfrom workstations to cell phones will suffice. Moreover, web-based interfaces require\nonly a web browser; there is no need to install Python to access the data except on the\nsingle-server machine. Although traditional web-based approaches may sacrifice some\nof the utility and speed of in-process GUI toolkits, their portability gain can be\ncompelling.\nAs we\u2019ll also see later in this book, there are a variety of ways to go about scripting\ninteractive web pages of the sort we\u2019ll need in order to access our data. Basic server-\nside CGI scripting is more than adequate for simple tasks like ours. Because it\u2019s perhaps\nthe simplest approach, and embodies the foundations of more advanced techniques,\nCGI scripting is also well-suited to getting started on the Web.\nFor more advanced applications, a wealth of toolkits and frameworks for Python\u2014\nincluding Django, TurboGears, Google\u2019s App Engine, pylons, web2py, Zope, Plone,\nTwisted, CherryPy, Webware, mod_python, PSP, and Quixote\u2014can simplify common\ntasks and provide tools that we might otherwise need to code from scratch in the CGI\nworld. Though they pose a new set of tradeoffs, emerging technologies such as Flex,\nSilverlight, and pyjamas (an AJAX-based port of the Google Web Toolkit to Python,\nand Python-to-JavaScript compiler) offer additional paths to achieving interactive or\ndynamic user-interfaces in web pages on clients, and open the door to using Python in\nRich Internet Applications (RIAs).\nI\u2019ll say more about these tools later. For now, let\u2019s keep things simple and code a CGI\nscript.\nCGI Basics\nCGI scripting in Python is easy as long as you already have a handle on things like\nHTML forms, URLs, and the client/server model of the Web (all topics we\u2019ll address\nin detail later in this book). Whether you\u2019re aware of all the underlying details or not,\nthe basic interaction model is probably familiar.\nIn a nutshell, a user visits a website and receives a form, coded in HTML, to be filled\nout in his or her browser. After submitting the form, a script, identified within either\n52 | Chapter 1:\u2002A Sneak Previewthe form or the address used to contact the server, is run on the server and produces\nanother HTML page as a reply. Along the way, data typically passes through three\nprograms: from the client browser, to the web server, to the CGI script, and back again\nto the browser. This is a natural model for the database access interaction we\u2019re after\u2014\nusers can submit a database key to the server and receive the corresponding record as\na reply page.\nWe\u2019ll go into CGI basics in depth later in this book, but as a first example, let\u2019s start\nout with a simple interactive example that requests and then echoes back a user\u2019s name\nin a web browser. The first page in this interaction is just an input form produced by\nthe HTML file shown in Example 1-30. This HTML file is stored on the web server\nmachine, and it is transferred to the web browser running on the client machine upon\nrequest.\nExample 1-30. PP4E\\Preview\\cgi101.html\n<html>\n<title>Interactive Page</title>\n<body>\n<form method=POST action=\"cgi-bin/cgi101.py\">\n    <P><B>Enter your name:</B>\n    <P><input type=text name=user>\n    <P><input type=submit>\n</form>\n</body></html>\nNotice how this HTML form names the script that will process its input on the server\nin its action attribute. This page is requested by submitting its URL (web address).\nWhen received by the web browser on the client, the input form that this code produces\nis shown in Figure 1-10 (in Internet Explorer here).\nFigure 1-10. cgi101.html input form page\nWhen this input form is submitted, a web server intercepts the request (more on the\nweb server in a moment) and runs the Python CGI script in Example 1-31. Like the\nStep 6: Adding a Web Interface | 53HTML file, this Python script resides on the same machine as the web server; it\u2019s run\non the server machine to handle the inputs and generate a reply to the browser on the\nclient. It uses the cgi module to parse the form\u2019s input and insert it into the HTML\nreply stream, properly escaped. The cgi module gives us a dictionary-like interface to\nform inputs sent by the browser, and the HTML code that this script prints winds up\nrendering the next page on the client\u2019s browser. In the CGI world, the standard output\nstream is connected to the client through a socket.\nExample 1-31. PP4E\\Preview\\cgi-bin\\cgi101.py\n#!/usr/bin/python\nimport cgi\nform = cgi.FieldStorage()                 # parse form data\nprint('Content-type: text/html\\n')        # hdr plus blank line\nprint('<title>Reply Page</title>')        # html reply page\nif not 'user' in form:\n    print('<h1>Who are you?</h1>')\nelse:\n    print('<h1>Hello <i>%s</i>!</h1>' % cgi.escape(form['user'].value))\nAnd if all goes well, we receive the reply page shown in Figure 1-11\u2014essentially, just\nan echo of the data we entered in the input page. The page in this figure is produced\nby the HTML printed by the Python CGI script running on the server. Along the way,\nthe user\u2019s name was transferred from a client to a server and back again\u2014potentially\nacross networks and miles. This isn\u2019t much of a website, of course, but the basic prin-\nciples here apply, whether you\u2019re just echoing inputs or doing full-blown e-whatever.\nFigure 1-11. cgi101.py script reply page for input form\nIf you have trouble getting this interaction to run on Unix-like systems, you may need\nto modify the path to your Python in the #! line at the top of the script file and make\nit executable with a chmod command, but this is dependent on your web server (again,\nmore on the missing server piece in a moment).\n54 | Chapter 1:\u2002A Sneak PreviewAlso note that the CGI script in Example 1-31 isn\u2019t printing complete HTML: the\n<html> and <body> tags of the static HTML file in Example 1-30 are missing. Strictly\nspeaking, such tags should be printed, but web browsers don\u2019t mind the omissions,\nand this book\u2019s goal is not to teach legalistic HTML; see other resources for more on\nHTML.\nGUIs versus the Web\nBefore moving on, it\u2019s worth taking a moment to compare this basic CGI example with\nthe simple GUI of Example 1-28 and Figure 1-6. Here, we\u2019re running scripts on a server\nto generate HTML that is rendered in a web browser. In the GUI, we make calls to\nbuild the display and respond to events within a single process and on a single machine.\nThe GUI runs multiple layers of software, but not multiple programs. By contrast, the\nCGI approach is much more distributed\u2014the server, the browser, and possibly the\nCGI script itself run as separate programs that usually communicate over a network.\nBecause of such differences, the standalone GUI model may be simpler and more direct:\nthere is no intermediate server, replies do not require invoking a new program, no\nHTML needs to be generated, and the full power of a GUI toolkit is at our disposal.\nOn the other hand, a web-based interface can be viewed in any browser on any com-\nputer and only requires Python on the server machine.\nAnd just to muddle the waters further, a GUI can also employ Python\u2019s standard library\nnetworking tools to fetch and display data from a remote server (that\u2019s how web\nbrowsers do their work internally), and some newer frameworks such as Flex, Silver-\nlight, and pyjamas provide toolkits that support more full-featured user interfaces\nwithin web pages on the client (the RIAs I mentioned earlier), albeit at some added cost\nin code complexity and software stack depth. We\u2019ll revisit the trade-offs of the GUI\nand CGI schemes later in this book, because it\u2019s a major design choice today. First, let\u2019s\npreview a handful of pragmatic issues related to CGI work before we apply it to our\npeople database.\nRunning a Web Server\nOf course, to run CGI scripts at all, we need a web server that will serve up our HTML\nand launch our Python scripts on request. The server is a required mediator between\nthe browser and the CGI script. If you don\u2019t have an account on a machine that has\nsuch a server available, you\u2019ll want to run one of your own. We could configure and\nrun a full production-level web server such as the open source Apache system (which,\nby the way, can be tailored with Python-specific support by the mod_python extension).\nFor this chapter, however, I instead wrote a simple web server in Python using the code\nin Example 1-32.\nWe\u2019ll revisit the tools used in this example later in this book. In short, because Python\nprovides precoded support for various types of network servers, we can build a\nStep 6: Adding a Web Interface | 55CGI-capable and portable HTTP web server in just 8 lines of code (and a whopping 16\nif we include comments and blank lines).\nAs we\u2019ll see later in this book, it\u2019s also easy to build proprietary network servers with\nlow-level socket calls in Python, but the standard library provides canned implemen-\ntations for many common server types, web based or otherwise. The socketserver\nmodule, for instance, supports threaded and forking versions of TCP and UDP servers.\nThird-party systems such as Twisted provide even more implementations. For serving\nup web content, the standard library modules used in Example 1-32 provide what\nwe need.\nExample 1-32. PP4E\\Preview\\webserver.py\n\"\"\"\nImplement an HTTP web server in Python that knows how to run server-side\nCGI scripts coded in Python;  serves files and scripts from current working\ndir;  Python scripts must be stored in webdir\\cgi-bin or webdir\\htbin;\n\"\"\"\nimport os, sys\nfrom http.server import HTTPServer, CGIHTTPRequestHandler\nwebdir = '.'   # where your html files and cgi-bin script directory live\nport   = 80    # default http://localhost/, else use http://localhost:xxxx/\nos.chdir(webdir)                                       # run in HTML root dir\nsrvraddr = (\"\", port)                                  # my hostname, portnumber\nsrvrobj  = HTTPServer(srvraddr, CGIHTTPRequestHandler)\nsrvrobj.serve_forever()                                # run as perpetual daemon\nThe classes this script uses assume that the HTML files to be served up reside in the\ncurrent working directory and that the CGI scripts to be run live in a cgi-bin or htbin\nsubdirectory there. We\u2019re using a cgi-bin subdirectory for scripts, as suggested by the\nfilename of Example 1-31. Some web servers look at filename extensions to detect CGI\nscripts; our script uses this subdirectory-based scheme instead.\nTo launch the server, simply run this script (in a console window, by an icon click, or\notherwise); it runs perpetually, waiting for requests to be submitted from browsers and\nother clients. The server listens for requests on the machine on which it runs and on\nthe standard HTTP port number 80. To use this script to serve up other websites, either\nlaunch it from the directory that contains your HTML files and a cgi-bin subdirectory\nthat contains your CGI scripts, or change its webdir variable to reflect the site\u2019s root\ndirectory (it will automatically change to that directory and serve files located there).\nBut where in cyberspace do you actually run the server script? If you look closely\nenough, you\u2019ll notice that the server name in the addresses of the prior section\u2019s ex-\namples (near the top right of the browser after the http://) is always localhost. To keep\nthis simple, I am running the web server on the same machine as the web browser;\nthat\u2019s what the server name \u201clocalhost\u201d (and the equivalent IP address \u201c127.0.0.1\u201d)\nmeans. That is, the client and server machines are the same: the client (web browser)\n56 | Chapter 1:\u2002A Sneak Previewand server (web server) are just different processes running at the same time on the\nsame computer.\nThough not meant for enterprise-level work, this turns out to be a great way to test\nCGI scripts\u2014you can develop them on the same machine without having to transfer\ncode back to a remote server machine after each change. Simply run this script from\nthe directory that contains both your HTML files and a cgi-bin subdirectory for scripts\nand then use http://localhost/\u2026 in your browser to access your HTML and script files.\nHere is the trace output the web server script produces in a Windows console window\nthat is running on the same machine as the web browser and launched from the direc-\ntory where the HTML files reside:\n...\\PP4E\\Preview> python webserver.py\nmark-VAIO - - [28/Jan/2010 18:34:01] \"GET /cgi101.html HTTP/1.1\" 200 -\nmark-VAIO - - [28/Jan/2010 18:34:12] \"POST /cgi-bin/cgi101.py HTTP/1.1\" 200 -\nmark-VAIO - - [28/Jan/2010 18:34:12] command: C:\\Python31\\python.exe -u C:\\Users\n\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\Preview\\cgi-bin\\cgi101.py \"\"\nmark-VAIO - - [28/Jan/2010 18:34:13] CGI script exited OK\nmark-VAIO - - [28/Jan/2010 18:35:25] \"GET /cgi-bin/cgi101.py?user=Sue+Smith HTTP\n/1.1\" 200 -\nmark-VAIO - - [28/Jan/2010 18:35:25] command: C:\\Python31\\python.exe -u C:\\Users\n\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\Preview\\cgi-bin\\cgi101.py\nmark-VAIO - - [28/Jan/2010 18:35:26] CGI script exited OK\nOne pragmatic note here: you may need administrator privileges in order to run a server\non the script\u2019s default port 80 on some platforms: either find out how to run this way\nor try running on a different port. To run this server on a different port, change the port\nnumber in the script and name it explicitly in the URL (e.g., http://localhost:8888/).\nWe\u2019ll learn more about this convention later in this book.\nAnd to run this server on a remote computer, upload the HTML files and CGI scripts\nsubdirectory to the remote computer, launch the server script on that machine, and\nreplace \u201clocalhost\u201d in the URLs with the domain name or IP address of your server\nmachine (e.g., http://www.myserver.com/). When running the server remotely, all the\ninteraction will be as shown here, but inputs and replies will be automatically shipped\nacross network connections, not routed between programs running on the same\ncomputer.\nTo delve further into the server classes our web server script employs, see their imple-\nmentation in Python\u2019s standard library (C:\\Python31\\Lib for Python 3.1); one of the\nmajor advantages of open source system like Python is that we can always look under\nthe hood this way. In Chapter 15, we\u2019ll expand Example 1-32 to allow the directory\nname and port numbers to be passed in on the command line.\nUsing Query Strings and urllib\nIn the basic CGI example shown earlier, we ran the Python script by filling out and\nsubmitting a form that contained the name of the script. Really, server-side CGI scripts\ncan be invoked in a variety of ways\u2014either by submitting an input form as shown so\nStep 6: Adding a Web Interface | 57far or by sending the server an explicit URL (Internet address) string that contains inputs \nat the end. Such an explicit URL can be sent to a server either inside or outside of a \nbrowser; in a sense, it bypasses the traditional input form page.\nFor instance, Figure 1-12 shows the reply generated by the server after typing a URL of \nthe following form in the address field at the top of the web browser (+ means a space \nhere):\nhttp://localhost/cgi-bin/cgi101.py?user=Sue+Smith\nFigure 1-12. cgi101.py reply to GET-style query parameters\nThe inputs here, known as query parameters, show up at the end of the URL after \nthe ?; they are not entered into a form\u2019s input fields. Adding inputs to URLs is some-\ntimes called a GET request. Our original input form uses the POST method, which \ninstead ships inputs in a separate step. Luckily, Python CGI scripts don\u2019t have to dis-\ntinguish between the two; the cgi module\u2019s input parser handles any data submission \nmethod differences for us.\nIt\u2019s even possible, and often useful, to submit URLs with inputs appended as query \nparameters completely outside any web browser. The Python urllib module package, \nfor instance, allows us to read the reply generated by a server for any valid URL. In \neffect, it allows us to visit a web page or invoke a CGI script from within another script; \nyour Python code, instead of a browser, acts as the web client. Here is this module in \naction, run from the interactive command line:\n>>> from urllib.request import urlopen\n>>> conn = urlopen('http://localhost/cgi-bin/cgi101.py?user=Sue+Smith')\n>>> reply = conn.read()\n>>> reply\nb'<title>Reply Page</title>\\n<h1>Hello <i>Sue Smith</i>!</h1>\\n'\n>>> urlopen('http://localhost/cgi-bin/cgi101.py').read()\nb'<title>Reply Page</title>\\n<h1>Who are you?</h1>\\n'\n>>> urlopen('http://localhost/cgi-bin/cgi101.py?user=Bob').read()\nb'<title>Reply Page</title>\\n<h1>Hello <i>Bob</i>!</h1>\\n'\n58 | Chapter 1:\u2002A Sneak PreviewThe urllib module package gives us a file-like interface to the server\u2019s reply for a URL.\nNotice that the output we read from the server is raw HTML code (normally rendered\nby a browser). We can process this text with any of Python\u2019s text-processing tools,\nincluding:\n\u2022 String methods to search and split\n\u2022 The re regular expression pattern-matching module\n\u2022 Full-blown HTML and XML parsing support in the standard library, including\nhtml.parser, as well as SAX-, DOM-, and ElementTree\u2013style XML parsing tools.\nWhen combined with such tools, the urllib package is a natural for a variety of\ntechniques\u2014ad-hoc interactive testing of websites, custom client-side GUIs, \u201cscreen\nscraping\u201d of web page content, and automated regression testing systems for remote\nserver-side CGI scripts.\nFormatting Reply Text\nOne last fine point: because CGI scripts use text to communicate with clients, they\nneed to format their replies according to a set of rules. For instance, notice how Ex-\nample 1-31 adds a blank line between the reply\u2019s header and its HTML by printing an\nexplicit newline (\\n) in addition to the one print adds automatically; this is a required\nseparator.\nAlso note how the text inserted into the HTML reply is run through the cgi.escape\n(a.k.a. html.escape in Python 3.2; see the note under \u201cPython HTML and URL Escape\nTools\u201d on page 1203) call, just in case the input includes a character that is special in\nHTML. For example, Figure 1-13 shows the reply we receive for form input Bob </i>\nSmith\u2014the </i> in the middle becomes &lt;/i&gt; in the reply, and so doesn\u2019t interfere\nwith real HTML code (use your browser\u2019s view source option to see this for yourself);\nif not escaped, the rest of the name would not be italicized.\nFigure 1-13. Escaping HTML characters\nStep 6: Adding a Web Interface | 59Escaping text like this isn\u2019t always required, but it is a good rule of thumb when its\ncontent isn\u2019t known; scripts that generate HTML have to respect its rules. As we\u2019ll see\nlater in this book, a related call, urllib.parse.quote, applies URL escaping rules to text.\nAs we\u2019ll also see, larger frameworks often handle text formatting tasks for us.\nA Web-Based Shelve Interface\nNow, to use the CGI techniques of the prior sections for our database application, we\nbasically just need a bigger input and reply form. Figure 1-14 shows the form we\u2019ll\nimplement for accessing our database in a web browser.\nFigure 1-14. peoplecgi.html input page\nCoding the website\nTo implement the interaction, we\u2019ll code an initial HTML input form, as well as a\nPython CGI script for displaying fetch results and processing update requests. Exam-\nple 1-33 shows the input form\u2019s HTML code that builds the page in Figure 1-14.\nExample 1-33. PP4E\\Preview\\peoplecgi.html\n<html>\n<title>People Input Form</title>\n<body>\n<form method=POST action=\"cgi-bin/peoplecgi.py\">\n    <table>\n    <tr><th>Key <td><input type=text name=key>\n    <tr><th>Name<td><input type=text name=name>\n    <tr><th>Age <td><input type=text name=age>\n    <tr><th>Job <td><input type=text name=job>\n    <tr><th>Pay <td><input type=text name=pay>\n    </table>\n60 | Chapter 1:\u2002A Sneak Preview<p>\n    <input type=submit value=\"Fetch\",  name=action>\n    <input type=submit value=\"Update\", name=action>\n</form>\n</body></html>\nTo handle form (and other) requests, Example 1-34 implements a Python CGI script\nthat fetches and updates our shelve\u2019s records. It echoes back a page similar to that\nproduced by Example 1-33, but with the form fields filled in from the attributes of\nactual class objects in the shelve database.\nAs in the GUI, the same web page is used for both displaying results and inputting\nupdates. Unlike the GUI, this script is run anew for each step of user interaction, and\nit reopens the database each time (the reply page\u2019s action field provides a link back to\nthe script for the next request). The basic CGI model provides no automatic memory\nfrom page to page, so we have to start from scratch each time.\nExample 1-34. PP4E\\Preview\\cgi-bin\\peoplecgi.py\n\"\"\"\nImplement a web-based interface for viewing and updating class instances\nstored in a shelve; the shelve lives on server (same machine if localhost)\n\"\"\"\nimport cgi, shelve, sys, os                   # cgi.test() dumps inputs\nshelvename = 'class-shelve'                   # shelve files are in cwd\nfieldnames = ('name', 'age', 'job', 'pay')\nform = cgi.FieldStorage()                     # parse form data\nprint('Content-type: text/html')              # hdr, blank line is in replyhtml\nsys.path.insert(0, os.getcwd())               # so this and pickler find person\n# main html template\nreplyhtml = \"\"\"\n<html>\n<title>People Input Form</title>\n<body>\n<form method=POST action=\"peoplecgi.py\">\n    <table>\n    <tr><th>key<td><input type=text name=key value=\"%(key)s\">\n    $ROWS$\n    </table>\n    <p>\n    <input type=submit value=\"Fetch\",  name=action>\n    <input type=submit value=\"Update\", name=action>\n</form>\n</body></html>\n\"\"\"\n# insert html for data rows at $ROWS$\nrowhtml  = '<tr><th>%s<td><input type=text name=%s value=\"%%(%s)s\">\\n'\nrowshtml = ''\nfor fieldname in fieldnames:\n    rowshtml += (rowhtml % ((fieldname,) * 3))\nStep 6: Adding a Web Interface | 61replyhtml = replyhtml.replace('$ROWS$', rowshtml)\ndef htmlize(adict):\n    new = adict.copy()\n    for field in fieldnames:                       # values may have &, >, etc.\n        value = new[field]                         # display as code: quoted\n        new[field] = cgi.escape(repr(value))       # html-escape special chars\n    return new\ndef fetchRecord(db, form):\n    try:\n        key = form['key'].value\n        record = db[key]\n        fields = record.__dict__                   # use attribute dict\n        fields['key'] = key                        # to fill reply string\n    except:\n        fields = dict.fromkeys(fieldnames, '?')\n        fields['key'] = 'Missing or invalid key!'\n    return fields\ndef updateRecord(db, form):\n    if not 'key' in form:\n        fields = dict.fromkeys(fieldnames, '?')\n        fields['key'] = 'Missing key input!'\n    else:\n        key = form['key'].value\n        if key in db:\n            record = db[key]                       # update existing record\n        else:\n            from person import Person              # make/store new one for key\n            record = Person(name='?', age='?')     # eval: strings must be quoted\n        for field in fieldnames:\n            setattr(record, field, eval(form[field].value))\n        db[key] = record\n        fields = record.__dict__\n        fields['key'] = key\n    return fields\ndb = shelve.open(shelvename)\naction = form['action'].value if 'action' in form else None\nif action == 'Fetch':\n    fields = fetchRecord(db, form)\nelif action == 'Update':\n    fields = updateRecord(db, form)\nelse:\n    fields = dict.fromkeys(fieldnames, '?')        # bad submit button value\n    fields['key'] = 'Missing or invalid action!'\ndb.close()\nprint(replyhtml % htmlize(fields))                 # fill reply from dict\nThis is a fairly large script, because it has to handle user inputs, interface with the\ndatabase, and generate HTML for the reply page. Its behavior is fairly straightforward,\nthough, and similar to the GUI of the prior section.\n62 | Chapter 1:\u2002A Sneak PreviewDirectories, string formatting, and security\nA few fine points before we move on. First of all, make sure the web server script we\nwrote earlier in Example 1-32 is running before you proceed; it\u2019s going to catch our\nrequests and route them to our script.\nAlso notice how this script adds the current working directory (os.getcwd) to the\nsys.path module search path when it first starts. Barring a PYTHONPATH change, this is\nrequired to allow both the pickler and this script itself to import the person module one\nlevel up from the script. Because of the new way the web server runs CGI scripts in\nPython 3, the current working directory isn\u2019t added to sys.path, even though the\nshelve\u2019s files are located there correctly when opened. Such details can vary per server.\nThe only other feat of semi-magic the CGI script relies on is using a record\u2019s attribute\ndictionary (__dict__) as the source of values when applying HTML escapes to field\nvalues and string formatting to the HTML reply template string in the last line of the\nscript. Recall that a %(key)code replacement target fetches a value by key from a\ndictionary:\n>>> D = {'say': 5, 'get': 'shrubbery'}\n>>> D['say']\n5\n>>> S = '%(say)s => %(get)s' % D\n>>> S\n'5 => shrubbery'\nBy using an object\u2019s attribute dictionary, we can refer to attributes by name in the format\nstring. In fact, part of the reply template is generated by code. If its structure is con-\nfusing, simply insert statements to print replyhtml and to call sys.exit, and run from\na simple command line. This is how the table\u2019s HTML in the middle of the reply is\ngenerated (slightly formatted here for readability):\n   <table>\n   <tr><th>key<td><input type=text name=key value=\"%(key)s\">\n   <tr><th>name<td><input type=text name=name value=\"%(name)s\">\n   <tr><th>age<td><input type=text name=age value=\"%(age)s\">\n   <tr><th>job<td><input type=text name=job value=\"%(job)s\">\n   <tr><th>pay<td><input type=text name=pay value=\"%(pay)s\">\n   </table>\nThis text is then filled in with key values from the record\u2019s attribute dictionary by string\nformatting at the end of the script. This is done after running the dictionary through a\nutility to convert its values to code text with repr and escape that text per HTML\nconventions with cgi.escape (again, the last step isn\u2019t always required, but it\u2019s generally\na good practice).\nThese HTML reply lines could have been hardcoded in the script, but generating them\nfrom a tuple of field names is a more general approach\u2014we can add new fields in the\nfuture without having to update the HTML template each time. Python\u2019s string pro-\ncessing tools make this a snap.\nStep 6: Adding a Web Interface | 63In the interest of fairness, I should point out that Python\u2019s newer str.format method\ncould achieve much the same effect as the traditional % format expression used by this\nscript, and it provides specific syntax for referencing object attributes which to some\nmight seem more explicit than using __dict__ keys:\n>>> D = {'say': 5, 'get': 'shrubbery'}\n>>> '%(say)s => %(get)s' % D                    # expression: key reference\n'5 => shrubbery'\n>>> '{say} => {get}'.format(**D)                # method: key reference\n'5 => shrubbery'\n>>> from person import Person\n>>> bob = Person('Bob', 35)\n>>> '%(name)s, %(age)s' % bob.__dict__          # expression: __dict__ keys\n'Bob, 35'\n>>> '{0.name} => {0.age}'.format(bob)           # method: attribute syntax\n'Bob => 35'\nBecause we need to escape attribute values first, though, the format method call\u2019s at-\ntribute syntax can\u2019t be used directly this way; the choice is really between both tech-\nnique\u2019s key reference syntax above. (At this writing, it\u2019s not clear which formatting\ntechnique may come to dominate, so we take liberties with using either in this book;\nif one replaces the other altogether someday, you\u2019ll want to go with the winner.)\nIn the interest of security, I also need to remind you one last time that the eval call used\nin this script to convert inputs to Python objects is powerful, but not secure\u2014it happily\nruns any Python code, which can perform any system modifications that the script\u2019s\nprocess has permission to make. If you care, you\u2019ll need to trust the input source, run\nin a restricted environment, or use more focused input converters like int and float.\nThis is generally a larger concern in the Web world, where request strings might arrive\nfrom arbitrary sources. Since we\u2019re all friends here, though, we\u2019ll ignore the threat.\nUsing the website\nDespite the extra complexities of servers, directories, and strings, using the web inter-\nface is as simple as using the GUI, and it has the added advantage of running on any\nmachine with a browser and Web connection. To fetch a record, fill in the Key field\nand click Fetch; the script populates the page with field data grabbed from the corre-\nsponding class instance in the shelve, as illustrated in Figure 1-15 for key bob.\nFigure 1-15 shows what happens when the key comes from the posted form. As usual,\nyou can also invoke the CGI script by instead passing inputs on a query string at the\nend of the URL; Figure 1-16 shows the reply we get when accessing a URL of the\nfollowing form:\nhttp://localhost/cgi-bin/peoplecgi.py?action=Fetch&key=sue\n64 | Chapter 1:\u2002A Sneak PreviewAs we\u2019ve seen, such a URL can be submitted either within your browser or by scripts\nthat use tools such as the urllib package. Again, replace \u201clocalhost\u201d with your server\u2019s\ndomain name if you are running the script on a remote machine.\nTo update a record, fetch it by key, enter new values in the field inputs, and click\nUpdate; the script will take the input fields and store them in the attributes of the class\ninstance in the shelve. Figure 1-17 shows the reply we get after updating sue.\nFigure 1-15. peoplecgi.py reply page\nFigure 1-16. peoplecgi.py reply for query parameters\nStep 6: Adding a Web Interface | 65Finally, adding a record works the same as in the GUI: fill in a new key and field values\nand click Update; the CGI script creates a new class instance, fills out its attributes,\nand stores it in the shelve under the new key. There really is a class object behind the\nweb page here, but we don\u2019t have to deal with the logic used to generate it.\nFigure 1-18 shows a record added to the database in this way.\nFigure 1-17. peoplecgi.py update reply\nFigure 1-18. peoplecgi.py after adding a new record\nIn principle, we could also update and add records by submitting a URL\u2014either from\na browser or from a script\u2014such as:\nhttp://localhost/cgi-bin/\n   peoplecgi.py?action=Update&key=sue&pay=50000&name=Sue+Smith& ...more...\n66 | Chapter 1:\u2002A Sneak PreviewExcept for automated tools, though, typing such a long URL will be noticeably more\ndifficult than filling out the input page. Here is part of the reply page generated for the\n\u201cguido\u201d record\u2019s display of Figure 1-18 (use your browser\u2019s \u201cview page source\u201d option\nto see this for yourself). Note how the < and > characters are translated to HTML escapes\nwith cgi.escape before being inserted into the reply:\n<tr><th>key<td><input type=text name=key value=\"guido\">\n<tr><th>name<td><input type=text name=name value=\"'GvR'\">\n<tr><th>age<td><input type=text name=age value=\"None\">\n<tr><th>job<td><input type=text name=job value=\"'BDFL'\">\n<tr><th>pay<td><input type=text name=pay value=\"'&lt;shrubbery&gt;'\">\nAs usual, the standard library urllib module package comes in handy for testing our\nCGI script; the output we get back is raw HTML, but we can parse it with other standard\nlibrary tools and use it as the basis of a server-side script regression testing system run\non any Internet-capable machine. We might even parse the server\u2019s reply fetched this\nway and display its data in a client-side GUI coded with tkinter; GUIs and web pages\nare not mutually exclusive techniques. The last test in the following interaction shows\na portion of the error message page\u2019s HTML that is produced when the action is missing\nor invalid in the inputs, with line breaks added for readability:\n>>> from urllib.request import urlopen\n>>> url = 'http://localhost/cgi-bin/peoplecgi.py?action=Fetch&key=sue'\n>>> urlopen(url).read()\nb'<html>\\n<title>People Input Form</title>\\n<body>\\n\n<form method=POST action=\"peoplecgi.py\">\\n    <table>\\n\n<tr><th>key<td><input type=text name=key value=\"sue\">\\n\n<tr><th>name<td><input type=text name=name value=\"\\'Sue Smith\\'\">\\n\n<tr><t ...more deleted...\n>>> urlopen('http://localhost/cgi-bin/peoplecgi.py').read()\nb'<html>\\n<title>People Input Form</title>\\n<body>\\n\n<form method=POST action=\"peoplecgi.py\">\\n    <table>\\n\n<tr><th>key<td><input type=text name=key value=\"Missing or invalid action!\">\\n\n    <tr><th>name<td><input type=text name=name value=\"\\'?\\'\">\\n\n<tr><th>age<td><input type=text name=age value=\"\\'?\\'\">\\n<tr> ...more deleted...\nIn fact, if you\u2019re running this CGI script on \u201clocalhost,\u201d you can use both the last\nsection\u2019s GUI and this section\u2019s web interface to view the same physical shelve file\u2014\nthese are just alternative interfaces to the same persistent Python objects. For compar-\nison, Figure 1-19 shows what the record we saw in Figure 1-18 looks like in the GUI;\nit\u2019s the same object, but we are not contacting an intermediate server, starting other\nscripts, or generating HTML to view it.\nAnd as before, we can always check our work on the server machine either interactively\nor by running scripts. We may be viewing a database through web browsers and GUIs,\nbut, ultimately, it is just Python objects in a Python shelve file:\n>>> import shelve\n>>> db = shelve.open('class-shelve')\n>>> db['sue'].name\n'Sue Smith'\nStep 6: Adding a Web Interface | 67>>> db['guido'].job\n'BDFL'\n>>> list(db['guido'].name)\n['G', 'v', 'R']\n>>> list(db.keys())\n['sue', 'bill', 'nobody', 'tomtom', 'tom', 'bob', 'peg', 'guido']\nHere in action again is the original database script we wrote in Example 1-19 before\nwe moved on to GUIs and the web; there are many ways to view Python data:\n...\\PP4E\\Preview> dump_db_classes.py\nsue =>\n   Sue Smith 60000\nbill =>\n   bill 9999\nnobody =>\n   John Doh None\ntomtom =>\n   Tom Tom 40000\ntom =>\n   Tom Doe 90000\nbob =>\n   Bob Smith 30000\npeg =>\n   1 4\nguido =>\n   GvR <shrubbery>\nSmith\nDoe\nFuture directions\nNaturally, there are plenty of improvements we could make here, too:\n\u2022 The HTML code of the initial input page in Example 1-33, for instance, is some-\nwhat redundant with the script in Example 1-34, and it could be automatically\ngenerated by another script that shares common information.\nFigure 1-19. Same object displayed in the GUI\n68 | Chapter 1:\u2002A Sneak Preview\u2022 In fact, we might avoid hardcoding HTML in our script completely if we use one\nof the HTML generator tools we\u2019ll meet later, including HTMLgen (a system for\ncreating HTML from document object trees) and PSP (Python Server Pages, a\nserver-side HTML templating system for Python similar to PHP and ASP).\n\u2022 For ease of maintenance, it might also be better to split the CGI script\u2019s HTML\ncode off to a separate file in order to better divide display from logic (different\nparties with possibly different skill sets could work on the different files).\n\u2022 Moreover, if this website might be accessed by many people simultaneously, we\nwould have to add file locking or move to a database such as ZODB or MySQL to\nsupport concurrent updates. ZODB and other full-blown database systems would\nalso provide transaction rollbacks in the event of failures. For basic file locking,\nthe os.open call and its flags provide the tools we need.\n\u2022 ORMs (object relational mappers) for Python such as SQLObject and SQLAlchemy\nmentioned earlier might also allow us to gain concurrent update support of an\nunderlying relational database system, but retain our Python class view of the data.\n\u2022 In the end, if our site grows much beyond a few interactive pages, we might also\nmigrate from basic CGI scripting to a more complete web framework such as one\nof those mentioned at the start of this section\u2014 Django, TurboGears, pyjamas,\nand others. If we must retain information across pages, tools such as cookies, hid-\nden inputs, mod_python session data, and FastCGI may help too.\n\u2022 If our site eventually includes content produced by its own users, we might tran-\nsition to Plone, a popular open source Python- and Zope-based site builder that,\nusing a workflow model, delegates control of site content to its producers.\n\u2022 And if wireless or cloud interfaces are on our agenda, we might eventually migrate\nour system to cell phones using a Python port such as those available for scripting\nNokia platforms and Google\u2019s Android, or to a cloud-computing platform such as\nGoogle\u2019s Python-friendly App Engine. Python tends to go wherever technology\ntrends lead.\nFor now, though, both the GUI and web-based interfaces we\u2019ve coded get the job done.\nThe End of the Demo\nAnd that concludes our sneak preview demo of Python in action. We\u2019ve explored data\nrepresentation, OOP, object persistence, GUIs, and website basics. We haven\u2019t studied\nany of these topics in any great depth. Hopefully, though, this chapter has piqued your\ncuriosity about Python applications programming.\nIn the rest of this book, we\u2019ll delve into these and other application programming tools\nand topics, in order to help you put Python to work in your own programs. In the next\nchapter, we begin our tour with the systems programming and administration tools\navailable to Python programmers.\nThe End of the Demo | 69The Python \u201cSecret Handshake\u201d\nI\u2019ve been involved with Python for some 18 years now as of this writing in 2010, and I\nhave seen it grow from an obscure language into one that is used in some fashion in\nalmost every development organization and a solid member of the top four or five most\nwidely-used programming languages in the world. It has been a fun ride.\nBut looking back over the years, it seems to me that if Python truly has a single legacy,\nit is simply that Python has made quality a more central focus in the development world.\nIt was almost inevitable. A language that requires its users to line up code for readability\ncan\u2019t help but make people raise questions about good software practice in general.\nProbably nothing summarizes this aspect of Python life better than the standard li-\nbrary this module\u2014a sort of Easter egg in Python written by Python core developer \nTim Peters, which captures much of the design philosophy behind the language. To\nsee this for yourself, go to any Python interactive prompt and import the module\n(naturally, it\u2019s available on all platforms):\n    >>> import this\n    The Zen of Python, by Tim Peters\n    Beautiful is better than ugly.\n    Explicit is better than implicit.\n    Simple is better than complex.\n    Complex is better than complicated.\n    Flat is better than nested.\n    Sparse is better than dense.\n    Readability counts.\n    Special cases aren't special enough to break the rules.\n    Although practicality beats purity.\n    Errors should never pass silently.\n    Unless explicitly silenced.\n    In the face of ambiguity, refuse the temptation to guess.\n    There should be one-- and preferably only one --obvious way to do it.\n    Although that way may not be obvious at first unless you're Dutch.\n    Now is better than never.\n    Although never is often better than *right* now.\n    If the implementation is hard to explain, it's a bad idea.\n    If the implementation is easy to explain, it may be a good idea.\n    Namespaces are one honking great idea -- let's do more of those!\n    >>>\nWorth special mention, the \u201cExplicit is better than implicit\u201d rule has become known\nas \u201cEIBTI\u201d in the Python world\u2014one of Python\u2019s defining ideas, and one of its sharpest\ncontrasts with other languages. As anyone who has worked in this field for more than\na few years can attest, magic and engineering do not mix. Python has not always fol-\nlowed all of these guidelines, of course, but it comes very close. And if Python\u2019s main\ncontribution to the software world is getting people to think about such things, it seems\nlike a win. Besides, it looked great on the T-shirt.\n70 | Chapter 1:\u2002A Sneak PreviewPART II\nSystem Programming\nThis first in-depth part of the book presents Python\u2019s system programming tools\u2014 \ninterfaces to services in the underlying operating system as well as the context of an \nexecuting program. It consists of the following chapters:\nChapter 2 \nThis chapter provides a comprehensive first look at commonly used system inter-\nface tools. It starts slowly and is meant in part as a reference for tools and techniques \nwe\u2019ll be using later in the book.\nChapter 3 \nThis chapter continues the tour begun in Chapter 2, by showing how Python\u2019s \nsystem interfaces are applied to process standard streams, command-line argu-\nments, shell variables, and more.\nChapter 4 \nThis chapter continues our survey of system interfaces by focusing on tools and \ntechniques used to process files and directories in Python. We\u2019ll learn about binary \nfiles, tree walkers, and so on.\nChapter 5 \nThis chapter is an introduction to Python\u2019s library support for running programs \nin parallel. Here, you\u2019ll find coverage of threads, process forks, pipes, sockets, \nsignals, queues, and the like.\nChapter 6 \nThis last chapter is a collection of typical system programming examples that draw \nupon the material of the prior four chapters. Python scripts here perform real tasks; \namong other things, they split and join files, compare and copy directory trees, test \nother programs, and search and launch files.\nAlthough this part of the book emphasizes systems programming tasks, the tools \nintroduced are general-purpose and are used often in later chapters.", "2": "CHAPTER 2\nSystem Tools\n\u201cThe os.path to Knowledge\u201d\nThis chapter begins our in-depth look at ways to apply Python to real programming \ntasks. In this and the following chapters, you\u2019ll see how to use Python to write system \ntools, GUIs, database applications, Internet scripts, websites, and more. Along the way, \nwe\u2019ll also study larger Python programming concepts in action: code reuse, maintain-\nability, object-oriented programming (OOP), and so on.\nIn this first part of the book, we begin our Python programming tour by exploring \nthe systems application domain\u2014scripts that deal with files, programs, and the general \nenvironment surrounding a program. Although the examples in this domain focus on \nparticular kinds of tasks, the techniques they employ will prove to be useful in later \nparts of the book as well. In other words, you should begin your journey here, unless \nyou are already a Python systems programming wizard.\nWhy Python Here?\nPython\u2019s system interfaces span application domains, but for the next five chapters, \nmost of our examples fall into the category of system tools\u2014programs sometimes called \ncommand-line utilities, shell scripts, system administration, systems programming, \nand other permutations of such words. Regardless of their title, you are probably al-\nready familiar with this sort of script; these scripts accomplish such tasks as processing \nfiles in a directory, launching test programs, and so on. Such programs historically have \nbeen written in nonportable and syntactically obscure shell languages such as DOS \nbatch files, csh, and awk.\nEven in this relatively simple domain, though, some of Python\u2019s better attributes shine \nbrightly. For instance, Python\u2019s ease of use and extensive built-in library make it simple \n(and even fun) to use advanced system tools such as threads, signals, forks, sockets, \nand their kin; such tools are much less accessible under the obscure syntax of shell \nlanguages and the slow development cycles of compiled languages. Python\u2019s support \nfor concepts like code clarity and OOP also help us write shell tools that can be read,\n73maintained, and reused. When using Python, there is no need to start every new script\nfrom scratch.\nMoreover, we\u2019ll find that Python not only includes all the interfaces we need in order\nto write system tools, but it also fosters script portability. By employing Python\u2019s stand-\nard library, most system scripts written in Python are automatically portable to all major\nplatforms. For instance, you can usually run in Linux a Python directory-processing\nscript written in Windows without changing its source code at all\u2014simply copy over\nthe source code. Though writing scripts that achieve such portability utopia requires\nsome extra effort and practice, if used well, Python could be the only system scripting\ntool you need to use.\nThe Next Five Chapters\nTo make this part of the book easier to study, I have broken it down into five chapters:\n\u2022 In this chapter, I\u2019ll introduce the main system-related modules in overview fashion.\nWe\u2019ll meet some of the most commonly used system tools here for the first time.\n\u2022 In Chapter 3, we continue exploring the basic system interfaces by studying their\nrole in core system programming concepts: streams, command-line arguments,\nenvironment variables, and so on.\n\u2022 Chapter 4 focuses on the tools Python provides for processing files, directories,\nand directory trees.\n\u2022 In Chapter 5, we\u2019ll move on to cover Python\u2019s standard tools for parallel\nprocessing\u2014processes, threads, queues, pipes, signals, and more.\n\u2022 Chapter 6 wraps up by presenting a collection of complete system-oriented pro-\ngrams. The examples here are larger and more realistic, and they use the tools\nintroduced in the prior four chapters to perform real, practical tasks. This collection\nincludes both general system scripts, as well as scripts for processing directories of\nfiles.\nEspecially in the examples chapter at the end of this part, we will be concerned as much\nwith system interfaces as with general Python development concepts. We\u2019ll see non-\nobject-oriented and object-oriented versions of some examples along the way, for in-\nstance, to help illustrate the benefits of thinking in more strategic ways.\n\u201cBatteries Included\u201d\nThis chapter, and those that follow, deal with both the Python language and its standard\nlibrary\u2014a collection of precoded modules written in Python and C that are automat-\nically installed with the Python interpreter. Although Python itself provides an easy-to-\nuse scripting language, much of the real action in Python development involves this\nvast library of programming tools (a few hundred modules at last count) that ship with\nthe Python package.\n74 | Chapter 2:\u2002System ToolsIn fact, the standard library is so powerful that it is not uncommon to hear Python\ndescribed as batteries included\u2014a phrase generally credited to Frank Stajano meaning\nthat most of what you need for real day-to-day work is already there for importing.\nPython\u2019s standard library, while not part of the core language per se, is a standard part\nof the Python system and you can expect it to be available wherever your scripts run.\nIndeed, this is a noteworthy difference between Python and some other scripting lan-\nguages\u2014because Python comes with so many library tools \u201cout of the box,\u201d supple-\nmental sites like Perl\u2019s CPAN are not as important.\nAs we\u2019ll see, the standard library forms much of the challenge in Python programming.\nOnce you\u2019ve mastered the core language, you\u2019ll find that you\u2019ll spend most of your time\napplying the built-in functions and modules that come with the system. On the other\nhand, libraries are where most of the fun happens. In practice, programs become most\ninteresting when they start using services external to the language interpreter: networks,\nfiles, GUIs, XML, databases, and so on. All of these are supported in the Python\nstandard library.\nBeyond the standard library, there is an additional collection of third-party packages\nfor Python that must be fetched and installed separately. As of this writing, you can\nfind most of these third-party extensions via general web searches, and using the links\nat http://www.python.org and at the PyPI website (accessible from http://www.python\n.org). Some third-party extensions are large systems in their own right; NumPy, Django,\nand VPython, for instance, add vector processing, website construction, and visuali-\nzation, respectively.\nIf you have to do something special with Python, chances are good that either its support\nis part of the standard Python install package or you can find a free and open source\nmodule that will help. Most of the tools we\u2019ll employ in this text are a standard part of\nPython, but I\u2019ll be careful to point out things that must be installed separately. Of\ncourse, Python\u2019s extreme code reuse idiom also makes your programs dependent on\nthe code you reuse; in practice, though, and as we\u2019ll see repeatedly in this book, pow-\nerful libraries coupled with open source access speed development without locking you\ninto an existing set of features or limitations.\nSystem Scripting Overview\nTo begin our exploration of the systems domain, we will take a quick tour through the\nstandard library sys and os modules in this chapter, before moving on to larger system\nprogramming concepts. As you can tell from the length of their attribute lists, both of\nthese are large modules\u2014the following reflects Python 3.1 running on Windows 7\noutside IDLE:\nC:\\...\\PP4E\\System> python\nPython 3.1.1 (r311:74483, Aug 17 2009, 17:02:12) [MSC v.1500 32 bit (...)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import sys, os\n>>> len(dir(sys))          # 65 attributes\n65\nSystem Scripting Overview | 75>>> len(dir(os))           # 122 on Windows, more on Unix\n122\n>>> len(dir(os.path))      # a nested module within os\n52\nThe content of these two modules may vary per Python version and platform. For\nexample, os is much larger under Cygwin after building Python 3.1 from its source code\nthere (Cygwin is a system that provides Unix-like functionality on Windows; it is dis-\ncussed further in \u201cMore on Cygwin Python for Windows\u201d on page 185):\n$ ./python.exe\nPython 3.1.1 (r311:74480, Feb 20 2010, 10:16:52)\n[GCC 3.4.4 (cygming special, gdc 0.12, using dmd 0.125)] on cygwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> import sys, os\n>>> len(dir(sys))\n64\n>>> len(dir(os))\n217\n>>> len(dir(os.path))\n51\nAs I\u2019m not going to demonstrate every item in every built-in module, the first thing I\nwant to do is show you how to get more details on your own. Officially, this task also\nserves as an excuse for introducing a few core system scripting concepts; along the way,\nwe\u2019ll code a first script to format documentation.\nPython System Modules\nMost system-level interfaces in Python are shipped in just two modules: sys and os.\nThat\u2019s somewhat oversimplified; other standard modules belong to this domain too.\nAmong them are the following:\nglob\nFor filename expansion\nsocket\nFor network connections and Inter-Process Communication (IPC)\nthreading, _thread, queue\nFor running and synchronizing concurrent threads\ntime, timeit\nFor accessing system time details\nsubprocess, multiprocessing\nFor launching and controlling parallel processes\nsignal, select, shutil, tempfile, and others\nFor various other system-related tasks\nThird-party extensions such as pySerial (a serial port interface), Pexpect (an Expect\nwork-alike for controlling cross-program dialogs), and even Twisted (a networking\n76 | Chapter 2:\u2002System Toolsframework) can be arguably lumped into the systems domain as well. In addition, some\nbuilt-in functions are actually system interfaces as well\u2014the open function, for example,\ninterfaces with the file system. But by and large, sys and os together form the core of\nPython\u2019s built-in system tools arsenal.\nIn principle at least, sys exports components related to the Python interpreter itself\n(e.g., the module search path), and os contains variables and functions that map to the\noperating system on which Python is run. In practice, this distinction may not always\nseem clear-cut (e.g., the standard input and output streams show up in sys, but they\nare arguably tied to operating system paradigms). The good news is that you\u2019ll soon\nuse the tools in these modules so often that their locations will be permanently stamped\non your memory.*\nThe os module also attempts to provide a portable programming interface to the un-\nderlying operating system; its functions may be implemented differently on different\nplatforms, but to Python scripts, they look the same everywhere. And if that\u2019s still not\nenough, the os module also exports a nested submodule, os.path, which provides a\nportable interface to file and directory processing tools.\nModule Documentation Sources\nAs you can probably deduce from the preceding paragraphs, learning to write system\nscripts in Python is mostly a matter of learning about Python\u2019s system modules. Luckily,\nthere are a variety of information sources to make this task easier\u2014from module at-\ntributes to published references and books.\nFor instance, if you want to know everything that a built-in module exports, you can\nread its library manual entry; study its source code (Python is open source software,\nafter all); or fetch its attribute list and documentation string interactively. Let\u2019s import\nsys in Python 3.1 and see what it has to offer:\nC:\\...\\PP4E\\System> python\n>>> import sys\n>>> dir(sys)\n['__displayhook__', '__doc__', '__excepthook__', '__name__', '__package__',\n'__stderr__', '__stdin__', '__stdout__', '_clear_type_cache', '_current_frames',\n'_getframe', 'api_version', 'argv', 'builtin_module_names', 'byteorder',\n'call_tracing', 'callstats', 'copyright', 'displayhook', 'dllhandle',\n'dont_write_bytecode', 'exc_info', 'excepthook', 'exec_prefix', 'executable',\n'exit', 'flags', 'float_info', 'float_repr_style', 'getcheckinterval',\n'getdefaultencoding', 'getfilesystemencoding', 'getprofile', 'getrecursionlimit',\n'getrefcount', 'getsizeof', 'gettrace', 'getwindowsversion', 'hexversion',\n'int_info', 'intern', 'maxsize', 'maxunicode', 'meta_path', 'modules', 'path',\n'path_hooks', 'path_importer_cache', 'platform', 'prefix', 'ps1', 'ps2',\n'setcheckinterval', 'setfilesystemencoding', 'setprofile', 'setrecursionlimit',\n* They may also work their way into your subconscious. Python newcomers sometimes describe a phenomenon\nin which they \u201cdream in Python\u201d (insert overly simplistic Freudian analysis here\u2026).\nSystem Scripting Overview | 77'settrace', 'stderr', 'stdin', 'stdout', 'subversion', 'version', 'version_info',\n'warnoptions', 'winver']\nThe dir function simply returns a list containing the string names of all the attributes\nin any object with attributes; it\u2019s a handy memory jogger for modules at the interactive\nprompt. For example, we know there is something called sys.version, because the\nname version came back in the dir result. If that\u2019s not enough, we can always consult\nthe __doc__ string of built-in modules:\n>>> sys.__doc__\n\"This module provides access to some objects used or maintained by the\\ninterpre\nter and to functions that interact strongly with the interpreter.\\n\\nDynamic obj\nects:\\n\\nargv -- command line arguments; argv[0] is the script pathname if known\n\\npath -- module search path; path[0] is the script directory, else ''\\nmodules\n-- dictionary of loaded modules\\n\\ndisplayhook -- called to show results in an i\n...lots of text deleted here...\"\nPaging Documentation Strings\nThe __doc__ built-in attribute just shown usually contains a string of documentation,\nbut it may look a bit weird when displayed this way\u2014it\u2019s one long string with embedded\nend-line characters that print as \\n, not as a nice list of lines. To format these strings\nfor a more humane display, you can simply use a print function-call statement:\n>>> print(sys.__doc__)\nThis module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\nDynamic objects:\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\n...lots of lines deleted here...\nThe print built-in function, unlike interactive displays, interprets end-line characters\ncorrectly. Unfortunately, print doesn\u2019t, by itself, do anything about scrolling or paging\nand so can still be unwieldy on some platforms. Tools such as the built-in help func-\ntion can do better:\n>>> help(sys)\nHelp on built-in module sys:\nNAME\n    sys\nFILE\n    (built-in)\nMODULE DOCS\n    http://docs.python.org/library/sys\n78 | Chapter 2:\u2002System ToolsDESCRIPTION\n    This module provides access to some objects used or maintained by the\n    interpreter and to functions that interact strongly with the interpreter.\n    Dynamic objects:\n    argv -- command line arguments; argv[0] is the script pathname if known\n    path -- module search path; path[0] is the script directory, else ''\n    modules -- dictionary of loaded modules\n...lots of lines deleted here...\nThe help function is one interface provided by the PyDoc system\u2014standard library\ncode that ships with Python and renders documentation (documentation strings, as\nwell as structural details) related to an object in a formatted way. The format is either\nlike a Unix manpage, which we get for help, or an HTML page, which is more grandiose.\nIt\u2019s a handy way to get basic information when working interactively, and it\u2019s a last\nresort before falling back on manuals and books.\nA Custom Paging Script\nThe help function we just met is also fairly fixed in the way it displays information;\nalthough it attempts to page the display in some contexts, its page size isn\u2019t quite right\non some of the machines I use. Moreover, it doesn\u2019t page at all in the IDLE GUI, instead\nrelying on manual use if the scrollbar\u2014potentially painful for large displays. When I\nwant more control over the way help text is printed, I usually use a utility script of my\nown, like the one in Example 2-1.\nExample 2-1. PP4E\\System\\more.py\n\"\"\"\nsplit and interactively page a string or file of text\n\"\"\"\ndef more(text, numlines=15):\n    lines = text.splitlines()                # like split('\\n') but no '' at end\n    while lines:\n        chunk = lines[:numlines]\n        lines = lines[numlines:]\n        for line in chunk: print(line)\n        if lines and input('More?') not in ['y', 'Y']: break\nif __name__ == '__main__':\n    import sys                               # when run, not imported\n    more(open(sys.argv[1]).read(), 10)       # page contents of file on cmdline\nThe meat of this file is its more function, and if you know enough Python to be qualified\nto read this book, it should be fairly straightforward. It simply splits up a string around\nend-line characters, and then slices off and displays a few lines at a time (15 by default)\nto avoid scrolling off the screen. A slice expression, lines[:15], gets the first 15 items\nin a list, and lines[15:] gets the rest; to show a different number of lines each time,\nSystem Scripting Overview | 79pass a number to the numlines argument (e.g., the last line in Example 2-1 passes 10 to\nthe numlines argument of the more function).\nThe splitlines string object method call that this script employs returns a list of sub-\nstrings split at line ends (e.g., [\"line\", \"line\",...]). An alternative splitlines method\ndoes similar work, but retains an empty line at the end of the result if the last line is\n\\n terminated:\n>>> line = 'aaa\\nbbb\\nccc\\n'\n>>> line.split('\\n')\n['aaa', 'bbb', 'ccc', '']\n>>> line.splitlines()\n['aaa', 'bbb', 'ccc']\nAs we\u2019ll see more formally in Chapter 4, the end-of-line character is normally always\n\\n (which stands for a byte usually having a binary value of 10) within a Python script,\nno matter what platform it is run upon. (If you don\u2019t already know why this matters,\nDOS \\r characters in text are dropped by default when read.)\nString Method Basics\nNow, Example 2-1 is a simple Python program, but it already brings up three important\ntopics that merit quick detours here: it uses string methods, reads from a file, and is set\nup to be run or imported. Python string methods are not a system-related tool per se,\nbut they see action in most Python programs. In fact, they are going to show up\nthroughout this chapter as well as those that follow, so here is a quick review of some\nof the more useful tools in this set. String methods include calls for searching and\nreplacing:\n>>> mystr = 'xxxSPAMxxx'\n>>> mystr.find('SPAM')                           # return first offset\n3\n>>> mystr = 'xxaaxxaa'\n>>> mystr.replace('aa', 'SPAM')                  # global replacement\n'xxSPAMxxSPAM'\nThe find call returns the offset of the first occurrence of a substring, and replace does\nglobal search and replacement. Like all string operations, replace returns a new string\ninstead of changing its subject in-place (recall that strings are immutable). With these\nmethods, substrings are just strings; in Chapter 19, we\u2019ll also meet a module called\nre that allows regular expression patterns to show up in searches and replacements.\nIn more recent Pythons, the in membership operator can often be used as an alternative\nto find if all we need is a yes/no answer (it tests for a substring\u2019s presence). There are\nalso a handful of methods for removing whitespace on the ends of strings\u2014especially\nuseful for lines of text read from a file:\n>>> mystr = 'xxxSPAMxxx'\n>>> 'SPAM' in mystr                              # substring search/test\n80 | Chapter 2:\u2002System ToolsTrue\n>>> 'Ni' in mystr                                # when not found\nFalse\n>>> mystr.find('Ni')\n-1\n>>> mystr = '\\t  Ni\\n'\n>>> mystr.strip()                                # remove whitespace\n'Ni'\n>>> mystr.rstrip()                               # same, but just on right side\n'\\t  Ni'\nString methods also provide functions that are useful for things such as case conver-\nsions, and a standard library module named string defines some useful preset variables,\namong other things:\n>>> mystr = 'SHRUBBERY'\n>>> mystr.lower()                           # case converters\n'shrubbery'\n>>> mystr.isalpha()                         # content tests\nTrue\n>>> mystr.isdigit()\nFalse\n>>> import string                           # case presets: for 'in', etc.\n>>> string.ascii_lowercase\n'abcdefghijklmnopqrstuvwxyz'\n>>> string.whitespace                       # whitespace characters\n' \\t\\n\\r\\x0b\\x0c'\nThere are also methods for splitting up strings around a substring delimiter and putting\nthem back together with a substring in between. We\u2019ll explore these tools later in this\nbook, but as an introduction, here they are at work:\n>>> mystr = 'aaa,bbb,ccc'\n>>> mystr.split(',')                        # split into substrings list\n['aaa', 'bbb', 'ccc']\n>>> mystr = 'a  b\\nc\\nd'\n>>> mystr.split()                           # default delimiter: whitespace\n['a', 'b', 'c', 'd']\n>>> delim = 'NI'\n>>> delim.join(['aaa', 'bbb', 'ccc'])       # join substrings list\n'aaaNIbbbNIccc'\n>>> ' '.join(['A', 'dead', 'parrot'])       # add a space between\n'A dead parrot'\nSystem Scripting Overview | 81>>> chars = list('Lorreta')                 # convert to characters list\n>>> chars\n['L', 'o', 'r', 'r', 'e', 't', 'a']\n>>> chars.append('!')\n>>> ''.join(chars)                          # to string: empty delimiter\n'Lorreta!'\nThese calls turn out to be surprisingly powerful. For example, a line of data columns\nseparated by tabs can be parsed into its columns with a single split call; the more.py\nscript uses the splitlines variant shown earlier to split a string into a list of line strings.\nIn fact, we can emulate the replace call we saw earlier in this section with a split/join\ncombination:\n>>> mystr = 'xxaaxxaa'\n>>> 'SPAM'.join(mystr.split('aa'))          # str.replace, the hard way!\n'xxSPAMxxSPAM'\nFor future reference, also keep in mind that Python doesn\u2019t automatically convert\nstrings to numbers, or vice versa; if you want to use one as you would use the other,\nyou must say so with manual conversions:\n>>> int(\"42\"), eval(\"42\")                   # string to int conversions\n(42, 42)\n>>> str(42), repr(42)                       # int to string conversions\n('42', '42')\n>>> (\"%d\" % 42), '{:d}'.format(42)          # via formatting expression, method\n('42', '42')\n>>> \"42\" + str(1), int(\"42\") + 1            # concatenation, addition\n('421', 43)\nIn the last command here, the first expression triggers string concatenation (since both\nsides are strings), and the second invokes integer addition (because both objects are\nnumbers). Python doesn\u2019t assume you meant one or the other and convert automati-\ncally; as a rule of thumb, Python tries to avoid magic\u2014and the temptation to guess\u2014\nwhenever possible. String tools will be covered in more detail later in this book (in fact,\nthey get a full chapter in Part V), but be sure to also see the library manual for additional\nstring method tools.\nOther String Concepts in Python 3.X: Unicode and bytes\nTechnically speaking, the Python 3.X string story is a bit richer than I\u2019ve implied here.\nWhat I\u2019ve shown so far is the str object type\u2014a sequence of characters (technically,\nUnicode \u201ccode points\u201d represented as Unicode \u201ccode units\u201d) which represents both\nASCII and wider Unicode text, and handles encoding and decoding both manually on\nrequest and automatically on file transfers. Strings are coded in quotes (e.g., 'abc'),\nalong with various syntax for coding non-ASCII text (e.g., '\\xc4\\xe8', '\\u00c4\\u00e8').\n82 | Chapter 2:\u2002System ToolsReally, though, 3.X has two additional string types that support most str string oper-\nations: bytes\u2014a sequence of short integers for representing 8-bit binary data, and\nbytearray\u2014a mutable variant of bytes. You generally know you are dealing with\nbytes if strings display or are coded with a leading \u201cb\u201d character before the opening\nquote (e.g., b'abc', b'\\xc4\\xe8'). As we\u2019ll see in Chapter 4, files in 3.X follow a similar\ndichotomy, using str in text mode (which also handles Unicode encodings and line-\nend conversions) and bytes in binary mode (which transfers bytes to and from files\nunchanged). And in Chapter 5, we\u2019ll see the same distinction for tools like sockets,\nwhich deal in byte strings today.\nUnicode text is used in Internationalized applications, and many of Python\u2019s binary-\noriented tools deal in byte strings today. This includes some file tools we\u2019ll meet along\nthe way, such as the open call, and the os.listdir and os.walk tools we\u2019ll study in\nupcoming chapters. As we\u2019ll see, even simple directory tools sometimes have to be\naware of Unicode in file content and names. Moreover, tools such as object pickling\nand binary data parsing are byte-oriented today.\nLater in the book, we\u2019ll also find that Unicode also pops up today in the text displayed\nin GUIs; the bytes shipped other networks; Internet standard such as email; and even\nsome persistence topics such as DBM files and shelves. Any interface that deals in text\nnecessarily deals in Unicode today, because str is Unicode, whether ASCII or wider.\nOnce we reach the realm of the applications programming presented in this book,\nUnicode is no longer an optional topic for most Python 3.X programmers.\nIn this book, we\u2019ll defer further coverage of Unicode until we can see it in the context\nof application topics and practical programs. For more fundamental details on how\n3.X\u2019s Unicode text and binary data support impact both string and file usage in some\nroles, please see Learning Python, Fourth Edition; since this is officially a core language\ntopic, it enjoys in-depth coverage and a full 45-page dedicated chapter in that book.\nFile Operation Basics\nBesides processing strings, the more.py script also uses files\u2014it opens the external file\nwhose name is listed on the command line using the built-in open function, and it reads\nthat file\u2019s text into memory all at once with the file object read method. Since file objects\nreturned by open are part of the core Python language itself, I assume that you have at\nleast a passing familiarity with them at this point in the text. But just in case you\u2019ve\nflipped to this chapter early on in your Pythonhood, the following calls load a file\u2019s\ncontents into a string, load a fixed-size set of bytes into a string, load a file\u2019s contents\ninto a list of line strings, and load the next line in the file into a string, respectively:\nopen('file').read()            # read entire file into string\nopen('file').read(N)           # read next N bytes into string\nopen('file').readlines()       # read entire file into line strings list\nopen('file').readline()        # read next line, through '\\n'\nSystem Scripting Overview | 83As we\u2019ll see in a moment, these calls can also be applied to shell commands in Python\nto read their output. File objects also have write methods for sending strings to the\nassociated file. File-related topics are covered in depth in Chapter 4, but making an\noutput file and reading it back is easy in Python:\n>>> file = open('spam.txt', 'w')        # create file spam.txt\n>>> file.write(('spam' * 5) + '\\n')     # write text: returns #characters written\n21\n>>> file.close()\n>>> file = open('spam.txt')             # or open('spam.txt').read()\n>>> text = file.read()                  # read into a string\n>>> text\n'spamspamspamspamspam\\n'\nUsing Programs in Two Ways\nAlso by way of review, the last few lines in the more.py file in Example 2-1 introduce\none of the first big concepts in shell tool programming. They instrument the file to be\nused in either of two ways\u2014as a script or as a library.\nRecall that every Python module has a built-in __name__ variable that Python sets to the\n__main__ string only when the file is run as a program, not when it\u2019s imported as a\nlibrary. Because of that, the more function in this file is executed automatically by the\nlast line in the file when this script is run as a top-level program, but not when it is\nimported elsewhere. This simple trick turns out to be one key to writing reusable script\ncode: by coding program logic as functions rather than as top-level code, you can also\nimport and reuse it in other scripts.\nThe upshot is that we can run more.py by itself or import and call its more function\nelsewhere. When running the file as a top-level program, we list on the command line\nthe name of a file to be read and paged: as I\u2019ll describe in more depth in the next chapter,\nwords typed in the command that is used to start a program show up in the built-in\nsys.argv list in Python. For example, here is the script file in action, paging itself (be\nsure to type this command line in your PP4E\\System directory, or it won\u2019t find the input\nfile; more on command lines later):\nC:\\...\\PP4E\\System> python more.py more.py\n\"\"\"\nsplit and interactively page a string or file of text\n\"\"\"\ndef more(text, numlines=15):\n    lines = text.splitlines()                # like split('\\n') but no '' at end\n    while lines:\n        chunk = lines[:numlines]\n        lines = lines[numlines:]\n        for line in chunk: print(line)\nMore?y\n        if lines and input('More?') not in ['y', 'Y']: break\n84 | Chapter 2:\u2002System Toolsif __name__ == '__main__':\n    import sys                               # when run, not imported\n    more(open(sys.argv[1]).read(), 10)       # page contents of file on cmdline\nWhen the more.py file is imported, we pass an explicit string to its more function, and\nthis is exactly the sort of utility we need for documentation text. Running this utility\non the sys module\u2019s documentation string gives us a bit more information in human-\nreadable form about what\u2019s available to scripts:\nC:\\...\\PP4E\\System> python\n>>> from more import more\n>>> import sys\n>>> more(sys.__doc__)\nThis module provides access to some objects used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter.\nDynamic objects:\nargv -- command line arguments; argv[0] is the script pathname if known\npath -- module search path; path[0] is the script directory, else ''\nmodules -- dictionary of loaded modules\ndisplayhook -- called to show results in an interactive session\nexcepthook -- called to handle any uncaught exception other than SystemExit\n  To customize printing in an interactive session or to install a custom\n  top-level exception handler, assign other functions to replace these.\nstdin -- standard input file object; used by input()\nMore?\nPressing \u201cy\u201d or \u201cY\u201d here makes the function display the next few lines of documenta-\ntion, and then prompt again, unless you\u2019ve run past the end of the lines list. Try this\non your own machine to see what the rest of the module\u2019s documentation string looks\nlike. Also try experimenting by passing a different window size in the second\nargument\u2014more(sys.__doc__, 5) shows just 5 lines at a time.\nPython Library Manuals\nIf that still isn\u2019t enough detail, your next step is to read the Python library manual\u2019s\nentry for sys to get the full story. All of Python\u2019s standard manuals are available online,\nand they often install alongside Python itself. On Windows, the standard manuals are\ninstalled automatically, but here are a few simple pointers:\n\u2022 On Windows, click the Start button, pick All Programs, select the Python entry\nthere, and then choose the Python Manuals item. The manuals should magically\nappear on your display; as of Python 2.4, the manuals are provided as a Windows\nhelp file and so support searching and navigation.\n\u2022 On Linux or Mac OS X, you may be able to click on the manuals\u2019 entries in a file\nexplorer or start your browser from a shell command line and navigate to the library\nmanual\u2019s HTML files on your machine.\nSystem Scripting Overview | 85\u2022 If you can\u2019t find the manuals on your computer, you can always read them online.\nGo to Python\u2019s website at http://www.python.org and follow the documentation\nlinks there. This website also has a simple searching utility for the manuals.\nHowever you get started, be sure to pick the Library manual for things such as sys; this\nmanual documents all of the standard library, built-in types and functions, and more.\nPython\u2019s standard manual set also includes a short tutorial, a language reference, ex-\ntending references, and more.\nCommercially Published References\nAt the risk of sounding like a marketing droid, I should mention that you can also\npurchase the Python manual set, printed and bound; see the book information page at\nhttp://www.python.org for details and links. Commercially published Python reference\nbooks are also available today, including Python Essential Reference, Python in a Nut-\nshell, Python Standard Library, and Python Pocket Reference. Some of these books are\nmore complete and come with examples, but the last one serves as a convenient memory\njogger once you\u2019ve taken a library tour or two.\u2020\nIntroducing the sys Module\nBut enough about documentation sources (and scripting basics)\u2014let\u2019s move on to\nsystem module details. As mentioned earlier, the sys and os modules form the core of\nmuch of Python\u2019s system-related tool set. To see how, we\u2019ll turn to a quick, interactive\ntour through some of the tools in these two modules before applying them in bigger\nexamples. We\u2019ll start with sys, the smaller of the two; remember that to see a full list\nof all the attributes in sys, you need to pass it to the dir function (or see where we did\nso earlier in this chapter).\nPlatforms and Versions\nLike most modules, sys includes both informational names and functions that take\naction. For instance, its attributes give us the name of the underlying operating system\non which the platform code is running, the largest possible \u201cnatively sized\u201d integer on\nthis machine (though integers can be arbitrarily long in Python 3.X), and the version\nnumber of the Python interpreter running our code:\nC:\\...\\PP4E\\System> python\n>>> import sys\n\u2020 Full disclosure: I also wrote the last of the books listed as a replacement for the reference appendix that\nappeared in the first edition of this book; it\u2019s meant to be a supplement to the text you\u2019re reading, and its\nlatest edition also serves as a translation resource for Python 2.X readers. As explained in the Preface, the\nbook you\u2019re holding is meant as tutorial, not reference, so you\u2019ll probably want to find some sort of reference\nresource eventually (though I\u2019m nearly narcissistic enough to require that it be mine).\n86 | Chapter 2:\u2002System Tools>>> sys.platform, sys.maxsize, sys.version\n('win32', 2147483647, '3.1.1 (r311:74483, Aug 17 2009, 17:02:12) ...more deleted...')\n>>> if sys.platform[:3] == 'win': print('hello windows')\n...\nhello windows\nIf you have code that must act differently on different machines, simply test the\nsys.platform string as done here; although most of Python is cross-platform, nonport-\nable tools are usually wrapped in if tests like the one here. For instance, we\u2019ll see later\nthat some program launch and low-level console interaction tools may vary per plat-\nform\u2014simply test sys.platform to pick the right tool for the machine on which your\nscript is running.\nThe Module Search Path\nThe sys module also lets us inspect the module search path both interactively and\nwithin a Python program. sys.path is a list of directory name strings representing the\ntrue search path in a running Python interpreter. When a module is imported, Python\nscans this list from left to right, searching for the module\u2019s file on each directory named\nin the list. Because of that, this is the place to look to verify that your search path is\nreally set as intended.\u2021\nThe sys.path list is simply initialized from your PYTHONPATH setting\u2014the content of\nany .pth path files located in Python\u2019s directories on your machine plus system\ndefaults\u2014when the interpreter is first started up. In fact, if you inspect sys.path inter-\nactively, you\u2019ll notice quite a few directories that are not on your PYTHONPATH:\nsys.path also includes an indicator for the script\u2019s home directory (an empty string\u2014\nsomething I\u2019ll explain in more detail after we meet os.getcwd) and a set of standard\nlibrary directories that may vary per installation:\n>>> sys.path\n['', 'C:\\\\PP4thEd\\\\Examples', ...plus standard library paths deleted... ]\nSurprisingly, sys.path can actually be changed by a program, too. A script can use list\noperations such as append, extend, insert, pop, and remove, as well as the del statement\nto configure the search path at runtime to include all the source directories to which it\nneeds access. Python always uses the current sys.path setting to import, no matter what\nyou\u2019ve changed it to:\n>>> sys.path.append(r'C:\\mydir')\n>>> sys.path\n['', 'C:\\\\PP4thEd\\\\Examples', ...more deleted..., 'C:\\\\mydir']\n\u2021 It\u2019s not impossible that Python sees PYTHONPATH differently than you do. A syntax error in your system shell\nconfiguration files may botch the setting of PYTHONPATH, even if it looks fine to you. On Windows, for example,\nif a space appears around the = of a DOS set command in your configuration file (e.g., set NAME = VALUE),\nyou may actually set NAME to an empty string, not to VALUE!\nIntroducing the sys Module | 87Changing sys.path directly like this is an alternative to setting your PYTHONPATH shell\nvariable, but not a very permanent one. Changes to sys.path are retained only until the\nPython process ends, and they must be remade every time you start a new Python\nprogram or session. However, some types of programs (e.g., scripts that run on a web\nserver) may not be able to depend on PYTHONPATH settings; such scripts can instead\nconfigure sys.path on startup to include all the directories from which they will need\nto import modules. For a more concrete use case, see Example 1-34 in the prior\nchapter\u2014there we had to tweak the search path dynamically this way, because the web\nserver violated our import path assumptions.\nWindows Directory Paths\nNotice the use of a raw string literal in the sys.path configuration code: because back-\nslashes normally introduce escape code sequences in Python strings, Windows users\nshould be sure to either double up on backslashes when using them in DOS directory\npath strings (e.g., in \"C:\\\\dir\", \\\\ is an escape sequence that really means \\), or use\nraw string constants to retain backslashes literally (e.g., r\"C:\\dir\").\nIf you inspect directory paths on Windows (as in the sys.path interaction listing), Py-\nthon prints double \\\\ to mean a single \\. Technically, you can get away with a\nsingle \\ in a string if it is followed by a character Python does not recognize as the rest\nof an escape sequence, but doubles and raw strings are usually easier than memorizing\nescape code tables.\nAlso note that most Python library calls accept either forward (/) or backward (\\)\nslashes as directory path separators, regardless of the underlying platform. That is, /\nusually works on Windows too and aids in making scripts portable to Unix. Tools in\nthe os and os.path modules, described later in this chapter, further aid in script path\nportability.\nThe Loaded Modules Table\nThe sys module also contains hooks into the interpreter; sys.modules, for example, is\na dictionary containing one name:module entry for every module imported in your\nPython session or program (really, in the calling Python process):\n>>> sys.modules\n{'reprlib': <module 'reprlib' from 'c:\\python31\\lib\\reprlib.py'>, ...more deleted...\n>>> list(sys.modules.keys())\n ['reprlib', 'heapq', '__future__', 'sre_compile', '_collections', 'locale', '_sre',\n'functools', 'encodings', 'site', 'operator', 'io', '__main__', ...more deleted... ]\n>>> sys\n<module 'sys' (built-in)>\n>>> sys.modules['sys']\n<module 'sys' (built-in)>\n88 | Chapter 2:\u2002System ToolsWe might use such a hook to write programs that display or otherwise process all the\nmodules loaded by a program (just iterate over the keys of sys.modules).\nAlso in the interpret hooks category, an object\u2019s reference count is available via\nsys.getrefcount, and the names of modules built-in to the Python executable are listed\nin sys.builtin_module_names. See Python\u2019s library manual for details; these are mostly\nPython internals information, but such hooks can sometimes become important to\nprogrammers writing tools for other programmers to use.\nException Details\nOther attributes in the sys module allow us to fetch all the information related to the\nmost recently raised Python exception. This is handy if we want to process exceptions\nin a more generic fashion. For instance, the sys.exc_info function returns a tuple with\nthe latest exception\u2019s type, value, and traceback object. In the all class-based exception\nmodel that Python 3 uses, the first two of these correspond to the most recently raised\nexception\u2019s class, and the instance of it which was raised:\n>>> try:\n...     raise IndexError\n... except:\n...     print(sys.exc_info())\n...\n(<class 'IndexError'>, IndexError(), <traceback object at 0x019B8288>)\nWe might use such information to format our own error message to display in a GUI\npop-up window or HTML web page (recall that by default, uncaught exceptions ter-\nminate programs with a Python error display). The first two items returned by this call\nhave reasonable string displays when printed directly, and the third is a traceback object\nthat can be processed with the standard traceback module:\n>>> import traceback, sys\n>>> def grail(x):\n...     raise TypeError('already got one')\n...\n>>> try:\n...     grail('arthur')\n... except:\n...     exc_info = sys.exc_info()\n...     print(exc_info[0])\n...     print(exc_info[1])\n...     traceback.print_tb(exc_info[2])\n...\n<class 'TypeError'>\nalready got one\n  File \"<stdin>\", line 2, in <module>\n  File \"<stdin>\", line 2, in grail\nThe traceback module can also format messages as strings and route them to specific\nfile objects; see the Python library manual for more details.\nIntroducing the sys Module | 89Other sys Module Exports\nThe sys module exports additional commonly-used tools that we will meet in the con-\ntext of larger topics and examples introduced later in this part of the book. For instance:\n\u2022 Command-line arguments show up as a list of strings called sys.argv.\n\u2022 Standard streams are available as sys.stdin, sys.stdout, and sys.stderr.\n\u2022 Program exit can be forced with sys.exit calls.\nSince these lead us to bigger topics, though, we will cover them in sections of their own.\nIntroducing the os Module\nAs mentioned, os is the larger of the two core system modules. It contains all of the\nusual operating-system calls you use in C programs and shell scripts. Its calls deal with\ndirectories, processes, shell variables, and the like. Technically, this module provides\nPOSIX tools\u2014a portable standard for operating-system calls\u2014along with platform-\nindependent directory processing tools as the nested module os.path. Operationally,\nos serves as a largely portable interface to your computer\u2019s system calls: scripts written\nwith os and os.path can usually be run unchanged on any platform. On some platforms,\nos includes extra tools available just for that platform (e.g., low-level process calls on\nUnix); by and large, though, it is as cross-platform as is technically feasible.\nTools in the os Module\nLet\u2019s take a quick look at the basic interfaces in os. As a preview, Table 2-1 summarizes\nsome of the most commonly used tools in the os module, organized by functional area.\nTable 2-1. Commonly used os module tools\nTasks\nTools\nShell variables\nos.environ\nRunning programs\nos.system, os.popen, os.execv, os.spawnv\nSpawning processes\nos.fork, os.pipe, os.waitpid, os.kill\nDescriptor files, locks\nos.open, os.read, os.write\nFile processing\nos.remove, os.rename, os.mkfifo, os.mkdir, os.rmdir\nAdministrative tools\nos.getcwd, os.chdir, os.chmod, os.getpid, os.listdir, os.access\nPortability tools\nos.sep, os.pathsep, os.curdir, os.path.split, os.path.join\nPathname tools\nos.path.exists('path'), os.path.isdir('path'), os.path.getsize('path')\nIf you inspect this module\u2019s attributes interactively, you get a huge list of names that\nwill vary per Python release, will likely vary per platform, and isn\u2019t incredibly useful\n90 | Chapter 2:\u2002System Toolsuntil you\u2019ve learned what each name means (I\u2019ve let this line-wrap and removed most\nof this list to save space\u2014run the command on your own):\n>>> import os\n>>> dir(os)\n['F_OK', 'MutableMapping', 'O_APPEND', 'O_BINARY', 'O_CREAT', 'O_EXCL', 'O_NOINH\nERIT', 'O_RANDOM', 'O_RDONLY', 'O_RDWR', 'O_SEQUENTIAL', 'O_SHORT_LIVED', 'O_TEM\nPORARY', 'O_TEXT', 'O_TRUNC', 'O_WRONLY', 'P_DETACH', 'P_NOWAIT', 'P_NOWAITO', '\nP_OVERLAY', 'P_WAIT', 'R_OK', 'SEEK_CUR', 'SEEK_END', 'SEEK_SET', 'TMP_MAX',\n...9 lines removed here...\n'pardir', 'path', 'pathsep', 'pipe', 'popen', 'putenv', 'read', 'remove', 'rem\novedirs', 'rename', 'renames', 'rmdir', 'sep', 'spawnl', 'spawnle', 'spawnv', 's\npawnve', 'startfile', 'stat', 'stat_float_times', 'stat_result', 'statvfs_result\n', 'strerror', 'sys', 'system', 'times', 'umask', 'unlink', 'urandom', 'utime',\n'waitpid', 'walk', 'write']\nBesides all of these, the nested os.path module exports even more tools, most of which\nare related to processing file and directory names portably:\n>>> dir(os.path)\n['__all__', '__builtins__', '__doc__', '__file__', '__name__', '__package__',\n'_get_altsep', '_get_bothseps', '_get_colon', '_get_dot', '_get_empty',\n'_get_sep', '_getfullpathname', 'abspath', 'altsep', 'basename', 'commonprefix',\n'curdir', 'defpath', 'devnull', 'dirname', 'exists', 'expanduser', 'expandvars',\n'extsep', 'genericpath', 'getatime', 'getctime', 'getmtime', 'getsize', 'isabs',\n'isdir', 'isfile', 'islink', 'ismount', 'join', 'lexists', 'normcase', 'normpath',\n'os', 'pardir', 'pathsep', 'realpath', 'relpath', 'sep', 'split', 'splitdrive',\n'splitext', 'splitunc', 'stat', 'supports_unicode_filenames', 'sys']\nAdministrative Tools\nJust in case those massive listings aren\u2019t quite enough to go on, let\u2019s experiment inter-\nactively with some of the more commonly used os tools. Like sys, the os module comes\nwith a collection of informational and administrative tools:\n>>> os.getpid()\n7980\n>>> os.getcwd()\n'C:\\\\PP4thEd\\\\Examples\\\\PP4E\\\\System'\n>>> os.chdir(r'C:\\Users')\n>>> os.getcwd()\n'C:\\\\Users'\nAs shown here, the os.getpid function gives the calling process\u2019s process ID (a unique\nsystem-defined identifier for a running program, useful for process control and unique\nname creation), and os.getcwd returns the current working directory. The current\nworking directory is where files opened by your script are assumed to live, unless their\nnames include explicit directory paths. That\u2019s why earlier I told you to run the following\ncommand in the directory where more.py lives:\nC:\\...\\PP4E\\System> python more.py more.py\nIntroducing the os Module | 91The input filename argument here is given without an explicit directory path (though\nyou could add one to page files in another directory). If you need to run in a different\nworking directory, call the os.chdir function to change to a new directory; your code\nwill run relative to the new directory for the rest of the program (or until the next\nos.chdir call). The next chapter will have more to say about the notion of a current\nworking directory, and its relation to module imports when it explores script execution\ncontext.\nPortability Constants\nThe os module also exports a set of names designed to make cross-platform program-\nming simpler. The set includes platform-specific settings for path and directory sepa-\nrator characters, parent and current directory indicators, and the characters used to\nterminate lines on the underlying computer.\n>>> os.pathsep, os.sep, os.pardir, os.curdir, os.linesep\n(';', '\\\\', '..', '.', '\\r\\n')\nos.sep is whatever character is used to separate directory components on the platform\non which Python is running; it is automatically preset to \\ on Windows, / for POSIX\nmachines, and : on some Macs. Similarly, os.pathsep provides the character that sep-\narates directories on directory lists, : for POSIX and ; for DOS and Windows.\nBy using such attributes when composing and decomposing system-related strings in\nour scripts, we make the scripts fully portable. For instance, a call of the form dir\npath.split(os.sep) will correctly split platform-specific directory names into compo-\nnents, though dirpath may look like dir\\dir on Windows, dir/dir on Linux, and\ndir:dir on some Macs. As mentioned, on Windows you can usually use forward slashes\nrather than backward slashes when giving filenames to be opened, but these portability\nconstants allow scripts to be platform neutral in directory processing code.\nNotice also how os.linesep comes back as \\r\\n here\u2014the symbolic escape code which\nreflects the carriage-return + line-feed line terminator convention on Windows, which\nyou don\u2019t normally notice when processing text files in Python. We\u2019ll learn more about\nend-of-line translations in Chapter 4.\nCommon os.path Tools\nThe nested module os.path provides a large set of directory-related tools of its own.\nFor example, it includes portable functions for tasks such as checking a file\u2019s type\n(isdir, isfile, and others); testing file existence (exists); and fetching the size of a file\nby name (getsize):\n>>> os.path.isdir(r'C:\\Users'), os.path.isfile(r'C:\\Users')\n(True, False)\n>>> os.path.isdir(r'C:\\config.sys'), os.path.isfile(r'C:\\config.sys')\n(False, True)\n>>> os.path.isdir('nonesuch'), os.path.isfile('nonesuch')\n92 | Chapter 2:\u2002System Tools(False, False)\n>>> os.path.exists(r'c:\\Users\\Brian')\nFalse\n>>> os.path.exists(r'c:\\Users\\Default')\nTrue\n>>> os.path.getsize(r'C:\\autoexec.bat')\n24\nThe os.path.isdir and os.path.isfile calls tell us whether a filename is a directory or\na simple file; both return False if the named file does not exist (that is, nonexistence\nimplies negation). We also get calls for splitting and joining directory path strings,\nwhich automatically use the directory name conventions on the platform on which\nPython is running:\n>>> os.path.split(r'C:\\temp\\data.txt')\n('C:\\\\temp', 'data.txt')\n>>> os.path.join(r'C:\\temp', 'output.txt')\n'C:\\\\temp\\\\output.txt'\n>>> name = r'C:\\temp\\data.txt'                            # Windows paths\n>>> os.path.dirname(name), os.path.basename(name)\n('C:\\\\temp', 'data.txt')\n>>> name = '/home/lutz/temp/data.txt'                     # Unix-style paths\n>>> os.path.dirname(name), os.path.basename(name)\n('/home/lutz/temp', 'data.txt')\n>>> os.path.splitext(r'C:\\PP4thEd\\Examples\\PP4E\\PyDemos.pyw')\n('C:\\\\PP4thEd\\\\Examples\\\\PP4E\\\\PyDemos', '.pyw')\nos.path.split separates a filename from its directory path, and os.path.join puts them\nback together\u2014all in entirely portable fashion using the path conventions of the ma-\nchine on which they are called. The dirname and basename calls here return the first and\nsecond items returned by a split simply as a convenience, and splitext strips the file\nextension (after the last .). Subtle point: it\u2019s almost equivalent to use string split and\njoin method calls with the portable os.sep string, but not exactly:\n>>> os.sep\n'\\\\'\n>>> pathname = r'C:\\PP4thEd\\Examples\\PP4E\\PyDemos.pyw'\n>>> os.path.split(pathname)                                # split file from dir\n('C:\\\\PP4thEd\\\\Examples\\\\PP4E', 'PyDemos.pyw')\n>>> pathname.split(os.sep)                                 # split on every slash\n['C:', 'PP4thEd', 'Examples', 'PP4E', 'PyDemos.pyw']\n>>> os.sep.join(pathname.split(os.sep))\n'C:\\\\PP4thEd\\\\Examples\\\\PP4E\\\\PyDemos.pyw'\n>>> os.path.join(*pathname.split(os.sep))\n'C:PP4thEd\\\\Examples\\\\PP4E\\\\PyDemos.pyw'\nIntroducing the os Module | 93The last join call require individual arguments (hence the *) but doesn\u2019t insert a first\nslash because of the Windows drive syntax; use the preceding str.join method instead\nif the difference matters. The normpath call comes in handy if your paths become a\njumble of Unix and Windows separators:\n>>> mixed\n'C:\\\\temp\\\\public/files/index.html'\n>>> os.path.normpath(mixed)\n'C:\\\\temp\\\\public\\\\files\\\\index.html'\n>>> print(os.path.normpath(r'C:\\temp\\\\sub\\.\\file.ext'))\nC:\\temp\\sub\\file.ext\nThis module also has an abspath call that portably returns the full directory pathname\nof a file; it accounts for adding the current directory as a path prefix, .. parent syntax,\nand more:\n>>> os.chdir(r'C:\\Users')\n>>> os.getcwd()\n'C:\\\\Users'\n>>> os.path.abspath('')                        # empty string means the cwd\n'C:\\\\Users'\n>>> os.path.abspath('temp')                    # expand to full pathname in cwd\n'C:\\\\Users\\\\temp'\n>>> os.path.abspath(r'PP4E\\dev')               # partial paths relative to cwd\n'C:\\\\Users\\\\PP4E\\\\dev'\n>>> os.path.abspath('.')                       # relative path syntax expanded\n'C:\\\\Users'\n>>> os.path.abspath('..')\n'C:\\\\'\n>>> os.path.abspath(r'..\\examples')\n'C:\\\\examples'\n>>> os.path.abspath(r'C:\\PP4thEd\\chapters')    # absolute paths unchanged\n'C:\\\\PP4thEd\\\\chapters'\n>>> os.path.abspath(r'C:\\temp\\spam.txt')\n'C:\\\\temp\\\\spam.txt'\nBecause filenames are relative to the current working directory when they aren\u2019t fully\nspecified paths, the os.path.abspath function helps if you want to show users what\ndirectory is truly being used to store a file. On Windows, for example, when GUI-based\nprograms are launched by clicking on file explorer icons and desktop shortcuts, the\nexecution directory of the program is the clicked file\u2019s home directory, but that is not\nalways obvious to the person doing the clicking; printing a file\u2019s abspath can help.\nRunning Shell Commands from Scripts\nThe os module is also the place where we run shell commands from within Python\nscripts. This concept is intertwined with others, such as streams, which we won\u2019t cover\nfully until the next chapter, but since this is a key concept employed throughout this\n94 | Chapter 2:\u2002System Toolspart of the book, let\u2019s take a quick first look at the basics here. Two os functions allow\nscripts to run any command line that you can type in a console window:\nos.system\nRuns a shell command from a Python script\nos.popen\nRuns a shell command and connects to its input or output streams\nIn addition, the relatively new subprocess module provides finer-grained control over\nstreams of spawned shell commands and can be used as an alternative to, and even for\nthe implementation of, the two calls above (albeit with some cost in extra code\ncomplexity).\nWhat\u2019s a shell command?\nTo understand the scope of the calls listed above, we first need to define a few terms.\nIn this text, the term shell means the system that reads and runs command-line strings\non your computer, and shell command means a command-line string that you would\nnormally enter at your computer\u2019s shell prompt.\nFor example, on Windows, you can start an MS-DOS console window (a.k.a. \u201cCom-\nmand Prompt\u201d) and type DOS commands there\u2014commands such as dir to get a di-\nrectory listing, type to view a file, names of programs you wish to start, and so on. DOS\nis the system shell, and commands such as dir and type are shell commands. On Linux\nand Mac OS X, you can start a new shell session by opening an xterm or terminal\nwindow and typing shell commands there too\u2014ls to list directories, cat to view files,\nand so on. A variety of shells are available on Unix (e.g., csh, ksh), but they all read and\nrun command lines. Here are two shell commands typed and run in an MS-DOS console\nbox on Windows:\nC:\\...\\PP4E\\System> dir /B         ...type a shell command line\nhelloshell.py                      ...its output shows up here\nmore.py                            ...DOS is the shell on Windows\nmore.pyc\nspam.txt\n__init__.py\nC:\\...\\PP4E\\System> type helloshell.py\n# a Python program\nprint('The Meaning of Life')\nRunning shell commands\nNone of this is directly related to Python, of course (despite the fact that Python\ncommand-line scripts are sometimes confusingly called \u201cshell tools\u201d). But because the\nos module\u2019s system and popen calls let Python scripts run any sort of command that the\nunderlying system shell understands, our scripts can make use of every command-line\ntool available on the computer, whether it\u2019s coded in Python or not. For example, here\nIntroducing the os Module | 95is some Python code that runs the two DOS shell commands typed at the shell prompt\nshown previously:\nC:\\...\\PP4E\\System> python\n>>> import os\n>>> os.system('dir /B')\nhelloshell.py\nmore.py\nmore.pyc\nspam.txt\n__init__.py\n0\n>>> os.system('type helloshell.py')\n# a Python program\nprint('The Meaning of Life')\n0\n>>> os.system('type hellshell.py')\nThe system cannot find the file specified.\n1\nThe 0s at the end of the first two commands here are just the return values of the system\ncall itself (its exit status; zero generally means success). The system call can be used to\nrun any command line that we could type at the shell\u2019s prompt (here, C:\\...\\PP4E\n\\System>). The command\u2019s output normally shows up in the Python session\u2019s or pro-\ngram\u2019s standard output stream.\nCommunicating with shell commands\nBut what if we want to grab a command\u2019s output within a script? The os.system call\nsimply runs a shell command line, but os.popen also connects to the standard input or\noutput streams of the command; we get back a file-like object connected to the com-\nmand\u2019s output by default (if we pass a w mode flag to popen, we connect to the com-\nmand\u2019s input stream instead). By using this object to read the output of a command\nspawned with popen, we can intercept the text that would normally appear in the\nconsole window where a command line is typed:\n>>> open('helloshell.py').read()\n\"# a Python program\\nprint('The Meaning of Life')\\n\"\n>>> text = os.popen('type helloshell.py').read()\n>>> text\n\"# a Python program\\nprint('The Meaning of Life')\\n\"\n>>> listing = os.popen('dir /B').readlines()\n>>> listing\n['helloshell.py\\n', 'more.py\\n', 'more.pyc\\n', 'spam.txt\\n', '__init__.py\\n']\nHere, we first fetch a file\u2019s content the usual way (using Python files), then as the output\nof a shell type command. Reading the output of a dir command lets us get a listing of\nfiles in a directory that we can then process in a loop. We\u2019ll learn other ways to obtain\nsuch a list in Chapter 4; there we\u2019ll also learn how file iterators make the readlines call\n96 | Chapter 2:\u2002System Toolsin the os.popen example above unnecessary in most programs, except to display the\nlist interactively as we did here (see also \u201csubprocess, os.popen, and Itera-\ntors\u201d on page 101 for more on the subject).\nSo far, we\u2019ve run basic DOS commands; because these calls can run any command line\nthat we can type at a shell prompt, they can also be used to launch other Python scripts.\nAssuming your system search path is set to locate your Python (so that you can use the\nshorter \u201cpython\u201d in the following instead of the longer \u201cC:\\Python31\\python\u201d):\n>>> os.system('python helloshell.py')       # run a Python program\nThe Meaning of Life\n0\n>>> output = os.popen('python helloshell.py').read()\n>>> output\n'The Meaning of Life\\n'\nIn all of these examples, the command-line strings sent to system and popen are hard-\ncoded, but there\u2019s no reason Python programs could not construct such strings at\nruntime using normal string operations (+, %, etc.). Given that commands can be dy-\nnamically built and run this way, system and popen turn Python scripts into flexible and\nportable tools for launching and orchestrating other programs. For example, a Python\ntest \u201cdriver\u201d script can be used to run programs coded in any language (e.g., C++, Java,\nPython) and analyze their output. We\u2019ll explore such a script in Chapter 6. We\u2019ll also\nrevisit os.popen in the next chapter in conjunction with stream redirection; as we\u2019ll find,\nthis call can also send input to programs.\nThe subprocess module alternative\nAs mentioned, in recent releases of Python the subprocess module can achieve the same\neffect as os.system and os.popen; it generally requires extra code but gives more control\nover how streams are connected and used. This becomes especially useful when streams\nare tied in more complex ways.\nFor example, to run a simple shell command like we did with os.system earlier, this\nnew module\u2019s call function works roughly the same (running commands like \u201ctype\u201d\nthat are built into the shell on Windows requires extra protocol, though normal exe-\ncutables like \u201cpython\u201d do not):\n>>> import subprocess\n>>> subprocess.call('python helloshell.py')              # roughly like os.system()\nThe Meaning of Life\n0\n>>> subprocess.call('cmd /C \"type helloshell.py\"')       # built-in shell cmd\n# a Python program\nprint('The Meaning of Life')\n0\n>>> subprocess.call('type helloshell.py', shell=True)    # alternative for built-ins\n# a Python program\nprint('The Meaning of Life')\n0\nIntroducing the os Module | 97Notice the shell=True in the last command here. This is a subtle and platform-\ndependent requirement:\n\u2022 On Windows, we need to pass a shell=True argument to subprocess tools like\ncall and Popen (shown ahead) in order to run commands built into the shell. Win-\ndows commands like \u201ctype\u201d require this extra protocol, but normal executables\nlike \u201cpython\u201d do not.\n\u2022 On Unix-like platforms, when shell is False (its default), the program command\nline is run directly by os.execvp, a call we\u2019ll meet in Chapter 5. If this argument is\nTrue, the command-line string is run through a shell instead, and you can specify\nthe shell to use with additional arguments.\nMore on some of this later; for now, it\u2019s enough to note that you may need to pass\nshell=True to run some of the examples in this section and book in Unix-like environ-\nments, if they rely on shell features like program path lookup. Since I\u2019m running code\non Windows, this argument will often be omitted here.\nBesides imitating os.system, we can similarly use this module to emulate the\nos.popen call used earlier, to run a shell command and obtain its standard output text\nin our script:\n>>> pipe = subprocess.Popen('python helloshell.py', stdout=subprocess.PIPE)\n>>> pipe.communicate()\n(b'The Meaning of Life\\r\\n', None)\n>>> pipe.returncode\n0\nHere, we connect the stdout stream to a pipe, and communicate to run the command\nto completion and receive its standard output and error streams\u2019 text; the command\u2019s\nexit status is available in an attribute after it completes. Alternatively, we can use other\ninterfaces to read the command\u2019s standard output directly and wait for it to exit (which\nreturns the exit status):\n>>> pipe = subprocess.Popen('python helloshell.py', stdout=subprocess.PIPE)\n>>> pipe.stdout.read()\nb'The Meaning of Life\\r\\n'\n>>> pipe.wait()\n0\nIn fact, there are direct mappings from os.popen calls to subprocess.Popen objects:\n>>> from subprocess import Popen, PIPE\n>>> Popen('python helloshell.py', stdout=PIPE).communicate()[0]\nb'The Meaning of Life\\r\\n'\n>>>\n>>> import os\n>>> os.popen('python helloshell.py').read()\n'The Meaning of Life\\n'\nAs you can probably tell, subprocess is extra work in these relatively simple cases. It\nstarts to look better, though, when we need to control additional streams in flexible\nways. In fact, because it also allows us to process a command\u2019s error and input streams\n98 | Chapter 2:\u2002System Toolsin similar ways, in Python 3.X subprocess replaces the original os.popen2, os.popen3,\nand os.popen4 calls which were available in Python 2.X; these are now just use cases\nfor subprocess object interfaces. Because more advanced use cases for this module deal\nwith standard streams, we\u2019ll postpone additional details about this module until we\nstudy stream redirection in the next chapter.\nShell command limitations\nBefore we move on, you should keep in mind two limitations of system and popen. First,\nalthough these two functions themselves are fairly portable, their use is really only as\nportable as the commands that they run. The preceding examples that run DOS dir\nand type shell commands, for instance, work only on Windows, and would have to be\nchanged in order to run ls and cat commands on Unix-like platforms.\nSecond, it is important to remember that running Python files as programs this way is\nvery different and generally much slower than importing program files and calling\nfunctions they define. When os.system and os.popen are called, they must start a brand-\nnew, independent program running on your operating system (they generally run the\ncommand in a new process). When importing a program file as a module, the Python\ninterpreter simply loads and runs the file\u2019s code in the same process in order to generate\na module object. No other program is spawned along the way.\u00a7\nThere are good reasons to build systems as separate programs, too, and in the next\nchapter we\u2019ll explore things such as command-line arguments and streams that allow\nprograms to pass information back and forth. But in many cases, imported modules\nare a faster and more direct way to compose systems.\nIf you plan to use these calls in earnest, you should also know that the os.system call\nnormally blocks\u2014that is, pauses\u2014its caller until the spawned command line exits. On\nLinux and Unix-like platforms, the spawned command can generally be made to run\nindependently and in parallel with the caller by adding an & shell background operator\nat the end of the command line:\nos.system(\"python program.py arg arg &\")\nOn Windows, spawning with a DOS start command will usually launch the command\nin parallel too:\nos.system(\"start program.py arg arg\")\n\u00a7 The Python code exec(open(file).read()) also runs a program file\u2019s code, but within the same process that\ncalled it. It\u2019s similar to an import in that regard, but it works more as if the file\u2019s text had been pasted into\nthe calling program at the place where the exec call appears (unless explicit global or local namespace\ndictionaries are passed). Unlike imports, such an exec unconditionally reads and executes a file\u2019s code (it\nmay be run more than once per process), no module object is generated by the file\u2019s execution, and unless\noptional namespace dictionaries are passed in, assignments in the file\u2019s code may overwrite variables in the\nscope where the exec appears; see other resources or the Python library manual for more details.\nIntroducing the os Module | 99In fact, this is so useful that an os.startfile call was added in recent Python releases.\nThis call opens a file with whatever program is listed in the Windows registry for the\nfile\u2019s type\u2014as though its icon has been clicked with the mouse cursor:\nos.startfile(\"webpage.html\")    # open file in your web browser\nos.startfile(\"document.doc\")    # open file in Microsoft Word\nos.startfile(\"myscript.py\")     # run file with Python\nThe os.popen call does not generally block its caller (by definition, the caller must be\nable to read or write the file object returned) but callers may still occasionally become\nblocked under both Windows and Linux if the pipe object is closed\u2014e.g., when gar-\nbage is collected\u2014before the spawned program exits or the pipe is read exhaustively\n(e.g., with its read() method). As we will see later in this part of the book, the Unix\nos.fork/exec and Windows os.spawnv calls can also be used to run parallel programs\nwithout blocking.\nBecause the os module\u2019s system and popen calls, as well as the subprocess module, also\nfall under the category of program launchers, stream redirectors, and cross-process\ncommunication devices, they will show up again in the following chapters, so we\u2019ll\ndefer further details for the time being. If you\u2019re looking for more details right away,\nbe sure to see the stream redirection section in the next chapter and the directory listings \nsection in Chapter 4.\nOther os Module Exports\nThat\u2019s as much of a tour around os as we have space for here. Since most other os\nmodule tools are even more difficult to appreciate outside the context of larger appli-\ncation topics, we\u2019ll postpone a deeper look at them until later chapters. But to let you\nsample the flavor of this module, here is a quick preview for reference. Among the os\nmodule\u2019s other weapons are these:\nos.environ\nFetches and sets shell environment variables\nos.fork\nSpawns a new child process on Unix-like systems\nos.pipe\nCommunicates between programs\nos.execlp\nStarts new programs\nos.spawnv\nStarts new programs with lower-level control\nos.open\nOpens a low-level descriptor-based file\nos.mkdir\nCreates a new directory\n100 | Chapter 2:\u2002System Toolsos.mkfifo\nCreates a new named pipe\nos.stat\nFetches low-level file information\nos.remove\nDeletes a file by its pathname\nos.walk\nApplies a function or loop body to all parts of an entire directory tree\nAnd so on. One caution up front: the os module provides a set of file open, read, and\nwrite calls, but all of these deal with low-level file access and are entirely distinct from\nPython\u2019s built-in stdio file objects that we create with the built-in open function. You\nshould normally use the built-in open function, not the os module, for all but very special\nfile-processing needs (e.g., opening with exclusive access file locking).\nIn the next chapter we will apply sys and os tools such as those we\u2019ve introduced here\nto implement common system-level tasks, but this book doesn\u2019t have space to provide\nan exhaustive list of the contents of modules we will meet along the way. Again, if you\nhave not already done so, you should become acquainted with the contents of modules\nsuch as os and sys using the resources described earlier. For now, let\u2019s move on to\nexplore additional system tools in the context of broader system programming\nconcepts\u2014the context surrounding a running script.\nsubprocess, os.popen, and Iterators\nIn Chapter 4, we\u2019ll explore file iterators, but you\u2019ve probably already studied the basics\nprior to picking up this book. Because os.popen objects have an iterator that reads one\nline at a time, their readlines method call is usually superfluous. For example, the\nfollowing steps through lines produced by another program without any explicit reads:\n>>> import os\n>>> for line in os.popen('dir /B *.py'): print(line, end='')\n...\nhelloshell.py\nmore.py\n__init__.py\nInterestingly, Python 3.1 implements os.popen using the subprocess.Popen object that\nwe studied in this chapter. You can see this for yourself in file os.py in the Python\nstandard library on your machine (see C:\\Python31\\Lib on Windows); the os.popen\nresult is an object that manages the Popen object and its piped stream:\n>>> I = os.popen('dir /B *.py')\n>>> I\n<os._wrap_close object at 0x013BC750>\nBecause this pipe wrapper object defines an __iter__ method, it supports line iteration,\nboth automatic (e.g., the for loop above) and manual. Curiously, although the pipe\nwrapper object supports direct __next__ method calls as though it were its own iterator\nIntroducing the os Module | 101(just like simple files), it does not support the next built-in function, even though the\nlatter is supposed to simply call the former:\n>>> I = os.popen('dir /B *.py')\n>>> I.__next__()\n'helloshell.py\\n'\n>>> I = os.popen('dir /B *.py')\n>>> next(I)\nTypeError: _wrap_close object is not an iterator\nThe reason for this is subtle\u2014direct __next__ calls are intercepted by a __getattr__\ndefined in the pipe wrapper object, and are properly delegated to the wrapped object;\nbut next function calls invoke Python\u2019s operator overloading machinery, which in 3.X\nbypasses the wrapper\u2019s __getattr__ for special method names like __next__. Since the\npipe wrapper object doesn\u2019t define a __next__ of its own, the call is not caught and\ndelegated, and the next built-in fails. As explained in full in the book Learning Py-\nthon, the wrapper\u2019s __getattr__ isn\u2019t tried because 3.X begins such searches at the class,\nnot the instance.\nThis behavior may or may not have been anticipated, and you don\u2019t need to care if you\niterate over pipe lines automatically with for loops, comprehensions, and other tools.\nTo code manual iterations robustly, though, be sure to call the iter built-in first\u2014this\ninvokes the __iter__ defined in the pipe wrapper object itself, to correctly support both\nflavors of advancement:\n>>> I = os.popen('dir /B *.py')\n>>> I = iter(I)                       # what for loops do\n>>> I.__next__()                      # now both forms work\n'helloshell.py\\n'\n>>> next(I)\n'more.py\\n'\n102 | Chapter 2:\u2002System Tools", "3": "CHAPTER 3\nScript Execution Context\n\u201cI\u2019d Like to Have an Argument, Please\u201d\nPython scripts don\u2019t run in a vacuum (despite what you may have heard). Depending \non platforms and startup procedures, Python programs may have all sorts of enclosing \ncontext\u2014information automatically passed in to the program by the operating system \nwhen the program starts up. For instance, scripts have access to the following sorts of \nsystem-level inputs and interfaces:\nCurrent working directory \nos.getcwd gives access to the directory from which a script is started, and many file \ntools use its value implicitly.\nCommand-line arguments \nsys.argv gives access to words typed on the command line that are used to start \nthe program and that serve as script inputs.\nShell variables \nos.environ provides an interface to names assigned in the enclosing shell (or a \nparent program) and passed in to the script.\nStandard streams \nsys.stdin, stdout, and stderr export the three input/output streams that are at the \nheart of command-line shell tools, and can be leveraged by scripts with print op-\ntions, the os.popen call and subprocess module introduced in Chapter 2, the \nio.StringIO class, and more.\nSuch tools can serve as inputs to scripts, configuration parameters, and so on. In this \nchapter, we will explore all these four context\u2019s tools\u2014both their Python interfaces \nand their typical roles.\n103Current Working Directory\nThe notion of the current working directory (CWD) turns out to be a key concept in\nsome scripts\u2019 execution: it\u2019s always the implicit place where files processed by the script\nare assumed to reside unless their names have absolute directory paths. As we saw\nearlier, os.getcwd lets a script fetch the CWD name explicitly, and os.chdir allows a\nscript to move to a new CWD.\nKeep in mind, though, that filenames without full pathnames map to the CWD and\nhave nothing to do with your PYTHONPATH setting. Technically, a script is always\nlaunched from the CWD, not the directory containing the script file. Conversely, im-\nports always first search the directory containing the script, not the CWD (unless the\nscript happens to also be located in the CWD). Since this distinction is subtle and tends\nto trip up beginners, let\u2019s explore it in a bit more detail.\nCWD, Files, and Import Paths\nWhen you run a Python script by typing a shell command line such as python\ndir1\\dir2\\file.py, the CWD is the directory you were in when you typed this com-\nmand, not dir1\\dir2. On the other hand, Python automatically adds the identity of the\nscript\u2019s home directory to the front of the module search path such that file.py can\nalways import other files in dir1\\dir2 no matter where it is run from. To illustrate, let\u2019s\nwrite a simple script to echo both its CWD and its module search path:\nC:\\...\\PP4E\\System> type whereami.py\nimport os, sys\nprint('my os.getcwd =>', os.getcwd())           # show my cwd execution dir\nprint('my sys.path  =>', sys.path[:6])          # show first 6 import paths\ninput()                                         # wait for keypress if clicked\nNow, running this script in the directory in which it resides sets the CWD as expected\nand adds it to the front of the module import search path. We met the sys.path module\nsearch path earlier; its first entry might also be the empty string to designate CWD\nwhen you\u2019re working interactively, and most of the CWD has been truncated to \u201c...\u201d\nhere for display:\nC:\\...\\PP4E\\System> set PYTHONPATH=C:\\PP4thEd\\Examples\nC:\\...\\PP4E\\System> python whereami.py\nmy os.getcwd => C:\\...\\PP4E\\System\nmy sys.path  => ['C:\\\\...\\\\PP4E\\\\System', 'C:\\\\PP4thEd\\\\Examples', ...more... ]\nBut if we run this script from other places, the CWD moves with us (it\u2019s the directory\nwhere we type commands), and Python adds a directory to the front of the module\nsearch path that allows the script to still see files in its own home directory. For instance,\nwhen running from one level up (..), the System name added to the front of sys.path\nwill be the first directory that Python searches for imports within whereami.py; it points\nimports back to the directory containing the script that was run. Filenames without\n104 | Chapter 3:\u2002Script Execution Contextcomplete paths, though, will be mapped to the CWD (C:\\PP4thEd\\Examples\\PP4E),\nnot the System subdirectory nested there:\nC:\\...\\PP4E\\System> cd ..\nC:\\...\\PP4E> python System\\whereami.py\nmy os.getcwd => C:\\...\\PP4E\nmy sys.path  => ['C:\\\\...\\\\PP4E\\\\System', 'C:\\\\PP4thEd\\\\Examples', ...more... ]\nC:\\...\\PP4E> cd System\\temp\nC:\\...\\PP4E\\System\\temp> python ..\\whereami.py\nmy os.getcwd => C:\\...\\PP4E\\System\\temp\nmy sys.path  => ['C:\\\\...\\\\PP4E\\\\System', 'C:\\\\PP4thEd\\\\Examples', ...]\nThe net effect is that filenames without directory paths in a script will be mapped to\nthe place where the command was typed (os.getcwd), but imports still have access to\nthe directory of the script being run (via the front of sys.path). Finally, when a file is\nlaunched by clicking its icon, the CWD is just the directory that contains the clicked\nfile. The following output, for example, appears in a new DOS console box when\nwhereami.py is double-clicked in Windows Explorer:\nmy os.getcwd => C:\\...\\PP4E\\System\nmy sys.path  => ['C:\\\\...\\\\PP4E\\\\System', ...more... ]\nIn this case, both the CWD used for filenames and the first import search directory are\nthe directory containing the script file. This all usually works out just as you expect,\nbut there are two pitfalls to avoid:\n\u2022 Filenames might need to include complete directory paths if scripts cannot be sure\nfrom where they will be run.\n\u2022 Command-line scripts cannot always rely on the CWD to gain import visibility to\nfiles that are not in their own directories; instead, use PYTHONPATH settings and\npackage import paths to access modules in other directories.\nFor example, scripts in this book, regardless of how they are run, can always import\nother files in their own home directories without package path imports (import file\nhere), but must go through the PP4E package root to find files anywhere else in the\nexamples tree (from PP4E.dir1.dir2 import filethere), even if they are run from the\ndirectory containing the desired external module. As usual for modules, the PP4E\n\\dir1\\dir2 directory name could also be added to PYTHONPATH to make files there visible\neverywhere without package path imports (though adding more directories to PYTHON\nPATH increases the likelihood of name clashes). In either case, though, imports are al-\nways resolved to the script\u2019s home directory or other Python search path settings, not\nto the CWD.\nCurrent Working Directory | 105CWD and Command Lines\nThis distinction between the CWD and import search paths explains why many scripts\nin this book designed to operate in the current working directory (instead of one whose\nname is passed in) are run with command lines such as this one:\nC:\\temp> python C:\\...\\PP4E\\Tools\\cleanpyc.py                   process cwd\nIn this example, the Python script file itself lives in the directory C:\\...\\PP4E\\Tools, but\nbecause it is run from C:\\temp, it processes the files located in C:\\temp (i.e., in the CWD,\nnot in the script\u2019s home directory). To process files elsewhere with such a script, simply\ncd to the directory to be processed to change the CWD:\nC:\\temp> cd C:\\PP4thEd\\Examples\nC:\\PP4thEd\\Examples> python C:\\...\\PP4E\\Tools\\cleanpyc.py       process cwd\nBecause the CWD is always implied, a cd command tells the script which directory to\nprocess in no less certain terms than passing a directory name to the script explicitly,\nlike this (portability note: you may need to add quotes around the *.py in this and other\ncommand-line examples to prevent it from being expanded in some Unix shells):\nC:\\...\\PP4E\\Tools> python find.py *.py C:\\temp                  process named dir\nIn this command line, the CWD is the directory containing the script to be run (notice\nthat the script filename has no directory path prefix); but since this script processes a\ndirectory named explicitly on the command line (C:\\temp), the CWD is irrelevant. Fi-\nnally, if we want to run such a script located in some other directory in order to process\nfiles located in yet another directory, we can simply give directory paths to both:\nC:\\temp> python C:\\...\\PP4E\\Tools\\find.py *.cxx C:\\PP4thEd\\Examples\\PP4E\nHere, the script has import visibility to files in its PP4E\\Tools home directory and pro-\ncesses files in the directory named on the command line, but the CWD is something\nelse entirely (C:\\temp). This last form is more to type, of course, but watch for a variety\nof CWD and explicit script-path command lines like these in this book.\nCommand-Line Arguments\nThe sys module is also where Python makes available the words typed on the command\nthat is used to start a Python script. These words are usually referred to as command-\nline arguments and show up in sys.argv, a built-in list of strings. C programmers may\nnotice its similarity to the C argv array (an array of C strings). It\u2019s not much to look at\ninteractively, because no command-line arguments are passed to start up Python in this\nmode:\n>>> import sys\n>>> sys.argv\n['']\n106 | Chapter 3:\u2002Script Execution ContextTo really see what arguments are about, we need to run a script from the shell command\nline. Example 3-1 shows an unreasonably simple one that just prints the argv list for\ninspection.\nExample 3-1. PP4E\\System\\testargv.py\nimport sys\nprint(sys.argv)\nRunning this script prints the command-line arguments list; note that the first item is\nalways the name of the executed Python script file itself, no matter how the script was\nstarted (see \u201cExecutable Scripts on Unix\u201d on page 108).\nC:\\...\\PP4E\\System> python testargv.py\n['testargv.py']\nC:\\...\\PP4E\\System> python testargv.py spam eggs cheese\n['testargv.py', 'spam', 'eggs', 'cheese']\nC:\\...\\PP4E\\System> python testargv.py -i data.txt -o results.txt\n['testargv.py', '-i', 'data.txt', '-o', 'results.txt']\nThe last command here illustrates a common convention. Much like function argu-\nments, command-line options are sometimes passed by position and sometimes by\nname using a \u201c-name value\u201d word pair. For instance, the pair -i data.txt means the\n-i option\u2019s value is data.txt (e.g., an input filename). Any words can be listed, but\nprograms usually impose some sort of structure on them.\nCommand-line arguments play the same role in programs that function arguments do\nin functions: they are simply a way to pass information to a program that can vary per\nprogram run. Because they don\u2019t have to be hardcoded, they allow scripts to be more\ngenerally useful. For example, a file-processing script can use a command-line argu-\nment as the name of the file it should process; see Chapter 2\u2019s more.py script (Exam-\nple 2-1) for a prime example. Other scripts might accept processing mode flags, Internet\naddresses, and so on.\nParsing Command-Line Arguments\nOnce you start using command-line arguments regularly, though, you\u2019ll probably find\nit inconvenient to keep writing code that fishes through the list looking for words. More\ntypically, programs translate the arguments list on startup into structures that are more\nconveniently processed. Here\u2019s one way to do it: the script in Example 3-2 scans the\nargv list looking for -optionname optionvalue word pairs and stuffs them into a dic-\ntionary by option name for easy retrieval.\nCommand-Line Arguments | 107Example 3-2. PP4E\\System\\testargv2.py \n\"collect command-line options in a dictionary\"\ndef getopts(argv):\n    opts = {}\n    while argv:\n        if argv[0][0] == '-':                  # find \"-name value\" pairs\n            opts[argv[0]] = argv[1]            # dict key is \"-name\" arg\n            argv = argv[2:]\n        else:\n            argv = argv[1:]\n    return opts\nif __name__ == '__main__':\n    from sys import argv                       # example client code\n    myargs = getopts(argv)\n    if '-i' in myargs:\n        print(myargs['-i'])\n    print(myargs)\nYou might import and use such a function in all your command-line tools. When run \nby itself, this file just prints the formatted argument dictionary:\nC:\\...\\PP4E\\System> python testargv2.py\n{}\nC:\\...\\PP4E\\System> python testargv2.py -i data.txt -o results.txt\ndata.txt\n{'-o': 'results.txt', '-i': 'data.txt'}\nNaturally, we could get much more sophisticated here in terms of argument patterns, \nerror checking, and the like. For more complex command lines, we could also use \ncommand-line processing tools in the Python standard library to parse arguments:\n\u2022 The getopt module, modeled after a Unix/C utility of the same name\n\u2022 The optparse module, a newer alternative, generally considered to be more \npowerful\nBoth of these are documented in Python\u2019s library manual, which also provides usage \nexamples which we\u2019ll defer to here in the interest of space. In general, the more con-\nfigurable your scripts, the more you must invest in command-line processing logic \ncomplexity.\nExecutable Scripts on Unix\nUnix and Linux users: you can also make text files of Python source code directly \nexecutable by adding a special line at the top with the path to the Python interpreter \nand giving the file executable permission. For instance, type this code into a text file \ncalled myscript:\n#!/usr/bin/python\nprint('And nice red uniforms')\n108 | Chapter 3:\u2002Script Execution ContextThe first line is normally taken as a comment by Python (it starts with a #); but when\nthis file is run, the operating system sends lines in this file to the interpreter listed after\n#! in line 1. If this file is made directly executable with a shell command of the form\nchmod +x myscript, it can be run directly without typing python in the command, as\nthough it were a binary executable program:\n% myscript a b c\nAnd nice red uniforms\nWhen run this way, sys.argv will still have the script\u2019s name as the first word in the\nlist: [\"myscript\", \"a\", \"b\", \"c\"], exactly as if the script had been run with the more\nexplicit and portable command form python myscript a b c. Making scripts directly\nexecutable is actually a Unix trick, not a Python feature, but it\u2019s worth pointing out\nthat it can be made a bit less machine dependent by listing the Unix env command at\nthe top instead of a hardcoded path to the Python executable:\n#!/usr/bin/env python\nprint('Wait for it...')\nWhen coded this way, the operating system will employ your environment variable\nsettings to locate your Python interpreter (your PATH variable, on most platforms). If\nyou run the same script on many machines, you need only change your environment\nsettings on each machine (you don\u2019t need to edit Python script code). Of course, you\ncan always run Python files with a more explicit command line:\n% python myscript a b c\nThis assumes that the python interpreter program is on your system\u2019s search path setting\n(otherwise, you need to type its full path), but it works on any Python platform with a\ncommand line. Since this is more portable, I generally use this convention in the book\u2019s\nexamples, but consult your Unix manpages for more details on any of the topics men-\ntioned here. Even so, these special #! lines will show up in many examples in this book\njust in case readers want to run them as executables on Unix or Linux; on other plat-\nforms, they are simply ignored as Python comments.\nNote that on recent flavors of Windows, you can usually also type a script\u2019s filename\ndirectly (without the word python) to make it go, and you don\u2019t have to add a #! line\nat the top. Python uses the Windows registry on this platform to declare itself as the\nprogram that opens files with Python extensions (.py and others). This is also why you\ncan launch files on Windows by clicking on them.\nShell Environment Variables\nShell variables, sometimes known as environment variables, are made available to Py-\nthon scripts as os.environ, a Python dictionary-like object with one entry per variable\nsetting in the shell. Shell variables live outside the Python system; they are often set at\nyour system prompt or within startup files or control-panel GUIs and typically serve\nas system-wide configuration inputs to programs.\nShell Environment Variables | 109In fact, by now you should be familiar with a prime example: the PYTHONPATH module\nsearch path setting is a shell variable used by Python to import modules. By setting it\nonce in your operating system, its value is available every time a Python program is run.\nShell variables can also be set by programs to serve as inputs to other programs in an\napplication; because their values are normally inherited by spawned programs, they\ncan be used as a simple form of interprocess communication.\nFetching Shell Variables\nIn Python, the surrounding shell environment becomes a simple preset object, not spe-\ncial syntax. Indexing os.environ by the desired shell variable\u2019s name string (e.g.,\nos.environ['USER']) is the moral equivalent of adding a dollar sign before a variable\nname in most Unix shells (e.g., $USER), using surrounding percent signs on DOS\n(%USER%), and calling getenv(\"USER\") in a C program. Let\u2019s start up an interactive session\nto experiment (run in Python 3.1 on a Windows 7 laptop):\n>>> import os\n>>> os.environ.keys()\nKeysView(<os._Environ object at 0x013B8C70>)\n>>> list(os.environ.keys())\n['TMP', 'COMPUTERNAME', 'USERDOMAIN', 'PSMODULEPATH', 'COMMONPROGRAMFILES',\n...many more deleted...\n'NUMBER_OF_PROCESSORS', 'PROCESSOR_LEVEL', 'USERPROFILE', 'OS', 'PUBLIC', 'QTJAVA']\n>>> os.environ['TEMP']\n'C:\\\\Users\\\\mark\\\\AppData\\\\Local\\\\Temp'\nHere, the keys method returns an iterable of assigned variables, and indexing fetches\nthe value of the shell variable TEMP on Windows. This works the same way on Linux,\nbut other variables are generally preset when Python starts up. Since we know about\nPYTHONPATH, let\u2019s peek at its setting within Python to verify its content (as I wrote this,\nmine was set to the root of the book examples tree for this fourth edition, as well as a\ntemporary development location):\n>>> os.environ['PYTHONPATH']\n'C:\\\\PP4thEd\\\\Examples;C:\\\\Users\\\\Mark\\\\temp'\n>>> for srcdir in os.environ['PYTHONPATH'].split(os.pathsep):\n...     print(srcdir)\n...\nC:\\PP4thEd\\Examples\nC:\\Users\\Mark\\temp\n>>> import sys\n>>> sys.path[:3]\n['', 'C:\\\\PP4thEd\\\\Examples', 'C:\\\\Users\\\\Mark\\\\temp']\nPYTHONPATH is a string of directory paths separated by whatever character is used to\nseparate items in such paths on your platform (e.g., ; on DOS/Windows, : on Unix\nand Linux). To split it into its components, we pass to the split string method an\n110 | Chapter 3:\u2002Script Execution Contextos.pathsep delimiter\u2014a portable setting that gives the proper separator for the under-\nlying machine. As usual, sys.path is the actual search path at runtime, and reflects the\nresult of merging in the PYTHONPATH setting after the current directory.\nChanging Shell Variables\nLike normal dictionaries, the os.environ object supports both key indexing and\nassignment. As for dictionaries, assignments change the value of the key:\n>>> os.environ['TEMP']\n'C:\\\\Users\\\\mark\\\\AppData\\\\Local\\\\Temp\n>>> os.environ['TEMP'] = r'c:\\temp'\n>>> os.environ['TEMP']\n'c:\\\\temp'\nBut something extra happens here. In all recent Python releases, values assigned to\nos.environ keys in this fashion are automatically exported to other parts of the appli-\ncation. That is, key assignments change both the os.environ object in the Python pro-\ngram as well as the associated variable in the enclosing shell environment of the running\nprogram\u2019s process. Its new value becomes visible to the Python program, all linked-in\nC modules, and any programs spawned by the Python process.\nInternally, key assignments to os.environ call os.putenv\u2014a function that changes the\nshell variable outside the boundaries of the Python interpreter. To demonstrate how\nthis works, we need a couple of scripts that set and fetch shell variables; the first is\nshown in Example 3-3.\nExample 3-3. PP4E\\System\\Environment\\setenv.py\nimport os\nprint('setenv...', end=' ')\nprint(os.environ['USER'])                # show current shell variable value\nos.environ['USER'] = 'Brian'             # runs os.putenv behind the scenes\nos.system('python echoenv.py')\nos.environ['USER'] = 'Arthur'            # changes passed to spawned programs\nos.system('python echoenv.py')           # and linked-in C library modules\nos.environ['USER'] = input('?')\nprint(os.popen('python echoenv.py').read())\nThis setenv.py script simply changes a shell variable, USER, and spawns another script\nthat echoes this variable\u2019s value, as shown in Example 3-4.\nExample 3-4. PP4E\\System\\Environment\\echoenv.py\nimport os\nprint('echoenv...', end=' ')\nprint('Hello,', os.environ['USER'])\nShell Environment Variables | 111No matter how we run echoenv.py, it displays the value of USER in the enclosing shell;\nwhen run from the command line, this value comes from whatever we\u2019ve set the variable\nto in the shell itself:\nC:\\...\\PP4E\\System\\Environment> set USER=Bob\nC:\\...\\PP4E\\System\\Environment> python echoenv.py\nechoenv... Hello, Bob\nWhen spawned by another script such as setenv.py using the os.system and os.popen\ntools we met earlier, though, echoenv.py gets whatever USER settings its parent program\nhas made:\nC:\\...\\PP4E\\System\\Environment> python setenv.py\nsetenv... Bob\nechoenv... Hello, Brian\nechoenv... Hello, Arthur\n?Gumby\nechoenv... Hello, Gumby\nC:\\...\\PP4E\\System\\Environment> echo %USER%\nBob\nThis works the same way on Linux. In general terms, a spawned program always\ninherits environment settings from its parents. Spawned programs are programs started\nwith Python tools such as os.spawnv, the os.fork/exec combination on Unix-like plat-\nforms, and os.popen, os.system, and the subprocess module on a variety of platforms.\nAll programs thus launched get the environment variable settings that exist in the parent\nat launch time.*\nFrom a larger perspective, setting shell variables like this before starting a new program\nis one way to pass information into the new program. For instance, a Python configu-\nration script might tailor the PYTHONPATH variable to include custom directories just\nbefore launching another Python script; the launched script will have the custom search\npath in its sys.path because shell variables are passed down to children (in fact, watch\nfor such a launcher script to appear at the end of Chapter 6).\nShell Variable Fine Points: Parents, putenv, and getenv\nNotice the last command in the preceding example\u2014the USER variable is back to its\noriginal value after the top-level Python program exits. Assignments to os.environ keys\nare passed outside the interpreter and down the spawned programs chain, but never\nback up to parent program processes (including the system shell). This is also true in\nC programs that use the putenv library call, and it isn\u2019t a Python limitation per se.\n* This is by default. Some program-launching tools also let scripts pass environment settings that are different\nfrom their own to child programs. For instance, the os.spawnve call is like os.spawnv, but it accepts a dictionary\nargument representing the shell environment to be passed to the started program. Some os.exec* variants\n(ones with an \u201ce\u201d at the end of their names) similarly accept explicit environments; see the os.exec* call\nformats in Chapter 5 for more details.\n112 | Chapter 3:\u2002Script Execution ContextIt\u2019s also likely to be a nonissue if a Python script is at the top of your application. But\nkeep in mind that shell settings made within a program usually endure only for that\nprogram\u2019s run and for the run of its spawned children. If you need to export a shell\nvariable setting so that it lives on after Python exits, you may be able to find platform-\nspecific extensions that do this; search http://www.python.org or the Web at large.\nAnother subtlety: as implemented today, changes to os.environ automatically call\nos.putenv, which runs the putenv call in the C library if it is available on your platform\nto export the setting outside Python to any linked-in C code. However, although\nos.environ changes call os.putenv, direct calls to os.putenv do not update os.environ\nto reflect the change. Because of this, the os.environ mapping interface is generally\npreferred to os.putenv.\nAlso note that environment settings are loaded into os.environ on startup and not on\neach fetch; hence, changes made by linked-in C code after startup may not be reflected\nin os.environ. Python does have a more focused os.getenv call today, but it is simply\ntranslated into an os.environ fetch on most platforms (or all, in 3.X), not into a call to\ngetenv in the C library. Most applications won\u2019t need to care, especially if they are pure\nPython code. On platforms without a putenv call, os.environ can be passed as a pa-\nrameter to program startup tools to set the spawned program\u2019s environment.\nStandard Streams\nThe sys module is also the place where the standard input, output, and error streams\nof your Python programs live; these turn out to be another common way for programs\nto communicate:\n>>> import sys\n>>> for f in (sys.stdin, sys.stdout, sys.stderr): print(f)\n...\n<_io.TextIOWrapper name='<stdin>' encoding='cp437'>\n<_io.TextIOWrapper name='<stdout>' encoding='cp437'>\n<_io.TextIOWrapper name='<stderr>' encoding='cp437'>\nThe standard streams are simply preopened Python file objects that are automatically\nconnected to your program\u2019s standard streams when Python starts up. By default, all\nof them are tied to the console window where Python (or a Python program) was star-\nted. Because the print and input built-in functions are really nothing more than user-\nfriendly interfaces to the standard output and input streams, they are similar to using\nstdout and stdin in sys directly:\n>>> print('hello stdout world')\nhello stdout world\n>>> sys.stdout.write('hello stdout world' + '\\n')\nhello stdout world\n19\nStandard Streams | 113>>> input('hello stdin world>')\nhello stdin world>spam\n'spam'\n>>> print('hello stdin world>'); sys.stdin.readline()[:-1]\nhello stdin world>\neggs\n'eggs'\nStandard Streams on Windows\nWindows users: if you click a .py Python program\u2019s filename in a Windows file explorer\nto start it (or launch it with os.system), a DOS console window automatically pops up\nto serve as the program\u2019s standard stream. If your program makes windows of its own,\nyou can avoid this console pop-up window by naming your program\u2019s source-code file\nwith a .pyw extension, not with a .py extension. The .pyw extension simply means\na .py source file without a DOS pop up on Windows (it uses Windows registry settings\nto run a custom version of Python). A .pyw file may also be imported as usual.\nAlso note that because printed output goes to this DOS pop up when a program is\nclicked, scripts that simply print text and exit will generate an odd \u201cflash\u201d\u2014the DOS\nconsole box pops up, output is printed into it, and the pop up goes away immediately\n(not the most user-friendly of features!). To keep the DOS pop-up box around so that\nyou can read printed output, simply add an input() call at the bottom of your script to\npause for an Enter key press before exiting.\nRedirecting Streams to Files and Programs\nTechnically, standard output (and print) text appears in the console window where a\nprogram was started, standard input (and input) text comes from the keyboard, and\nstandard error text is used to print Python error messages to the console window. At\nleast that\u2019s the default. It\u2019s also possible to redirect these streams both to files and to\nother programs at the system shell, as well as to arbitrary objects within a Python script.\nOn most systems, such redirections make it easy to reuse and combine general-purpose\ncommand-line utilities.\nRedirection is useful for things like canned (precoded) test inputs: we can apply a single\ntest script to any set of inputs by simply redirecting the standard input stream to a\ndifferent file each time the script is run. Similarly, redirecting the standard output\nstream lets us save and later analyze a program\u2019s output; for example, testing systems\nmight compare the saved standard output of a script with a file of expected output to\ndetect failures.\nAlthough it\u2019s a powerful paradigm, redirection turns out to be straightforward to use.\nFor instance, consider the simple read-evaluate-print loop program in Example 3-5.\n114 | Chapter 3:\u2002Script Execution ContextExample 3-5. PP4E\\System\\Streams\\teststreams.py\n\"read numbers till eof and show squares\"\ndef interact():\n    print('Hello stream world')                     # print sends to sys.stdout\n    while True:\n        try:\n            reply = input('Enter a number>')        # input reads sys.stdin\n        except EOFError:\n            break                                   # raises an except on eof\n        else:                                       # input given as a string\n            num = int(reply)\n            print(\"%d squared is %d\" % (num, num ** 2))\n    print('Bye')\nif __name__ == '__main__':\n    interact()                                      # when run, not imported\nAs usual, the interact function here is automatically executed when this file is run, not\nwhen it is imported. By default, running this file from a system command line makes\nthat standard stream appear where you typed the Python command. The script simply\nreads numbers until it reaches end-of-file in the standard input stream (on Windows,\nend-of-file is usually the two-key combination Ctrl-Z; on Unix, type Ctrl-D instead\u2020):\nC:\\...\\PP4E\\System\\Streams> python teststreams.py\nHello stream world\nEnter a number>12\n12 squared is 144\nEnter a number>10\n10 squared is 100\nEnter a number>^Z\nBye\nBut on both Windows and Unix-like platforms, we can redirect the standard input\nstream to come from a file with the < filename shell syntax. Here is a command session\nin a DOS console box on Windows that forces the script to read its input from a text\nfile, input.txt. It\u2019s the same on Linux, but replace the DOS type command with a Unix\ncat command:\nC:\\...\\PP4E\\System\\Streams> type input.txt\n8\n6\nC:\\...\\PP4E\\System\\Streams> python teststreams.py < input.txt\nHello stream world\n\u2020 Notice that input raises an exception to signal end-of-file, but file read methods simply return an empty string\nfor this condition. Because input also strips the end-of-line character at the end of lines, an empty string result\nmeans an empty line, so an exception is necessary to specify the end-of-file condition. File read methods\nretain the end-of-line character and denote an empty line as \"\\n\" instead of \"\". This is one way in which\nreading sys.stdin directly differs from input. The latter also accepts a prompt string that is automatically\nprinted before input is accepted.\nStandard Streams | 115Enter a number>8 squared is 64\nEnter a number>6 squared is 36\nEnter a number>Bye\nHere, the input.txt file automates the input we would normally type interactively\u2014the\nscript reads from this file rather than from the keyboard. Standard output can be sim-\nilarly redirected to go to a file with the > filename shell syntax. In fact, we can combine\ninput and output redirection in a single command:\nC:\\...\\PP4E\\System\\Streams> python teststreams.py < input.txt > output.txt\nC:\\...\\PP4E\\System\\Streams> type output.txt\nHello stream world\nEnter a number>8 squared is 64\nEnter a number>6 squared is 36\nEnter a number>Bye\nThis time, the Python script\u2019s input and output are both mapped to text files, not to\nthe interactive console session.\nChaining programs with pipes\nOn Windows and Unix-like platforms, it\u2019s also possible to send the standard output\nof one program to the standard input of another using the | shell character between\ntwo commands. This is usually called a \u201cpipe\u201d operation because the shell creates a\npipeline that connects the output and input of two commands. Let\u2019s send the output\nof the Python script to the standard more command-line program\u2019s input to see how\nthis works:\nC:\\...\\PP4E\\System\\Streams> python teststreams.py < input.txt | more\nHello stream world\nEnter a number>8 squared is 64\nEnter a number>6 squared is 36\nEnter a number>Bye\nHere, teststreams\u2019s standard input comes from a file again, but its output (written by\nprint calls) is sent to another program, not to a file or window. The receiving program\nis more, a standard command-line paging program available on Windows and Unix-like\nplatforms. Because Python ties scripts into the standard stream model, though, Python\nscripts can be used on both ends. One Python script\u2019s output can always be piped into\nanother Python script\u2019s input:\nC:\\...\\PP4E\\System\\Streams> type writer.py\nprint(\"Help! Help! I'm being repressed!\")\nprint(42)\nC:\\...\\PP4E\\System\\Streams> type reader.py\nprint('Got this: \"%s\"' % input())\nimport sys\ndata = sys.stdin.readline()[:-1]\nprint('The meaning of life is', data, int(data) * 2)\n116 | Chapter 3:\u2002Script Execution ContextC:\\...\\PP4E\\System\\Streams> python writer.py\nHelp! Help! I'm being repressed!\n42\nC:\\...\\PP4E\\System\\Streams> python writer.py | python reader.py\nGot this: \"Help! Help! I'm being repressed!\"\nThe meaning of life is 42 84\nThis time, two Python programs are connected. Script reader gets input from script\nwriter; both scripts simply read and write, oblivious to stream mechanics. In practice,\nsuch chaining of programs is a simple form of cross-program communications. It makes\nit easy to reuse utilities written to communicate via stdin and stdout in ways we never\nanticipated. For instance, a Python program that sorts stdin text could be applied to\nany data source we like, including the output of other scripts. Consider the Python\ncommand-line utility scripts in Examples 3-6 and 3-7 which sort and sum lines in the\nstandard input stream.\nExample 3-6. PP4E\\System\\Streams\\sorter.py\nimport sys                                  # or sorted(sys.stdin)\nlines = sys.stdin.readlines()               # sort stdin input lines,\nlines.sort()                                # send result to stdout\nfor line in lines: print(line, end='')      # for further processing\nExample 3-7. PP4E\\System\\Streams\\adder.py\nimport sys\nsum = 0\nwhile True:\n    try:\n        line = input()                     # or call sys.stdin.readlines()\n    except EOFError:                       # or for line in sys.stdin:\n        break                              # input strips \\n at end\n    else:\n        sum += int(line)                   # was sting.atoi() in 2nd ed\nprint(sum)\nWe can apply such general-purpose tools in a variety of ways at the shell command line\nto sort and sum arbitrary files and program outputs (Windows note: on my prior XP\nmachine and Python 2.X, I had to type \u201cpython file.py\u201d here, not just \u201cfile.py,\u201d or else\nthe input redirection failed; with Python 3.X on Windows 7 today, either form works):\nC:\\...\\PP4E\\System\\Streams> type data.txt\n123\n000\n999\n042\nC:\\...\\PP4E\\System\\Streams> python sorter.py < data.txt            sort a file\n000\n042\n123\n999\nStandard Streams | 117C:\\...\\PP4E\\System\\Streams> python adder.py < data.txt             sum file\n1164\nC:\\...\\PP4E\\System\\Streams> type data.txt | python adder.py        sum type output\n1164\nC:\\...\\PP4E\\System\\Streams> type writer2.py\nfor data in (123, 0, 999, 42):\n    print('%03d' % data)\nC:\\...\\PP4E\\System\\Streams> python writer2.py | python sorter.py   sort py output\n000\n042\n123\n999\nC:\\...\\PP4E\\System\\Streams> writer2.py | sorter.py                 shorter form\n...same output as prior command on Windows...\nC:\\...\\PP4E\\System\\Streams> python writer2.py | python sorter.py | python adder.py\n1164\nThe last command here connects three Python scripts by standard streams\u2014the output\nof each prior script is fed to the input of the next via pipeline shell syntax.\nCoding alternatives for adders and sorters\nA few coding pointers here: if you look closely, you\u2019ll notice that sorter.py reads all of\nstdin at once with the readlines method, but adder.py reads one line at a time. If the\ninput source is another program, some platforms run programs connected by pipes in\nparallel. On such systems, reading line by line works better if the data streams being\npassed are large, because readers don\u2019t have to wait until writers are completely finished\nto get busy processing data. Because input just reads stdin, the line-by-line scheme\nused by adder.py can always be coded with manual sys.stdin reads too:\nC:\\...\\PP4E\\System\\Streams> type adder2.py\nimport sys\nsum = 0\nwhile True:\n    line = sys.stdin.readline()\n    if not line: break\n    sum += int(line)\nprint(sum)\nThis version utilizes the fact that int allows the digits to be surrounded by whitespace\n(readline returns a line including its \\n, but we don\u2019t have to use [:-1] or rstrip() to\nremove it for int). In fact, we can use Python\u2019s more recent file iterators to achieve the\nsame effect\u2014the for loop, for example, automatically grabs one line each time through\nwhen we iterate over a file object directly (more on file iterators in the next chapter):\nC:\\...\\PP4E\\System\\Streams> type adder3.py\nimport sys\nsum = 0\n118 | Chapter 3:\u2002Script Execution Contextfor line in sys.stdin: sum += int(line)\nprint(sum)\nChanging sorter to read line by line this way may not be a big performance boost,\nthough, because the list sort method requires that the list already be complete. As we\u2019ll\nsee in Chapter 18, manually coded sort algorithms are generally prone to be much\nslower than the Python list sorting method.\nInterestingly, these two scripts can also be coded in a much more compact fashion in\nPython 2.4 and later by using the new sorted built-in function, generator expressions,\nand file iterators. The following work the same way as the originals, with noticeably\nless source-file real estate:\nC:\\...\\PP4E\\System\\Streams> type sorterSmall.py\nimport sys\nfor line in sorted(sys.stdin): print(line, end='')\nC:\\...\\PP4E\\System\\Streams> type adderSmall.py\nimport sys\nprint(sum(int(line) for line in sys.stdin))\nIn its argument to sum, the latter of these employs a generator expression, which is much\nlike a list comprehension, but results are returned one at a time, not in a physical list.\nThe net effect is space optimization. For more details, see a core language resource,\nsuch as the book Learning Python.\nRedirected Streams and User Interaction\nEarlier in this section, we piped teststreams.py output into the standard more command-\nline program with a command like this:\nC:\\...\\PP4E\\System\\Streams> python teststreams.py < input.txt | more\nBut since we already wrote our own \u201cmore\u201d paging utility in Python in the preceding\nchapter, why not set it up to accept input from stdin too? For example, if we change\nthe last three lines of the more.py file listed as Example 2-1 in the prior chapter\u2026\nif __name__ == '__main__':                       # when run, not when imported\n    import sys\n    if len(sys.argv) == 1:                       # page stdin if no cmd args\n        more(sys.stdin.read())\n    else:\n        more(open(sys.argv[1]).read())\n\u2026it almost seems as if we should be able to redirect the standard output of\nteststreams.py into the standard input of more.py:\nC:\\...\\PP4E\\System\\Streams> python teststreams.py < input.txt | python ..\\more.py\nHello stream world\nEnter a number>8 squared is 64\nEnter a number>6 squared is 36\nEnter a number>Bye\nStandard Streams | 119This technique generally works for Python scripts. Here, teststreams.py takes input\nfrom a file again. And, as in the last section, one Python program\u2019s output is piped to\nanother\u2019s input\u2014the more.py script in the parent (..) directory.\nBut there\u2019s a subtle problem lurking in the preceding more.py command. Really, chain-\ning worked there only by sheer luck: if the first script\u2019s output is long enough that\nmore has to ask the user if it should continue, the script will utterly fail (specifically,\nwhen input for user interaction triggers EOFError).\nThe problem is that the augmented more.py uses stdin for two disjointed purposes. It\nreads a reply from an interactive user on stdin by calling input, but now it also accepts\nthe main input text on stdin. When the stdin stream is really redirected to an input\nfile or pipe, we can\u2019t use it to input a reply from an interactive user; it contains only the\ntext of the input source. Moreover, because stdin is redirected before the program even\nstarts up, there is no way to know what it meant prior to being redirected in the com-\nmand line.\nIf we intend to accept input on stdin and use the console for user interaction, we have\nto do a bit more: we would also need to use special interfaces to read user replies from\na keyboard directly, instead of standard input. On Windows, Python\u2019s standard library\nmsvcrt module provides such tools; on many Unix-like platforms, reading from device\nfile /dev/tty will usually suffice.\nSince this is an arguably obscure use case, we\u2019ll delegate a complete solution to a sug-\ngested exercise. Example 3-8 shows a Windows-only modified version of the more\nscript that pages the standard input stream if called with no arguments, but also makes\nuse of lower-level and platform-specific tools to converse with a user at a keyboard if\nneeded.\nExample 3-8. PP4E\\System\\Streams\\moreplus.py\n\"\"\"\nsplit and interactively page a string, file, or stream of\ntext to stdout; when run as a script, page stdin or file\nwhose name is passed on cmdline; if input is stdin, can't\nuse it for user reply--use platform-specific tools or GUI;\n\"\"\"\nimport sys\ndef getreply():\n    \"\"\"\n    read a reply key from an interactive user\n    even if stdin redirected to a file or pipe\n    \"\"\"\n    if sys.stdin.isatty():                       # if stdin is console\n        return input('?')                        # read reply line from stdin\n    else:\n        if sys.platform[:3] == 'win':            # if stdin was redirected\n            import msvcrt                        # can't use to ask a user\n            msvcrt.putch(b'?')\n120 | Chapter 3:\u2002Script Execution Contextkey = msvcrt.getche()                # use windows console tools\n            msvcrt.putch(b'\\n')                  # getch() does not echo key\n            return key\n        else:\n            assert False, 'platform not supported'\n            #linux?: open('/dev/tty').readline()[:-1]\ndef more(text, numlines=10):\n    \"\"\"\n    page multiline string to stdout\n    \"\"\"\n    lines = text.splitlines()\n    while lines:\n        chunk = lines[:numlines]\n        lines = lines[numlines:]\n        for line in chunk: print(line)\n        if lines and getreply() not in [b'y', b'Y']: break\nif __name__ == '__main__':                       # when run, not when imported\n    if len(sys.argv) == 1:                       # if no command-line arguments\n        more(sys.stdin.read())                   # page stdin, no inputs\n    else:\n        more(open(sys.argv[1]).read())           # else page filename argument\nMost of the new code in this version shows up in its getreply function. The file\u2019s\nisatty method tells us whether stdin is connected to the console; if it is, we simply\nread replies on stdin as before. Of course, we have to add such extra logic only to scripts\nthat intend to interact with console users and take input on stdin. In a GUI application,\nfor example, we could instead pop up dialogs, bind keyboard-press events to run call-\nbacks, and so on (we\u2019ll meet GUIs in Chapter 7).\nArmed with the reusable getreply function, though, we can safely run our moreplus\nutility in a variety of ways. As before, we can import and call this module\u2019s function\ndirectly, passing in whatever string we wish to page:\n>>> from moreplus import more\n>>> more(open('adderSmall.py').read())\nimport sys\nprint(sum(int(line) for line in sys.stdin))\nAlso as before, when run with a command-line argument, this script interactively pages\nthrough the named file\u2019s text:\nC:\\...\\PP4E\\System\\Streams> python moreplus.py adderSmall.py\nimport sys\nprint(sum(int(line) for line in sys.stdin))\nC:\\...\\PP4E\\System\\Streams> python moreplus.py moreplus.py\n\"\"\"\nsplit and interactively page a string, file, or stream of\ntext to stdout; when run as a script, page stdin or file\nwhose name is passed on cmdline; if input is stdin, can't\nuse it for user reply--use platform-specific tools or GUI;\n\"\"\"\nStandard Streams | 121import sys\ndef getreply():\n?n\nBut now the script also correctly pages text redirected into stdin from either a file or a\ncommand pipe, even if that text is too long to fit in a single display chunk. On most\nshells, we send such input via redirection or pipe operators like these:\nC:\\...\\PP4E\\System\\Streams> python moreplus.py < moreplus.py\n\"\"\"\nsplit and interactively page a string, file, or stream of\ntext to stdout; when run as a script, page stdin or file\nwhose name is passed on cmdline; if input is stdin, can't\nuse it for user reply--use platform-specific tools or GUI;\n\"\"\"\nimport sys\ndef getreply():\n?n\nC:\\...\\PP4E\\System\\Streams> type moreplus.py | python moreplus.py\n\"\"\"\nsplit and interactively page a string, file, or stream of\ntext to stdout; when run as a script, page stdin or file\nwhose name is passed on cmdline; if input is stdin, can't\nuse it for user reply--use platform-specific tools or GUI;\n\"\"\"\nimport sys\ndef getreply():\n?n\nFinally, piping one Python script\u2019s output into this script\u2019s input now works as expec-\nted, without botching user interaction (and not just because we got lucky):\n......\\System\\Streams> python teststreams.py < input.txt | python moreplus.py\nHello stream world\nEnter a number>8 squared is 64\nEnter a number>6 squared is 36\nEnter a number>Bye\nHere, the standard output of one Python script is fed to the standard input of another\nPython script located in the same directory: moreplus.py reads the output of\nteststreams.py.\nAll of the redirections in such command lines work only because scripts don\u2019t care what\nstandard input and output really are\u2014interactive users, files, or pipes between pro-\ngrams. For example, when run as a script, moreplus.py simply reads stream\nsys.stdin; the command-line shell (e.g., DOS on Windows, csh on Linux) attaches\nsuch streams to the source implied by the command line before the script is started.\n122 | Chapter 3:\u2002Script Execution ContextScripts use the preopened stdin and stdout file objects to access those sources, regard-\nless of their true nature.\nAnd for readers keeping count, we have just run this single more pager script in four\ndifferent ways: by importing and calling its function, by passing a filename command-\nline argument, by redirecting stdin to a file, and by piping a command\u2019s output to\nstdin. By supporting importable functions, command-line arguments, and standard\nstreams, Python system tools code can be reused in a wide variety of modes.\nRedirecting Streams to Python Objects\nAll of the previous standard stream redirections work for programs written in any lan-\nguage that hook into the standard streams and rely more on the shell\u2019s command-line\nprocessor than on Python itself. Command-line redirection syntax like < filename and\n| program is evaluated by the shell, not by Python. A more Pythonesque form of redi-\nrection can be done within scripts themselves by resetting sys.stdin and sys.stdout to \nfile-like objects.\nThe main trick behind this mode is that anything that looks like a file in terms of\nmethods will work as a standard stream in Python. The object\u2019s interface (sometimes\ncalled its protocol), and not the object\u2019s specific datatype, is all that matters. That is:\n\u2022 Any object that provides file-like read methods can be assigned to sys.stdin to\nmake input come from that object\u2019s read methods.\n\u2022 Any object that defines file-like write methods can be assigned to sys.stdout; all\nstandard output will be sent to that object\u2019s methods.\nBecause print and input simply call the write and readline methods of whatever objects\nsys.stdout and sys.stdin happen to reference, we can use this technique to both pro-\nvide and intercept standard stream text with objects implemented as classes.\nIf you\u2019ve already studied Python, you probably know that such plug-and-play com-\npatibility is usually called polymorphism\u2014it doesn\u2019t matter what an object is, and it\ndoesn\u2019t matter what its interface does, as long as it provides the expected interface.\nThis liberal approach to datatypes accounts for much of the conciseness and flexibility\nof Python code. Here, it provides a way for scripts to reset their own streams. Exam-\nple 3-9 shows a utility module that demonstrates this concept.\nExample 3-9. PP4E\\System\\Streams\\redirect.py\n\"\"\"\nfile-like objects that save standard output text in a string and provide\nstandard input text from a string; redirect runs a passed-in function\nwith its output and input streams reset to these file-like class objects;\n\"\"\"\nimport sys                                      # get built-in modules\nclass Output:                                   # simulated output file\nStandard Streams | 123def __init__(self):\n        self.text = ''                          # empty string when created\n    def write(self, string):                    # add a string of bytes\n        self.text += string\n    def writelines(self, lines):                # add each line in a list\n        for line in lines: self.write(line)\nclass Input:                                    # simulated input file\n    def __init__(self, input=''):               # default argument\n        self.text = input                       # save string when created\n    def read(self, size=None):                  # optional argument\n        if size == None:                        # read N bytes, or all\n            res, self.text = self.text, ''\n        else:\n            res, self.text = self.text[:size], self.text[size:]\n        return res\n    def readline(self):\n        eoln = self.text.find('\\n')             # find offset of next eoln\n        if eoln == \u22121:                          # slice off through eoln\n            res, self.text = self.text, ''\n        else:\n            res, self.text = self.text[:eoln+1], self.text[eoln+1:]\n        return res\ndef redirect(function, pargs, kargs, input):    # redirect stdin/out\n    savestreams = sys.stdin, sys.stdout         # run a function object\n    sys.stdin   = Input(input)                  # return stdout text\n    sys.stdout  = Output()\n    try:\n        result = function(*pargs, **kargs)      # run function with args\n        output = sys.stdout.text\n    finally:\n        sys.stdin, sys.stdout = savestreams     # restore if exc or not\n    return (result, output)                     # return result if no exc\nThis module defines two classes that masquerade as real files:\nOutput\nProvides the write method interface (a.k.a. protocol) expected of output files but\nsaves all output in an in-memory string as it is written.\nInput\nProvides the interface expected of input files, but provides input on demand from\nan in-memory string passed in at object construction time.\nThe redirect function at the bottom of this file combines these two objects to run a\nsingle function with input and output redirected entirely to Python class objects. The\npassed-in function to run need not know or care that its print and input function calls\nand stdin and stdout method calls are talking to a class rather than to a real file, pipe,\nor user.\nTo demonstrate, import and run the interact function at the heart of the test\nstreams script of Example 3-5 that we\u2019ve been running from the shell (to use the\n124 | Chapter 3:\u2002Script Execution Contextredirection utility function, we need to deal in terms of functions, not files). When run\ndirectly, the function reads from the keyboard and writes to the screen, just as if it were\nrun as a program without redirection:\nC:\\...\\PP4E\\System\\Streams> python\n>>> from teststreams import interact\n>>> interact()\nHello stream world\nEnter a number>2\n2 squared is 4\nEnter a number>3\n3 squared is 9\nEnter a number^Z\nBye\n>>>\nNow, let\u2019s run this function under the control of the redirection function in\nredirect.py and pass in some canned input text. In this mode, the interact function\ntakes its input from the string we pass in ('4\\n5\\n6\\n'\u2014three lines with explicit end-\nof-line characters), and the result of running the function is a tuple with its return value\nplus a string containing all the text written to the standard output stream:\n>>> from redirect import redirect\n>>> (result, output) = redirect(interact, (), {}, '4\\n5\\n6\\n')\n>>> print(result)\nNone\n>>> output\n'Hello stream world\\nEnter a number>4 squared is 16\\nEnter a number>5 squared\nis 25\\nEnter a number>6 squared is 36\\nEnter a number>Bye\\n'\nThe output is a single, long string containing the concatenation of all text written to\nstandard output. To make this look better, we can pass it to print or split it up with\nthe string object\u2019s splitlines method:\n>>> for line in output.splitlines(): print(line)\n...\nHello stream world\nEnter a number>4 squared is 16\nEnter a number>5 squared is 25\nEnter a number>6 squared is 36\nEnter a number>Bye\nBetter still, we can reuse the more.py module we wrote in the preceding chapter\n(Example 2-1); it\u2019s less to type and remember, and it\u2019s already known to work well (the\nfollowing, like all cross-directory imports in this book\u2019s examples, assumes that the\ndirectory containing the PP4E root is on your module search path\u2014change your PYTHON\nPATH setting as needed):\n>>> from PP4E.System.more import more\n>>> more(output)\nHello stream world\nEnter a number>4 squared is 16\nEnter a number>5 squared is 25\nStandard Streams | 125Enter a number>6 squared is 36\nEnter a number>Bye\nThis is an artificial example, of course, but the techniques illustrated are widely appli-\ncable. For instance, it\u2019s straightforward to add a GUI interface to a program written to\ninteract with a command-line user. Simply intercept standard output with an object\nsuch as the Output class instance shown earlier and throw the text string up in a window.\nSimilarly, standard input can be reset to an object that fetches text from a graphical\ninterface (e.g., a popped-up dialog box). Because classes are plug-and-play compatible\nwith real files, we can use them in any tool that expects a file. Watch for a GUI stream-\nredirection module named guiStreams in Chapter 10 that provides a concrete imple-\nmentation of some of these ideas.\nThe io.StringIO and io.BytesIO Utility Classes\nThe prior section\u2019s technique of redirecting streams to objects proved so handy that\nnow a standard library module automates the task for many use cases (though some\nuse cases, such as GUIs, may still require more custom code). The standard library tool\nprovides an object that maps a file object interface to and from in-memory strings. For\nexample:\n>>> from io import StringIO\n>>> buff = StringIO()                   # save written text to a string\n>>> buff.write('spam\\n')\n5\n>>> buff.write('eggs\\n')\n5\n>>> buff.getvalue()\n'spam\\neggs\\n'\n>>> buff = StringIO('ham\\nspam\\n')      # provide input from a string\n>>> buff.readline()\n'ham\\n'\n>>> buff.readline()\n'spam\\n'\n>>> buff.readline()\n''\nAs in the prior section, instances of StringIO objects can be assigned to sys.stdin and\nsys.stdout to redirect streams for input and print calls and can be passed to any code\nthat was written to expect a real file object. Again, in Python, the object interface, not\nthe concrete datatype, is the name of the game:\n>>> from io import StringIO\n>>> import sys\n>>> buff = StringIO()\n>>> temp = sys.stdout\n>>> sys.stdout = buff\n>>> print(42, 'spam', 3.141)              # or print(..., file=buff)\n126 | Chapter 3:\u2002Script Execution Context>>> sys.stdout = temp                     # restore original stream\n>>> buff.getvalue()\n'42 spam 3.141\\n'\nNote that there is also an io.BytesIO class with similar behavior, but which maps file\noperations to an in-memory bytes buffer, instead of a str string:\n>>> from io import BytesIO\n>>> stream = BytesIO()\n>>> stream.write(b'spam')\n>>> stream.getvalue()\nb'spam'\n>>> stream = BytesIO(b'dpam')\n>>> stream.read()\nb'dpam'\nDue to the sharp distinction that Python 3X draws between text and binary data, this\nalternative may be better suited for scripts that deal with binary data. We\u2019ll learn more\nabout the text-versus-binary issue in the next chapter when we explore files.\nCapturing the stderr Stream\nWe\u2019ve been focusing on stdin and stdout redirection, but stderr can be similarly reset\nto files, pipes, and objects. Although some shells support this, it\u2019s also straightforward\nwithin a Python script. For instance, assigning sys.stderr to another instance of a class\nsuch as Output or a StringIO object in the preceding section\u2019s example allows your script\nto intercept text written to standard error, too.\nPython itself uses standard error for error message text (and the IDLE GUI interface\nintercepts it and colors it red by default). However, no higher-level tools for standard\nerror do what print and input do for the output and input streams. If you wish to print\nto the error stream, you\u2019ll want to call sys.stderr.write() explicitly or read the next\nsection for a print call trick that makes this easier.\nRedirecting standard errors from a shell command line is a bit more complex and less\nportable. On most Unix-like systems, we can usually capture stderr output by using\nshell-redirection syntax of the form command > output 2>&1. This may not work on some\nplatforms, though, and can even vary per Unix shell; see your shell\u2019s manpages for more\ndetails.\nRedirection Syntax in Print Calls\nBecause resetting the stream attributes to new objects was so popular, the Python\nprint built-in is also extended to include an explicit file to which output is to be sent.\nA statement of this form:\nprint(stuff, file=afile)            # afile is an object, not a string name\nStandard Streams | 127prints stuff to afile instead of to sys.stdout. The net effect is similar to simply as-\nsigning sys.stdout to an object, but there is no need to save and restore in order to\nreturn to the original output stream (as shown in the section on redirecting streams to\nobjects). For example:\nimport sys\nprint('spam' * 2, file=sys.stderr)\nwill send text the standard error stream object rather than sys.stdout for the duration\nof this single print call only. The next normal print statement (without file) prints to\nstandard output as usual. Similarly, we can use either our custom class or the standard\nlibrary\u2019s class as the output file with this hook:\n>>> from io import StringIO\n>>> buff = StringIO()\n>>> print(42, file=buff)\n>>> print('spam', file=buff)\n>>> print(buff.getvalue())\n42\nspam\n>>> from redirect import Output\n>>> buff = Output()\n>>> print(43, file=buff)\n>>> print('eggs', file=buff)\n>>> print(buff.text)\n43\neggs\nOther Redirection Options: os.popen and subprocess Revisited\nNear the end of the preceding chapter, we took a first look at the built-in os.popen\nfunction and its subprocess.Popen relative, which provide a way to redirect another\ncommand\u2019s streams from within a Python program. As we saw, these tools can be used\nto run a shell command line (a string we would normally type at a DOS or csh prompt)\nbut also provide a Python file-like object connected to the command\u2019s output stream\u2014\nreading the file object allows a script to read another program\u2019s output. I suggested that\nthese tools may be used to tap into input streams as well.\nBecause of that, the os.popen and subprocess tools are another way to redirect streams\nof spawned programs and are close cousins to some of the techniques we just met.\nTheir effect is much like the shell | command-line pipe syntax for redirecting streams\nto programs (in fact, their names mean \u201cpipe open\u201d), but they are run within a script\nand provide a file-like interface to piped streams. They are similar in spirit to the\nredirect function, but are based on running programs (not calling functions), and the\ncommand\u2019s streams are processed in the spawning script as files (not tied to class ob-\njects). These tools redirect the streams of a program that a script starts, instead of\nredirecting the streams of the script itself.\n128 | Chapter 3:\u2002Script Execution ContextRedirecting input or output with os.popen\nIn fact, by passing in the desired mode flag, we redirect either a spawned program\u2019s\noutput or input streams to a file in the calling scripts, and we can obtain the spawned\nprogram\u2019s exit status code from the close method (None means \u201cno error\u201d here). To\nillustrate, consider the following two scripts:\nC:\\...\\PP4E\\System\\Streams> type hello-out.py\nprint('Hello shell world')\nC:\\...\\PP4E\\System\\Streams> type hello-in.py\ninp = input()\nopen('hello-in.txt', 'w').write('Hello ' + inp + '\\n')\nThese scripts can be run from a system shell window as usual:\nC:\\...\\PP4E\\System\\Streams> python hello-out.py\nHello shell world\nC:\\...\\PP4E\\System\\Streams> python hello-in.py\nBrian\nC:\\...\\PP4E\\System\\Streams> type hello-in.txt\nHello Brian\nAs we saw in the prior chapter, Python scripts can read output from other programs\nand scripts like these, too, using code like the following:\nC:\\...\\PP4E\\System\\Streams> python\n>>> import os\n>>> pipe = os.popen('python hello-out.py')         # 'r' is default--read stdout\n>>> pipe.read()\n'Hello shell world\\n'\n>>> print(pipe.close())                            # exit status: None is good\nNone\nBut Python scripts can also provide input to spawned programs\u2019 standard input\nstreams\u2014passing a \u201cw\u201d mode argument, instead of the default \u201cr\u201d, connects the re-\nturned object to the spawned program\u2019s input stream. What we write on the spawning\nend shows up as input in the program started:\n>>> pipe = os.popen('python hello-in.py', 'w')     # 'w'--write to program stdin\n>>> pipe.write('Gumby\\n')\n6\n>>> pipe.close()                                   # \\n at end is optional\n>>> open('hello-in.txt').read()                    # output sent to a file\n'Hello Gumby\\n'\nThe popen call is also smart enough to run the command string as an independent\nprocess on platforms that support such a notion. It accepts an optional third argument\nthat can be used to control buffering of written text, which we\u2019ll finesse here.\nStandard Streams | 129Redirecting input and output with subprocess\nFor even more control over the streams of spawned programs, we can employ the\nsubprocess module we introduced in the preceding chapter. As we learned earlier, this\nmodule can emulate os.popen functionality, but it can also achieve feats such as\nbidirectional stream communication (accessing both a program\u2019s input and output)\nand tying the output of one program to the input of another.\nFor instance, this module provides multiple ways to spawn a program and get both its\nstandard output text and exit status. Here are three common ways to leverage this\nmodule to start a program and redirect its output stream (recall from Chapter 2 that\nyou may need to pass a shell=True argument to Popen and call to make this section\u2019s\nexamples work on Unix-like platforms as they are coded here):\nC:\\...\\PP4E\\System\\Streams> python\n>>> from subprocess import Popen, PIPE, call\n>>> X = call('python hello-out.py')                            # convenience\nHello shell world\n>>> X\n0\n>>> pipe = Popen('python hello-out.py', stdout=PIPE)\n>>> pipe.communicate()[0]                                      # (stdout, stderr)\nb'Hello shell world\\r\\n'\n>>> pipe.returncode                                            # exit status\n0\n>>> pipe = Popen('python hello-out.py', stdout=PIPE)\n>>> pipe.stdout.read()\nb'Hello shell world\\r\\n'\n>>> pipe.wait()                                                # exit status\n0\nThe call in the first of these three techniques is just a convenience function (there are\nmore of these which you can look up in the Python library manual), and the\ncommunicate in the second is roughly a convenience for the third (it sends data to stdin,\nreads data from stdout until end-of-file, and waits for the process to end):\nRedirecting and connecting to the spawned program\u2019s input stream is just as simple,\nthough a bit more complex than the os.popen approach with 'w' file mode shown in\nthe preceding section (as mentioned in the last chapter, os.popen is implemented with\nsubprocess, and is thus itself just something of a convenience function today):\n>>> pipe = Popen('python hello-in.py', stdin=PIPE)\n>>> pipe.stdin.write(b'Pokey\\n')\n6\n>>> pipe.stdin.close()\n>>> pipe.wait()\n0\n>>> open('hello-in.txt').read()                       # output sent to a file\n'Hello Pokey\\n'\n130 | Chapter 3:\u2002Script Execution ContextIn fact, we can use obtain both the input and output streams of a spawned program with\nthis module. Let\u2019s reuse the simple writer and reader scripts we wrote earlier to\ndemonstrate:\nC:\\...\\PP4E\\System\\Streams> type writer.py\nprint(\"Help! Help! I'm being repressed!\")\nprint(42)\nC:\\...\\PP4E\\System\\Streams> type reader.py\nprint('Got this: \"%s\"' % input())\nimport sys\ndata = sys.stdin.readline()[:-1]\nprint('The meaning of life is', data, int(data) * 2)\nCode like the following can both read from and write to the reader script\u2014the pipe\nobject has two file-like objects available as attached attributes, one connecting to the\ninput stream, and one to the output (Python 2.X users might recognize these as equiv-\nalent to the tuple returned by the now-defunct os.popen2):\n>>> pipe = Popen('python reader.py', stdin=PIPE, stdout=PIPE)\n>>> pipe.stdin.write(b'Lumberjack\\n')\n11\n>>> pipe.stdin.write(b'12\\n')\n3\n>>> pipe.stdin.close()\n>>> output = pipe.stdout.read()\n>>> pipe.wait()\n0\n>>> output\nb'Got this: \"Lumberjack\"\\r\\nThe meaning of life is 12 24\\r\\n'\nAs we\u2019ll learn in Chapter 5, we have to be cautious when talking back and forth to a\nprogram like this; buffered output streams can lead to deadlock if writes and reads are\ninterleaved, and we may eventually need to consider tools like the Pexpect utility as a\nworkaround (more on this later).\nFinally, even more exotic stream control is possible\u2014the following connects two pro-\ngrams, by piping the output of one Python script into another, first with shell syntax,\nand then with the subprocess module:\nC:\\...\\PP4E\\System\\Streams> python writer.py | python reader.py\nGot this: \"Help! Help! I'm being repressed!\"\nThe meaning of life is 42 84\nC:\\...\\PP4E\\System\\Streams> python\n>>> from subprocess import Popen, PIPE\n>>> p1 = Popen('python writer.py', stdout=PIPE)\n>>> p2 = Popen('python reader.py', stdin=p1.stdout, stdout=PIPE)\n>>> output = p2.communicate()[0]\n>>> output\nb'Got this: \"Help! Help! I\\'m being repressed!\"\\r\\nThe meaning of life is 42 84\\r\\n'\n>>> p2.returncode\n0\nStandard Streams | 131We can get close to this with os.popen, but that the fact that its pipes are read or write\n(and not both) prevents us from catching the second script\u2019s output in our code:\n>>> import os\n>>> p1 = os.popen('python writer.py', 'r')\n>>> p2 = os.popen('python reader.py', 'w')\n>>> p2.write( p1.read() )\n36\n>>> X = p2.close()\nGot this: \"Help! Help! I'm being repressed!\"\nThe meaning of life is 42 84\n>>> print(X)\nNone\nFrom the broader perspective, the os.popen call and subprocess module are Python\u2019s\nportable equivalents of Unix-like shell syntax for redirecting the streams of spawned\nprograms. The Python versions also work on Windows, though, and are the most\nplatform-neutral way to launch another program from a Python script. The command-\nline strings you pass to them may vary per platform (e.g., a directory listing requires an\nls on Unix but a dir on Windows), but the call itself works on all major Python\nplatforms.\nOn Unix-like platforms, the combination of the calls os.fork, os.pipe, os.dup, and\nsome os.exec variants can also be used to start a new independent program with\nstreams connected to the parent program\u2019s streams. As such, it\u2019s yet another way to\nredirect streams and a low-level equivalent to tools such as os.popen (os.fork is available\nin Cygwin\u2019s Python on Windows).\nSince these are all more advanced parallel processing tools, though, we\u2019ll defer further\ndetails on this front until Chapter 5, especially its coverage of pipes and exit status\ncodes. And we\u2019ll resurrect subprocess again in Chapter 6, to code a regression tester\nthat intercepts all three standard streams of spawned test scripts\u2014inputs, outputs, and\nerrors.\nBut first, Chapter 4 continues our survey of Python system interfaces by exploring the\ntools available for processing files and directories. Although we\u2019ll be shifting focus\nsomewhat, we\u2019ll find that some of what we\u2019ve learned here will already begin to come\nin handy as general system-related tools. Spawning shell commands, for instance, pro-\nvides ways to inspect directories, and the file interface we will expand on in the next\nchapter is at the heart of the stream processing techniques we have studied here.\n132 | Chapter 3:\u2002Script Execution ContextPython Versus csh\nIf you are familiar with other common shell script languages, it might be useful to see\nhow Python compares. Here is a simple script in a Unix shell language called csh that\nmails all the files in the current working directory with a suffix of .py (i.e., all Python\nsource files) to a hopefully fictitious address:\n#!/bin/csh\nforeach x (*.py)\n    echo $x\n    mail eric@halfabee.com -s $x < $x\nend\nAn equivalent Python script looks similar:\n#!/usr/bin/python\nimport os, glob\nfor x in glob.glob('*.py'):\n    print(x)\n    os.system('mail eric@halfabee.com -s %s < %s' % (x, x))\nbut is slightly more verbose. Since Python, unlike csh, isn\u2019t meant just for shell scripts,\nsystem interfaces must be imported and called explicitly. And since Python isn\u2019t just a\nstring-processing language, character strings must be enclosed in quotes, as in C.\nAlthough this can add a few extra keystrokes in simple scripts like this, being a general-\npurpose language makes Python a better tool once we leave the realm of trivial pro-\ngrams. We could, for example, extend the preceding script to do things like transfer\nfiles by FTP, pop up a GUI message selector and status bar, fetch messages from an\nSQL database, and employ COM objects on Windows, all using standard Python tools.\nPython scripts also tend to be more portable to other platforms than csh. For instance,\nif we used the Python SMTP interface module to send mail instead of relying on a Unix\ncommand-line mail tool, the script would run on any machine with Python and an\nInternet link (as we\u2019ll see in Chapter 13, SMTP requires only sockets). And like C, we\ndon\u2019t need $ to evaluate variables; what else would you expect in a free language?\nStandard Streams | 133", "4": "CHAPTER 4\nFile and Directory Tools\n\u201cErase Your Hard Drive in Five Easy Steps!\u201d\nThis chapter continues our look at system interfaces in Python by focusing on file and \ndirectory-related tools. As you\u2019ll see, it\u2019s easy to process files and directory trees with \nPython\u2019s built-in and standard library support. Because files are part of the core Python \nlanguage, some of this chapter\u2019s material is a review of file basics covered in books like \nLearning Python, Fourth Edition, and we\u2019ll defer to such resources for more back-\nground details on some file-related concepts. For example, iteration, context managers, \nand the file object\u2019s support for Unicode encodings are demonstrated along the way, \nbut these topics are not repeated in full here. This chapter\u2019s goal is to tell enough of the \nfile story to get you started writing useful scripts.\nFile Tools\nExternal files are at the heart of much of what we do with system utilities. For instance, \na testing system may read its inputs from one file, store program results in another file, \nand check expected results by loading yet another file. Even user interface and Internet-\noriented programs may load binary images and audio clips from files on the underlying \ncomputer. It\u2019s a core programming concept.\nIn Python, the built-in open function is the primary tool scripts use to access the files \non the underlying computer system. Since this function is an inherent part of the Python \nlanguage, you may already be familiar with its basic workings. When called, the open\nfunction returns a new file object that is connected to the external file; the file object \nhas methods that transfer data to and from the file and perform a variety of file-related \noperations. The open function also provides a portable interface to the underlying file-\nsystem\u2014it works the same way on every platform on which Python runs.\nOther file-related modules built into Python allow us to do things such as manipulate \nlower-level descriptor-based files (os); copy, remove, and move files and collections of \nfiles (os and shutil); store data and objects in files by key (dbm and shelve); and access\n135SQL databases (sqlite3 and third-party add-ons). The last two of these categories are\nrelated to database topics, addressed in Chapter 17.\nIn this section, we\u2019ll take a brief tutorial look at the built-in file object and explore a\nhandful of more advanced file-related topics. As usual, you should consult either Py-\nthon\u2019s library manual or reference books such as Python Pocket Reference for further\ndetails and methods we don\u2019t have space to cover here. Remember, for quick interactive\nhelp, you can also run dir(file) on an open file object to see an attributes list that\nincludes methods; help(file) for general help; and help(file.read) for help on a spe-\ncific method such as read, though the file object implementation in 3.1 provides less\ninformation for help than the library manual and other resources.\nThe File Object Model in Python 3.X\nJust like the string types we noted in Chapter 2, file support in Python 3.X is a bit richer\nthan it was in the past. As we noted earlier, in Python 3.X str strings always represent\nUnicode text (ASCII or wider), and bytes and bytearray strings represent raw binary\ndata. Python 3.X draws a similar and related distinction between files containing text\nand binary data:\n\u2022 Text files contain Unicode text. In your script, text file content is always a str\nstring\u2014a sequence of characters (technically, Unicode \u201ccode points\u201d). Text files\nperform the automatic line-end translations described in this chapter by default\nand automatically apply Unicode encodings to file content: they encode to and\ndecode from raw binary bytes on transfers to and from the file, according to a\nprovided or default encoding name. Encoding is trivial for ASCII text, but may be\nsophisticated in other cases.\n\u2022 Binary files contain raw 8-bit bytes. In your script, binary file content is always a\nbyte string, usually a bytes object\u2014a sequence of small integers, which supports\nmost str operations and displays as ASCII characters whenever possible. Binary\nfiles perform no translations of data when it is transferred to and from files: no line-\nend translations or Unicode encodings are performed.\nIn practice, text files are used for all truly text-related data, and binary files store items\nlike packed binary data, images, audio files, executables, and so on. As a programmer\nyou distinguish between the two file types in the mode string argument you pass to\nopen: adding a \u201cb\u201d (e.g., 'rb', 'wb') means the file contains binary data. For coding new\nfile content, use normal strings for text (e.g., 'spam' or bytes.decode()) and byte strings\nfor binary (e.g., b'spam' or str.encode()).\nUnless your file scope is limited to ASCII text, the 3.X text/binary distinction can\nsometimes impact your code. Text files create and require str strings, and binary files\nuse byte strings; because you cannot freely mix the two string types in expressions, you\nmust choose file mode carefully. Many built-in tools we\u2019ll use in this book make the\nchoice for us; the struct and pickle modules, for instance, deal in byte strings in 3.X,\n136 | Chapter 4:\u2002File and Directory Toolsand the xml package in Unicode str. You must even be aware of the 3.X text/binary\ndistinction when using system tools like pipe descriptors and sockets, because they\ntransfer data as byte strings today (though their content can be decoded and encoded\nas Unicode text if needed).\nMoreover, because text-mode files require that content be decodable per a Unicode\nencoding scheme, you must read undecodable file content in binary mode, as byte\nstrings (or catch Unicode exceptions in try statements and skip the file altogether).\nThis may include both truly binary files as well as text files that use encodings that are\nnondefault and unknown. As we\u2019ll see later in this chapter, because str strings are\nalways Unicode in 3.X, it\u2019s sometimes also necessary to select byte string mode for the\nnames of files in directory tools such as os.listdir, glob.glob, and os.walk if they\ncannot be decoded (passing in byte strings essentially suppresses decoding).\nIn fact, we\u2019ll see examples where the Python 3.X distinction between str text and\nbytes binary pops up in tools beyond basic files throughout this book\u2014in Chapters\n5 and 12 when we explore sockets; in Chapters 6 and 11 when we\u2019ll need to ignore\nUnicode errors in file and directory searches; in Chapter 12, where we\u2019ll see how client-\nside Internet protocol modules such as FTP and email, which run atop sockets, imply\nfile modes and encoding requirements; and more.\nBut just as for string types, although we will see some of these concepts in action in this\nchapter, we\u2019re going to take much of this story as a given here. File and string objects\nare core language material and are prerequisite to this text. As mentioned earlier, be-\ncause they are addressed by a 45-page chapter in the book Learning Python, Fourth\nEdition, I won\u2019t repeat their coverage in full in this book. If you find yourself confused\nby the Unicode and binary file and string concepts in the following sections, I encourage\nyou to refer to that text or other resources for more background information in this\ndomain.\nUsing Built-in File Objects\nDespite the text/binary dichotomy in Python 3.X, files are still very straightforward to\nuse. For most purposes, in fact, the open built-in function and its files objects are all\nyou need to remember to process files in your scripts. The file object returned by\nopen has methods for reading data (read, readline, readlines); writing data (write,\nwritelines); freeing system resources (close); moving to arbitrary positions in the file\n(seek); forcing data in output buffers to be transferred to disk (flush); fetching the\nunderlying file handle (fileno); and more. Since the built-in file object is so easy to use,\nlet\u2019s jump right into a few interactive examples.\nOutput files\nTo make a new file, call open with two arguments: the external name of the file to be\ncreated and a mode string w (short for write). To store data on the file, call the file object\u2019s\nwrite method with a string containing the data to store, and then call the close method\nFile Tools | 137to close the file. File write calls return the number of characters or bytes written (which\nwe\u2019ll sometimes omit in this book to save space), and as we\u2019ll see, close calls are often\noptional, unless you need to open and read the file again during the same program or\nsession:\nC:\\temp> python\n>>> file = open('data.txt', 'w')            # open output file object: creates\n>>> file.write('Hello file world!\\n')       # writes strings verbatim\n18\n>>> file.write('Bye   file world.\\n')       # returns number chars/bytes written\n18\n>>> file.close()                            # closed on gc and exit too\nAnd that\u2019s it\u2014you\u2019ve just generated a brand-new text file on your computer, regardless\nof the computer on which you type this code:\nC:\\temp> dir data.txt /B\ndata.txt\nC:\\temp> type data.txt\nHello file world!\nBye   file world.\nThere is nothing unusual about the new file; here, I use the DOS dir and type com-\nmands to list and display the new file, but it shows up in a file explorer GUI, too.\nIn the open function call shown in the preceding example, the first argument\ncan optionally specify a complete directory path as part of the filename string. If we\npass just a simple filename without a path, the file will appear in Python\u2019s current\nworking directory. That is, it shows up in the place where the code is run. Here, the\ndirectory C:\\temp on my machine is implied by the bare filename data.txt, so this ac-\ntually creates a file at C:\\temp\\data.txt. More accurately, the filename is relative to the\ncurrent working directory if it does not include a complete absolute directory path. See\n\u201cCurrent Working Directory\u201d on page 104 (Chapter 3), for a refresher on this topic.\nAlso note that when opening in w mode, Python either creates the external file if it does\nnot yet exist or erases the file\u2019s current contents if it is already present on your machine\n(so be careful out there\u2014you\u2019ll delete whatever was in the file before).\nNotice that we added an explicit \\n end-of-line character to lines written to the\nfile; unlike the print built-in function, file object write methods write exactly what they\nare passed without adding any extra formatting. The string passed to write shows up\ncharacter for character on the external file. In text files, data written may undergo line-\nend or Unicode translations which we\u2019ll describe ahead, but these are undone when\nthe data is later read back.\nOutput files also sport a writelines method, which simply writes all of the strings in a\nlist one at a time without adding any extra formatting. For example, here is a write\nlines equivalent to the two write calls shown earlier:\nfile.writelines(['Hello file world!\\n', 'Bye   file world.\\n'])\nOpening.\nWriting.\n138 | Chapter 4:\u2002File and Directory ToolsThis call isn\u2019t as commonly used (and can be emulated with a simple for loop or other\niteration tool), but it is convenient in scripts that save output in a list to be written later.\nThe file close method used earlier finalizes file contents and frees up system\nresources. For instance, closing forces buffered output data to be flushed out to disk.\nNormally, files are automatically closed when the file object is garbage collected by the\ninterpreter (that is, when it is no longer referenced). This includes all remaining open\nfiles when the Python session or program exits. Because of that, close calls are often\noptional. In fact, it\u2019s common to see file-processing code in Python in this idiom:\nopen('somefile.txt', 'w').write(\"G'day Bruce\\n\")       # write to temporary object\nopen('somefile.txt', 'r').read()                       # read from temporary object\nSince both these expressions make a temporary file object, use it immediately, and do\nnot save a reference to it, the file object is reclaimed right after data is transferred, and\nis automatically closed in the process. There is usually no need for such code to call the\nclose method explicitly.\nIn some contexts, though, you may wish to explicitly close anyhow:\n\u2022 For one, because the Jython implementation relies on Java\u2019s garbage collector, you\ncan\u2019t always be as sure about when files will be reclaimed as you can in standard\nPython. If you run your Python code with Jython, you may need to close manually\nif many files are created in a short amount of time (e.g. in a loop), in order to avoid\nrunning out of file resources on operating systems where this matters.\n\u2022 For another, some IDEs, such as Python\u2019s standard IDLE GUI, may hold on to\nyour file objects longer than you expect (in stack tracebacks of prior errors, for\ninstance), and thus prevent them from being garbage collected as soon as you might\nexpect. If you write to an output file in IDLE, be sure to explicitly close (or flush)\nyour file if you need to reliably read it back during the same IDLE session. Other-\nwise, output buffers might not be flushed to disk and your file may be incomplete\nwhen read.\n\u2022 And while it seems very unlikely today, it\u2019s not impossible that this auto-close on\nreclaim file feature could change in future. This is technically a feature of the file\nobject\u2019s implementation, which may or may not be considered part of the language\ndefinition over time.\nFor these reasons, manual close calls are not a bad idea in nontrivial programs, even if\nthey are technically not required. Closing is a generally harmless but robust habit to \nform.\nEnsuring file closure: Exception handlers and context managers\nManual file close method calls are easy in straight-line code, but how do you ensure\nfile closure when exceptions might kick your program beyond the point where the close\ncall is coded? First of all, make sure you must\u2014files close themselves when they are\ncollected, and this will happen eventually, even when exceptions occur.\nClosing.\nFile Tools | 139If closure is required, though, there are two basic alternatives: the try statement\u2019s\nfinally clause is the most general, since it allows you to provide general exit actions\nfor any type of exceptions:\nmyfile = open(filename, 'w')\ntry:\n    ...process myfile...\nfinally:\n    myfile.close()\nIn recent Python releases, though, the with statement provides a more concise alterna-\ntive for some specific objects and exit actions, including closing files:\nwith open(filename, 'w') as myfile:\n    ...process myfile, auto-closed on statement exit...\nThis statement relies on the file object\u2019s context manager: code automatically run both\non statement entry and on statement exit regardless of exception behavior. Because the\nfile object\u2019s exit code closes the file automatically, this guarantees file closure whether\nan exception occurs during the statement or not.\nThe with statement is notably shorter (3 lines) than the try/finally alternative, but it\u2019s\nalso less general\u2014with applies only to objects that support the context manager pro-\ntocol, whereas try/finally allows arbitrary exit actions for arbitrary exception con-\ntexts. While some other object types have context managers, too (e.g., thread locks),\nwith is limited in scope. In fact, if you want to remember just one exit actions option,\ntry/finally is the most inclusive. Still, with yields less code for files that must be closed\nand can serve well in such specific roles. It can even save a line of code when no\nexceptions are expected (albeit at the expense of further nesting and indenting file\nprocessing logic):\nmyfile = open(filename, 'w')               # traditional form\n...process myfile...\nmyfile.close()\nwith open(filename) as myfile:             # context manager form\n    ...process myfile...\nIn Python 3.1 and later, this statement can also specify multiple (a.k.a. nested) context\nmanagers\u2014any number of context manager items may be separated by commas, and\nmultiple items work the same as nested with statements. In general terms, the 3.1 and\nlater code:\nwith A() as a, B() as b:\n    ...statements...\nRuns the same as the following, which works in 3.1, 3.0, and 2.6:\nwith A() as a:\n    with B() as b:\n        ...statements...\n140 | Chapter 4:\u2002File and Directory ToolsFor example, when the with statement block exits in the following, both files\u2019 exit\nactions are automatically run to close the files, regardless of exception outcomes:\nwith open('data') as fin, open('results', 'w') as fout:\n    for line in fin:\n        fout.write(transform(line))\nContext manager\u2013dependent code like this seems to have become more common in\nrecent years, but this is likely at least in part because newcomers are accustomed to\nlanguages that require manual close calls in all cases. In most contexts there is no need\nto wrap all your Python file-processing code in with statements\u2014the files object\u2019s auto-\nclose-on-collection behavior often suffices, and manual close calls are enough for many\nother scripts. You should use the with or try options outlined here only if you must\nclose, and only in the presence of potential exceptions. Since standard C Python auto-\nmatically closes files on collection, though, neither option is required in many (and\nperhaps most) scripts.\nInput files\nReading data from external files is just as easy as writing, but there are more methods\nthat let us load data in a variety of modes. Input text files are opened with either a mode\nflag of r (for \u201cread\u201d) or no mode flag at all\u2014it defaults to r if omitted, and it commonly\nis. Once opened, we can read the lines of a text file with the readlines method:\nC:\\temp> python\n>>> file = open('data.txt')                  # open input file object: 'r' default\n>>> lines = file.readlines()                 # read into line string list\n>>> for line in lines:                       # BUT use file line iterator! (ahead)\n...     print(line, end='')                  # lines have a '\\n' at end\n...\nHello file world!\nBye   file world.\nThe readlines method loads the entire contents of the file into memory and gives it to\nour scripts as a list of line strings that we can step through in a loop. In fact, there are\nmany ways to read an input file:\nfile.read()\nReturns a string containing all the characters (or bytes) stored in the file\nfile.read(N)\nReturns a string containing the next N characters (or bytes) from the file\nfile.readline()\nReads through the next \\n and returns a line string\nfile.readlines()\nReads the entire file and returns a list of line strings\nFile Tools | 141Let\u2019s run these method calls to read files, lines, and characters from a text file\u2014the\nseek(0) call is used here before each test to rewind the file to its beginning (more on\nthis call in a moment):\n>>> file.seek(0)                               # go back to the front of file\n>>> file.read()                                # read entire file into string\n'Hello file world!\\nBye   file world.\\n'\n>>> file.seek(0)                               # read entire file into lines list\n>>> file.readlines()\n['Hello file world!\\n', 'Bye   file world.\\n']\n>>> file.seek(0)\n>>> file.readline()                            # read one line at a time\n'Hello file world!\\n'\n>>> file.readline()\n'Bye   file world.\\n'\n>>> file.readline()                            # empty string at end-of-file\n''\n>>> file.seek(0)                               # read N (or remaining) chars/bytes\n>>> file.read(1), file.read(8)                 # empty string at end-of-file\n('H', 'ello fil')\nAll of these input methods let us be specific about how much to fetch. Here are a few\nrules of thumb about which to choose:\n\u2022 read() and readlines() load the entire file into memory all at once. That makes\nthem handy for grabbing a file\u2019s contents with as little code as possible. It also\nmakes them generally fast, but costly in terms of memory for huge files\u2014loading\na multigigabyte file into memory is not generally a good thing to do (and might not\nbe possible at all on a given computer).\n\u2022 On the other hand, because the readline() and read(N) calls fetch just part of the\nfile (the next line or N-character-or-byte block), they are safer for potentially big\nfiles but a bit less convenient and sometimes slower. Both return an empty string\nwhen they reach end-of-file. If speed matters and your files aren\u2019t huge, read or\nreadlines may be a generally better choice.\n\u2022 See also the discussion of the newer file iterators in the next section. As we\u2019ll see,\niterators combine the convenience of readlines() with the space efficiency of read\nline() and are the preferred way to read text files by lines today.\nThe seek(0) call used repeatedly here means \u201cgo back to the start of the file.\u201d In our\nexample, it is an alternative to reopening the file each time. In files, all read and write\noperations take place at the current position; files normally start at offset 0 when opened\nand advance as data is transferred. The seek call simply lets us move to a new position\nfor the next transfer operation. More on this method later when we explore random\naccess files.\n142 | Chapter 4:\u2002File and Directory ToolsReading lines with file iterators\nIn older versions of Python, the traditional way to read a file line by line in a for loop\nwas to read the file into a list that could be stepped through as usual:\n>>> file = open('data.txt')\n>>> for line in file.readlines():    # DON'T DO THIS ANYMORE!\n...     print(line, end='')\nIf you\u2019ve already studied the core language using a first book like Learning Python, you\nmay already know that this coding pattern is actually more work than is needed today\u2014\nboth for you and your computer\u2019s memory. In recent Pythons, the file object includes\nan iterator which is smart enough to grab just one line per request in all iteration con-\ntexts, including for loops and list comprehensions. The practical benefit of this exten-\nsion is that you no longer need to call readlines in a for loop to scan line by line\u2014the\niterator reads lines on request automatically:\n>>> file = open('data.txt')\n>>> for line in file:                  # no need to call readlines\n...     print(line, end='')            # iterator reads next line each time\n...\nHello file world!\nBye   file world.\nBetter still, you can open the file in the loop statement itself, as a temporary which will\nbe automatically closed on garbage collection when the loop ends (that\u2019s normally the\nfile\u2019s sole reference):\n>>> for line in open('data.txt'):      # even shorter: temporary file object\n...     print(line, end='')            # auto-closed when garbage collected\n...\nHello file world!\nBye   file world.\nMoreover, this file line-iterator form does not load the entire file into a line\u2019s list all at\nonce, so it will be more space efficient for large text files. Because of that, this is the\nprescribed way to read line by line today. If you want to see what really happens inside\nthe for loop, you can use the iterator manually; it\u2019s just a __next__ method (run by the\nnext built-in function), which is similar to calling the readline method each time\nthrough, except that read methods return an empty string at end-of-file (EOF) and the\niterator raises an exception to end the iteration:\n>>> file = open('data.txt')      # read methods: empty at EOF\n>>> file.readline()\n'Hello file world!\\n'\n>>> file.readline()\n'Bye   file world.\\n'\n>>> file.readline()\n''\n>>> file = open('data.txt')      # iterators: exception at EOF\n>>> file.__next__()              # no need to call iter(file) first,\n'Hello file world!\\n'            # since files are their own iterator\nFile Tools | 143>>> file.__next__()\n'Bye   file world.\\n'\n>>> file.__next__()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nStopIteration\nInterestingly, iterators are automatically used in all iteration contexts, including the\nlist constructor call, list comprehension expressions, map calls, and in membership\nchecks:\n>>> open('data.txt').readlines()                             # always read lines\n['Hello file world!\\n', 'Bye   file world.\\n']\n>>> list(open('data.txt'))                                   # force line iteration\n['Hello file world!\\n', 'Bye   file world.\\n']\n>>> lines = [line.rstrip() for line in open('data.txt')]     # comprehension\n>>> lines\n['Hello file world!', 'Bye   file world.']\n>>> lines = [line.upper() for line in open('data.txt')]      # arbitrary actions\n>>> lines\n['HELLO FILE WORLD!\\n', 'BYE   FILE WORLD.\\n']\n>>> list(map(str.split, open('data.txt')))                   # apply a function\n[['Hello', 'file', 'world!'], ['Bye', 'file', 'world.']]\n>>> line = 'Hello file world!\\n'\n>>> line in open('data.txt')                                 # line membership\nTrue\nIterators may seem somewhat implicit at first glance, but they\u2019re representative of the\nmany ways that Python makes developers\u2019 lives easier over time.\nOther open options\nBesides the w and (default) r file open modes, most platforms support an a mode string,\nmeaning \u201cappend.\u201d In this output mode, write methods add data to the end of the file,\nand the open call will not erase the current contents of the file:\n>>> file = open('data.txt', 'a')          # open in append mode: doesn't erase\n>>> file.write('The Life of Brian')       # added at end of existing data\n>>> file.close()\n>>>\n>>> open('data.txt').read()               # open and read entire file\n'Hello file world!\\nBye   file world.\\nThe Life of Brian'\nIn fact, although most files are opened using the sorts of calls we just ran, open actually\nsupports additional arguments for more specific processing needs, the first three of\nwhich are the most commonly used\u2014the filename, the open mode, and a buffering\nspecification. All but the first of these are optional: if omitted, the open mode argument\n144 | Chapter 4:\u2002File and Directory Toolsdefaults to r (input), and the buffering policy is to enable full buffering. For special\nneeds, here are a few things you should know about these three open arguments:\nFilename\nAs mentioned earlier, filenames can include an explicit directory path to refer to\nfiles in arbitrary places on your computer; if they do not, they are taken to be names\nrelative to the current working directory (described in the prior chapter). In general,\nmost filename forms you can type in your system shell will work in an open call.\nFor instance, a relative filename argument r'..\\temp\\spam.txt' on Windows\nmeans spam.txt in the temp subdirectory of the current working directory\u2019s\nparent\u2014up one, and down to directory temp.\nOpen mode\nThe open function accepts other modes, too, some of which we\u2019ll see at work later\nin this chapter: r+, w+, and a+ to open for reads and writes, and any mode string\nwith a b to designate binary mode. For instance, mode r+ means both reads and\nwrites are allowed on an existing file; w+ allows reads and writes but creates the file\nanew, erasing any prior content; rb and wb read and write data in binary mode\nwithout any translations; and wb+ and r+b both combine binary mode and input\nplus output. In general, the mode string defaults to r for read but can be w for write\nand a for append, and you may add a + for update, as well as a b or t for binary or\ntext mode; order is largely irrelevant.\nAs we\u2019ll see later in this chapter, the + modes are often used in conjunction with\nthe file object\u2019s seek method to achieve random read/write access. Regardless of\nmode, file contents are always strings in Python programs\u2014read methods return\na string, and we pass a string to write methods. As also described later, though, the\nmode string implies which type of string is used: str for text mode or bytes and\nother byte string types for binary mode.\nBuffering policy\nThe open call also takes an optional third buffering policy argument which lets you\ncontrol buffering for the file\u2014the way that data is queued up before being trans-\nferred, to boost performance. If passed, 0 means file operations are unbuffered\n(data is transferred immediately, but allowed in binary modes only), 1 means they\nare line buffered, and any other positive value means to use a full buffering (which\nis the default, if no buffering argument is passed).\nAs usual, Python\u2019s library manual and reference texts have the full story on additional\nopen arguments beyond these three. For instance, the open call supports additional\narguments related to the end-of-line mapping behavior and the automatic Unicode\nencoding of content performed for text-mode files. Since we\u2019ll discuss both of these\nconcepts in the next section, let\u2019s move ahead.\nFile Tools | 145Binary and Text Files\nAll of the preceding examples process simple text files, but Python scripts can also open\nand process files containing binary data\u2014JPEG images, audio clips, packed binary data\nproduced by FORTRAN and C programs, encoded text, and anything else that can be\nstored in files as bytes. The primary difference in terms of your code is the mode argu-\nment passed to the built-in open function:\n>>> file = open('data.txt', 'wb')      # open binary output file\n>>> file = open('data.txt', 'rb')      # open binary input file\nOnce you\u2019ve opened binary files in this way, you may read and write their contents\nusing the same methods just illustrated: read, write, and so on. The readline and\nreadlines methods as well as the file\u2019s line iterator still work here for text files opened\nin binary mode, but they don\u2019t make sense for truly binary data that isn\u2019t line oriented\n(end-of-line bytes are meaningless, if they appear at all).\nIn all cases, data transferred between files and your programs is represented as Python\nstrings within scripts, even if it is binary data. For binary mode files, though, file content\nis represented as byte strings. Continuing with our text file from preceding examples:\n>>> open('data.txt').read()                                   # text mode: str\n'Hello file world!\\nBye   file world.\\nThe Life of Brian'\n>>> open('data.txt', 'rb').read()                             # binary mode: bytes\nb'Hello file world!\\r\\nBye   file world.\\r\\nThe Life of Brian'\n>>> file = open('data.txt', 'rb')\n>>> for line in file: print(line)\n...\nb'Hello file world!\\r\\n'\nb'Bye   file world.\\r\\n'\nb'The Life of Brian'\nThis occurs because Python 3.X treats text-mode files as Unicode, and automatically\ndecodes content on input and encodes it on output. Binary mode files instead give us\naccess to file content as raw byte strings, with no translation of content\u2014they reflect\nexactly what is stored on the file. Because str strings are always Unicode text in 3.X,\nthe special bytes string is required to represent binary data as a sequence of byte-size\nintegers which may contain any 8-bit value. Because normal and byte strings have al-\nmost identical operation sets, many programs can largely take this on faith; but keep\nin mind that you really must open truly binary data in binary mode for input, because\nit will not generally be decodable as Unicode text.\nSimilarly, you must also supply byte strings for binary mode output\u2014normal strings\nare not raw binary data, but are decoded Unicode characters (a.k.a. code points) which\nare encoded to binary on text-mode output:\n>>> open('data.bin', 'wb').write(b'Spam\\n')\n5\n>>> open('data.bin', 'rb').read()\n146 | Chapter 4:\u2002File and Directory Toolsb'Spam\\n'\n>>> open('data.bin', 'wb').write('spam\\n')\nTypeError: must be bytes or buffer, not str\nBut notice that this file\u2019s line ends with just \\n, instead of the Windows \\r\\n that showed\nup in the preceding example for the text file in binary mode. Strictly speaking, binary\nmode disables Unicode encoding translation, but it also prevents the automatic end-\nof-line character translation performed by text-mode files by default. Before we can\nunderstand this fully, though, we need to study the two main ways in which text files\ndiffer from binary.\nUnicode encodings for text files\nAs mentioned earlier, text-mode file objects always translate data according to a default\nor provided Unicode encoding type, when the data is transferred to and from external\nfile. Their content is encoded on files, but decoded in memory. Binary mode files don\u2019t\nperform any such translation, which is what we want for truly binary data. For instance,\nconsider the following string, which embeds a Unicode character whose binary value\nis outside the normal 7-bit range of the ASCII encoding standard:\n>>> data = 'sp\\xe4m'\n>>> data\n'sp\u00e4m'\n>>> 0xe4, bin(0xe4), chr(0xe4)\n(228, '0b11100100', '\u00e4')\nIt\u2019s possible to manually encode this string according to a variety of Unicode encoding\ntypes\u2014its raw binary byte string form is different under some encodings:\n>>> data.encode('latin1')                  # 8-bit characters: ascii + extras\nb'sp\\xe4m'\n>>> data.encode('utf8')                    # 2 bytes for special characters only\nb'sp\\xc3\\xa4m'\n>>> data.encode('ascii')                   # does not encode per ascii\nUnicodeEncodeError: 'ascii' codec can't encode character '\\xe4' in position 2:\nordinal not in range(128)\nPython displays printable characters in these strings normally, but nonprintable bytes\nshow as \\xNN hexadecimal escapes which become more prevalent under more sophis-\nticated encoding schemes (cp500 in the following is an EBCDIC encoding):\n>>> data.encode('utf16')                   # 2 bytes per character plus preamble\nb'\\xff\\xfes\\x00p\\x00\\xe4\\x00m\\x00'\n>>> data.encode('cp500')                   # an ebcdic encoding: very different\nb'\\xa2\\x97C\\x94'\nThe encoded results here reflect the string\u2019s raw binary form when stored in files. Man-\nual encoding is usually unnecessary, though, because text files handle encodings\nautomatically on data transfers\u2014reads decode and writes encode, according\nFile Tools | 147to the encoding name passed in (or a default for the underlying platform: see\nsys.getdefaultencoding). Continuing our interactive session:\n>>> open('data.txt', 'w', encoding='latin1').write(data)\n4\n>>> open('data.txt', 'r', encoding='latin1').read()\n'sp\u00e4m'\n>>> open('data.txt', 'rb').read()\nb'sp\\xe4m'\nIf we open in binary mode, though, no encoding translation occurs\u2014the last command\nin the preceding example shows us what\u2019s actually stored on the file. To see how file\ncontent differs for other encodings, let\u2019s save the same string again:\n>>> open('data.txt', 'w', encoding='utf8').write(data)        # encode data per utf8\n4\n>>> open('data.txt', 'r', encoding='utf8').read()             # decode: undo encoding\n'sp\u00e4m'\n>>> open('data.txt', 'rb').read()                             # no data translations\nb'sp\\xc3\\xa4m'\nThis time, raw file content is different, but text mode\u2019s auto-decoding makes the string\nthe same by the time it\u2019s read back by our script. Really, encodings pertain only to\nstrings while they are in files; once they are loaded into memory, strings are simply\nsequences of Unicode characters (\u201ccode points\u201d). This translation step is what we want\nfor text files, but not for binary. Because binary modes skip the translation, you\u2019ll want\nto use them for truly binary data. If fact, you usually must\u2014trying to write unencodable\ndata and attempting to read undecodable data is an error:\n>>> open('data.txt', 'w', encoding='ascii').write(data)\nUnicodeEncodeError: 'ascii' codec can't encode character '\\xe4' in position 2:\nordinal not in range(128)\n>>> open(r'C:\\Python31\\python.exe', 'r').read()\nUnicodeDecodeError: 'charmap' codec can't decode byte 0x90 in position 2:\ncharacter maps to <undefined>\nBinary mode is also a last resort for reading text files, if they cannot be decoded per the\nunderlying platform\u2019s default, and the encoding type is unknown\u2014the following re-\ncreates the original strings if encoding type is known, but fails if it is not known unless\nbinary mode is used (such failure may occur either on inputting the data or printing it,\nbut it fails nevertheless):\n>>> open('data.txt', 'w', encoding='cp500').writelines(['spam\\n', 'ham\\n'])\n>>> open('data.txt', 'r', encoding='cp500').readlines()\n['spam\\n', 'ham\\n']\n>>> open('data.txt', 'r').readlines()\nUnicodeDecodeError: 'charmap' codec can't decode byte 0x81 in position 2:\ncharacter maps to <undefined>\n>>> open('data.txt', 'rb').readlines()\n[b'\\xa2\\x97\\x81\\x94\\r%\\x88\\x81\\x94\\r%']\n148 | Chapter 4:\u2002File and Directory Tools>>> open('data.txt', 'rb').read()\nb'\\xa2\\x97\\x81\\x94\\r%\\x88\\x81\\x94\\r%'\nIf all your text is ASCII you generally can ignore encoding altogether; data in files maps\ndirectly to characters in strings, because ASCII is a subset of most platforms\u2019 default\nencodings. If you must process files created with other encodings, and possibly on\ndifferent platforms (obtained from the Web, for instance), binary mode may be required\nif encoding type is unknown. Keep in mind, however, that text in still-encoded binary\nform might not work as you expect: because it is encoded per a given encoding scheme,\nit might not accurately compare or combine with text encoded in other schemes.\nAgain, see other resources for more on the Unicode story. We\u2019ll revisit the Unicode\nstory at various points in this book, especially in Chapter 9, to see how it relates to the\ntkinter Text widget, and in Part IV, covering Internet programming, to learn what it\nmeans for data shipped over networks by protocols such as FTP, email, and the Web\nat large. Text files have another feature, though, which is similarly a nonfeature for\nbinary data: line-end translations, the topic of the next section.\nEnd-of-line translations for text files\nFor historical reasons, the end of a line of text in a file is represented by different char-\nacters on different platforms. It\u2019s a single \\n character on Unix-like platforms, but the\ntwo-character sequence \\r\\n on Windows. That\u2019s why files moved between Linux and\nWindows may look odd in your text editor after transfer\u2014they may still be stored using\nthe original platform\u2019s end-of-line convention.\nFor example, most Windows editors handle text in Unix format, but Notepad has been\na notable exception\u2014text files copied from Unix or Linux may look like one long line\nwhen viewed in Notepad, with strange characters inside (\\n). Similarly, transferring a\nfile from Windows to Unix in binary mode retains the \\r characters (which often appear\nas ^M in text editors).\nPython scripts that process text files don\u2019t normally have to care, because the files object\nautomatically maps the DOS \\r\\n sequence to a single \\n. It works like this by default\u2014\nwhen scripts are run on Windows:\n\u2022 For files opened in text mode, \\r\\n is translated to \\n when input.\n\u2022 For files opened in text mode, \\n is translated to \\r\\n when output.\n\u2022 For files opened in binary mode, no translation occurs on input or output.\nOn Unix-like platforms, no translations occur, because \\n is used in files. You should\nkeep in mind two important consequences of these rules. First, the end-of-line character\nfor text-mode files is almost always represented as a single \\n within Python scripts,\nregardless of how it is stored in external files on the underlying platform. By mapping\nto and from \\n on input and output, Python hides the platform-specific difference.\nThe second consequence of the mapping is subtler: when processing binary files, binary\nopen modes (e.g, rb, wb) effectively turn off line-end translations. If they did not, the\nFile Tools | 149translations listed previously could very well corrupt data as it is input or output\u2014a\nrandom \\r in data might be dropped on input, or added for a \\n in the data on output.\nThe net effect is that your binary data would be trashed when read and written\u2014\nprobably not quite what you want for your audio files and images!\nThis issue has become almost secondary in Python 3.X, because we generally cannot\nuse binary data with text-mode files anyhow\u2014because text-mode files automatically\napply Unicode encodings to content, transfers will generally fail when the data cannot\nbe decoded on input or encoded on output. Using binary mode avoids Unicode errors,\nand automatically disables line-end translations as well (Unicode error can be caught\nin try statements as well). Still, the fact that binary mode prevents end-of-line transla-\ntions to protect file content is best noted as a separate feature, especially if you work\nin an ASCII-only world where Unicode encoding issues are irrelevant.\nHere\u2019s the end-of-line translation at work in Python 3.1 on Windows\u2014text mode\ntranslates to and from the platform-specific line-end sequence so our scripts are\nportable:\n>>> open('temp.txt', 'w').write('shrubbery\\n')   # text output mode: \\n -> \\r\\n\n10\n>>> open('temp.txt', 'rb').read()                # binary input: actual file bytes\nb'shrubbery\\r\\n'\n>>> open('temp.txt', 'r').read()                 # test input mode: \\r\\n -> \\n\n'shrubbery\\n'\nBy contrast, writing data in binary mode prevents all translations as expected, even if\nthe data happens to contain bytes that are part of line-ends in text mode (byte strings\nprint their characters as ASCII if printable, else as hexadecimal escapes):\n>>> data = b'a\\0b\\rc\\r\\nd'                       # 4 escape code bytes, 4 normal\n>>> len(data)\n8\n>>> open('temp.bin', 'wb').write(data)           # write binary data to file as is\n8\n>>> open('temp.bin', 'rb').read()                # read as binary: no translation\nb'a\\x00b\\rc\\r\\nd'\nBut reading binary data in text mode, whether accidental or not, can corrupt the data\nwhen transferred because of line-end translations (assuming it passes as decodable at\nall; ASCII bytes like these do on this Windows platform):\n>>> open('temp.bin', 'r').read()                 # text mode read: botches \\r !\n'a\\x00b\\nc\\nd'\nSimilarly, writing binary data in text mode can have as the same effect\u2014line-end bytes\nmay be changed or inserted (again, assuming the data is encodable per the platform\u2019s\ndefault):\n>>> open('temp.bin', 'w').write(data)            # must pass str for text mode\nTypeError: must be str, not bytes                # use bytes.decode() for to-str\n>>> data.decode()\n'a\\x00b\\rc\\r\\nd'\n150 | Chapter 4:\u2002File and Directory Tools>>> open('temp.bin', 'w').write(data.decode())\n8\n>>> open('temp.bin', 'rb').read()                # text mode write: added \\r !\nb'a\\x00b\\rc\\r\\r\\nd'\n>>> open('temp.bin', 'r').read()                 # again drops, alters \\r on input\n'a\\x00b\\nc\\n\\nd'\nThe short story to remember here is that you should generally use \\n to refer to end-\nline in all your text file content, and you should always open binary data in binary file\nmodes to suppress both end-of-line translations and any Unicode encodings. A file\u2019s\ncontent generally determines its open mode, and file open modes usually process file\ncontent exactly as we want.\nKeep in mind, though, that you might also need to use binary file modes for text in\nspecial contexts. For instance, in Chapter 6\u2019s examples, we\u2019ll sometimes open text files\nin binary mode to avoid possible Unicode decoding errors, for files generated on arbi-\ntrary platforms that may have been encoded in arbitrary ways. Doing so avoids encod-\ning errors, but also can mean that some text might not work as expected\u2014searches\nmight not always be accurate when applied to such raw text, since the search key must\nbe in bytes string formatted and encoded according to a specific and possibly incom-\npatible encoding scheme.\nIn Chapter 11\u2019s PyEdit, we\u2019ll also need to catch Unicode exceptions in a \u201cgrep\u201d direc-\ntory file search utility, and we\u2019ll go further to allow Unicode encodings to be specified\nfor file content across entire trees. Moreover, a script that attempts to translate between\ndifferent platforms\u2019 end-of-line character conventions explicitly may need to read text\nin binary mode to retain the original line-end representation truly present in the file; in\ntext mode, they would already be translated to \\n by the time they reached the script.\nIt\u2019s also possible to disable or further tailor end-of-line translations in text mode with\nadditional open arguments we will finesse here. See the newline argument in open ref-\nerence documentation for details; in short, passing an empty string to this argument\nalso prevents line-end translation but retains other text-mode behavior. For this chap-\nter, let\u2019s turn next to two common use cases for binary data files: packed binary data\nand random access.\nParsing packed binary data with the struct module\nBy using the letter b in the open call, you can open binary datafiles in a platform-neutral\nway and read and write their content with normal file object methods. But how do you\nprocess binary data once it has been read? It will be returned to your script as a simple\nstring of bytes, most of which are probably not printable characters.\nIf you just need to pass binary data along to another file or program, your work is\ndone\u2014for instance, simply pass the byte string to another file opened in binary mode.\nAnd if you just need to extract a number of bytes from a specific position, string slicing\nwill do the job; you can even follow up with bitwise operations if you need to. To get\nFile Tools | 151at the contents of binary data in a structured way, though, as well as to construct its\ncontents, the standard library struct module is a more powerful alternative.\nThe struct module provides calls to pack and unpack binary data, as though the data\nwas laid out in a C-language struct declaration. It is also capable of composing and\ndecomposing using any endian-ness you desire (endian-ness determines whether the\nmost significant bits of binary numbers are on the left or right side). Building a binary\ndatafile, for instance, is straightforward\u2014pack Python values into a byte string and\nwrite them to a file. The format string here in the pack call means big-endian (>), with\nan integer, four-character string, half integer, and floating-point number:\n>>> import struct\n>>> data = struct.pack('>i4shf', 2, 'spam', 3, 1.234)\n>>> data\nb'\\x00\\x00\\x00\\x02spam\\x00\\x03?\\x9d\\xf3\\xb6'\n>>> file = open('data.bin', 'wb')\n>>> file.write(data)\n14\n>>> file.close()\nNotice how the struct module returns a bytes string: we\u2019re in the realm of binary data\nhere, not text, and must use binary mode files to store. As usual, Python displays most\nof the packed binary data\u2019s bytes here with \\xNN hexadecimal escape sequences, because\nthe bytes are not printable characters. To parse data like that which we just produced,\nread it off the file and pass it to the struct module with the same format string\u2014you\nget back a tuple containing the values parsed out of the string and converted to Python\nobjects:\n>>> import struct\n>>> file   = open('data.bin', 'rb')\n>>> bytes  = file.read()\n>>> values = struct.unpack('>i4shf', data)\n>>> values\n(2, b'spam', 3, 1.2339999675750732)\nParsed-out strings are byte strings again, and we can apply string and bitwise operations\nto probe deeper:\n>>> bin(values[0] | 0b1)                            # accessing bits and bytes\n'0b11'\n>>> values[1], list(values[1]), values[1][0]\n(b'spam', [115, 112, 97, 109], 115)\nAlso note that slicing comes in handy in this domain; to grab just the four-character\nstring in the middle of the packed binary data we just read, we can simply slice it out.\nNumeric values could similarly be sliced out and then passed to struct.unpack for\nconversion:\n>>> bytes\nb'\\x00\\x00\\x00\\x02spam\\x00\\x03?\\x9d\\xf3\\xb6'\n>>> bytes[4:8]\nb'spam'\n152 | Chapter 4:\u2002File and Directory Tools>>> number = bytes[8:10]\n>>> number\nb'\\x00\\x03'\n>>> struct.unpack('>h', number)\n(3,)\nPacked binary data crops up in many contexts, including some networking tasks, and\nin data produced by other programming languages. Because it\u2019s not part of every pro-\ngramming job\u2019s description, though, we\u2019ll defer to the struct module\u2019s entry in the\nPython library manual for more details.\nRandom access files\nBinary files also typically see action in random access processing. Earlier, we mentioned\nthat adding a + to the open mode string allows a file to be both read and written. This\nmode is typically used in conjunction with the file object\u2019s seek method to support\nrandom read/write access. Such flexible file processing modes allow us to read bytes\nfrom one location, write to another, and so on. When scripts combine this with binary\nfile modes, they may fetch and update arbitrary bytes within a file.\nWe used seek earlier to rewind files instead of closing and reopening. As mentioned,\nread and write operations always take place at the current position in the file; files\nnormally start at offset 0 when opened and advance as data is transferred. The seek call\nlets us move to a new position for the next transfer operation by passing in a byte offset.\nPython\u2019s seek method also accepts an optional second argument that has one of three\nvalues\u20140 for absolute file positioning (the default); 1 to seek relative to the current\nposition; and 2 to seek relative to the file\u2019s end. That\u2019s why passing just an offset of 0\nto seek is roughly a file rewind operation: it repositions the file to its absolute start. In\ngeneral, seek supports random access on a byte-offset basis. Seeking to a multiple of a\nrecord\u2019s size in a binary file, for instance, allows us to fetch a record by its relative\nposition.\nAlthough you can use seek without + modes in open (e.g., to just read from random\nlocations), it\u2019s most flexible when combined with input/output files. And while you\ncan perform random access in text mode, too, the fact that text modes perform Unicode\nencodings and line-end translations make them difficult to use when absolute byte\noffsets and lengths are required for seeks and reads\u2014your data may look very different\nwhen stored in files. Text mode may also make your data nonportable to platforms\nwith different default encodings, unless you\u2019re willing to always specify an explicit\nencoding for opens. Except for simple unencoded ASCII text without line-ends, seek\ntends to works best with binary mode files.\nTo demonstrate, let\u2019s create a file in w+b mode (equivalent to wb+) and write some data\nto it; this mode allows us to both read and write, but initializes the file to be empty if\nit\u2019s already present (all w modes do). After writing some data, we seek back to file start\nto read its content (some integer return values are omitted in this example again for\nbrevity):\nFile Tools | 153>>> records = [bytes([char] * 8) for char in b'spam']\n>>> records\n[b'ssssssss', b'pppppppp', b'aaaaaaaa', b'mmmmmmmm']\n>>> file = open('random.bin', 'w+b')\n>>> for rec in records:                                   # write four records\n...     size = file.write(rec)                            # bytes for binary mode\n...\n>>> file.flush()\n>>> pos = file.seek(0)                                    # read entire file\n>>> print(file.read())\nb'ssssssssppppppppaaaaaaaammmmmmmm'\nNow, let\u2019s reopen our file in r+b mode; this mode allows both reads and writes again,\nbut does not initialize the file to be empty. This time, we seek and read in multiples of\nthe size of data items (\u201crecords\u201d) stored, to both fetch and update them at random:\nc:\\temp> python\n>>> file = open('random.bin', 'r+b')\n>>> print(file.read())                           # read entire file\nb'ssssssssppppppppaaaaaaaammmmmmmm'\n>>> record = b'X' * 8\n>>> file.seek(0)                                 # update first record\n>>> file.write(record)\n>>> file.seek(len(record) * 2)                   # update third record\n>>> file.write(b'Y' * 8)\n>>> file.seek(8)\n>>> file.read(len(record))                       # fetch second record\nb'pppppppp'\n>>> file.read(len(record))                       # fetch next (third) record\nb'YYYYYYYY'\n>>> file.seek(0)                                 # read entire file\n>>> file.read()\nb'XXXXXXXXppppppppYYYYYYYYmmmmmmmm'\nc:\\temp> type random.bin                         # the view outside Python\nXXXXXXXXppppppppYYYYYYYYmmmmmmmm\nFinally, keep in mind that seek can be used to achieve random access, even if it\u2019s just\nfor input. The following seeks in multiples of record size to read (but not write) fixed-\nlength records at random. Notice that it also uses r text mode: since this data is simple\nASCII text bytes and has no line-ends, text and binary modes work the same on this\nplatform:\nc:\\temp> python\n>>> file = open('random.bin', 'r')        # text mode ok if no encoding/endlines\n>>> reclen = 8\n>>> file.seek(reclen * 3)                 # fetch record 4\n>>> file.read(reclen)\n'mmmmmmmm'\n>>> file.seek(reclen * 1)                 # fetch record 2\n>>> file.read(reclen)\n154 | Chapter 4:\u2002File and Directory Tools'pppppppp'\n>>> file = open('random.bin', 'rb')       # binary mode works the same here\n>>> file.seek(reclen * 2)                 # fetch record 3\n>>> file.read(reclen)                     # returns byte strings\nb'YYYYYYYY'\nBut unless your file\u2019s content is always a simple unencoded text form like ASCII and\nhas no translated line-ends, text mode should not generally be used if you are going to\nseek\u2014line-ends may be translated on Windows and Unicode encodings may make\narbitrary transformations, both of which can make absolute seek offsets difficult to use.\nIn the following, for example, the positions of characters after the first non-ASCII no\nlonger match between the string in Python and its encoded representation on the file:\n>>> data = 'sp\\xe4m'                                 # data to your script\n>>> data, len(data)                                  # 4 unicode chars, 1 nonascii\n('sp\u00e4m', 4)\n>>> data.encode('utf8'), len(data.encode('utf8'))    # bytes written to file\n(b'sp\\xc3\\xa4m', 5)\n>>> f = open('test', mode='w+', encoding='utf8')     # use text mode, encoded\n>>> f.write(data)\n>>> f.flush()\n>>> f.seek(0); f.read(1)                             # ascii bytes work\n's'\n>>> f.seek(2); f.read(1)                             # as does 2-byte nonascii\n'\u00e4'\n>>> data[3]                                          # but offset 3 is not 'm' !\n'm'\n>>> f.seek(3); f.read(1)\nUnicodeDecodeError: 'utf8' codec can't decode byte 0xa4 in position 0:\nunexpected code byte\nAs you can see, Python\u2019s file modes provide flexible file processing for programs that\nrequire it. In fact, the os module offers even more file processing options, as the next\nsection describes.\nLower-Level File Tools in the os Module\nThe os module contains an additional set of file-processing functions that are distinct\nfrom the built-in file object tools demonstrated in previous examples. For instance, here\nis a partial list of os file-related calls:\nos.open( path, flags, mode )\nOpens a file and returns its descriptor\nos.read( descriptor, N )\nReads at most N bytes and returns a byte string\nos.write( descriptor, string )\nWrites bytes in byte string string to the file\nFile Tools | 155os.lseek( descriptor, position , how )\nMoves to position in the file\nTechnically, os calls process files by their descriptors, which are integer codes or \u201chan-\ndles\u201d that identify files in the operating system. Descriptor-based files deal in raw bytes,\nand have no notion of the line-end or Unicode translations for text that we studied in\nthe prior section. In fact, apart from extras like buffering, descriptor-based files gener-\nally correspond to binary mode file objects, and we similarly read and write bytes\nstrings, not str strings. However, because the descriptor-based file tools in os are lower\nlevel and more complex than the built-in file objects created with the built-in open\nfunction, you should generally use the latter for all but very special file-processing\nneeds.*\nUsing os.open files\nTo give you the general flavor of this tool set, though, let\u2019s run a few interactive ex-\nperiments. Although built-in file objects and os module descriptor files are processed\nwith distinct tool sets, they are in fact related\u2014the file system used by file objects simply\nadds a layer of logic on top of descriptor-based files.\nIn fact, the fileno file object method returns the integer descriptor associated with a\nbuilt-in file object. For instance, the standard stream file objects have descriptors 0, 1,\nand 2; calling the os.write function to send data to stdout by descriptor has the same\neffect as calling the sys.stdout.write method:\n>>> import sys\n>>> for stream in (sys.stdin, sys.stdout, sys.stderr):\n...     print(stream.fileno())\n...\n0\n1\n2\n>>> sys.stdout.write('Hello stdio world\\n')        # write via file method\nHello stdio world\n18\n>>> import os\n>>> os.write(1, b'Hello descriptor world\\n')       # write via os module\nHello descriptor world\n23\nBecause file objects we open explicitly behave the same way, it\u2019s also possible to process\na given real external file on the underlying computer through the built-in open function,\ntools in the os module, or both (some integer return values are omitted here for brevity):\n* For instance, to process pipes, described in Chapter 5. The Python os.pipe call returns two file descriptors,\nwhich can be processed with os module file tools or wrapped in a file object with os.fdopen. When used with\ndescriptor-based file tools in os, pipes deal in byte strings, not text. Some device files may require lower-level\ncontrol as well.\n156 | Chapter 4:\u2002File and Directory Tools>>> file = open(r'C:\\temp\\spam.txt', 'w')       # create external file, object\n>>> file.write('Hello stdio file\\n')            # write via file object method\n>>> file.flush()                                # else os.write to disk first!\n>>> fd = file.fileno()                          # get descriptor from object\n>>> fd\n3\n>>> import os\n>>> os.write(fd, b'Hello descriptor file\\n')    # write via os module\n>>> file.close()\nC:\\temp> type spam.txt                          # lines from both schemes\nHello stdio file\nHello descriptor file\nos.open mode flags\nSo why the extra file tools in os? In short, they give more low-level control over file\nprocessing. The built-in open function is easy to use, but it may be limited by the un-\nderlying filesystem that it uses, and it adds extra behavior that we do not want. The\nos module lets scripts be more specific\u2014for example, the following opens a descriptor-\nbased file in read-write and binary modes by performing a binary \u201cor\u201d on two mode\nflags exported by os:\n>>> fdfile = os.open(r'C:\\temp\\spam.txt', (os.O_RDWR | os.O_BINARY))\n>>> os.read(fdfile, 20)\nb'Hello stdio file\\r\\nHe'\n>>> os.lseek(fdfile, 0, 0)                        # go back to start of file\n>>> os.read(fdfile, 100)                          # binary mode retains \"\\r\\n\"\nb'Hello stdio file\\r\\nHello descriptor file\\n'\n>>> os.lseek(fdfile, 0, 0)\n>>> os.write(fdfile, b'HELLO')                    # overwrite first 5 bytes\n5\nC:\\temp> type spam.txt\nHELLO stdio file\nHello descriptor file\nIn this case, binary mode strings rb+ and r+b in the basic open call are equivalent:\n>>> file = open(r'C:\\temp\\spam.txt', 'rb+')       # same but with open/objects\n>>> file.read(20)\nb'HELLO stdio file\\r\\nHe'\n>>> file.seek(0)\n>>> file.read(100)\nb'HELLO stdio file\\r\\nHello descriptor file\\n'\n>>> file.seek(0)\n>>> file.write(b'Jello')\n5\n>>> file.seek(0)\n>>> file.read()\nb'Jello stdio file\\r\\nHello descriptor file\\n'\nFile Tools | 157But on some systems, os.open flags let us specify more advanced things like exclusive \naccess (O_EXCL) and nonblocking modes (O_NONBLOCK) when a file is opened. Some of \nthese flags are not portable across platforms (another reason to use built-in file objects \nmost of the time); see the library manual or run a dir(os) call on your machine for an \nexhaustive list of other open flags available.\nOne final note here: using os.open with the O_EXCL flag is the most portable way to lock \nfiles for concurrent updates or other process synchronization in Python today. We\u2019ll \nsee contexts where this can matter in the next chapter, when we begin to explore \nmultiprocessing tools. Programs running in parallel on a server machine, for instance, \nmay need to lock files before performing updates, if multiple threads or processes might \nattempt such updates at the same time.\nWrapping descriptors in file objects\nWe saw earlier how to go from file object to field descriptor with the fileno file object \nmethod; given a descriptor, we can use os module tools for lower-level file access to \nthe underlying file. We can also go the other way\u2014the os.fdopen call wraps a file de-\nscriptor in a file object. Because conversions work both ways, we can generally use \neither tool set\u2014file object or os module:\n>>> fdfile = os.open(r'C:\\temp\\spam.txt', (os.O_RDWR | os.O_BINARY))\n>>> fdfile\n3\n>>> objfile = os.fdopen(fdfile, 'rb')\n>>> objfile.read()\nb'Jello stdio file\\r\\nHello descriptor file\\n'\nIn fact, we can wrap a file descriptor in either a binary or text-mode file object: in text \nmode, reads and writes perform the Unicode encodings and line-end translations we \nstudied earlier and deal in str strings instead of bytes:\nC:\\...\\PP4E\\System> python\n>>> import os\n>>> fdfile = os.open(r'C:\\temp\\spam.txt', (os.O_RDWR | os.O_BINARY))\n>>> objfile = os.fdopen(fdfile, 'r')\n>>> objfile.read()\n'Jello stdio file\\nHello descriptor file\\n'\nIn Python 3.X, the built-in open call also accepts a file descriptor instead of a file name \nstring; in this mode it works much like os.fdopen, but gives you greater control\u2014for \nexample, you can use additional arguments to specify a nondefault Unicode encoding \nfor text and suppress the default descriptor close. Really, though, os.fdopen accepts \nthe same extra-control arguments in 3.X, because it has been redefined to do little but \ncall back to the built-in open (see os.py in the standard library):\nC:\\...\\PP4E\\System> python\n>>> import os\n>>> fdfile = os.open(r'C:\\temp\\spam.txt', (os.O_RDWR | os.O_BINARY))\n>>> fdfile\n3\n158 | Chapter 4:\u2002File and Directory Tools>>> objfile = open(fdfile, 'r', encoding='latin1', closefd=False)\n>>> objfile.read()\n'Jello stdio file\\nHello descriptor file\\n'\n>>> objfile = os.fdopen(fdfile, 'r', encoding='latin1', closefd=True)\n>>> objfile.seek(0)\n>>> objfile.read()\n'Jello stdio file\\nHello descriptor file\\n'\nWe\u2019ll make use of this file object wrapper technique to simplify text-oriented pipes and\nother descriptor-like objects later in this book (e.g., sockets have a makefile method\nwhich achieves similar effects).\nOther os module file tools\nThe os module also includes an assortment of file tools that accept a file pathname\nstring and accomplish file-related tasks such as renaming (os.rename), deleting\n(os.remove), and changing the file\u2019s owner and permission settings (os.chown,\nos.chmod). Let\u2019s step through a few examples of these tools in action:\n>>> os.chmod('spam.txt', 0o777)          # enable all accesses\nThis os.chmod file permissions call passes a 9-bit string composed of three sets of three\nbits each. From left to right, the three sets represent the file\u2019s owning user, the file\u2019s\ngroup, and all others. Within each set, the three bits reflect read, write, and execute\naccess permissions. When a bit is \u201c1\u201d in this string, it means that the corresponding\noperation is allowed for the assessor. For instance, octal 0777 is a string of nine \u201c1\u201d\nbits in binary, so it enables all three kinds of accesses for all three user groups; octal\n0600 means that the file can be read and written only by the user that owns it (when\nwritten in binary, 0600 octal is really bits 110 000 000).\nThis scheme stems from Unix file permission settings, but the call works on Windows\nas well. If it\u2019s puzzling, see your system\u2019s documentation (e.g., a Unix manpage) for\nchmod. Moving on:\n>>> os.rename(r'C:\\temp\\spam.txt', r'C:\\temp\\eggs.txt')      # from, to\n>>> os.remove(r'C:\\temp\\spam.txt')                           # delete file?\nWindowsError: [Error 2] The system cannot find the file specified: 'C:\\\\temp\\\\...'\n>>> os.remove(r'C:\\temp\\eggs.txt')\nThe os.rename call used here changes a file\u2019s name; the os.remove file deletion call\ndeletes a file from your system and is synonymous with os.unlink (the latter reflects\nthe call\u2019s name on Unix but was obscure to users of other platforms).\u2020 The os module\nalso exports the stat system call:\n\u2020 For related tools, see also the shutil module in Python\u2019s standard library; it has higher-level tools for copying\nand removing files and more. We\u2019ll also write directory compare, copy, and search tools of our own in\nChapter 6, after we\u2019ve had a chance to study the directory tools presented later in this chapter.\nFile Tools | 159>>> open('spam.txt', 'w').write('Hello stat world\\n')        # +1 for \\r added\n17\n>>> import os\n>>> info = os.stat(r'C:\\temp\\spam.txt')\n>>> info\nnt.stat_result(st_mode=33206, st_ino=0, st_dev=0, st_nlink=0, st_uid=0, st_gid=0,\nst_size=18, st_atime=1267645806, st_mtime=1267646072, st_ctime=1267645806)\n>>> info.st_mode, info.st_size                  # via named-tuple item attr names\n(33206, 18)\n>>> import stat\n>>> info[stat.ST_MODE], info[stat.ST_SIZE]      # via stat module presets\n(33206, 18)\n>>> stat.S_ISDIR(info.st_mode), stat.S_ISREG(info.st_mode)\n(False, True)\nThe os.stat call returns a tuple of values (really, in 3.X a special kind of tuple with\nnamed items) giving low-level information about the named file, and the stat module\nexports constants and functions for querying this information in a portable way. For\ninstance, indexing an os.stat result on offset stat.ST_SIZE returns the file\u2019s size, and\ncalling stat.S_ISDIR with the mode item from an os.stat result checks whether the file\nis a directory. As shown earlier, though, both of these operations are available in the\nos.path module, too, so it\u2019s rarely necessary to use os.stat except for low-level file\nqueries:\n>>> path = r'C:\\temp\\spam.txt'\n>>> os.path.isdir(path), os.path.isfile(path), os.path.getsize(path)\n(False, True, 18)\nFile Scanners\nBefore we leave our file tools survey, it\u2019s time for something that performs a more\ntangible task and illustrates some of what we\u2019ve learned so far. Unlike some shell-tool\nlanguages, Python doesn\u2019t have an implicit file-scanning loop procedure, but it\u2019s simple\nto write a general one that we can reuse for all time. The module in Example 4-1 defines\na general file-scanning routine, which simply applies a passed-in Python function to\neach line in an external file.\nExample 4-1. PP4E\\System\\Filetools\\scanfile.py\ndef scanner(name, function):\n    file = open(name, 'r')               # create a file object\n    while True:\n        line = file.readline()           # call file methods\n        if not line: break               # until end-of-file\n        function(line)                   # call a function object\n    file.close()\nThe scanner function doesn\u2019t care what line-processing function is passed in, and that\naccounts for most of its generality\u2014it is happy to apply any single-argument function\n160 | Chapter 4:\u2002File and Directory Toolsthat exists now or in the future to all of the lines in a text file. If we code this module\nand put it in a directory on the module search path, we can use it any time we need to\nstep through a file line by line. Example 4-2 is a client script that does simple line\ntranslations.\nExample 4-2. PP4E\\System\\Filetools\\commands.py\n#!/usr/local/bin/python\nfrom sys import argv\nfrom scanfile import scanner\nclass UnknownCommand(Exception): pass\ndef processLine(line):                      # define a function\n    if line[0] == '*':                      # applied to each line\n        print(\"Ms.\", line[1:-1])\n    elif line[0] == '+':\n        print(\"Mr.\", line[1:-1])            # strip first and last char: \\n\n    else:\n        raise UnknownCommand(line)          # raise an exception\nfilename = 'data.txt'\nif len(argv) == 2: filename = argv[1]       # allow filename cmd arg\nscanner(filename, processLine)              # start the scanner\nThe text file hillbillies.txt contains the following lines:\n*Granny\n+Jethro\n*Elly May\n+\"Uncle Jed\"\nand our commands script could be run as follows:\nC:\\...\\PP4E\\System\\Filetools> python commands.py hillbillies.txt\nMs. Granny\nMr. Jethro\nMs. Elly May\nMr. \"Uncle Jed\"\nThis works, but there are a variety of coding alternatives for both files, some of which\nmay be better than those listed above. For instance, we could also code the command\nprocessor of Example 4-2 in the following way; especially if the number of command\noptions starts to become large, such a data-driven approach may be more concise\nand easier to maintain than a large if statement with essentially redundant actions (if\nyou ever have to change the way output lines print, you\u2019ll have to change it in only one\nplace with this form):\ncommands = {'*': 'Ms.', '+': 'Mr.'}     # data is easier to expand than code?\ndef processLine(line):\n    try:\n        print(commands[line[0]], line[1:-1])\n    except KeyError:\n        raise UnknownCommand(line)\nFile Tools | 161The scanner could similarly be improved. As a rule of thumb, we can also usually speed\nthings up by shifting processing from Python code to built-in tools. For instance, if\nwe\u2019re concerned with speed, we can probably make our file scanner faster by using the\nfile\u2019s line iterator to step through the file instead of the manual readline loop in Ex-\nample 4-1 (though you\u2019d have to time this with your Python to be sure):\ndef scanner(name, function):\n    for line in open(name, 'r'):         # scan line by line\n        function(line)                   # call a function object\nAnd we can work more magic in Example 4-1 with the iteration tools like the map built-\nin function, the list comprehension expression, and the generator expression. Here are\nthree minimalist\u2019s versions; the for loop is replaced by map or a comprehension, and\nwe let Python close the file for us when it is garbage collected or the script exits (these\nall build a temporary list of results along the way to run through their iterations, but\nthis overhead is likely trivial for all but the largest of files):\ndef scanner(name, function):\n    list(map(function, open(name, 'r')))\ndef scanner(name, function):\n    [function(line) for line in open(name, 'r')]\ndef scanner(name, function):\n    list(function(line) for line in open(name, 'r'))\nFile filters\nThe preceding works as planned, but what if we also want to change a file while scanning\nit? Example 4-3 shows two approaches: one uses explicit files, and the other uses the\nstandard input/output streams to allow for redirection on the command line.\nExample 4-3. PP4E\\System\\Filetools\\filters.py\nimport sys\ndef filter_files(name, function):         # filter file through function\n    input  = open(name, 'r')              # create file objects\n    output = open(name + '.out', 'w')     # explicit output file too\n    for line in input:\n        output.write(function(line))      # write the modified line\n    input.close()\n    output.close()                        # output has a '.out' suffix\ndef filter_stream(function):              # no explicit files\n    while True:                           # use standard streams\n        line = sys.stdin.readline()       # or: input()\n        if not line: break\n        print(function(line), end='')     # or: sys.stdout.write()\nif __name__ == '__main__':\n    filter_stream(lambda line: line)      # copy stdin to stdout if run\n162 | Chapter 4:\u2002File and Directory ToolsNotice that the newer context managers feature discussed earlier could save us a few\nlines here in the file-based filter of Example 4-3, and also guarantee immediate file\nclosures if the processing function fails with an exception:\ndef filter_files(name, function):\n    with open(name, 'r') as input, open(name + '.out', 'w') as output:\n        for line in input:\n            output.write(function(line))      # write the modified line\nAnd again, file object line iterators could simplify the stream-based filter\u2019s code in this\nexample as well:\ndef filter_stream(function):\n    for line in sys.stdin:                    # read by lines automatically\n        print(function(line), end='')\nSince the standard streams are preopened for us, they\u2019re often easier to use. When run\nstandalone, it simply parrots stdin to stdout:\nC:\\...\\PP4E\\System\\Filetools> filters.py < hillbillies.txt\n*Granny\n+Jethro\n*Elly May\n+\"Uncle Jed\"\nBut this module is also useful when imported as a library (clients provide the line-\nprocessing function):\n>>> from filters import filter_files\n>>> filter_files('hillbillies.txt', str.upper)\n>>> print(open('hillbillies.txt.out').read())\n*GRANNY\n+JETHRO\n*ELLY MAY\n+\"UNCLE JED\"\nWe\u2019ll see files in action often in the remainder of this book, especially in the more\ncomplete and functional system examples of Chapter 6. First though, we turn to tools\nfor processing our files\u2019 home.\nDirectory Tools\nOne of the more common tasks in the shell utilities domain is applying an operation\nto a set of files in a directory\u2014a \u201cfolder\u201d in Windows-speak. By running a script on a\nbatch of files, we can automate (that is, script) tasks we might have to otherwise run\nrepeatedly by hand.\nFor instance, suppose you need to search all of your Python files in a development\ndirectory for a global variable name (perhaps you\u2019ve forgotten where it is used). There\nare many platform-specific ways to do this (e.g., the find and grep commands in Unix),\nbut Python scripts that accomplish such tasks will work on every platform where Py-\nthon works\u2014Windows, Unix, Linux, Macintosh, and just about any other platform\nDirectory Tools | 163commonly used today. If you simply copy your script to any machine you wish to use\nit on, it will work regardless of which other tools are available there; all you need is\nPython. Moreover, coding such tasks in Python also allows you to perform arbitrary\nactions along the way\u2014replacements, deletions, and whatever else you can code in the\nPython language.\nWalking One Directory\nThe most common way to go about writing such tools is to first grab a list of the names\nof the files you wish to process, and then step through that list with a Python for loop\nor other iteration tool, processing each file in turn. The trick we need to learn here,\nthen, is how to get such a directory list within our scripts. For scanning directories there\nare at least three options: running shell listing commands with os.popen, matching\nfilename patterns with glob.glob, and getting directory listings with os.listdir. They\nvary in interface, result format, and portability.\nRunning shell listing commands with os.popen\nHow did you go about getting directory file listings before you heard of Python? If you\u2019re\nnew to shell tools programming, the answer may be \u201cWell, I started a Windows file\nexplorer and clicked on things,\u201d but I\u2019m thinking here in terms of less GUI-oriented\ncommand-line mechanisms.\nOn Unix, directory listings are usually obtained by typing ls in a shell; on Windows,\nthey can be generated with a dir command typed in an MS-DOS console box. Because\nPython scripts may use os.popen to run any command line that we can type in a shell,\nthey are the most general way to grab a directory listing inside a Python program. We\nmet os.popen in the prior chapters; it runs a shell command string and gives us a file\nobject from which we can read the command\u2019s output. To illustrate, let\u2019s first assume\nthe following directory structures\u2014I have both the usual dir and a Unix-like ls com-\nmand from Cygwin on my Windows laptop:\nc:\\temp> dir /B\nparts\nPP3E\nrandom.bin\nspam.txt\ntemp.bin\ntemp.txt\nc:\\temp> c:\\cygwin\\bin\\ls\nPP3E  parts  random.bin  spam.txt  temp.bin  temp.txt\nc:\\temp> c:\\cygwin\\bin\\ls parts\npart0001  part0002  part0003  part0004\nThe parts and PP3E names are a nested subdirectory in C:\\temp here (the latter is a copy\nof the prior edition\u2019s examples tree, which I used occasionally in this text). Now, as\n164 | Chapter 4:\u2002File and Directory Toolswe\u2019ve seen, scripts can grab a listing of file and directory names at this level by simply\nspawning the appropriate platform-specific command line and reading its output (the\ntext normally thrown up on the console window):\nC:\\temp> python\n>>> import os\n>>> os.popen('dir /B').readlines()\n['parts\\n', 'PP3E\\n', 'random.bin\\n', 'spam.txt\\n', 'temp.bin\\n', 'temp.txt\\n']\nLines read from a shell command come back with a trailing end-of-line character, but\nit\u2019s easy enough to slice it off; the os.popen result also gives us a line iterator just like\nnormal files:\n>>> for line in os.popen('dir /B'):\n...     print(line[:-1])\n...\nparts\nPP3E\nrandom.bin\nspam.txt\ntemp.bin\ntemp.txt\n>>> lines = [line[:-1] for line in os.popen('dir /B')]\n>>> lines\n['parts', 'PP3E', 'random.bin', 'spam.txt', 'temp.bin', 'temp.txt']\nFor pipe objects, the effect of iterators may be even more useful than simply avoiding\nloading the entire result into memory all at once: readlines will always block the caller\nuntil the spawned program is completely finished, whereas the iterator might not.\nThe dir and ls commands let us be specific about filename patterns to be matched and\ndirectory names to be listed by using name patterns; again, we\u2019re just running shell\ncommands here, so anything you can type at a shell prompt goes:\n >>> os.popen('dir *.bin /B').readlines()\n['random.bin\\n', 'temp.bin\\n']\n>>> os.popen(r'c:\\cygwin\\bin\\ls *.bin').readlines()\n['random.bin\\n', 'temp.bin\\n']\n>>> list(os.popen(r'dir parts /B'))\n['part0001\\n', 'part0002\\n', 'part0003\\n', 'part0004\\n']\n>>> [fname for fname in os.popen(r'c:\\cygwin\\bin\\ls parts')]\n['part0001\\n', 'part0002\\n', 'part0003\\n', 'part0004\\n']\nThese calls use general tools and work as advertised. As I noted earlier, though, the\ndownsides of os.popen are that it requires using a platform-specific shell command and\nit incurs a performance hit to start up an independent program. In fact, different listing\ntools may sometimes produce different results:\n>>> list(os.popen(r'dir parts\\part* /B'))\n['part0001\\n', 'part0002\\n', 'part0003\\n', 'part0004\\n']\nDirectory Tools | 165>>>\n>>> list(os.popen(r'c:\\cygwin\\bin\\ls parts/part*'))\n['parts/part0001\\n', 'parts/part0002\\n', 'parts/part0003\\n', 'parts/part0004\\n']\nThe next two alternative techniques do better on both counts.\nThe glob module\nThe term globbing comes from the * wildcard character in filename patterns; per com-\nputing folklore, a * matches a \u201cglob\u201d of characters. In less poetic terms, globbing simply\nmeans collecting the names of all entries in a directory\u2014files and subdirectories\u2014\nwhose names match a given filename pattern. In Unix shells, globbing expands filename\npatterns within a command line into all matching filenames before the command is\never run. In Python, we can do something similar by calling the glob.glob built-in\u2014a\ntool that accepts a filename pattern to expand, and returns a list (not a generator) of\nmatching file names:\n>>> import glob\n>>> glob.glob('*')\n['parts', 'PP3E', 'random.bin', 'spam.txt', 'temp.bin', 'temp.txt']\n>>> glob.glob('*.bin')\n['random.bin', 'temp.bin']\n>>> glob.glob('parts')\n['parts']\n>>> glob.glob('parts/*')\n['parts\\\\part0001', 'parts\\\\part0002', 'parts\\\\part0003', 'parts\\\\part0004']\n>>> glob.glob('parts\\part*')\n['parts\\\\part0001', 'parts\\\\part0002', 'parts\\\\part0003', 'parts\\\\part0004']\nThe glob call accepts the usual filename pattern syntax used in shells: ? means any one\ncharacter, * means any number of characters, and [] is a character selection set.\u2021 The\npattern should include a directory path if you wish to glob in something other than the\ncurrent working directory, and the module accepts either Unix or DOS-style directory\nseparators (/ or \\). This call is implemented without spawning a shell command (it uses\nos.listdir, described in the next section) and so is likely to be faster and more portable\nand uniform across all Python platforms than the os.popen schemes shown earlier.\nTechnically speaking, glob is a bit more powerful than described so far. In fact, using\nit to list files in one directory is just one use of its pattern-matching skills. For instance,\nit can also be used to collect matching names across multiple directories, simply because\neach level in a passed-in directory path can be a pattern too:\n>>> for path in glob.glob(r'PP3E\\Examples\\PP3E\\*\\s*.py'): print(path)\n...\n\u2021 In fact, glob just uses the standard fnmatch module to match name patterns; see the fnmatch description in\nChapter 6\u2019s find module example for more details.\n166 | Chapter 4:\u2002File and Directory ToolsPP3E\\Examples\\PP3E\\Lang\\summer-alt.py\nPP3E\\Examples\\PP3E\\Lang\\summer.py\nPP3E\\Examples\\PP3E\\PyTools\\search_all.py\nHere, we get back filenames from two different directories that match the s*.py pattern;\nbecause the directory name preceding this is a * wildcard, Python collects all possible\nways to reach the base filenames. Using os.popen to spawn shell commands achieves\nthe same effect, but only if the underlying shell or listing command does, too, and with\npossibly different result formats across tools and platforms.\nThe os.listdir call\nThe os module\u2019s listdir call provides yet another way to collect filenames in a Python\nlist. It takes a simple directory name string, not a filename pattern, and returns a list\ncontaining the names of all entries in that directory\u2014both simple files and nested\ndirectories\u2014for use in the calling script:\n>>> import os\n>>> os.listdir('.')\n['parts', 'PP3E', 'random.bin', 'spam.txt', 'temp.bin', 'temp.txt']\n>>>\n>>> os.listdir(os.curdir)\n['parts', 'PP3E', 'random.bin', 'spam.txt', 'temp.bin', 'temp.txt']\n>>>\n>>> os.listdir('parts')\n['part0001', 'part0002', 'part0003', 'part0004']\nThis, too, is done without resorting to shell commands and so is both fast and portable\nto all major Python platforms. The result is not in any particular order across platforms\n(but can be sorted with the list sort method or sorted built-in function); returns base\nfilenames without their directory path prefixes; does not include names \u201c.\u201d or \u201c..\u201d if\npresent; and includes names of both files and directories at the listed level.\nTo compare all three listing techniques, let\u2019s run them here side by side on an explicit\ndirectory. They differ in some ways but are mostly just variations on a theme for this\ntask\u2014os.popen returns end-of-lines and may sort filenames on some platforms,\nglob.glob accepts a pattern and returns filenames with directory prefixes, and os.list\ndir takes a simple directory name and returns names without directory prefixes:\n>>> os.popen('dir /b parts').readlines()\n['part0001\\n', 'part0002\\n', 'part0003\\n', 'part0004\\n']\n>>> glob.glob(r'parts\\*')\n['parts\\\\part0001', 'parts\\\\part0002', 'parts\\\\part0003', 'parts\\\\part0004']\n>>> os.listdir('parts')\n['part0001', 'part0002', 'part0003', 'part0004']\nOf these three, glob and listdir are generally better options if you care about script\nportability and result uniformity, and listdir seems fastest in recent Python releases\n(but gauge its performance yourself\u2014implementations may change over time).\nDirectory Tools | 167Splitting and joining listing results\nIn the last example, I pointed out that glob returns names with directory paths, whereas\nlistdir gives raw base filenames. For convenient processing, scripts often need to split\nglob results into base files or expand listdir results into full paths. Such translations\nare easy if we let the os.path module do all the work for us. For example, a script that\nintends to copy all files elsewhere will typically need to first split off the base filenames\nfrom glob results so that it can add different directory names on the front:\n>>> dirname = r'C:\\temp\\parts'\n>>>\n>>> import glob\n>>> for file in glob.glob(dirname + '/*'):\n...     head, tail = os.path.split(file)\n...     print(head, tail, '=>', ('C:\\\\Other\\\\' + tail))\n...\nC:\\temp\\parts part0001 => C:\\Other\\part0001\nC:\\temp\\parts part0002 => C:\\Other\\part0002\nC:\\temp\\parts part0003 => C:\\Other\\part0003\nC:\\temp\\parts part0004 => C:\\Other\\part0004\nHere, the names after the => represent names that files might be moved to. Conversely,\na script that means to process all files in a different directory than the one it runs in will\nprobably need to prepend listdir results with the target directory name before passing\nfilenames on to other tools:\n>>> import os\n>>> for file in os.listdir(dirname):\n...     print(dirname, file, '=>', os.path.join(dirname, file))\n...\nC:\\temp\\parts part0001 => C:\\temp\\parts\\part0001\nC:\\temp\\parts part0002 => C:\\temp\\parts\\part0002\nC:\\temp\\parts part0003 => C:\\temp\\parts\\part0003\nC:\\temp\\parts part0004 => C:\\temp\\parts\\part0004\nWhen you begin writing realistic directory processing tools of the sort we\u2019ll develop in\nChapter 6, you\u2019ll find these calls to be almost habit.\nWalking Directory Trees\nYou may have noticed that almost all of the techniques in this section so far return the\nnames of files in only a single directory (globbing with more involved patterns is the\nonly exception). That\u2019s fine for many tasks, but what if you want to apply an operation\nto every file in every directory and subdirectory in an entire directory tree?\nFor instance, suppose again that we need to find every occurrence of a global name in\nour Python scripts. This time, though, our scripts are arranged into a module pack-\nage: a directory with nested subdirectories, which may have subdirectories of their own.\nWe could rerun our hypothetical single-directory searcher manually in every directory\nin the tree, but that\u2019s tedious, error prone, and just plain not fun.\n168 | Chapter 4:\u2002File and Directory ToolsLuckily, in Python it\u2019s almost as easy to process a directory tree as it is to inspect a single\ndirectory. We can either write a recursive routine to traverse the tree, or use a tree-\nwalker utility built into the os module. Such tools can be used to search, copy, compare,\nand otherwise process arbitrary directory trees on any platform that Python runs on\n(and that\u2019s just about everywhere).\nThe os.walk visitor\nTo make it easy to apply an operation to all files in a complete directory tree, Python\ncomes with a utility that scans trees for us and runs code we provide at every directory\nalong the way: the os.walk function is called with a directory root name and automat-\nically walks the entire tree at root and below.\nOperationally, os.walk is a generator function\u2014at each directory in the tree, it yields a\nthree-item tuple, containing the name of the current directory as well as lists of both\nall the files and all the subdirectories in the current directory. Because it\u2019s a generator,\nits walk is usually run by a for loop (or other iteration tool); on each iteration, the\nwalker advances to the next subdirectory, and the loop runs its code for the next level\nof the tree (for instance, opening and searching all the files at that level).\nThat description might sound complex the first time you hear it, but os.walk is fairly\nstraightforward once you get the hang of it. In the following, for example, the loop\nbody\u2019s code is run for each directory in the tree rooted at the current working directory\n(.). Along the way, the loop simply prints the directory name and all the files at the\ncurrent level after prepending the directory name. It\u2019s simpler in Python than in English\n(I removed the PP3E subdirectory for this test to keep the output short):\n>>> import os\n>>> for (dirname, subshere, fileshere) in os.walk('.'):\n...     print('[' + dirname + ']')\n...     for fname in fileshere:\n...         print(os.path.join(dirname, fname))        # handle one file\n...\n[.]\n.\\random.bin\n.\\spam.txt\n.\\temp.bin\n.\\temp.txt\n[.\\parts]\n.\\parts\\part0001\n.\\parts\\part0002\n.\\parts\\part0003\n.\\parts\\part0004\nIn other words, we\u2019ve coded our own custom and easily changed recursive directory\nlisting tool in Python. Because this may be something we would like to tweak and reuse\nelsewhere, let\u2019s make it permanently available in a module file, as shown in Exam-\nple 4-4, now that we\u2019ve worked out the details interactively.\nDirectory Tools | 169Example 4-4. PP4E\\System\\Filetools\\lister_walk.py\n\"list file tree with os.walk\"\nimport sys, os\ndef lister(root):                                           # for a root dir\n    for (thisdir, subshere, fileshere) in os.walk(root):    # generate dirs in tree\n        print('[' + thisdir + ']')\n        for fname in fileshere:                             # print files in this dir\n            path = os.path.join(thisdir, fname)             # add dir name prefix\n            print(path)\nif __name__ == '__main__':\n    lister(sys.argv[1])                                     # dir name in cmdline\nWhen packaged this way, the code can also be run from a shell command line. Here it\nis being launched with the root directory to be listed passed in as a command-line\nargument:\nC:\\...\\PP4E\\System\\Filetools> python lister_walk.py C:\\temp\\test\n[C:\\temp\\test]\nC:\\temp\\test\\random.bin\nC:\\temp\\test\\spam.txt\nC:\\temp\\test\\temp.bin\nC:\\temp\\test\\temp.txt\n[C:\\temp\\test\\parts]\nC:\\temp\\test\\parts\\part0001\nC:\\temp\\test\\parts\\part0002\nC:\\temp\\test\\parts\\part0003\nC:\\temp\\test\\parts\\part0004\nHere\u2019s a more involved example of os.walk in action. Suppose you have a directory tree\nof files and you want to find all Python source files within it that reference the mime\ntypes module we\u2019ll study in Chapter 6. The following is one (albeit hardcoded and\noverly specific) way to accomplish this task:\n>>> import os\n>>> matches = []\n>>> for (dirname, dirshere, fileshere) in os.walk(r'C:\\temp\\PP3E\\Examples'):\n...     for filename in fileshere:\n...         if filename.endswith('.py'):\n...             pathname = os.path.join(dirname, filename)\n...             if 'mimetypes' in open(pathname).read():\n...                 matches.append(pathname)\n...\n>>> for name in matches: print(name)\n...\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Email\\mailtools\\mailParser.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Email\\mailtools\\mailSender.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\downloadflat.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\downloadflat_modular.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\ftptools.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\uploadflat.py\nC:\\temp\\PP3E\\Examples\\PP3E\\System\\Media\\playfile.py\n170 | Chapter 4:\u2002File and Directory ToolsThis code loops through all the files at each level, looking for files with .py at the end\nof their names and which contain the search string. When a match is found, its full\nname is appended to the results list object; alternatively, we could also simply build a\nlist of all .py files and search each in a for loop after the walk. Since we\u2019re going to code\nmuch more general solution to this type of problem in Chapter 6, though, we\u2019ll let this\nstand for now.\nIf you want to see what\u2019s really going on in the os.walk generator, call its __next__\nmethod (or equivalently, pass it to the next built-in function) manually a few times,\njust as the for loop does automatically; each time, you advance to the next subdirectory\nin the tree:\n>>> gen = os.walk(r'C:\\temp\\test')\n>>> gen.__next__()\n('C:\\\\temp\\\\test', ['parts'], ['random.bin', 'spam.txt', 'temp.bin', 'temp.txt'])\n>>> gen.__next__()\n('C:\\\\temp\\\\test\\\\parts', [], ['part0001', 'part0002', 'part0003', 'part0004'])\n>>> gen.__next__()\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nStopIteration\nThe library manual documents os.walk further than we will here. For instance, it sup-\nports bottom-up instead of top-down walks with its optional topdown=False argument,\nand callers may prune tree branches by deleting names in the subdirectories lists of the\nyielded tuples.\nInternally, the os.walk call generates filename lists at each level with the os.listdir call\nwe met earlier, which collects both file and directory names in no particular order and\nreturns them without their directory paths; os.walk segregates this list into subdirec-\ntories and files (technically, nondirectories) before yielding a result. Also note that\nwalk uses the very same subdirectories list it yields to callers in order to later descend\ninto subdirectories. Because lists are mutable objects that can be changed in place, if\nyour code modifies the yielded subdirectory names list, it will impact what walk does\nnext. For example, deleting directory names will prune traversal branches, and sorting\nthe list will order the walk.\nRecursive os.listdir traversals\nThe os.walk tool does the work of tree traversals for us; we simply provide loop code\nwith task-specific logic. However, it\u2019s sometimes more flexible and hardly any more\nwork to do the walking ourselves. The following script recodes the directory listing\nscript with a manual recursive traversal function (a function that calls itself to repeat\nits actions). The mylister function in Example 4-5 is almost the same as lister in\nExample 4-4 but calls os.listdir to generate file paths manually and calls itself recur-\nsively to descend into subdirectories.\nDirectory Tools | 171Example 4-5. PP4E\\System\\Filetools\\lister_recur.py\n# list files in dir tree by recursion\nimport sys, os\ndef mylister(currdir):\n    print('[' + currdir + ']')\n    for file in os.listdir(currdir):              # list files here\n        path = os.path.join(currdir, file)        # add dir path back\n        if not os.path.isdir(path):\n            print(path)\n        else:\n            mylister(path)                        # recur into subdirs\nif __name__ == '__main__':\n    mylister(sys.argv[1])                         # dir name in cmdline\nAs usual, this file can be both imported and called or run as a script, though the fact\nthat its result is printed text makes it less useful as an imported component unless its\noutput stream is captured by another program.\nWhen run as a script, this file\u2019s output is equivalent to that of Example 4-4, but not\nidentical\u2014unlike the os.walk version, our recursive walker here doesn\u2019t order the walk\nto visit files before stepping into subdirectories. It could by looping through the file-\nnames list twice (selecting files first), but as coded, the order is dependent on os.list\ndir results. For most use cases, the walk order would be irrelevant:\nC:\\...\\PP4E\\System\\Filetools> python lister_recur.py C:\\temp\\test\n[C:\\temp\\test]\n[C:\\temp\\test\\parts]\nC:\\temp\\test\\parts\\part0001\nC:\\temp\\test\\parts\\part0002\nC:\\temp\\test\\parts\\part0003\nC:\\temp\\test\\parts\\part0004\nC:\\temp\\test\\random.bin\nC:\\temp\\test\\spam.txt\nC:\\temp\\test\\temp.bin\nC:\\temp\\test\\temp.txt\nWe\u2019ll make better use of most of this section\u2019s techniques in later examples in Chap-\nter 6 and in this book at large. For example, scripts for copying and comparing directory\ntrees use the tree-walker techniques introduced here. Watch for these tools in action\nalong the way. We\u2019ll also code a find utility in Chapter 6 that combines the tree traversal\nof os.walk with the filename pattern expansion of glob.glob.\nHandling Unicode Filenames in 3.X: listdir, walk, glob\nBecause all normal strings are Unicode in Python 3.X, the directory and file names\ngenerated by os.listdir, os.walk, and glob.glob so far in this chapter are technically\nUnicode strings. This can have some ramifications if your directories contain unusual\nnames that might not decode properly.\n172 | Chapter 4:\u2002File and Directory ToolsTechnically, because filenames may contain arbitrary text, the os.listdir works in two\nmodes in 3.X: given a bytes argument, this function will return filenames as encoded\nbyte strings; given a normal str string argument, it instead returns filenames as Unicode\nstrings, decoded per the filesystem\u2019s encoding scheme:\nC:\\...\\PP4E\\System\\Filetools> python\n>>> import os\n>>> os.listdir('.')[:4]\n['bigext-tree.py', 'bigpy-dir.py', 'bigpy-path.py', 'bigpy-tree.py']\n>>> os.listdir(b'.')[:4]\n[b'bigext-tree.py', b'bigpy-dir.py', b'bigpy-path.py', b'bigpy-tree.py']\nThe byte string version can be used if undecodable file names may be present. Because\nos.walk and glob.glob both work by calling os.listdir internally, they inherit this\nbehavior by proxy. The os.walk tree walker, for example, calls os.listdir at each di-\nrectory level; passing byte string arguments suppresses decoding and returns byte string\nresults:\n>>> for (dir, subs, files) in os.walk('..'): print(dir)\n...\n..\n..\\Environment\n..\\Filetools\n..\\Processes\n>>> for (dir, subs, files) in os.walk(b'..'): print(dir)\n...\nb'..'\nb'..\\\\Environment'\nb'..\\\\Filetools'\nb'..\\\\Processes'\nThe glob.glob tool similarly calls os.listdir internally before applying name patterns,\nand so also returns undecoded byte string names for byte string arguments:\n>>> glob.glob('.\\*')[:3]\n['.\\\\bigext-out.txt', '.\\\\bigext-tree.py', '.\\\\bigpy-dir.py']\n>>>\n>>> glob.glob(b'.\\*')[:3]\n[b'.\\\\bigext-out.txt', b'.\\\\bigext-tree.py', b'.\\\\bigpy-dir.py']\nGiven a normal string name (as a command-line argument, for example), you can force\nthe issue by converting to byte strings with manual encoding to suppress decoding:\n>>> name = '.'\n>>> os.listdir(name.encode())[:4]\n[b'bigext-out.txt', b'bigext-tree.py', b'bigpy-dir.py', b'bigpy-path.py']\nThe upshot is that if your directories may contain names which cannot be decoded\naccording to the underlying platform\u2019s Unicode encoding scheme, you may need to\npass byte strings to these tools to avoid Unicode encoding errors. You\u2019ll get byte strings\nback, which may be less readable if printed, but you\u2019ll avoid errors while traversing\ndirectories and files.\nDirectory Tools | 173This might be especially useful on systems that use simple encodings such as ASCII or\nLatin-1, but may contain files with arbitrarily encoded names from cross-machine cop-\nies, the Web, and so on. Depending upon context, exception handlers may be used to\nsuppress some types of encoding errors as well.\nWe\u2019ll see an example of how this can matter in the first section of Chapter 6, where an\nundecodable directory name generates an error if printed during a full disk scan (al-\nthough that specific error seems more related to printing than to decoding in general).\nNote that the basic open built-in function allows the name of the file being opened to\nbe passed as either Unicode str or raw bytes, too, though this is used only to name the\nfile initially; the additional mode argument determines whether the file\u2019s content is\nhandled in text or binary modes. Passing a byte string filename allows you to name files\nwith arbitrarily encoded names.\nUnicode policies: File content versus file names\nIn fact, it\u2019s important to keep in mind that there are two different Unicode concepts\nrelated to files: the encoding of file content and the encoding of file name. Python pro-\nvides your platform\u2019s defaults for these settings in two different attributes; on\nWindows 7:\n>>> import sys\n>>> sys.getdefaultencoding()          # file content encoding, platform default\n'utf-8'\n>>> sys.getfilesystemencoding()       # file name encoding, platform scheme\n'mbcs'\nThese settings allow you to be explicit when needed\u2014the content encoding is used\nwhen data is read and written to the file, and the name encoding is used when dealing\nwith names prior to transferring data. In addition, using bytes for file name tools may\nwork around incompatibilities with the underlying file system\u2019s scheme, and opening\nfiles in binary mode can suppress Unicode decoding errors for content.\nAs we\u2019ve seen, though, opening text files in binary mode may also mean that the raw\nand still-encoded text will not match search strings as expected: search strings must\nalso be byte strings encoded per a specific and possibly incompatible encoding scheme.\nIn fact, this approach essentially mimics the behavior of text files in Python 2.X, and\nunderscores why elevating Unicode in 3.X is generally desirable\u2014such text files some-\ntimes may appear to work even though they probably shouldn\u2019t. On the other hand,\nopening text in binary mode to suppress Unicode content decoding and avoid decoding\nerrors might still be useful if you do not wish to skip undecodable files and content is\nlargely irrelevant.\n174 | Chapter 4:\u2002File and Directory ToolsAs a rule of thumb, you should try to always provide an encoding name for text content\nif it might be outside the platform default, and you should rely on the default Unicode\nAPI for file names in most cases. Again, see Python\u2019s manuals for more on the Unicode\nfile name story than we have space to cover fully here, and see Learning Python, Fourth\nEdition, for more on Unicode in general.\nIn Chapter 6, we\u2019re going to put the tools we met in this chapter to realistic use. For\nexample, we\u2019ll apply file and directory tools to implement file splitters, testing systems,\ndirectory copies and compares, and a variety of utilities based on tree walking. We\u2019ll\nfind that Python\u2019s directory tools we met here have an enabling quality that allows us\nto automate a large set of real-world tasks. First, though, Chapter 5 concludes our basic\ntool survey, by exploring another system topic that tends to weave its way into a wide\nvariety of application domains\u2014parallel processing in Python.\nDirectory Tools | 175", "5": "CHAPTER 5\nParallel System Tools\n\u201cTelling the Monkeys What to Do\u201d\nMost computers spend a lot of time doing nothing. If you start a system monitor tool \nand watch the CPU utilization, you\u2019ll see what I mean\u2014it\u2019s rare to see one hit 100 \npercent, even when you are running multiple programs.* There are just too many delays \nbuilt into software: disk accesses, network traffic, database queries, waiting for users \nto click a button, and so on. In fact, the majority of a modern CPU\u2019s capacity is often \nspent in an idle state; faster chips help speed up performance demand peaks, but much \nof their power can go largely unused.\nEarly on in computing, programmers realized that they could tap into such unused \nprocessing power by running more than one program at the same time. By dividing the \nCPU\u2019s attention among a set of tasks, its capacity need not go to waste while any given \ntask is waiting for an external event to occur. The technique is usually called parallel \nprocessing (and sometimes \u201cmultiprocessing\u201d or even \u201cmultitasking\u201d) because many \ntasks seem to be performed at once, overlapping and parallel in time. It\u2019s at the heart \nof modern operating systems, and it gave rise to the notion of multiple-active-window \ncomputer interfaces we\u2019ve all come to take for granted. Even within a single program, \ndividing processing into tasks that run in parallel can make the overall system faster, \nat least as measured by the clock on your wall.\nJust as important is that modern software systems are expected to be responsive to \nusers regardless of the amount of work they must perform behind the scenes. It\u2019s usually \nunacceptable for a program to stall while busy carrying out a request. Consider an \nemail-browser user interface, for example; when asked to fetch email from a server, the \nprogram must download text from a server over a network. If you have enough email \nor a slow enough Internet link, that step alone can take minutes to finish. But while the\n* To watch on Windows, click the Start button, select All Programs \u2192 Accessories \u2192 System Tools \u2192 Resource \nMonitor, and monitor CPU/Processor usage (Task Manager\u2019s Performance tab may give similar results). The \ngraph rarely climbed above single-digit percentages on my laptop machine while writing this footnote (at \nleast until I typed while True: pass in a Python interactive session window\u2026).\n177download task proceeds, the program as a whole shouldn\u2019t stall\u2014it still must respond\nto screen redraws, mouse clicks, and so on.\nParallel processing comes to the rescue here, too. By performing such long-running\ntasks in parallel with the rest of the program, the system at large can remain responsive\nno matter how busy some of its parts may be. Moreover, the parallel processing model\nis a natural fit for structuring such programs and others; some tasks are more easily\nconceptualized and coded as components running as independent, parallel entities.\nThere are two fundamental ways to get tasks running at the same time in Python\u2014\nprocess forks and spawned threads. Functionally, both rely on underlying operating\nsystem services to run bits of Python code in parallel. Procedurally, they are very dif-\nferent in terms of interface, portability, and communication. For instance, at this writ-\ning direct process forks are not supported on Windows under standard Python (though\nthey are under Cygwin Python on Windows).\nBy contrast, Python\u2019s thread support works on all major platforms. Moreover, the\nos.spawn family of calls provides additional ways to launch programs in a platform-\nneutral way that is similar to forks, and the os.popen and os.system calls and\nsubprocess module we studied in Chapters 2 and 3 can be used to portably spawn\nprograms with shell commands. The newer multiprocessing module offers additional\nways to run processes portably in many contexts.\nIn this chapter, which is a continuation of our look at system interfaces available to\nPython programmers, we explore Python\u2019s built-in tools for starting tasks in parallel,\nas well as communicating with those tasks. In some sense, we\u2019ve already begun doing\nso\u2014os.system, os.popen, and subprocess, which we learned and applied over the last\nthree chapters, are a fairly portable way to spawn and speak with command-line pro-\ngrams, too. We won\u2019t repeat full coverage of those tools here.\nInstead, our emphasis in this chapter is on introducing more direct techniques\u2014forks,\nthreads, pipes, signals, sockets, and other launching techniques\u2014and on using Py-\nthon\u2019s built-in tools that support them, such as the os.fork call and the threading,\nqueue, and multiprocessing modules. In the next chapter (and in the remainder of this\nbook), we use these techniques in more realistic programs, so be sure you understand\nthe basics here before flipping ahead.\nOne note up front: although the process, thread, and IPC mechanisms we will explore\nin this chapter are the primary parallel processing tools in Python scripts, the third party\ndomain offers additional options which may serve more advanced or specialized roles.\nAs just one example, the MPI for Python system allows Python scripts to also employ\nthe Message Passing Interface (MPI) standard, allowing Python programs to exploit\nmultiple processors in various ways (see the Web for details). While such specific ex-\ntensions are beyond our scope in this book, the fundamentals of multiprocessing that\nwe will explore here should apply to more advanced techniques you may encounter in\nyour parallel futures.\n178 | Chapter 5:\u2002Parallel System ToolsForking Processes\nForked processes are a traditional way to structure parallel tasks, and they are a fun-\ndamental part of the Unix tool set. Forking is a straightforward way to start an inde-\npendent program, whether it is different from the calling program or not. Forking is\nbased on the notion of copying programs: when a program calls the fork routine, the\noperating system makes a new copy of that program and its process in memory and\nstarts running that copy in parallel with the original. Some systems don\u2019t really copy\nthe original program (it\u2019s an expensive operation), but the new copy works as if it were\na literal copy.\nAfter a fork operation, the original copy of the program is called the parent process,\nand the copy created by os.fork is called the child process. In general, parents can make\nany number of children, and children can create child processes of their own; all forked\nprocesses run independently and in parallel under the operating system\u2019s control, and\nchildren may continue to run after their parent exits.\nThis is probably simpler in practice than in theory, though. The Python script in Ex-\nample 5-1 forks new child processes until you type the letter q at the console.\nExample 5-1. PP4E\\System\\Processes\\fork1.py\n\"forks child processes until you type 'q'\"\nimport os\ndef child():\n    print('Hello from child',  os.getpid())\n    os._exit(0)  # else goes back to parent loop\ndef parent():\n    while True:\n        newpid = os.fork()\n        if newpid == 0:\n            child()\n        else:\n            print('Hello from parent', os.getpid(), newpid)\n        if input() == 'q': break\nparent()\nPython\u2019s process forking tools, available in the os module, are simply thin wrappers\nover standard forking calls in the system library also used by C language programs. To\nstart a new, parallel process, call the os.fork built-in function. Because this function\ngenerates a copy of the calling program, it returns a different value in each copy: zero\nin the child process and the process ID of the new child in the parent.\nForking Processes | 179Programs generally test this result to begin different processing in the child only; this\nscript, for instance, runs the child function in child processes only.\u2020\nBecause forking is ingrained in the Unix programming model, this script works well on\nUnix, Linux, and modern Macs. Unfortunately, this script won\u2019t work on the standard\nversion of Python for Windows today, because fork is too much at odds with the Win-\ndows model. Python scripts can always spawn threads on Windows, and the multi\nprocessing module described later in this chapter provides an alternative for running\nprocesses portably, which can obviate the need for process forks on Windows in con-\ntexts that conform to its constraints (albeit at some potential cost in low-level control).\nThe script in Example 5-1 does work on Windows, however, if you use the Python\nshipped with the Cygwin system (or build one of your own from source-code with\nCygwin\u2019s libraries). Cygwin is a free, open source system that provides full Unix-like\nfunctionality for Windows (and is described further in \u201cMore on Cygwin Python for\nWindows\u201d on page 185). You can fork with Python on Windows under Cygwin, even\nthough its behavior is not exactly the same as true Unix forks. Because it\u2019s close enough\nfor this book\u2019s examples, though, let\u2019s use it to run our script live:\n[C:\\...\\PP4E\\System\\Processes]$ python fork1.py\nHello from parent 7296 7920\nHello from child 7920\nHello from parent 7296 3988\nHello from child 3988\nHello from parent 7296 6796\nHello from child 6796\nq\nThese messages represent three forked child processes; the unique identifiers of all the\nprocesses involved are fetched and displayed with the os.getpid call. A subtle point:\nthe child process function is also careful to exit explicitly with an os._exit call. We\u2019ll\ndiscuss this call in more detail later in this chapter, but if it\u2019s not made, the child process\nwould live on after the child function returns (remember, it\u2019s just a copy of the original\nprocess). The net effect is that the child would go back to the loop in parent and start\nforking children of its own (i.e., the parent would have grandchildren). If you delete\nthe exit call and rerun, you\u2019ll likely have to type more than one q to stop, because\nmultiple processes are running in the parent function.\nIn Example 5-1, each process exits very soon after it starts, so there\u2019s little overlap in\ntime. Let\u2019s do something slightly more sophisticated to better illustrate multiple forked\nprocesses running in parallel. Example 5-2 starts up 5 copies of itself, each copy count-\ning up to 5 with a one-second delay between iterations. The time.sleep standard library\n\u2020 At least in the current Python implementation, calling os.fork in a Python script actually copies the Python\ninterpreter process (if you look at your process list, you\u2019ll see two Python entries after a fork). But since the\nPython interpreter records everything about your running script, it\u2019s OK to think of fork as copying your\nprogram directly. It really will if Python scripts are ever compiled to binary machine code.\n180 | Chapter 5:\u2002Parallel System Toolscall simply pauses the calling process for a number of seconds (you can pass a floating-\npoint value to pause for fractions of seconds).\nExample 5-2. PP4E\\System\\Processes\\fork-count.py\n\"\"\"\nfork basics: start 5 copies of this program running in parallel with\nthe original; each copy counts up to 5 on the same stdout stream--forks\ncopy process memory, including file descriptors; fork doesn't currently\nwork on Windows without Cygwin: use os.spawnv or multiprocessing on\nWindows instead; spawnv is roughly like a fork+exec combination;\n\"\"\"\nimport os, time\ndef counter(count):                                    # run in new process\n    for i in range(count):\n        time.sleep(1)                                  # simulate real work\n        print('[%s] => %s' % (os.getpid(), i))\nfor i in range(5):\n    pid = os.fork()\n    if pid != 0:\n        print('Process %d spawned' % pid)              # in parent: continue\n    else:\n        counter(5)                                     # else in child/new process\n        os._exit(0)                                    # run function and exit\nprint('Main process exiting.')                         # parent need not wait\nWhen run, this script starts 5 processes immediately and exits. All 5 forked processes\ncheck in with their first count display one second later and every second thereafter.\nNotice that child processes continue to run, even if the parent process that created them\nterminates:\n[C:\\...\\PP4E\\System\\Processes]$ python fork-count.py\nProcess 4556 spawned\nProcess 3724 spawned\nProcess 6360 spawned\nProcess 6476 spawned\nProcess 6684 spawned\nMain process exiting.\n[4556] => 0\n[3724] => 0\n[6360] => 0\n[6476] => 0\n[6684] => 0\n[4556] => 1\n[3724] => 1\n[6360] => 1\n[6476] => 1\n[6684] => 1\n[4556] => 2\n[3724] => 2\n[6360] => 2\nForking Processes | 181[6476] => 2\n[6684] => 2\n...more output omitted...\nThe output of all of these processes shows up on the same screen, because all of them\nshare the standard output stream (and a system prompt may show up along the way,\ntoo). Technically, a forked process gets a copy of the original process\u2019s global memory,\nincluding open file descriptors. Because of that, global objects like files start out with\nthe same values in a child process, so all the processes here are tied to the same single\nstream. But it\u2019s important to remember that global memory is copied, not shared; if a\nchild process changes a global object, it changes only its own copy. (As we\u2019ll see, this\nworks differently in threads, the topic of the next section.)\nThe fork/exec Combination\nIn Examples 5-1 and 5-2, child processes simply ran a function within the Python pro-\ngram and then exited. On Unix-like platforms, forks are often the basis of starting\nindependently running programs that are completely different from the program that\nperformed the fork call. For instance, Example 5-3 forks new processes until we type\nq again, but child processes run a brand-new program instead of calling a function in\nthe same file.\nExample 5-3. PP4E\\System\\Processes\\fork-exec.py\n\"starts programs until you type 'q'\"\nimport os\nparm = 0\nwhile True:\n    parm += 1\n    pid = os.fork()\n    if pid == 0:                                             # copy process\n        os.execlp('python', 'python', 'child.py', str(parm)) # overlay program\n        assert False, 'error starting program'               # shouldn't return\n    else:\n        print('Child is', pid)\n        if input() == 'q': break\nIf you\u2019ve done much Unix development, the fork/exec combination will probably look\nfamiliar. The main thing to notice is the os.execlp call in this code. In a nutshell, this\ncall replaces (overlays) the program running in the current process with a brand new\nprogram. Because of that, the combination of os.fork and os.execlp means start a new\nprocess and run a new program in that process\u2014in other words, launch a new program\nin parallel with the original program.\n182 | Chapter 5:\u2002Parallel System Toolsos.exec call formats\nThe arguments to os.execlp specify the program to be run by giving command-line\narguments used to start the program (i.e., what Python scripts know as sys.argv). If\nsuccessful, the new program begins running and the call to os.execlp itself never returns\n(since the original program has been replaced, there\u2019s really nothing to return to). If\nthe call does return, an error has occurred, so we code an assert after it that will always\nraise an exception if reached.\nThere are a handful of os.exec variants in the Python standard library; some allow us\nto configure environment variables for the new program, pass command-line argu-\nments in different forms, and so on. All are available on both Unix and Windows, and\nthey replace the calling program (i.e., the Python interpreter). exec comes in eight fla-\nvors, which can be a bit confusing unless you generalize:\nos.execv(program, commandlinesequence)\nThe basic \u201cv\u201d exec form is passed an executable program\u2019s name, along with a list\nor tuple of command-line argument strings used to run the executable (that is, the\nwords you would normally type in a shell to start a program).\nos.execl(program, cmdarg1, cmdarg2,... cmdargN)\nThe basic \u201cl\u201d exec form is passed an executable\u2019s name, followed by one or more\ncommand-line arguments passed as individual function arguments. This is the\nsame as os.execv(program, (cmdarg1, cmdarg2,...)).\nos.execlp\nos.execvp\nAdding the letter p to the execv and execl names means that Python will locate the\nexecutable\u2019s directory using your system search-path setting (i.e., PATH).\nos.execle\nos.execve\nAdding a letter e to the execv and execl names means an extra, last argument is a\ndictionary containing shell environment variables to send to the program.\nos.execvpe\nos.execlpe\nAdding the letters p and e to the basic exec names means to use the search path\nand to accept a shell environment settings dictionary.\nSo when the script in Example 5-3 calls os.execlp, individually passed parameters\nspecify a command line for the program to be run on, and the word python maps to an\nexecutable file according to the underlying system search-path setting environment\nvariable (PATH). It\u2019s as if we were running a command of the form python child.py 1\nin a shell, but with a different command-line argument on the end each time.\nForking Processes | 183Spawned child program\nJust as when typed at a shell, the string of arguments passed to os.execlp by the fork-\nexec script in Example 5-3 starts another Python program file, as shown in Example 5-4.\nExample 5-4. PP4E\\System\\Processes\\child.py\nimport os, sys\nprint('Hello from child', os.getpid(), sys.argv[1])\nHere is this code in action on Linux. It doesn\u2019t look much different from the original\nfork1.py, but it\u2019s really running a new program in each forked process. More observant\nreaders may notice that the child process ID displayed is the same in the parent program\nand the launched child.py program; os.execlp simply overlays a program in the same\nprocess:\n[C:\\...\\PP4E\\System\\Processes]$ python fork-exec.py\nChild is 4556\nHello from child 4556 1\nChild is 5920\nHello from child 5920 2\nChild is 316\nHello from child 316 3\nq\nThere are other ways to start up programs in Python besides the fork/exec combination.\nFor example, the os.system and os.popen calls and subprocess module which we ex-\nplored in Chapters 2 and 3 allow us to spawn shell commands. And the os.spawnv call\nand multiprocessing module, which we\u2019ll meet later in this chapter, allow us to start\nindependent programs and processes more portably. In fact, we\u2019ll see later that multi\nprocessing\u2019s process spawning model can be used as a sort of portable replacement for\nos.fork in some contexts (albeit a less efficient one) and used in conjunction with the\nos.exec* calls shown here to achieve a similar effect in standard Windows Python.\nWe\u2019ll see more process fork examples later in this chapter, especially in the program\nexits and process communication sections, so we\u2019ll forego additional examples here.\nWe\u2019ll also discuss additional process topics in later chapters of this book. For instance,\nforks are revisited in Chapter 12 to deal with servers and their zombies\u2014dead processes\nlurking in system tables after their demise. For now, let\u2019s move on to threads, a subject\nwhich at least some programmers find to be substantially less frightening\u2026\n184 | Chapter 5:\u2002Parallel System ToolsMore on Cygwin Python for Windows\nAs mentioned, the os.fork call is present in the Cygwin version of Python on Windows.\nEven though this call is missing in the standard version of Python for Windows, you\ncan fork processes on Windows with Python if you install and use Cygwin. However,\nthe Cygwin fork call is not as efficient and does not work exactly the same as a fork on\ntrue Unix systems.\nCygwin is a free, open source package which includes a library that attempts to provide\na Unix-like API for use on Windows machines, along with a set of command-line tools\nthat implement a Unix-like environment. It makes it easier to apply Unix skills and\ncode on Windows computers.\nAccording to its FAQ documentation, though, \u201cCygwin fork() essentially works like a\nnoncopy on write version of fork() (like old Unix versions used to do). Because of this\nit can be a little slow. In most cases, you are better off using the spawn family of calls\nif possible.\u201d Since this book\u2019s fork examples don\u2019t need to care about performance,\nCygwin\u2019s fork suffices.\nIn addition to the fork call, Cygwin provides other Unix tools that would otherwise not\nbe available on all flavors of Windows, including os.mkfifo (discussed later in this\nchapter). It also comes with a gcc compiler environment for building C extensions for\nPython on Windows that will be familiar to Unix developers. As long as you\u2019re willing\nto use Cygwin libraries to build your application and power your Python, it\u2019s very close\nto Unix on Windows.\nLike all third-party libraries, though, Cygwin adds an extra dependency to your sys-\ntems. Perhaps more critically, Cygwin currently uses the GNU GPL license, which adds\ndistribution requirements beyond those of standard Python. Unlike using Python itself,\nshipping a program that uses Cygwin libraries may require that your program\u2019s source\ncode be made freely available (though RedHat offers a \u201cbuy-out\u201d option which can\nrelieve you of this requirement). Note that this is a complex legal issue, and you should\nstudy Cygwin\u2019s license on your own if this may impact your programs. Its license does,\nhowever, impose more constraints than Python\u2019s (Python uses a \u201cBSD\u201d-style license,\nnot the GPL).\nDespite licensing issue, Cygwin still can be a great way to get Unix-like functionality\non Windows without installing a completely different operating system such as\nLinux\u2014a more complete but generally more complex option. For more details, see\nhttp://cygwin.com or run a search for Cygwin on the Web.\nSee also the standard library\u2019s multiprocessing module and os.spawn family of calls,\ncovered later in this chapter, for alternative way to start parallel tasks and programs on\nUnix and Windows that do not require fork and exec calls. To run a simple function\ncall in parallel on Windows (rather than on an external program), also see the section\non standard library threads later in this chapter. Threads, multiprocessing, and\nos.spawn calls work on Windows in standard Python.\nForking Processes | 185Fourth Edition Update: As I was updating this chapter in February 2010, Cygwin\u2019s\nofficial Python was still Python 2.5.2. To get Python 3.1 under Cygwin, it had to be\nbuilt from its source code. If this is still required when you read this, make sure you\nhave gcc and make installed on your Cygwin, then fetch Python\u2019s source code package\nfrom python.org, unpack it, and build Python with the usual commands:\n    ./configure\n    make\n    make test\n    sudo make install\nThis will install Python as python3. The same procedure works on all Unix-like plat-\nforms; on OS X and Cygwin, the executable is called python.exe; elsewhere it\u2019s named\npython. You can generally skip the last two of the above steps if you\u2019re willing to run\nPython 3.1 out of your own build directory. Be sure to also check if Python 3.X is a\nstandard Cygwin package by the time you read this; when building from source you\nmay have to tweak a few files (I had to comment-out a #define in Modules/main.c), but\nthese are too specific and temporal to get into here.\nThreads\nThreads are another way to start activities running at the same time. In short, they run\na call to a function (or any other type of callable object) in parallel with the rest of the\nprogram. Threads are sometimes called \u201clightweight processes,\u201d because they run in\nparallel like forked processes, but all of them run within the same single process. While\nprocesses are commonly used to start independent programs, threads are commonly\nused for tasks such as nonblocking input calls and long-running tasks in a GUI. They\nalso provide a natural model for algorithms that can be expressed as independently\nrunning tasks. For applications that can benefit from parallel processing, some devel-\nopers consider threads to offer a number of advantages:\nPerformance\nBecause all threads run within the same process, they don\u2019t generally incur a big\nstartup cost to copy the process itself. The costs of both copying forked processes\nand running threads can vary per platform, but threads are usually considered less\nexpensive in terms of performance overhead.\nSimplicity\nTo many observers, threads can be noticeably simpler to program, too, especially\nwhen some of the more complex aspects of processes enter the picture (e.g., process\nexits, communication schemes, and zombie processes, covered in Chapter 12).\nShared global memory\nOn a related note, because threads run in a single process, every thread shares the\nsame global memory space of the process. This provides a natural and easy way\nfor threads to communicate\u2014by fetching and setting names or objects accessible\nto all the threads. To the Python programmer, this means that things like global\n186 | Chapter 5:\u2002Parallel System Toolsscope variables, passed objects and their attributes, and program-wide interpreter\ncomponents such as imported modules are shared among all threads in a program;\nif one thread assigns a global variable, for instance, its new value will be seen by\nother threads. Some care must be taken to control access to shared items, but to\nsome this seems generally simpler to use than the process communication tools\nnecessary for forked processes, which we\u2019ll meet later in this chapter and book\n(e.g., pipes, streams, signals, sockets, etc.). Like much in programming, this is not\na universally shared view, however, so you\u2019ll have to weigh the difference for your\nprograms and platforms yourself.\nPortability\nPerhaps most important is the fact that threads are more portable than forked\nprocesses. At this writing, os.fork is not supported by the standard version of\nPython on Windows, but threads are. If you want to run parallel tasks portably in\na Python script today and you are unwilling or unable to install a Unix-like library\nsuch as Cygwin on Windows, threads may be your best bet. Python\u2019s thread tools\nautomatically account for any platform-specific thread differences, and they pro-\nvide a consistent interface across all operating systems. Having said that, the rela-\ntively new multiprocessing module described later in this chapter offers another\nanswer to the process portability issue in some use cases.\nSo what\u2019s the catch? There are three potential downsides you should be aware of before\nyou start spinning your threads:\nFunction calls versus programs\nFirst of all, threads are not a way\u2014at least, not a direct way\u2014to start up another\nprogram. Rather, threads are designed to run a call to a function (technically, any\ncallable, including bound and unbound methods) in parallel with the rest of the\nprogram. As we saw in the prior section, by contrast, forked processes can either\ncall a function or start a new program. Naturally, the threaded function can run\nscripts with the exec built-in function and can start new programs with tools such\nas os.system, os.popen and the subprocess module, especially if doing so is itself a\nlong-running task. But fundamentally, threads run in-program functions.\nIn practice, this is usually not a limitation. For many applications, parallel functions\nare sufficiently powerful. For instance, if you want to implement nonblocking input\nand output and avoid blocking a GUI or its users with long-running tasks, threads\ndo the job; simply spawn a thread to run a function that performs the potentially\nlong-running task. The rest of the program will continue independently.\nThread synchronization and queues\nSecondly, the fact that threads share objects and names in global process memory\nis both good news and bad news\u2014it provides a communication mechanism, but\nwe have to be careful to synchronize a variety of operations. As we\u2019ll see, even\noperations such as printing are a potential conflict since there is only one\nsys.stdout per process, which is shared by all threads.\nThreads | 187Luckily, the Python queue module, described in this section, makes this simple:\nrealistic threaded programs are usually structured as one or more producer (a.k.a.\nworker) threads that add data to a queue, along with one or more consumer threads\nthat take the data off the queue and process it. In a typical threaded GUI, for\nexample, producers may download or compute data and place it on the queue; the\nconsumer\u2014the main GUI thread\u2014checks the queue for data periodically with a\ntimer event and displays it in the GUI when it arrives. Because the shared queue is\nthread-safe, programs structured this way automatically synchronize much cross-\nthread data communication.\nThe global interpreter lock (GIL)\nFinally, as we\u2019ll learn in more detail later in this section, Python\u2019s implementation\nof threads means that only one thread is ever really running its Python language\ncode in the Python virtual machine at any point in time. Python threads are true\noperating system threads, but all threads must acquire a single shared lock when\nthey are ready to run, and each thread may be swapped out after running for a short\nperiod of time (currently, after a set number of virtual machine instructions, though\nthis implementation may change in Python 3.2).\nBecause of this structure, the Python language parts of Python threads cannot today\nbe distributed across multiple CPUs on a multi-CPU computer. To leverage more\nthan one CPU, you\u2019ll simply need to use process forking, not threads (the amount\nand complexity of code required for both are roughly the same). Moreover, the\nparts of a thread that perform long-running tasks implemented as C extensions can\nrun truly independently if they release the GIL to allow the Python code of other\nthreads to run while their task is in progress. Python code, however, cannot truly\noverlap in time.\nThe advantage of Python\u2019s implementation of threads is performance\u2014when it\nwas attempted, making the virtual machine truly thread-safe reportedly slowed all\nprograms by a factor of two on Windows and by an even larger factor on Linux.\nEven nonthreaded programs ran at half speed.\nEven though the GIL\u2019s multiplexing of Python language code makes Python\nthreads less useful for leveraging capacity on multiple CPU machines, threads are\nstill useful as programming tools to implement nonblocking operations, especially\nin GUIs. Moreover, the newer multiprocessing module we\u2019ll meet later offers an-\nother solution here, too\u2014by providing a portable thread-like API that is imple-\nmented with processes, programs can both leverage the simplicity and\nprogrammability of threads and benefit from the scalability of independent pro-\ncesses across CPUs.\nDespite what you may think after reading the preceding overview, threads are remark-\nably easy to use in Python. In fact, when a program is started it is already running a\nthread, usually called the \u201cmain thread\u201d of the process. To start new, independent\nthreads of execution within a process, Python code uses either the low-level _thread\nmodule to run a function call in a spawned thread, or the higher-level threading module\n188 | Chapter 5:\u2002Parallel System Toolsto manage threads with high-level class-based objects. Both modules also provide tools\nfor synchronizing access to shared objects with locks.\nThis book presents both the _thread and threading modules, and its\nexamples use both interchangeably. Some Python users would recom-\nmend that you always use threading rather than _thread in general. In\nfact, the latter was renamed from thread to _thread in 3.X to suggest\nsuch a lesser status for it. Personally, I think that is too extreme (and\nthis is one reason this book sometimes uses as thread in imports to\nretain the original module name). Unless you need the more powerful\ntools in threading, the choice is largely arbitrary, and the threading\nmodule\u2019s extra requirements may be unwarranted.\nThe basic thread module does not impose OOP, and as you\u2019ll see in the\nexamples of this section, is very straightforward to use. The threading\nmodule may be better for more complex tasks which require per-thread\nstate retention or joins, but not all threaded programs require its extra\ntools, and many use threads in more limited scopes. In fact, this is\nroughly the same as comparing the os.walk call and visitor classes we\u2019ll\nmeet in Chapter 6\u2014both have valid audiences and use cases. The most\ngeneral Python rule of thumb applies here as always: keep it simple,\nunless it has to be complex.\nThe _thread Module\nSince the basic _thread module is a bit simpler than the more advanced threading\nmodule covered later in this section, let\u2019s look at some of its interfaces first. This module\nprovides a portable interface to whatever threading system is available in your platform:\nits interfaces work the same on Windows, Solaris, SGI, and any system with an installed\npthreads POSIX threads implementation (including Linux and others). Python scripts\nthat use the Python _thread module work on all of these platforms without changing\ntheir source code.\nBasic usage\nLet\u2019s start off by experimenting with a script that demonstrates the main thread inter-\nfaces. The script in Example 5-5 spawns threads until you reply with a q at the console;\nit\u2019s similar in spirit to (and a bit simpler than) the script in Example 5-1, but it goes\nparallel with threads instead of process forks.\nExample 5-5. PP4E\\System\\Threads\\thread1.py\n\"spawn threads until you type 'q'\"\nimport _thread\ndef child(tid):\nThreads | 189print('Hello from thread', tid)\ndef parent():\n    i = 0\n    while True:\n        i += 1\n        _thread.start_new_thread(child, (i,))\n        if input() == 'q': break\nparent()\nThis script really contains only two thread-specific lines: the import of the _thread\nmodule and the thread creation call. To start a thread, we simply call the\n_thread.start_new_thread function, no matter what platform we\u2019re programming\non.\u2021 This call takes a function (or other callable) object and an arguments tuple and\nstarts a new thread to execute a call to the passed function with the passed arguments.\nIt\u2019s almost like Python\u2019s function(*args) call syntax, and similarly accepts an optional\nkeyword arguments dictionary, too, but in this case the function call begins running in\nparallel with the rest of the program.\nOperationally speaking, the _thread.start_new_thread call itself returns immediately\nwith no useful value, and the thread it spawns silently exits when the function being\nrun returns (the return value of the threaded function call is simply ignored). Moreover,\nif a function run in a thread raises an uncaught exception, a stack trace is printed and\nthe thread exits, but the rest of the program continues. With the _thread module, the\nentire program exits silently on most platforms when the main thread does (though as\nwe\u2019ll see later, the threading module may require special handling if child threads are\nstill running).\nIn practice, though, it\u2019s almost trivial to use threads in a Python script. Let\u2019s run this\nprogram to launch a few threads; we can run it on both Unix-like platforms and Win-\ndows this time, because threads are more portable than process forks\u2014here it is\nspawning threads on Windows:\nC:\\...\\PP4E\\System\\Threads> python thread1.py\nHello from thread 1\nHello from thread 2\nHello from thread 3\nHello from thread 4\nq\n\u2021 The _thread examples in this book now all use start_new_thread. This call is also available as\nthread.start_new for historical reasons, but this synonym may be removed in a future Python release. As of\nPython 3.1, both names are still available, but the help documentation for start_new claims that it is obsolete;\nin other words, you should probably prefer the other if you care about the future (and this book must!).\n190 | Chapter 5:\u2002Parallel System ToolsEach message here is printed from a new thread, which exits almost as soon as it is\nstarted.\nOther ways to code threads with _thread\nAlthough the preceding script runs a simple function, any callable object may be run in\nthe thread, because all threads live in the same process. For instance, a thread can also\nrun a lambda function or bound method of an object (the following code is part of file\nthread-alts.py in the book examples package):\nimport _thread                                       # all 3 print 4294967296\ndef action(i):                                       # function run in threads\n    print(i ** 32)\nclass Power:\n    def __init__(self, i):\n        self.i = i\n    def action(self):                                # bound method run in threads\n        print(self.i ** 32)\n_thread.start_new_thread(action, (2,))               # simple function\n_thread.start_new_thread((lambda: action(2)), ())    # lambda function to defer\nobj = Power(2)\n_thread.start_new_thread(obj.action, ())             # bound method object\nAs we\u2019ll see in larger examples later in this book, bound methods are especially useful\nin this role\u2014because they remember both the method function and instance object,\nthey also give access to state information and class methods for use within and during\nthe thread.\nMore fundamentally, because threads all run in the same process, bound methods run\nby threads reference the original in-process instance object, not a copy of it. Hence, any\nchanges to its state made in a thread will be visible to all threads automatically. More-\nover, since bound methods of a class instance pass for callables interchangeably with\nsimple functions, using them in threads this way just works. And as we\u2019ll see later, the\nfact that they are normal objects also allows them to be stored freely on shared queues.\nRunning multiple threads\nTo really understand the power of threads running in parallel, though, we have to do\nsomething more long-lived in our threads, just as we did earlier for processes. Let\u2019s\nmutate the fork-count program of the prior section to use threads. The script in Ex-\nample 5-6 starts 5 copies of its counter function running in parallel threads.\nExample 5-6. PP4E\\System\\Threads\\thread-count.py\n\"\"\"\nthread basics: start 5 copies of a function running in parallel;\nThreads | 191uses time.sleep so that the main thread doesn't die too early--\nthis kills all other threads on some platforms; stdout is shared:\nthread outputs may be intermixed in this version arbitrarily.\n\"\"\"\nimport _thread as thread, time\ndef counter(myId, count):                        # function run in threads\n    for i in range(count):\n        time.sleep(1)                            # simulate real work\n        print('[%s] => %s' % (myId, i))\nfor i in range(5):                               # spawn 5 threads\n    thread.start_new_thread(counter, (i, 5))     # each thread loops 5 times\ntime.sleep(6)\nprint('Main thread exiting.')                    # don't exit too early\nEach parallel copy of the counter function simply counts from zero up to four here and\nprints a message to standard output for each count.\nNotice how this script sleeps for 6 seconds at the end. On Windows and Linux machines\nthis has been tested on, the main thread shouldn\u2019t exit while any spawned threads are\nrunning if it cares about their work; if it does exit, all spawned threads are immediately\nterminated. This differs from processes, where spawned children live on when parents\nexit. Without the sleep here, the spawned threads would die almost immediately after\nthey are started.\nThis may seem ad hoc, but it isn\u2019t required on all platforms, and programs are usually\nstructured such that the main thread naturally lives as long as the threads it starts. For\ninstance, a user interface may start an FTP download running in a thread, but the\ndownload lives a much shorter life than the user interface itself. Later in this section,\nwe\u2019ll also see different ways to avoid this sleep using global locks and flags that let\nthreads signal their completion.\nMoreover, we\u2019ll later find that the threading module both provides a join method that\nlets us wait for spawned threads to finish explicitly, and refuses to allow a program to\nexit at all if any of its normal threads are still running (which may be useful in this case,\nbut can require extra work to shut down in others). The multiprocessing module we\u2019ll\nmeet later in this chapter also allows spawned children to outlive their parents, though\nthis is largely an artifact of its process-based model.\nNow, when Example 5-6 is run on Windows 7 under Python 3.1, here is the output I get:\nC:\\...\\PP4E\\System\\Threads> python thread-count.py\n[1] => 0\n[1] => 0\n[0] => 0\n[1] => 0\n[0] => 0\n[2] => 0\n[3] => 0\n192 | Chapter 5:\u2002Parallel System Tools[3] => 0\n[1] => 1\n[3] => 1\n[3] => 1\n[0] => 1[2] => 1\n[3] => 1\n[0] => 1[2] => 1\n[4] => 1\n[1] => 2\n[3] => 2[4] => 2\n[3] => 2[4] => 2\n[0] => 2\n[3] => 2[4] => 2\n[0] => 2\n[2] => 2\n[3] => 2[4] => 2\n[0] => 2\n[2] => 2\n...more output omitted...\nMain thread exiting.\nIf this looks odd, it\u2019s because it should. In fact, this demonstrates probably the most\nunusual aspect of threads. What\u2019s happening here is that the output of the 5 threads\nrun in parallel is intermixed\u2014because all the threaded function calls run in the same\nprocess, they all share the same standard output stream (in Python terms, there is just\none sys.stdout file between them, which is where printed text is sent). The net effect\nis that their output can be combined and confused arbitrarily. In fact, this script\u2019s\noutput can differ on each run. This jumbling of output grew even more pronounced in\nPython 3, presumably due to its new file output implementation.\nMore fundamentally, when multiple threads can access a shared resource like this, their\naccess must be synchronized to avoid overlap in time\u2014as explained in the next section.\nSynchronizing access to shared objects and names\nOne of the nice things about threads is that they automatically come with a cross-task\ncommunications mechanism: objects and namespaces in a process that span the life of\nthreads are shared by all spawned threads. For instance, because every thread runs in\nthe same process, if one Python thread changes a global scope variable, the change can\nbe seen by every other thread in the process, main or child. Similarly, threads can share\nand change mutable objects in the process\u2019s memory as long as they hold a reference\nto them (e.g., passed-in arguments). This serves as a simple way for a program\u2019s threads\nto pass information\u2014exit flags, result objects, event indicators, and so on\u2014back and\nforth to each other.\nThe downside to this scheme is that our threads must sometimes be careful to avoid\nchanging global objects and names at the same time. If two threads may change a shared\nobject at once, it\u2019s not impossible that one of the two changes will be lost (or worse,\nThreads | 193will silently corrupt the state of the shared object completely): one thread may step on\nthe work done so far by another whose operations are still in progress. The extent to\nwhich this becomes an issue varies per application, and sometimes it isn\u2019t an issue at all.\nBut even things that aren\u2019t obviously at risk may be at risk. Files and streams, for ex-\nample, are shared by all threads in a program; if multiple threads write to one stream\nat the same time, the stream might wind up with interleaved, garbled data. Exam-\nple 5-6 of the prior section was a simple demonstration of this phenomenon in action,\nbut it\u2019s indicative of the sorts of clashes in time that can occur when our programs go\nparallel. Even simple changes can go awry if they might happen concurrently. To be\nrobust, threaded programs need to control access to shared global items like these so\nthat only one thread uses them at once.\nLuckily, Python\u2019s _thread module comes with its own easy-to-use tools for synchro-\nnizing access to objects shared among threads. These tools are based on the concept\nof a lock\u2014to change a shared object, threads acquire a lock, make their changes, and\nthen release the lock for other threads to grab. Python ensures that only one thread can\nhold a lock at any point in time; if others request it while it\u2019s held, they are blocked\nuntil the lock becomes available. Lock objects are allocated and processed with simple\nand portable calls in the _thread module that are automatically mapped to thread lock-\ning mechanisms on the underlying platform.\nFor instance, in Example 5-7, a lock object created by _thread.allocate_lock is ac-\nquired and released by each thread around the print call that writes to the shared\nstandard output stream.\nExample 5-7. PP4E\\System\\Threads\\thread-count-mutex.py\n\"\"\"\nsynchronize access to stdout: because it is shared global,\nthread outputs may be intermixed if not synchronized\n\"\"\"\nimport _thread as thread, time\ndef counter(myId, count):                        # function run in threads\n    for i in range(count):\n        time.sleep(1)                            # simulate real work\n        mutex.acquire()\n        print('[%s] => %s' % (myId, i))          # print isn't interrupted now\n        mutex.release()\nmutex = thread.allocate_lock()                   # make a global lock object\nfor i in range(5):                               # spawn 5 threads\n    thread.start_new_thread(counter, (i, 5))     # each thread loops 5 times\ntime.sleep(6)\nprint('Main thread exiting.')                    # don't exit too early\nReally, this script simply augments Example 5-6 to synchronize prints with a thread\nlock. The net effect of the additional lock calls in this script is that no two threads will\n194 | Chapter 5:\u2002Parallel System Toolsever execute a print call at the same point in time; the lock ensures mutually exclusive\naccess to the stdout stream. Hence, the output of this script is similar to that of the\noriginal version, except that standard output text is never mangled by overlapping\nprints:\nC:\\...\\PP4E\\System\\Threads> thread-count-mutex.py\n[0] => 0\n[1] => 0\n[3] => 0\n[2] => 0\n[4] => 0\n[0] => 1\n[1] => 1\n[3] => 1\n[2] => 1\n[4] => 1\n[0] => 2\n[1] => 2\n[3] => 2\n[4] => 2\n[2] => 2\n[0] => 3\n[1] => 3\n[3] => 3\n[4] => 3\n[2] => 3\n[0] => 4\n[1] => 4\n[3] => 4\n[4] => 4\n[2] => 4\nMain thread exiting.\nThough somewhat platform-specific, the order in which the threads check in with their\nprints may still be arbitrary from run to run because they execute in parallel (getting\nwork done in parallel is the whole point of threads, after all); but they no longer collide\nin time while printing their text. We\u2019ll see other cases where the lock idiom comes in\nto play later in this chapter\u2014it\u2019s a core component of the multithreading model.\nWaiting for spawned thread exits\nBesides avoiding print collisions, thread module locks are surprisingly useful. They can\nform the basis of higher-level synchronization paradigms (e.g., semaphores) and can\nbe used as general thread communication devices.\u00a7 For instance, Example 5-8 uses a\nglobal list of locks to know when all child threads have finished.\n\u00a7 They cannot, however, be used to directly synchronize processes. Since processes are more independent, they\nusually require locking mechanisms that are more long-lived and external to programs. Chapter 4\u2019s\nos.open call with an open flag of O_EXCL allows scripts to lock and unlock files and so is ideal as a cross-process\nlocking tool. See also the synchronization tools in the multiprocessing and threading modules and the IPC\nsection later in this chapter for other general synchronization ideas.\nThreads | 195Example 5-8. PP4E\\System\\Threads\\thread-count-wait1.py\n\"\"\"\nuses mutexes to know when threads are done in parent/main thread,\ninstead of time.sleep; lock stdout to avoid comingled prints;\n\"\"\"\nimport _thread as thread\nstdoutmutex = thread.allocate_lock()\nexitmutexes = [thread.allocate_lock() for i in range(10)]\ndef counter(myId, count):\n    for i in range(count):\n        stdoutmutex.acquire()\n        print('[%s] => %s' % (myId, i))\n        stdoutmutex.release()\n    exitmutexes[myId].acquire()    # signal main thread\nfor i in range(10):\n    thread.start_new_thread(counter, (i, 100))\nfor mutex in exitmutexes:\n    while not mutex.locked(): pass\nprint('Main thread exiting.')\nA lock\u2019s locked method can be used to check its state. To make this work, the main\nthread makes one lock per child and tacks them onto a global exitmutexes list (re-\nmember, the threaded function shares global scope with the main thread). On exit,\neach thread acquires its lock on the list, and the main thread simply watches for all\nlocks to be acquired. This is much more accurate than na\u00efvely sleeping while child\nthreads run in hopes that all will have exited after the sleep. Run this on your own to\nsee its output\u2014all 10 spawned threads count up to 100 (they run in arbitrarily inter-\nleaved order that can vary per run and platform, but their prints run atomically and do\nnot comingle), before the main thread exits.\nDepending on how your threads run, this could be even simpler: since threads share\nglobal memory anyhow, we can usually achieve the same effect with a simple global\nlist of integers instead of locks. In Example 5-9, the module\u2019s namespace (scope) is\nshared by top-level code and the threaded function, as before. exitmutexes refers to the\nsame list object in the main thread and all threads it spawns. Because of that, changes\nmade in a thread are still noticed in the main thread without resorting to extra locks.\nExample 5-9. PP4E\\System\\Threads\\thread-count-wait2.py\n\"\"\"\nuses simple shared global data (not mutexes) to know when threads\nare done in parent/main thread; threads share list but not its items,\nassumes list won't move in memory once it has been created initially\n\"\"\"\nimport _thread as thread\nstdoutmutex = thread.allocate_lock()\n196 | Chapter 5:\u2002Parallel System Toolsexitmutexes = [False] * 10\ndef counter(myId, count):\n    for i in range(count):\n        stdoutmutex.acquire()\n        print('[%s] => %s' % (myId, i))\n        stdoutmutex.release()\n    exitmutexes[myId] = True  # signal main thread\nfor i in range(10):\n    thread.start_new_thread(counter, (i, 100))\nwhile False in exitmutexes: pass\nprint('Main thread exiting.')\nThe output of this script is similar to the prior\u201410 threads counting to 100 in parallel\nand synchronizing their prints along the way. In fact, both of the last two counting\nthread scripts produce roughly the same output as the original thread_count.py, albeit\nwithout stdout corruption and with larger counts and different random ordering of\noutput lines. The main difference is that the main thread exits immediately after (and\nno sooner than!) the spawned child threads:\nC:\\...\\PP4E\\System\\Threads> python thread-count-wait2.py\n...more deleted...\n[4] => 98\n[6] => 98\n[8] => 98\n[5] => 98\n[0] => 99\n[7] => 98\n[9] => 98\n[1] => 99\n[3] => 99\n[2] => 99\n[4] => 99\n[6] => 99\n[8] => 99\n[5] => 99\n[7] => 99\n[9] => 99\nMain thread exiting.\nCoding alternatives: busy loops, arguments, and context managers\nNotice how the main threads of both of the last two scripts fall into busy-wait loops at\nthe end, which might become significant performance drains in tight applications. If\nso, simply add a time.sleep call in the wait loops to insert a pause between end tests\nand to free up the CPU for other tasks: this call pauses the calling thread only (in this\ncase, the main one). You might also try experimenting with adding sleep calls to the\nthread function to simulate real work.\nThreads | 197Passing in the lock to threaded functions as an argument instead of referencing it in the\nglobal scope might be more coherent, too. When passed in, all threads reference the\nsame object, because they are all part of the same process. Really, the process\u2019s object\nmemory is shared memory for threads, regardless of how objects in that shared memory\nare referenced (whether through global scope variables, passed argument names, object\nattributes, or another way).\nAnd while we\u2019re at it, the with statement can be used to ensure thread operations around\na nested block of code, much like its use to ensure file closure in the prior chapter. The\nthread lock\u2019s context manager acquires the lock on with statement entry and releases\nit on statement exit regardless of exception outcomes. The net effect is to save one line\nof code, but also to guarantee lock release when exceptions are possible. Exam-\nple 5-10 adds all these coding alternatives to our threaded counter script.\nExample 5-10. PP4E\\System\\Threads\\thread-count-wait3.py\n\"\"\"\npassed in mutex object shared by all threads instead of globals;\nuse with context manager statement for auto acquire/release;\nsleep calls added to avoid busy loops and simulate real work\n\"\"\"\nimport _thread as thread, time\nstdoutmutex = thread.allocate_lock()\nnumthreads  = 5\nexitmutexes = [thread.allocate_lock() for i in range(numthreads)]\ndef counter(myId, count, mutex):                     # shared object passed in\n    for i in range(count):\n        time.sleep(1 / (myId+1))                     # diff fractions of second\n        with mutex:                                  # auto acquire/release: with\n            print('[%s] => %s' % (myId, i))\n    exitmutexes[myId].acquire()                      # global: signal main thread\nfor i in range(numthreads):\n    thread.start_new_thread(counter, (i, 5, stdoutmutex))\nwhile not all(mutex.locked() for mutex in exitmutexes): time.sleep(0.25)\nprint('Main thread exiting.')\nWhen run, the different sleep times per thread make them run more independently:\nC:\\...\\PP4E\\System\\Threads> thread-count-wait3.py\n[4] => 0\n[3] => 0\n[2] => 0\n[4] => 1\n[1] => 0\n[3] => 1\n[4] => 2\n[2] => 1\n[3] => 2\n[4] => 3\n198 | Chapter 5:\u2002Parallel System Tools[4] => 4\n[0] => 0\n[1] => 1\n[2] => 2\n[3] => 3\n[3] => 4\n[2] => 3\n[1] => 2\n[2] => 4\n[0] => 1\n[1] => 3\n[1] => 4\n[0] => 2\n[0] => 3\n[0] => 4\nMain thread exiting.\nOf course, threads are for much more than counting. We\u2019ll put shared global data to\nmore practical use in \u201cAdding a User Interface\u201d on page 867, where it will serve as\ncompletion signals from child processing threads transferring data over a network to a\nmain thread controlling a tkinter GUI display, and again later in Chapter 10\u2019s thread-\ntools and Chapter 14\u2019s PyMailGUI to post results of email operations to a GUI (watch\nfor \u201cPreview: GUIs and Threads\u201d on page 208 for more pointers on this topic). Global\ndata shared among threads also turns out to be the basis of queues, which are discussed\nlater in this chapter; each thread gets or puts data using the same shared queue object.\nThe threading Module\nThe Python standard library comes with two thread modules: _thread, the basic lower-\nlevel interface illustrated thus far, and threading, a higher-level interface based on\nobjects and classes. The threading module internally uses the _thread module to im-\nplement objects that represent threads and common synchronization tools. It is loosely\nbased on a subset of the Java language\u2019s threading model, but it differs in ways that\nonly Java programmers would notice.\u2016 Example 5-11 morphs our counting threads\nexample again to demonstrate this new module\u2019s interfaces.\nExample 5-11. PP4E\\System\\Threads\\thread-classes.py\n\"\"\"\nthread class instances with state and run() for thread's action;\nuses higher-level Java-like threading module object join method (not\nmutexes or shared global vars) to know when threads are done in main\nparent thread; see library manual for more details on threading;\n\"\"\"\nimport threading\n\u2016 But in case this means you, Python\u2019s lock and condition variables are distinct objects, not something inherent\nin all objects, and Python\u2019s Thread class doesn\u2019t have all the features of Java\u2019s. See Python\u2019s library manual\nfor further details.\nThreads | 199class Mythread(threading.Thread):              # subclass Thread object\n    def __init__(self, myId, count, mutex):\n        self.myId  = myId\n        self.count = count                     # per-thread state information\n        self.mutex = mutex                     # shared objects, not globals\n        threading.Thread.__init__(self)\n    def run(self):                             # run provides thread logic\n        for i in range(self.count):            # still sync stdout access\n            with self.mutex:\n                print('[%s] => %s' % (self.myId, i))\nstdoutmutex = threading.Lock()                 # same as thread.allocate_lock()\nthreads = []\nfor i in range(10):\n    thread = Mythread(i, 100, stdoutmutex)     # make/start 10 threads\n    thread.start()                             # starts run method in a thread\n    threads.append(thread)\nfor thread in threads:\n    thread.join()                              # wait for thread exits\nprint('Main thread exiting.')\nThe output of this script is the same as that shown for its ancestors earlier (again, threads\nmay be randomly distributed in time, depending on your platform):\nC:\\...\\PP4E\\System\\Threads> python thread-classes.py\n...more deleted...\n[4] => 98\n[8] => 97\n[9] => 97\n[5] => 98\n[3] => 99\n[6] => 98\n[7] => 98\n[4] => 99\n[8] => 98\n[9] => 98\n[5] => 99\n[6] => 99\n[7] => 99\n[8] => 99\n[9] => 99\nMain thread exiting.\nUsing the threading module this way is largely a matter of specializing classes. Threads\nin this module are implemented with a Thread object, a Python class which we may\ncustomize per application by providing a run method that defines the thread\u2019s action.\nFor example, this script subclasses Thread with its own Mythread class; the run method\nwill be executed by the Thread framework in a new thread when we make a Mythread\nand call its start method.\n200 | Chapter 5:\u2002Parallel System ToolsIn other words, this script simply provides methods expected by the Thread framework.\nThe advantage of taking this more coding-intensive route is that we get both per-thread\nstate information (the usual instance attribute namespace), and a set of additional\nthread-related tools from the framework \u201cfor free.\u201d The Thread.join method used near\nthe end of this script, for instance, waits until the thread exits (by default); we can use\nthis method to prevent the main thread from exiting before its children, rather than\nusing the time.sleep calls and global locks and variables we relied on in earlier threading\nexamples.\nThe example script also uses threading.Lock to synchronize stream access as before\n(though this name is really just a synonym for _thread.allocate_lock in the current\nimplementation). The threading module may provide the extra structure of classes, but\nit doesn\u2019t remove the specter of concurrent updates in the multithreading model in \ngeneral.\nOther ways to code threads with threading\nThe Thread class can also be used to start a simple function, or any other type of callable\nobject, without coding subclasses at all\u2014if not redefined, the Thread class\u2019s default\nrun method simply calls whatever you pass to its constructor\u2019s target argument, with\nany provided arguments passed to args (which defaults to () for none). This allows us\nto use Thread to run simple functions, too, though this call form is not noticeably sim-\npler than the basic _thread module. For instance, the following code snippets sketch\nfour different ways to spawn the same sort of thread (see four-threads*.py in the exam-\nples tree; you can run all four in the same script, but would have to also synchronize\nprints to avoid overlap):\nimport threading, _thread\ndef action(i):\n    print(i ** 32)\n# subclass with state\nclass Mythread(threading.Thread):\n    def __init__(self, i):\n        self.i = i\n        threading.Thread.__init__(self)\n    def run(self):                                        # redefine run for action\n        print(self.i ** 32)\nMythread(2).start()                                       # start invokes run()\n# pass action in\nthread = threading.Thread(target=(lambda: action(2)))     # run invokes target\nthread.start()\n# same but no lambda wrapper for state\nthreading.Thread(target=action, args=(2,)).start()        # callable plus its args\n# basic thread module\n_thread.start_new_thread(action, (2,))                    # all-function interface\nThreads | 201As a rule of thumb, class-based threads may be better if your threads require per-thread\nstate, or can leverage any of OOP\u2019s many benefits in general. Your thread classes don\u2019t\nnecessarily have to subclass Thread, though. In fact, just as in the _thread module, the\nthread\u2019s target in threading may be any type of callable object. When combined with\ntechniques such as bound methods and nested scope references, the choice between\ncoding techniques becomes even less clear-cut:\n# a non-thread class with state, OOP\nclass Power:\n    def __init__(self, i):\n        self.i = i\n    def action(self):\n        print(self.i ** 32)\nobj = Power(2)\nthreading.Thread(target=obj.action).start()        # thread runs bound method\n# nested scope to retain state\ndef action(i):\n    def power():\n        print(i ** 32)\n    return power\nthreading.Thread(target=action(2)).start()         # thread runs returned function\n# both with basic thread module\n_thread.start_new_thread(obj.action, ())           # thread runs a callable object\n_thread.start_new_thread(action(2), ())\nAs usual, the threading APIs are as flexible as the Python language itself.\nSynchronizing access to shared objects and names revisited\nEarlier, we saw how print operations in threads need to be synchronized with locks to\navoid overlap, because the output stream is shared by all threads. More formally,\nthreads need to synchronize their changes to any item that may be shared across thread\nin a process\u2014both objects and namespaces. Depending on a given program\u2019s goals,\nthis might include:\n\u2022 Mutable object in memory (passed or otherwise referenced objects whose lifetimes\nspan threads)\n\u2022 Names in global scopes (changeable variables outside thread functions and classes)\n\u2022 The contents of modules (each has just one shared copy in the system\u2019s module\ntable)\nFor instance, even simple global variables can require coordination if concurrent up-\ndates are possible, as in Example 5-12.\n202 | Chapter 5:\u2002Parallel System ToolsExample 5-12. PP4E\\System\\Threads\\thread-add-random.py\n\"prints different results on different runs on Windows 7\"\nimport threading, time\ncount = 0\ndef adder():\n    global count\n    count = count + 1             # update a shared name in global scope\n    time.sleep(0.5)               # threads share object memory and global names\n    count = count + 1\nthreads = []\nfor i in range(100):\n    thread = threading.Thread(target=adder, args=())\n    thread.start()\n    threads.append(thread)\nfor thread in threads: thread.join()\nprint(count)\nHere, 100 threads are spawned to update the same global scope variable twice (with a\nsleep between updates to better interleave their operations). When run on Windows 7\nwith Python 3.1, different runs produce different results:\nC:\\...\\PP4E\\System\\Threads> thread-add-random.py\n189\nC:\\...\\PP4E\\System\\Threads> thread-add-random.py\n200\nC:\\...\\PP4E\\System\\Threads> thread-add-random.py\n194\nC:\\...\\PP4E\\System\\Threads> thread-add-random.py\n191\nThis happens because threads overlap arbitrarily in time: statements, even the simple\nassignment statements like those here, are not guaranteed to run to completion by\nthemselves (that is, they are not atomic). As one thread updates the global, it may be\nusing the partial result of another thread\u2019s work in progress. The net effect is this seem-\ningly random behavior. To make this script work correctly, we need to again use thread\nlocks to synchronize the updates\u2014when Example 5-13 is run, it always prints 200 as\nexpected.\nExample 5-13. PP4E\\System\\Threads\\thread-add-synch.py\n\"prints 200 each time, because shared resource access synchronized\"\nimport threading, time\ncount = 0\ndef adder(addlock):                 # shared lock object passed in\nThreads | 203global count\n    with addlock:\n        count = count + 1           # auto acquire/release around stmt\n    time.sleep(0.5)\n    with addlock:\n        count = count + 1           # only 1 thread updating at once\naddlock = threading.Lock()\nthreads = []\nfor i in range(100):\n    thread = threading.Thread(target=adder, args=(addlock,))\n    thread.start()\n    threads.append(thread)\nfor thread in threads: thread.join()\nprint(count)\nAlthough some basic operations in the Python language are atomic and need not be\nsynchronized, you\u2019re probably better off doing so for every potential concurrent up-\ndate. Not only might the set of atomic operations change over time, but the internal\nimplementation of threads in general can as well (and in fact, it may in Python 3.2, as\ndescribed ahead).\nOf course, this is an artificial example (spawning 100 threads to add twice isn\u2019t exactly\na real-world use case for threads!), but it illustrates the issues that threads must address\nfor any sort of potentially concurrent updates to shared object or name. Luckily, for\nmany or most realistic applications, the queue module of the next section can make\nthread synchronization an automatic artifact of program structure.\nBefore we move ahead, I should point out that besides Thread and Lock, the\nthreading module also includes higher-level objects for synchronizing access to shared\nitems (e.g., Semaphore, Condition, Event)\u2014many more, in fact, than we have space to\ncover here; see the library manual for details. For more examples of threads and forks\nin general, see the remainder this chapter as well as the examples in the GUI and net-\nwork scripting parts of this book. We will thread GUIs, for instance, to avoid blocking\nthem, and we will thread and fork network servers to avoid denying service to clients.\nWe\u2019ll also explore the threading module\u2019s approach to program exits in the absence of\njoin calls in conjunction with queues\u2014our next topic.\nThe queue Module\nYou can synchronize your threads\u2019 access to shared resources with locks, but you often\ndon\u2019t have to. As mentioned, realistically scaled threaded programs are often structured\nas a set of producer and consumer threads, which communicate by placing data on,\nand taking it off of, a shared queue. As long as the queue synchronizes access to itself,\nthis automatically synchronizes the threads\u2019 interactions.\n204 | Chapter 5:\u2002Parallel System ToolsThe Python queue module implements this storage device. It provides a standard queue\ndata structure\u2014a first-in first-out (fifo) list of Python objects, in which items are added\non one end and removed from the other. Like normal lists, the queues provided by this\nmodule may contain any type of Python object, including both simple types (strings,\nlists, dictionaries, and so on) and more exotic types (class instances, arbitrary callables\nlike functions and bound methods, and more).\nUnlike normal lists, though, the queue object is automatically controlled with thread\nlock acquire and release operations, such that only one thread can modify the queue\nat any given point in time. Because of this, programs that use a queue for their cross-\nthread communication will be thread-safe and can usually avoid dealing with locks of\ntheir own for data passed between threads.\nLike the other tools in Python\u2019s threading arsenal, queues are surprisingly simple to\nuse. The script in Example 5-14, for instance, spawns two consumer threads that watch\nfor data to appear on the shared queue and four producer threads that place data on\nthe queue periodically after a sleep interval (each of their sleep durations differs to\nsimulate a real, long-running task). In other words, this program runs 7 threads (in-\ncluding the main one), 6 of which access the shared queue in parallel.\nExample 5-14. PP4E\\System\\Threads\\queuetest.py\n\"producer and consumer threads communicating with a shared queue\"\nnumconsumers = 2                  # how many consumers to start\nnumproducers = 4                  # how many producers to start\nnummessages  = 4                  # messages per producer to put\nimport _thread as thread, queue, time\nsafeprint = thread.allocate_lock()    # else prints may overlap\ndataQueue = queue.Queue()             # shared global, infinite size\ndef producer(idnum):\n    for msgnum in range(nummessages):\n        time.sleep(idnum)\n        dataQueue.put('[producer id=%d, count=%d]' % (idnum, msgnum))\ndef consumer(idnum):\n    while True:\n        time.sleep(0.1)\n        try:\n            data = dataQueue.get(block=False)\n        except queue.Empty:\n            pass\n        else:\n            with safeprint:\n                print('consumer', idnum, 'got =>', data)\nif __name__ == '__main__':\n    for i in range(numconsumers):\n        thread.start_new_thread(consumer, (i,))\n    for i in range(numproducers):\nThreads | 205thread.start_new_thread(producer, (i,))\n    time.sleep(((numproducers-1) * nummessages) + 1)\n    print('Main thread exit.')\nBefore I show you this script\u2019s output, I want to highlight a few points in its code.\nArguments versus globals\nNotice how the queue is assigned to a global variable; because of that, it is shared by\nall of the spawned threads (all of them run in the same process and in the same global\nscope). Since these threads change an object instead of a variable name, it would work\njust as well to pass the queue object in to the threaded functions as an argument\u2014the\nqueue is a shared object in memory, regardless of how it is referenced (see\nqueuetest2.py in the examples tree for a full version that does this):\ndataQueue = queue.Queue()             # shared object, infinite size\ndef producer(idnum, dataqueue):\n    for msgnum in range(nummessages):\n        time.sleep(idnum)\n        dataqueue.put('[producer id=%d, count=%d]' % (idnum, msgnum))\ndef consumer(idnum, dataqueue): ...\nif __name__ == '__main__':\n    for i in range(numproducers):\n        thread.start_new_thread(producer, (i, dataQueue))\n    for i in range(numproducers):\n        thread.start_new_thread(producer, (i, dataQueue))\nProgram exit with child threads\nAlso notice how this script exits when the main thread does, even though consumer\nthreads are still running in their infinite loops. This works fine on Windows (and most\nother platforms)\u2014with the basic _thread module, the program ends silently when the\nmain thread does. This is why we\u2019ve had to sleep in some examples to give threads time\nto do their work, but is also why we do not need to be concerned about exiting while\nconsumer threads are still running here.\nIn the alternative threading module, though, the program will not exit if any spawned\nthreads are running, unless they are set to be daemon threads. Specifically, the entire\nprogram exits when only daemon threads are left. Threads inherit a default initial dae-\nmonic value from the thread that creates them. The initial thread of a Python program\nis considered not daemonic, though alien threads created outside this module\u2019s control\nare considered daemonic (including some threads created in C code). To override in-\nherited defaults, a thread object\u2019s daemon flag can be set manually. In other words,\nnondaemon threads prevent program exit, and programs by default do not exit until\nall threading-managed threads finish.\n206 | Chapter 5:\u2002Parallel System ToolsThis is either a feature or nonfeature, depending on your program\u2014it allows spawned\nworker threads to finish their tasks in the absence of join calls or sleeps, but it can\nprevent programs like the one in Example 5-14 from shutting down when they wish.\nTo make this example work with threading, use the following alternative code (see\nqueuetest3.py in the examples tree for a complete version of this, as well as thread-count-\nthreading.py, also in the tree, for a case where this refusal to exit can come in handy):\nimport threading, queue, time\ndef producer(idnum, dataqueue): ...\ndef consumer(idnum, dataqueue): ...\nif __name__ == '__main__':\n    for i in range(numconsumers):\n        thread = threading.Thread(target=consumer, args=(i, dataQueue))\n        thread.daemon = True  # else cannot exit!\n        thread.start()\n    waitfor = []\n    for i in range(numproducers):\n        thread = threading.Thread(target=producer, args=(i, dataQueue))\n        waitfor.append(thread)\n        thread.start()\n    for thread in waitfor: thread.join()    # or time.sleep() long enough here\n    print('Main thread exit.')\nWe\u2019ll revisit the daemons and exits issue in Chapter 10 while studying GUIs; as we\u2019ll\nsee, it\u2019s no different in that context, except that the main thread is usually the GUI itself.\nRunning the script\nNow, as coded in Example 5-14, the following is the output of this example when run\non my Windows machine. Notice that even though the queue automatically coordi-\nnates the communication of data between the threads, this script still must use a lock\nto manually synchronize access to the standard output stream; queues synchronize data\npassing, but some programs may still need to use locks for other purposes. As in prior\nexamples, if the safeprint lock is not used, the printed lines from one consumer may\nbe intermixed with those of another. It is not impossible that a consumer may be paused\nin the middle of a print operation:\nC:\\...\\PP4E\\System\\Threads> queuetest.py\nconsumer 1 got => [producer id=0, count=0]\nconsumer 0 got => [producer id=0, count=1]\nconsumer 1 got => [producer id=0, count=2]\nconsumer 0 got => [producer id=0, count=3]\nconsumer 1 got => [producer id=1, count=0]\nconsumer 1 got => [producer id=2, count=0]\nconsumer 0 got => [producer id=1, count=1]\nconsumer 1 got => [producer id=3, count=0]\nconsumer 0 got => [producer id=1, count=2]\nThreads | 207consumer 1 got => [producer id=2, count=1]\nconsumer 1 got => [producer id=1, count=3]\nconsumer 1 got => [producer id=3, count=1]\nconsumer 0 got => [producer id=2, count=2]\nconsumer 1 got => [producer id=2, count=3]\nconsumer 1 got => [producer id=3, count=2]\nconsumer 1 got => [producer id=3, count=3]\nMain thread exit.\nTry adjusting the parameters at the top of this script to experiment with different sce-\nnarios. A single consumer, for instance, would simulate a GUI\u2019s main thread. Here is \nthe output of a single-consumer run\u2014producers still add to the queue in fairly random \nfashion, because threads run in parallel with each other and with the consumer:\nC:\\...\\PP4E\\System\\Threads> queuetest.py\nconsumer 0 got => [producer id=0, count=0]\nconsumer 0 got => [producer id=0, count=1]\nconsumer 0 got => [producer id=0, count=2]\nconsumer 0 got => [producer id=0, count=3]\nconsumer 0 got => [producer id=1, count=0]\nconsumer 0 got => [producer id=2, count=0]\nconsumer 0 got => [producer id=1, count=1]\nconsumer 0 got => [producer id=3, count=0]\nconsumer 0 got => [producer id=1, count=2]\nconsumer 0 got => [producer id=2, count=1]\nconsumer 0 got => [producer id=1, count=3]\nconsumer 0 got => [producer id=3, count=1]\nconsumer 0 got => [producer id=2, count=2]\nconsumer 0 got => [producer id=2, count=3]\nconsumer 0 got => [producer id=3, count=2]\nconsumer 0 got => [producer id=3, count=3]\nMain thread exit.\nIn addition to the basics used in our script, queues may be fixed or infinite in size, and \nget and put calls may or may not block; see the Python library manual for more details \non queue interface options. Since we just simulated a typical GUI structure, though, \nlet\u2019s explore the notion a bit further.\nPreview: GUIs and Threads\nWe will return to threads and queues and see additional thread and queue examples \nwhen we study GUIs later in this book. The PyMailGUI example in Chapter 14, for \ninstance, will make extensive use of thread and queue tools introduced here and de-\nveloped further in Chapter 10, and Chapter 9 will discuss threading in the context of \nthe tkinter GUI toolkit once we\u2019ve had a chance to study it. Although we can\u2019t get into \ncode at this point, threads are usually an integral part of most nontrivial GUIs. In fact, \nthe activity model of many GUIs is a combination of threads, a queue, and a timer-\nbased loop.\nHere\u2019s why. In the context of a GUI, any operation that can block or take a long time \nto complete must be spawned off to run in parallel so that the GUI (the main thread)\n208 | Chapter 5:\u2002Parallel System Toolsremains active and continues responding to its users. Although such tasks can be run\nas processes, the efficiency and shared-state model of threads make them ideal for this\nrole. Moreover, since most GUI toolkits do not allow multiple threads to update the\nGUI in parallel, updates are best restricted to the main thread.\nBecause only the main thread should generally update the display, GUI programs typ-\nically take the form of a main GUI thread and one or more long-running producer\nthreads\u2014one for each long-running task being performed. To synchronize their points\nof interface, all of the threads share data on a global queue: non-GUI threads post\nresults, and the GUI thread consumes them.\nMore specifically:\n\u2022 The main thread handles all GUI updates and runs a timer-based loop that wakes\nup periodically to check for new data on the queue to be displayed on-screen. In\nPython\u2019s tkinter toolkit, for instance, the widget after(msecs, func, *args) method\ncan be used to schedule queue-check events. Because such events are dispatched\nby the GUI\u2019s event processor, all GUI updates occur only in this main thread (and\noften must, due to the lack of thread safety in GUI toolkits).\n\u2022 The child threads don\u2019t do anything GUI-related. They just produce data and put\nit on the queue to be picked up by the main thread. Alternatively, child threads\ncan place a callback function on the queue, to be picked up and run by the main\nthread. It\u2019s not generally sufficient to simply pass in a GUI update callback function\nfrom the main thread to the child thread and run it from there; the function in\nshared memory will still be executed in the child thread, and potentially in parallel\nwith other threads.\nSince threads are much more responsive than a timer event loop in the GUI, this scheme\nboth avoids blocking the GUI (producer threads run in parallel with the GUI), and\navoids missing incoming events (producer threads run independent of the GUI event\nloop and as fast as they can). The main GUI thread will display the queued results as\nquickly as it can, in the context of a slower GUI event loop.\nAlso keep in mind that regardless of the thread safety of a GUI toolkit, threaded GUI\nprograms must still adhere to the principles of threaded programs in general\u2014access\nto shared resources may still need to be synchronized if it falls outside the scope of the\nproducer/consumer shared queue model. If spawned threads might also update an-\nother shared state that is used by the main GUI thread, thread locks may also be required\nto avoid operation overlap. For instance, spawned threads that download and cache\nemail probably cannot overlap with others that use or update the same cache. That is,\nqueues may not be enough; unless you can restrict threads\u2019 work to queuing their\nresults, threaded GUIs still must address concurrent updates.\nWe\u2019ll see how the threaded GUI model can be realized in code later in this book. For\nmore on this subject, see especially the discussion of threaded tkinter GUIs in\nThreads | 209Chapter 9, the thread queue tools implemented in Chapter 10, and the PyMailGUI\nexample in Chapter 14.\nLater in this chapter, we\u2019ll also meet the multiprocessing module, whose process and\nqueue support offers new options for implementing this GUI model using processes\ninstead of threads; as such, they work around the limitations of the thread GIL, but\nmay incur extra performance overheads that can vary per platform, and may not be\ndirectly usable at all in threading contexts (the direct shared and mutable object state\nof threads is not supported, though messaging is). For now, let\u2019s cover a few final thread\nfine points.\nThread Timers versus GUI Timers\nInterestingly, the threading module exports a general timer function, which, like the\ntkinter widget after method, can be used to run another function after a timer has\nexpired:\nTimer(N.M, somefunc).start()   # after N.M seconds run somefunc\nTimer objects have a start() method to set the timer as well as a cancel() method to\ncancel the scheduled event, and they implement the wait state in a spawned thread.\nFor example, the following prints a message after 5.5 seconds:\n>>> import sys\n>>> from threading import Timer\n>>> t = Timer(5.5, lambda: print('Spam!'))    # spawned thread\n>>> t.start()\n>>> Spam!\nThis may be useful in a variety of contexts, but it doesn\u2019t quite apply to GUIs: because\nthe time-delayed function call is run in a spawned thread, not in the main GUI thread,\nit should not generally perform GUI updates. Because the tkinter after method is run\nfrom the main thread\u2019s event processing loop instead, it runs in the main GUI thread\nand can freely update the GUI.\nAs a preview, for instance, the following displays a pop-up message window in 5.5\nseconds in the main thread of a tkinter GUI (you might also have to run win.main\nloop() in some interfaces):\n>>> from tkinter import Tk\n>>> from tkinter.messagebox import showinfo\n>>> win = Tk()\n>>> win.after(5500, lambda: showinfo('Popup', 'Spam!'))\nThe last call here schedules the function to be run once in the main GUI thread, but it\ndoes not pause the caller during the wait, and so does not block the GUI. It\u2019s equivalent\nto this simpler form:\n>>> win.after(5500, showinfo, 'Popup', 'Spam')\nStay tuned for much more on tkinter in the next part of this book, and watch for the\nfull story on its after timer events in Chapter 9 and the roles of threads in GUIs in\nChapter 10.\n210 | Chapter 5:\u2002Parallel System ToolsMore on the Global Interpreter Lock\nAlthough it\u2019s a lower-level topic than you generally need to do useful thread work in\nPython, the implementation of Python\u2019s threads can have impacts on both performance\nand coding. This section summarizes implementation details and some of their\nramifications.\nThreads implementation in the upcoming Python 3.2: This section de-\nscribes the current implementation of threads up to and including Py-\nthon 3.1. At this writing, Python 3.2 is still in development, but one of\nits likely enhancements is a new version of the GIL that provides better\nperformance, especially on some multicore CPUs. The new GIL imple-\nmentation will still synchronize access to the PVM (Python language\ncode is still multiplexed as before), but it will use a context switching\nscheme that is more efficient than the current N-bytecode-instruction\napproach.\nAmong other things, the current sys.setcheckinterval call will likely\nbe replaced with a timer duration call in the new scheme. Specifically,\nthe concept of a check interval for thread switches will be abandoned\nand replaced by an absolute time duration expressed in seconds. It\u2019s\nanticipated that this duration will default to 5 milliseconds, but it will\nbe tunable through sys.setswitchinterval.\nMoreover, there have been a variety of plans made to remove the GIL\naltogether (including goals of the Unladen Swallow project being con-\nducted by Google employees), though none have managed to produce\nany fruit thus far. Since I cannot predict the future, please see Python\nrelease documents to follow this (well\u2026) thread.\nStrictly speaking, Python currently uses the global interpreter lock (GIL) mechanism\nintroduced at the start of this section, which guarantees that one thread, at most, is\nrunning code within the Python interpreter at any given point in time. In addition, to\nmake sure that each thread gets a chance to run, the interpreter automatically switches\nits attention between threads at regular intervals (in Python 3.1, by releasing and ac-\nquiring the lock after a number of bytecode instructions) as well as at the start of long-\nrunning operations (e.g., on some file input/output requests).\nThis scheme avoids problems that could arise if multiple threads were to update Python\nsystem data at the same time. For instance, if two threads were allowed to simultane-\nously change an object\u2019s reference count, the result might be unpredictable. This\nscheme can also have subtle consequences. In this chapter\u2019s threading examples, for\ninstance, the stdout stream can be corrupted unless each thread\u2019s call to write text is\nsynchronized with thread locks.\nMoreover, even though the GIL prevents more than one Python thread from running\nat the same time, it is not enough to ensure thread safety in general, and it does not\nThreads | 211address higher-level synchronization issues at all. For example, as we saw, when more\nthan one thread might attempt to update the same variable at the same time, the threads\nshould generally be given exclusive access to the object with locks. Otherwise, it\u2019s not\nimpossible that thread switches will occur in the middle of an update statement\u2019s\nbytecode.\nLocks are not strictly required for all shared object access, especially if a single thread\nupdates an object inspected by other threads. As a rule of thumb, though, you should\ngenerally use locks to synchronize threads whenever update rendezvous are possible\ninstead of relying on artifacts of the current thread implementation.\nThe thread switch interval\nSome concurrent updates might work without locks if the thread-switch interval is set\nhigh enough to allow each thread to finish without being swapped out. The\nsys.setcheckinterval(N) call sets the frequency with which the interpreter checks for\nthings like thread switches and signal handlers.\nThis interval defines the number of bytecode instructions before a switch. It does not\nneed to be reset for most programs, but it can be used to tune thread performance.\nSetting higher values means switches happen less often: threads incur less overhead but\nthey are less responsive to events. Setting lower values makes threads more responsive\nto events but increases thread switch overhead.\nAtomic operations\nBecause of the way Python uses the GIL to synchronize threads\u2019 access to the virtual\nmachine, whole statements are not generally thread-safe, but each bytecode instruction\nis. Because of this bytecode indivisibility, some Python language operations are thread-\nsafe\u2014also called atomic, because they run without interruption\u2014and do not require\nthe use of locks or queues to avoid concurrent update issues. For instance, as of this\nwriting, list.append, fetches and some assignments for variables, list items, dictionary\nkeys, and object attributes, and other operations were still atomic in standard C Python;\nothers, such as x = x+1 (and any operation in general that reads data, modifies it, and\nwrites it back) were not.\nAs mentioned earlier, though, relying on these rules is a bit of a gamble, because they\nrequire a deep understanding of Python internals and may vary per release. Indeed, the\nset of atomic operations may be radically changed if a new free-threaded implementa-\ntion ever appears. As a rule of thumb, it may be easier to use locks for all access to global\nand shared objects than to try to remember which types of access may or may not be\nsafe across multiple threads.\nC API thread considerations\nFinally, if you plan to mix Python with C, also see the thread interfaces described in\nthe Python/C API standard manual. In threaded programs, C extensions must release\n212 | Chapter 5:\u2002Parallel System Toolsand reacquire the GIL around long-running operations to let the Python language por-\ntions of other Python threads run during the wait. Specifically, the long-running C\nextension function should release the lock on entry and reacquire it on exit when re-\nsuming Python code.\nAlso note that even though the Python code in Python threads cannot truly overlap in\ntime due to the GIL synchronization, the C-coded portions of threads can. Any number\nmay be running in parallel, as long as they do work outside the scope of the Python\nvirtual machine. In fact, C threads may overlap both with other C threads and with\nPython language threads run in the virtual machine. Because of this, splitting code off\nto C libraries is one way that Python applications can still take advantage of multi-CPU\nmachines.\nStill, it may often be easier to leverage such machines by simply writing Python pro-\ngrams that fork processes instead of starting threads. The complexity of process and\nthread code is similar. For more on C extensions and their threading requirements, see\nChapter 20. In short, Python includes C language tools (including a pair of GIL man-\nagement macros) that can be used to wrap long-running operations in C-coded exten-\nsions and that allow other Python language threads to run in parallel.\nA process-based alternative: multiprocessing (ahead)\nBy now, you should have a basic grasp of parallel processes and threads, and Python\u2019s\ntools that support them. Later in this chapter, we\u2019ll revisit both ideas to study the\nmultiprocessing module\u2014a standard library tool that seeks to combine the simplicity\nand portability of threads with the benefits of processes, by implementing a threading-\nlike API that runs processes instead of threads. It seeks to address the portability issue\nof processes, as well as the multiple-CPU limitations imposed in threads by the GIL,\nbut it cannot be used as a replacement for forking in some contexts, and it imposes\nsome constraints that threads do not, which stem from its process-based model (for\ninstance, mutable object state is not directly shared because objects are copied across\nprocess boundaries, and unpickleable objects such as bound methods cannot be as\nfreely used).\nBecause the multiprocessing module also implements tools to simplify tasks such as\ninter-process communication and exit status, though, let\u2019s first get a handle on Python\u2019s\nsupport in those domains as well, and explore some more process and thread examples\nalong the way.\nProgram Exits\nAs we\u2019ve seen, unlike C, there is no \u201cmain\u201d function in Python. When we run a program,\nwe simply execute all of the code in the top-level file, from top to bottom (i.e., in the\nfilename we listed in the command line, clicked in a file explorer, and so on). Scripts\nProgram Exits | 213normally exit when Python falls off the end of the file, but we may also call for program\nexit explicitly with tools in the sys and os modules.\nsys Module Exits\nFor example, the built-in sys.exit function ends a program when called, and earlier\nthan normal:\n>>> sys.exit(N)           # exit with status N, else exits on end of script\nInterestingly, this call really just raises the built-in SystemExit exception. Because of\nthis, we can catch it as usual to intercept early exits and perform cleanup activities; if\nuncaught, the interpreter exits as usual. For instance:\nC:\\...\\PP4E\\System> python\n>>> import sys\n>>> try:\n...     sys.exit()              # see also: os._exit, Tk().quit()\n... except SystemExit:\n...     print('ignoring exit')\n...\nignoring exit\n>>>\nProgramming tools such as debuggers can make use of this hook to avoid shutting\ndown. In fact, explicitly raising the built-in SystemExit exception with a Python raise\nstatement is equivalent to calling sys.exit. More realistically, a try block would catch\nthe exit exception raised elsewhere in a program; the script in Example 5-15, for in-\nstance, exits from within a processing function.\nExample 5-15. PP4E\\System\\Exits\\testexit_sys.py\ndef later():\n    import sys\n    print('Bye sys world')\n    sys.exit(42)\n    print('Never reached')\nif __name__ == '__main__': later()\nRunning this program as a script causes it to exit before the interpreter falls off the end\nof the file. But because sys.exit raises a Python exception, importers of its function\ncan trap and override its exit exception or specify a finally cleanup block to be run\nduring program exit processing:\nC:\\...\\PP4E\\System\\Exits> python testexit_sys.py\nBye sys world\nC:\\...\\PP4E\\System\\Exits> python\n>>> from testexit_sys import later\n>>> try:\n...     later()\n... except SystemExit:\n214 | Chapter 5:\u2002Parallel System Tools...     print('Ignored...')\n...\nBye sys world\nIgnored...\n>>> try:\n...     later()\n... finally:\n...     print('Cleanup')\n...\nBye sys world\nCleanup\nC:\\...\\PP4E\\System\\Exits>              # interactive session process exits\nos Module Exits\nIt\u2019s possible to exit Python in other ways, too. For instance, within a forked child proc-\ness on Unix, we typically call the os._exit function rather than sys.exit; threads may\nexit with a _thread.exit call; and tkinter GUI applications often end by calling some-\nthing named Tk().quit(). We\u2019ll meet the tkinter module later in this book; let\u2019s take\na look at os exits here.\nOn os._exit, the calling process exits immediately instead of raising an exception that\ncould be trapped and ignored. In fact, the process also exits without flushing output\nstream buffers or running cleanup handlers (defined by the atexit standard library\nmodule), so this generally should be used only by child processes after a fork, where\noverall program shutdown actions aren\u2019t desired. Example 5-16 illustrates the basics.\nExample 5-16. PP4E\\System\\Exits\\testexit_os.py\ndef outahere():\n    import os\n    print('Bye os world')\n    os._exit(99)\n    print('Never reached')\nif __name__ == '__main__': outahere()\nUnlike sys.exit, os._exit is immune to both try/except and try/finally interception:\nC:\\...\\PP4E\\System\\Exits> python testexit_os.py\nBye os world\nC:\\...\\PP4E\\System\\Exits> python\n>>> from testexit_os import outahere\n>>> try:\n...     outahere()\n... except:\n...     print('Ignored')\n...\nBye os world                                 # exits interactive process\nC:\\...\\PP4E\\System\\Exits> python\nProgram Exits | 215>>> from testexit_os import outahere\n>>> try:\n...     outahere()\n... finally:\n...     print('Cleanup')\n...\nBye os world                                 # ditto\nShell Command Exit Status Codes\nBoth the sys and os exit calls we just met accept an argument that denotes the exit\nstatus code of the process (it\u2019s optional in the sys call but required by os). After exit,\nthis code may be interrogated in shells and by programs that ran the script as a child\nprocess. On Linux, for example, we ask for the status shell variable\u2019s value in order to\nfetch the last program\u2019s exit status; by convention, a nonzero status generally indicates\nthat some sort of problem occurred:\n[mark@linux]$ python testexit_sys.py\nBye sys world\n[mark@linux]$ echo $status\n42\n[mark@linux]$ python testexit_os.py\nBye os world\n[mark@linux]$ echo $status\n99\nIn a chain of command-line programs, exit statuses could be checked along the way as\na simple form of cross-program communication.\nWe can also grab hold of the exit status of a program run by another script. For instance,\nas introduced in Chapters 2 and 3, when launching shell commands, exit status is\nprovided as:\n\u2022 The return value of an os.system call\n\u2022 The return value of the close method of an os.popen object (for historical reasons,\nNone is returned if the exit status was 0, which means no error occurred)\n\u2022 A variety of interfaces in the subprocess module (e.g., the call function\u2019s return\nvalue, a Popen object\u2019s returnvalue attribute and wait method result)\nIn addition, when running programs by forking processes, the exit status is available\nthrough the os.wait and os.waitpid calls in a parent process.\nExit status with os.system and os.popen\nLet\u2019s look at the case of the shell commands first\u2014the following, run on Linux, spawns\nExample 5-15, and Example 5-16 reads the output streams through pipes and fetches\ntheir exit status codes:\n[mark@linux]$ python\n>>> import os\n>>> pipe = os.popen('python testexit_sys.py')\n216 | Chapter 5:\u2002Parallel System Tools>>> pipe.read()\n'Bye sys world\\012'\n>>> stat = pipe.close()              # returns exit code\n>>> stat\n10752\n>>> hex(stat)\n'0x2a00'\n>>> stat >> 8                        # extract status from bitmask on Unix-likes\n42\n>>> pipe = os.popen('python testexit_os.py')\n>>> stat = pipe.close()\n>>> stat, stat >> 8\n(25344, 99)\nThis code works the same under Cygwin Python on Windows. When using os.popen\non such Unix-like platforms, for reasons we won\u2019t go into here, the exit status is actually\npacked into specific bit positions of the return value; it\u2019s really there, but we need to\nshift the result right by eight bits to see it. Commands run with os.system send their\nstatuses back directly through the Python library call:\n>>> stat = os.system('python testexit_sys.py')\nBye sys world\n>>> stat, stat >> 8\n(10752, 42)\n>>> stat = os.system('python testexit_os.py')\nBye os world\n>>> stat, stat >> 8\n(25344, 99)\nAll of this code works under the standard version of Python for Windows, too, though\nexit status is not encoded in a bit mask (test sys.platform if your code must handle\nboth formats):\nC:\\...\\PP4E\\System\\Exits> python\n>>> os.system('python testexit_sys.py')\nBye sys world\n42\n>>> os.system('python testexit_os.py')\nBye os world\n99\n>>> pipe = os.popen('python testexit_sys.py')\n>>> pipe.read()\n'Bye sys world\\n'\n>>> pipe.close()\n42\n>>>\n>>> os.popen('python testexit_os.py').close()\n99\nProgram Exits | 217Output stream buffering: A first look\nNotice that the last test in the preceding code didn\u2019t attempt to read the command\u2019s\noutput pipe. If we do, we may have to run the target script in unbuffered mode with the\n-u Python command-line flag or change the script to flush its output manually with\nsys.stdout.flush. Otherwise, the text printed to the standard output stream might not\nbe flushed from its buffer when os._exit is called in this case for immediate shutdown.\nBy default, standard output is fully buffered when connected to a pipe like this; it\u2019s only\nline-buffered when connected to a terminal:\n>>> pipe = os.popen('python testexit_os.py')\n>>> pipe.read()                                     # streams not flushed on exit\n''\n>>> pipe = os.popen('python -u testexit_os.py')     # force unbuffered streams\n>>> pipe.read()\n'Bye os world\\n'\nConfusingly, you can pass mode and buffering argument to specify line buffering in\nboth os.popen and subprocess.Popen, but this won\u2019t help here\u2014arguments passed to\nthese tools pertain to the calling process\u2019s input end of the pipe, not to the spawned\nprogram\u2019s output stream:\n>>> pipe = os.popen('python testexit_os.py', 'r', 1)   # line buffered only\n>>> pipe.read()                                        # but my pipe, not program's!\n''\n>>> from subprocess import Popen, PIPE\n>>> pipe = Popen('python testexit_os.py', bufsize=1, stdout=PIPE)   # for my pipe\n>>> pipe.stdout.read()                                              # doesn't help\nb''\nReally, buffering mode arguments in these tools pertain to output the caller writes to\na command\u2019s standard input stream, not to output read from that command.\nIf required, the spawned script itself can also manually flush its output buffers period-\nically or before forced exits. More on buffering when we discuss the potential for\ndeadlocks later in this chapter, and again in Chapters 10 and 12 where we\u2019ll see how it\napplies to sockets. Since we brought up subprocess, though, let\u2019s turn to its exit tools\nnext.\nExit status with subprocess\nThe alternative subprocess module offers exit status in a variety of ways, as we saw in\nChapters 2 and 3 (a None value in returncode indicates that the spawned program has\nnot yet terminated):\nC:\\...\\PP4E\\System\\Exits> python\n>>> from subprocess import Popen, PIPE, call\n>>> pipe = Popen('python testexit_sys.py', stdout=PIPE)\n>>> pipe.stdout.read()\nb'Bye sys world\\r\\n'\n218 | Chapter 5:\u2002Parallel System Tools>>> pipe.wait()\n42\n>>> call('python testexit_sys.py')\nBye sys world\n42\n>>> pipe = Popen('python testexit_sys.py', stdout=PIPE)\n>>> pipe.communicate()\n(b'Bye sys world\\r\\n', None)\n>>> pipe.returncode\n42\nThe subprocess module works the same on Unix-like platforms like Cygwin, but unlike\nos.popen, the exit status is not encoded, and so it matches the Windows result (note\nthat shell=True is needed to run this as is on Cygwin and Unix-like platforms, as we\nlearned in Chapter 2; on Windows this argument is required only to run commands\nbuilt into the shell, like dir):\n[C:\\...\\PP4E\\System\\Exits]$ python\n>>> from subprocess import Popen, PIPE, call\n>>> pipe = Popen('python testexit_sys.py', stdout=PIPE, shell=True)\n>>> pipe.stdout.read()\nb'Bye sys world\\n'\n>>> pipe.wait()\n42\n>>> call('python testexit_sys.py', shell=True)\nBye sys world\n42\nProcess Exit Status and Shared State\nNow, to learn how to obtain the exit status from forked processes, let\u2019s write a simple\nforking program: the script in Example 5-17 forks child processes and prints child\nprocess exit statuses returned by os.wait calls in the parent until a \u201cq\u201d is typed at the\nconsole.\nExample 5-17. PP4E\\System\\Exits\\testexit_fork.py\n\"\"\"\nfork child processes to watch exit status with os.wait; fork works on Unix\nand Cygwin but not standard Windows Python 3.1; note: spawned threads share\nglobals, but each forked process has its own copy of them (forks share file\ndescriptors)--exitstat is always the same here but will vary if for threads;\n\"\"\"\nimport os\nexitstat = 0\ndef child():                                  # could os.exit a script here\n    global exitstat                           # change this process's global\n    exitstat += 1                             # exit status to parent's wait\nProgram Exits | 219print('Hello from child', os.getpid(), exitstat)\n    os._exit(exitstat)\n    print('never reached')\ndef parent():\n    while True:\n        newpid = os.fork()                     # start a new copy of process\n        if newpid == 0:                        # if in copy, run child logic\n            child()                            # loop until 'q' console input\n        else:\n            pid, status = os.wait()\n            print('Parent got', pid, status, (status >> 8))\n            if input() == 'q': break\nif __name__ == '__main__': parent()\nRunning this program on Linux, Unix, or Cygwin (remember, fork still doesn\u2019t work\non standard Windows Python as I write the fourth edition of this book) produces the\nfollowing sort of results:\n[C:\\...\\PP4E\\System\\Exits]$ python testexit_fork.py\nHello from child 5828 1\nParent got 5828 256 1\nHello from child 9540 1\nParent got 9540 256 1\nHello from child 3152 1\nParent got 3152 256 1\nq\nIf you study this output closely, you\u2019ll notice that the exit status (the last number prin-\nted) is always the same\u2014the number 1. Because forked processes begin life as copies\nof the process that created them, they also have copies of global memory. Because of\nthat, each forked child gets and changes its own exitstat global variable without\nchanging any other process\u2019s copy of this variable. At the same time, forked processes\ncopy and thus share file descriptors, which is why prints go to the same place.\nThread Exits and Shared State\nIn contrast, threads run in parallel within the same process and share global memory.\nEach thread in Example 5-18 changes the single shared global variable, exitstat.\nExample 5-18. PP4E\\System\\Exits\\testexit_thread.py\n\"\"\"\nspawn threads to watch shared global memory change; threads normally exit\nwhen the function they run returns, but _thread.exit() can be called to\nexit calling thread; _thread.exit is the same as sys.exit and raising\nSystemExit; threads communicate with possibly locked global vars; caveat:\nmay need to make print/input calls atomic on some platforms--shared stdout;\n\"\"\"\n220 | Chapter 5:\u2002Parallel System Toolsimport _thread as thread\nexitstat = 0\ndef child():\n    global exitstat                               # process global names\n    exitstat += 1                                 # shared by all threads\n    threadid = thread.get_ident()\n    print('Hello from child', threadid, exitstat)\n    thread.exit()\n    print('never reached')\ndef parent():\n    while True:\n        thread.start_new_thread(child, ())\n        if input() == 'q': break\nif __name__ == '__main__': parent()\nThe following shows this script in action on Windows; unlike forks, threads run in the\nstandard version of Python on Windows, too. Thread identifiers created by Python\ndiffer each time\u2014they are arbitrary but unique among all currently active threads and\nso may be used as dictionary keys to keep per-thread information (a thread\u2019s id may be\nreused after it exits on some platforms):\nC:\\...\\PP4E\\System\\Exits> python testexit_thread.py\nHello from child 4908 1\nHello from child 4860 2\nHello from child 2752 3\nHello from child 8964 4\nq\nNotice how the value of this script\u2019s global exitstat is changed by each thread, because\nthreads share global memory within the process. In fact, this is often how threads com-\nmunicate in general. Rather than exit status codes, threads assign module-level globals\nor change shared mutable objects in-place to signal conditions, and they use thread\nmodule locks and queues to synchronize access to shared items if needed. This script\nmight need to synchronize, too, if it ever does something more realistic\u2014for global\ncounter changes, but even print and input may have to be synchronized if they overlap\nstream access badly on some platforms. For this simple demo, we forego locks by as-\nsuming threads won\u2019t mix their operations oddly.\nAs we\u2019ve learned, a thread normally exits silently when the function it runs returns,\nand the function return value is ignored. Optionally, the _thread.exit function can be\ncalled to terminate the calling thread explicitly and silently. This call works almost\nexactly like sys.exit (but takes no return status argument), and it works by raising a\nSystemExit exception in the calling thread. Because of that, a thread can also prema-\nturely end by calling sys.exit or by directly raising SystemExit. Be sure not to call\nos._exit within a thread function, though\u2014doing so can have odd results (the last time\nProgram Exits | 221I tried, it hung the entire process on my Linux system and killed every thread in the\nprocess on Windows!).\nThe alternative threading module for threads has no method equivalent to\n_thread.exit(), but since all that the latter does is raise a system-exit exception, doing\nthe same in threading has the same effect\u2014the thread exits immediately and silently,\nas in the following sort of code (see testexit-threading.py in the example tree for this\ncode):\nimport threading, sys, time\ndef action():\n   sys.exit()                 # or raise SystemExit()\n   print('not reached')\nthreading.Thread(target=action).start()\ntime.sleep(2)\nprint('Main exit')\nOn a related note, keep in mind that threads and processes have default lifespan models,\nwhich we explored earlier. By way of review, when child threads are still running, the\ntwo thread modules\u2019 behavior differs\u2014programs on most platforms exit when the pa-\nrent thread does under _thread, but not normally under threading unless children are\nmade daemons. When using processes, children normally outlive their parent. This\ndifferent process behavior makes sense if you remember that threads are in-process\nfunction calls, but processes are more independent and autonomous.\nWhen used well, exit status can be used to implement error detection and simple com-\nmunication protocols in systems composed of command-line scripts. But having said\nthat, I should underscore that most scripts do simply fall off the end of the source to\nexit, and most thread functions simply return; explicit exit calls are generally employed\nfor exceptional conditions and in limited contexts only. More typically, programs com-\nmunicate with richer tools than integer exit codes; the next section shows how.\nInterprocess Communication\nAs we saw earlier, when scripts spawn threads\u2014tasks that run in parallel within the\nprogram\u2014they can naturally communicate by changing and inspecting names and\nobjects in shared global memory. This includes both accessible variables and attributes,\nas well as referenced mutable objects. As we also saw, some care must be taken to use\nlocks to synchronize access to shared items that can be updated concurrently. Still,\nthreads offer a fairly straightforward communication model, and the queue module can\nmake this nearly automatic for many programs.\nThings aren\u2019t quite as simple when scripts start child processes and independent pro-\ngrams that do not share memory in general. If we limit the kinds of communications\nthat can happen between programs, many options are available, most of which we\u2019ve\n222 | Chapter 5:\u2002Parallel System Toolsalready seen in this and the prior chapters. For example, the following simple mecha-\nnisms can all be interpreted as cross-program communication devices:\n\u2022 Simple files\n\u2022 Command-line arguments\n\u2022 Program exit status codes\n\u2022 Shell environment variables\n\u2022 Standard stream redirections\n\u2022 Stream pipes managed by os.popen and subprocess\nFor instance, sending command-line options and writing to input streams lets us pass\nin program execution parameters; reading program output streams and exit codes gives\nus a way to grab a result. Because shell environment variable settings are inherited by\nspawned programs, they provide another way to pass context in. And pipes made by\nos.popen or subprocess allow even more dynamic communication. Data can be sent\nbetween programs at arbitrary times, not only at program start and exit.\nBeyond this set, there are other tools in the Python library for performing Inter-Process\nCommunication (IPC). This includes sockets, shared memory, signals, anonymous and\nnamed pipes, and more. Some vary in portability, and all vary in complexity and utility.\nFor instance:\n\u2022 Signals allow programs to send simple notification events to other programs.\n\u2022 Anonymous pipes allow threads and related processes that share file descriptors to\npass data, but generally rely on the Unix-like forking model for processes, which\nis not universally portable.\n\u2022 Named pipes are mapped to the system\u2019s filesystem\u2014they allow completely unre-\nlated programs to converse, but are not available in Python on all platforms.\n\u2022 Sockets map to system-wide port numbers\u2014they similarly let us transfer data be-\ntween arbitrary programs running on the same computer, but also between pro-\ngrams located on remote networked machines, and offer a more portable option.\nWhile some of these can be used as communication devices by threads, too, their full\npower becomes more evident when leveraged by separate processes which do not share\nmemory at large.\nIn this section, we explore directly managed pipes (both anonymous and named), as\nwell as signals. We also take a first look at sockets here, but largely as a preview; sockets\ncan be used for IPC on a single machine, but because the larger socket story also involves\ntheir role in networking, we\u2019ll save most of their details until the Internet part of this\nbook.\nOther IPC tools are available to Python programmers (e.g., shared memory as provided\nby the mmap module) but are not covered here for lack of space; search the Python\nInterprocess Communication | 223manuals and website for more details on other IPC schemes if you\u2019re looking for some-\nthing more specific.\nAfter this section, we\u2019ll also study the multiprocessing module, which offers additional\nand portable IPC options as part of its general process-launching API, including shared\nmemory, and pipes and queues of arbitrary pickled Python objects. For now, let\u2019s study\ntraditional approaches first.\nAnonymous Pipes\nPipes, a cross-program communication device, are implemented by your operating\nsystem and made available in the Python standard library. Pipes are unidirectional\nchannels that work something like a shared memory buffer, but with an interface re-\nsembling a simple file on each of two ends. In typical use, one program writes data on\none end of the pipe, and another reads that data on the other end. Each program sees\nonly its end of the pipes and processes it using normal Python file calls.\nPipes are much more within the operating system, though. For instance, calls to read\na pipe will normally block the caller until data becomes available (i.e., is sent by the\nprogram on the other end) instead of returning an end-of-file indicator. Moreover, read\ncalls on a pipe always return the oldest data written to the pipe, resulting in a first-in-\nfirst-out model\u2014the first data written is the first to be read. Because of such properties,\npipes are also a way to synchronize the execution of independent programs.\nPipes come in two flavors\u2014anonymous and named. Named pipes (often called fifos)\nare represented by a file on your computer. Because named pipes are really external\nfiles, the communicating processes need not be related at all; in fact, they can be inde-\npendently started programs.\nBy contrast, anonymous pipes exist only within processes and are typically used in\nconjunction with process forks as a way to link parent and spawned child processes\nwithin an application. Parent and child converse over shared pipe file descriptors, which\nare inherited by spawned processes. Because threads run in the same process and share\nall global memory in general, anonymous pipes apply to them as well.\nAnonymous pipe basics\nSince they are more traditional, let\u2019s start with a look at anonymous pipes. To illustrate,\nthe script in Example 5-19 uses the os.fork call to make a copy of the calling process\nas usual (we met forks earlier in this chapter). After forking, the original parent process\nand its child copy speak through the two ends of a pipe created with os.pipe prior to\nthe fork. The os.pipe call returns a tuple of two file descriptors\u2014the low-level file iden-\ntifiers we met in Chapter 4\u2014representing the input and output sides of the pipe. Be-\ncause forked child processes get copies of their parents\u2019 file descriptors, writing to the\npipe\u2019s output descriptor in the child sends data back to the parent on the pipe created\nbefore the child was spawned.\n224 | Chapter 5:\u2002Parallel System ToolsExample 5-19. PP4E\\System\\Processes\\pipe1.py\nimport os, time\ndef child(pipeout):\n    zzz = 0\n    while True:\n        time.sleep(zzz)                          # make parent wait\n        msg = ('Spam %03d' % zzz).encode()       # pipes are binary bytes\n        os.write(pipeout, msg)                   # send to parent\n        zzz = (zzz+1) % 5                        # goto 0 after 4\ndef parent():\n    pipein, pipeout = os.pipe()                  # make 2-ended pipe\n    if os.fork() == 0:                           # copy this process\n        child(pipeout)                           # in copy, run child\n    else:                                        # in parent, listen to pipe\n        while True:\n            line = os.read(pipein, 32)           # blocks until data sent\n            print('Parent %d got [%s] at %s' % (os.getpid(), line, time.time()))\nparent()\nIf you run this program on Linux, Cygwin, or another Unix-like platform (pipe is avail-\nable on standard Windows Python, but fork is not), the parent process waits for the\nchild to send data on the pipe each time it calls os.read. It\u2019s almost as if the child and\nparent act as client and server here\u2014the parent starts the child and waits for it to initiate\ncommunication.# To simulate differing task durations, the child keeps the parent wait-\ning one second longer between messages with time.sleep calls, until the delay has\nreached four seconds. When the zzz delay counter hits 005, it rolls back down to 000\nand starts again:\n[C:\\...\\PP4E\\System\\Processes]$ python pipe1.py\nParent 6716 got [b'Spam 000'] at 1267996104.53\nParent 6716 got [b'Spam 001'] at 1267996105.54\nParent 6716 got [b'Spam 002'] at 1267996107.55\nParent 6716 got [b'Spam 003'] at 1267996110.56\nParent 6716 got [b'Spam 004'] at 1267996114.57\nParent 6716 got [b'Spam 000'] at 1267996114.57\nParent 6716 got [b'Spam 001'] at 1267996115.59\nParent 6716 got [b'Spam 002'] at 1267996117.6\nParent 6716 got [b'Spam 003'] at 1267996120.61\nParent 6716 got [b'Spam 004'] at 1267996124.62\nParent 6716 got [b'Spam 000'] at 1267996124.62\n#We will clarify the notions of \u201cclient\u201d and \u201cserver\u201d in the Internet programming part of this book. There,\nwe\u2019ll communicate with sockets (which we\u2019ll see later in this chapter are roughly like bidirectional pipes for\nprograms running both across networks and on the same machine), but the overall conversation model is\nsimilar. Named pipes (fifos), described ahead, are also a better match to the client/server model because they\ncan be accessed by arbitrary, unrelated processes (no forks are required). But as we\u2019ll see, the socket port\nmodel is generally used by most Internet scripting protocols\u2014email, for instance, is mostly just formatted\nstrings shipped over sockets between programs on standard port numbers reserved for the email protocol.\nInterprocess Communication | 225Parent 6716 got [b'Spam 001'] at 1267996125.63\n...etc.: Ctrl-C to exit...\nNotice how the parent received a bytes string through the pipe. Raw pipes normally\ndeal in binary byte strings when their descriptors are used directly this way with the\ndescriptor-based file tools we met in Chapter 4 (as we saw there, descriptor read and\nwrite tools in os always return and expect byte strings). That\u2019s why we also have to\nmanually encode to bytes when writing in the child\u2014the string formatting operation\nis not available on bytes. As the next section shows, it\u2019s also possible to wrap a pipe\ndescriptor in a text-mode file object, much as we did in the file examples in Chap-\nter 4, but that object simply performs encoding and decoding automatically on trans-\nfers; it\u2019s still bytes in the pipe.\nWrapping pipe descriptors in file objects\nIf you look closely at the preceding output, you\u2019ll see that when the child\u2019s delay counter\nhits 004, the parent ends up reading two messages from the pipe at the same time; the\nchild wrote two distinct messages, but on some platforms or configurations (other than\nthat used here) they might be interleaved or processed close enough in time to be fetched\nas a single unit by the parent. Really, the parent blindly asks to read, at most, 32 bytes\neach time, but it gets back whatever text is available in the pipe, when it becomes\navailable.\nTo distinguish messages better, we can mandate a separator character in the pipe. An\nend-of-line makes this easy, because we can wrap the pipe descriptor in a file object\nwith os.fdopen and rely on the file object\u2019s readline method to scan up through the\nnext \\n separator in the pipe. This also lets us leverage the more powerful tools of the\ntext-mode file object we met in Chapter 4. Example 5-20 implements this scheme for\nthe parent\u2019s end of the pipe.\nExample 5-20. PP4E\\System\\Processes\\pipe2.py\n# same as pipe1.py, but wrap pipe input in stdio file object\n# to read by line, and close unused pipe fds in both processes\nimport os, time\ndef child(pipeout):\n    zzz = 0\n    while True:\n        time.sleep(zzz)                          # make parent wait\n        msg = ('Spam %03d\\n' % zzz).encode()     # pipes are binary in 3.X\n        os.write(pipeout, msg)                   # send to parent\n        zzz = (zzz+1) % 5                        # roll to 0 at 5\ndef parent():\n    pipein, pipeout = os.pipe()                  # make 2-ended pipe\n    if os.fork() == 0:                           # in child, write to pipe\n        os.close(pipein)                         # close input side here\n        child(pipeout)\n226 | Chapter 5:\u2002Parallel System Toolselse:                                        # in parent, listen to pipe\n        os.close(pipeout)                        # close output side here\n        pipein = os.fdopen(pipein)               # make text mode input file object\n        while True:\n            line = pipein.readline()[:-1]        # blocks until data sent\n            print('Parent %d got [%s] at %s' % (os.getpid(), line, time.time()))\nparent()\nThis version has also been augmented to close the unused end of the pipe in each process\n(e.g., after the fork, the parent process closes its copy of the output side of the pipe\nwritten by the child); programs should close unused pipe ends in general. Running with\nthis new version reliably returns a single child message to the parent each time it reads\nfrom the pipe, because they are separated with markers when written:\n[C:\\...\\PP4E\\System\\Processes]$ python pipe2.py\nParent 8204 got [Spam 000] at 1267997789.33\nParent 8204 got [Spam 001] at 1267997790.03\nParent 8204 got [Spam 002] at 1267997792.05\nParent 8204 got [Spam 003] at 1267997795.06\nParent 8204 got [Spam 004] at 1267997799.07\nParent 8204 got [Spam 000] at 1267997799.07\nParent 8204 got [Spam 001] at 1267997800.08\nParent 8204 got [Spam 002] at 1267997802.09\nParent 8204 got [Spam 003] at 1267997805.1\nParent 8204 got [Spam 004] at 1267997809.11\nParent 8204 got [Spam 000] at 1267997809.11\nParent 8204 got [Spam 001] at 1267997810.13\n...etc.: Ctrl-C to exit...\nNotice that this version\u2019s reads also return a text data str object now, per the default\nr text mode for os.fdopen. As mentioned, pipes normally deal in binary byte strings\nwhen their descriptors are used directly with os file tools, but wrapping in text-mode\nfiles allows us to use str strings to represent text data instead of bytes. In this example,\nbytes are decoded to str when read by the parent; using os.fdopen and text mode in\nthe child would allow us to avoid its manual encoding call, but the file object would\nencode the str data anyhow (though the encoding is trivial for ASCII bytes like those\nused here). As for simple files, the best mode for processing pipe data in is determined\nby its nature.\nAnonymous pipes and threads\nAlthough the os.fork call required by the prior section\u2019s examples isn\u2019t available on\nstandard Windows Python, os.pipe is. Because threads all run in the same process and\nshare file descriptors (and global memory in general), this makes anonymous pipes\nusable as a communication and synchronization device for threads, too. This is an\narguably lower-level mechanism than queues or shared names and objects, but it pro-\nvides an additional IPC option for threads. Example 5-21, for instance, demonstrates\nthe same type of pipe-based communication occurring between threads instead of\nprocesses.\nInterprocess Communication | 227Example 5-21. PP4E\\System\\Processes\\pipe-thread.py\n# anonymous pipes and threads, not processes; this version works on Windows\nimport os, time, threading\ndef child(pipeout):\n    zzz = 0\n    while True:\n        time.sleep(zzz)                              # make parent wait\n        msg = ('Spam %03d' % zzz).encode()           # pipes are binary bytes\n        os.write(pipeout, msg)                       # send to parent\n        zzz = (zzz+1) % 5                            # goto 0 after 4\ndef parent(pipein):\n    while True:\n        line = os.read(pipein, 32)                   # blocks until data sent\n        print('Parent %d got [%s] at %s' % (os.getpid(), line, time.time()))\npipein, pipeout = os.pipe()\nthreading.Thread(target=child, args=(pipeout,)).start()\nparent(pipein)\nSince threads work on standard Windows Python, this script does too. The output is\nsimilar here, but the speakers are in-process threads, not processes (note that because\nof its simple-minded infinite loops, at least one of its threads may not die on a Ctrl-C\u2014\non Windows you may need to use Task Manager to kill the python.exe process running\nthis script or close its window to exit):\nC:\\...\\PP4E\\System\\Processes> pipe-thread.py\nParent 8876 got [b'Spam 000'] at 1268579215.71\nParent 8876 got [b'Spam 001'] at 1268579216.73\nParent 8876 got [b'Spam 002'] at 1268579218.74\nParent 8876 got [b'Spam 003'] at 1268579221.75\nParent 8876 got [b'Spam 004'] at 1268579225.76\nParent 8876 got [b'Spam 000'] at 1268579225.76\nParent 8876 got [b'Spam 001'] at 1268579226.77\nParent 8876 got [b'Spam 002'] at 1268579228.79\n...etc.: Ctrl-C or Task Manager to exit...\nBidirectional IPC with anonymous pipes\nPipes normally let data flow in only one direction\u2014one side is input, one is output.\nWhat if you need your programs to talk back and forth, though? For example, one\nprogram might send another a request for information and then wait for that informa-\ntion to be sent back. A single pipe can\u2019t generally handle such bidirectional conversa-\ntions, but two pipes can. One pipe can be used to pass requests to a program and\nanother can be used to ship replies back to the requestor.\nThis really does have real-world applications. For instance, I once added a GUI interface\nto a command-line debugger for a C-like programming language by connecting two\nprocesses with pipes this way. The GUI ran as a separate process that constructed and\n228 | Chapter 5:\u2002Parallel System Toolssent commands to the non-GUI debugger\u2019s input stream pipe and parsed the results\nthat showed up in the debugger\u2019s output stream pipe. In effect, the GUI acted like a\nprogrammer typing commands at a keyboard and a client to the debugger server. More\ngenerally, by spawning command-line programs with streams attached by pipes, sys-\ntems can add new interfaces to legacy programs. In fact, we\u2019ll see a simple example of\nthis sort of GUI program structure in Chapter 10.\nThe module in Example 5-22 demonstrates one way to apply this idea to link the input\nand output streams of two programs. Its spawn function forks a new child program and\nconnects the input and output streams of the parent to the output and input streams\nof the child. That is:\n\u2022 When the parent reads from its standard input, it is reading text sent to the child\u2019s\nstandard output.\n\u2022 When the parent writes to its standard output, it is sending data to the child\u2019s\nstandard input.\nThe net effect is that the two independent programs communicate by speaking over\ntheir standard streams.\nExample 5-22. PP4E\\System\\Processes\\pipes.py\n\"\"\"\nspawn a child process/program, connect my stdin/stdout to child process's\nstdout/stdin--my reads and writes map to output and input streams of the\nspawned program; much like tying together streams with subprocess module;\n\"\"\"\nimport os, sys\ndef spawn(prog, *args):                       # pass progname, cmdline args\n    stdinFd  = sys.stdin.fileno()             # get descriptors for streams\n    stdoutFd = sys.stdout.fileno()            # normally stdin=0, stdout=1\n    parentStdin, childStdout  = os.pipe()     # make two IPC pipe channels\n    childStdin,  parentStdout = os.pipe()     # pipe returns (inputfd, outoutfd)\n    pid = os.fork()                           # make a copy of this process\n    if pid:\n        os.close(childStdout)                 # in parent process after fork:\n        os.close(childStdin)                  # close child ends in parent\n        os.dup2(parentStdin,  stdinFd)        # my sys.stdin copy  = pipe1[0]\n        os.dup2(parentStdout, stdoutFd)       # my sys.stdout copy = pipe2[1]\n    else:\n        os.close(parentStdin)                 # in child process after fork:\n        os.close(parentStdout)                # close parent ends in child\n        os.dup2(childStdin,  stdinFd)         # my sys.stdin copy  = pipe2[0]\n        os.dup2(childStdout, stdoutFd)        # my sys.stdout copy = pipe1[1]\n        args = (prog,) + args\n        os.execvp(prog, args)                 # new program in this process\n        assert False, 'execvp failed!'        # os.exec call never returns here\nif __name__ == '__main__':\nInterprocess Communication | 229mypid = os.getpid()\n    spawn('python', 'pipes-testchild.py', 'spam')     # fork child program\n    print('Hello 1 from parent', mypid)               # to child's stdin\n    sys.stdout.flush()                                # subvert stdio buffering\n    reply = input()                                   # from child's stdout\n    sys.stderr.write('Parent got: \"%s\"\\n' % reply)    # stderr not tied to pipe!\n    print('Hello 2 from parent', mypid)\n    sys.stdout.flush()\n    reply = sys.stdin.readline()\n    sys.stderr.write('Parent got: \"%s\"\\n' % reply[:-1])\nThe spawn function in this module does not work on standard Windows Python (re-\nmember that fork isn\u2019t yet available there today). In fact, most of the calls in this module\nmap straight to Unix system calls (and may be arbitrarily terrifying at first glance to\nnon-Unix developers!). We\u2019ve already met some of these (e.g., os.fork), but much of\nthis code depends on Unix concepts we don\u2019t have time to address well in this text.\nBut in simple terms, here is a brief summary of the system calls demonstrated in this\ncode:\nos.fork\nCopies the calling process as usual and returns the child\u2019s process ID in the parent\nprocess only.\nos.execvp\nOverlays a new program in the calling process; it\u2019s just like the os.execlp used\nearlier but takes a tuple or list of command-line argument strings (collected with\nthe *args form in the function header).\nos.pipe\nReturns a tuple of file descriptors representing the input and output ends of a pipe,\nas in earlier examples.\nos.close(fd)\nCloses the descriptor-based file fd.\nos.dup2(fd1,fd2)\nCopies all system information associated with the file named by the file descriptor\nfd1 to the file named by fd2.\nIn terms of connecting standard streams, os.dup2 is the real nitty-gritty here. For ex-\nample, the call os.dup2(parentStdin,stdinFd) essentially assigns the parent process\u2019s\nstdin file to the input end of one of the two pipes created; all stdin reads will henceforth\ncome from the pipe. By connecting the other end of this pipe to the child process\u2019s copy\nof the stdout stream file with os.dup2(childStdout,stdoutFd), text written by the child\nto its sdtdout winds up being routed through the pipe to the parent\u2019s stdin stream. The\neffect is reminiscent of the way we tied together streams with the subprocess module\nin Chapter 3, but this script is more low-level and less portable.\n230 | Chapter 5:\u2002Parallel System ToolsTo test this utility, the self-test code at the end of the file spawns the program shown\nin Example 5-23 in a child process and reads and writes standard streams to converse\nwith it over two pipes.\nExample 5-23. PP4E\\System\\Processes\\pipes-testchild.py\nimport os, time, sys\nmypid     = os.getpid()\nparentpid = os.getppid()\nsys.stderr.write('Child %d of %d got arg: \"%s\"\\n' %\n                                (mypid, parentpid, sys.argv[1]))\nfor i in range(2):\n    time.sleep(3)              # make parent process wait by sleeping here\n    recv = input()             # stdin tied to pipe: comes from parent's stdout\n    time.sleep(3)\n    send = 'Child %d got: [%s]' % (mypid, recv)\n    print(send)                # stdout tied to pipe: goes to parent's stdin\n    sys.stdout.flush()         # make sure it's sent now or else process blocks\nThe following is our test in action on Cygwin (it\u2019s similar other Unix-like platforms like\nLinux); its output is not incredibly impressive to read, but it represents two programs\nrunning independently and shipping data back and forth through a pipe device man-\naged by the operating system. This is even more like a client/server model (if you imag-\nine the child as the server, responding to requests sent from the parent). The text in\nsquare brackets in this output went from the parent process to the child and back to\nthe parent again, all through pipes connected to standard streams:\n[C:\\...\\PP4E\\System\\Processes]$ python pipes.py\nChild 9228 of 9096 got arg: \"spam\"\nParent got: \"Child 9228 got: [Hello 1 from parent 9096]\"\nParent got: \"Child 9228 got: [Hello 2 from parent 9096]\"\nOutput stream buffering revisited: Deadlocks and flushes\nThe two processes of the prior section\u2019s example engage in a simple dialog, but it\u2019s\nalready enough to illustrate some of the dangers lurking in cross-program communi-\ncations. First of all, notice that both programs need to write to stderr to display a\nmessage; their stdout streams are tied to the other program\u2019s input stream. Because\nprocesses share file descriptors, stderr is the same in both parent and child, so status\nmessages show up in the same place.\nMore subtly, note that both parent and child call sys.stdout.flush after they print text\nto the output stream. Input requests on pipes normally block the caller if no data is\navailable, but it seems that this shouldn\u2019t be a problem in our example because there\nare as many writes as there are reads on the other side of the pipe. By default, though,\nsys.stdout is buffered in this context, so the printed text may not actually be transmitted\nuntil some time in the future (when the output buffers fill up). In fact, if the flush calls\nare not made, both processes may get stuck on some platforms waiting for input from\nthe other\u2014input that is sitting in a buffer and is never flushed out over the pipe. They\nInterprocess Communication | 231wind up in a deadlock state, both blocked on input calls waiting for events that never\noccur.\nTechnically, by default stdout is just line-buffered when connected to a terminal, but\nit is fully buffered when connected to other devices such as files, sockets, and the pipes\nused here. This is why you see a script\u2019s printed text in a shell window immediately as\nit is produced, but not until the process exits or its buffer fills when its output stream\nis connected to something else.\nThis output buffering is really a function of the system libraries used to access pipes,\nnot of the pipes themselves (pipes do queue up output data, but they never hide it from\nreaders!). In fact, it appears to occur in this example only because we copy the pipe\u2019s\ninformation over to sys.stdout, a built-in file object that uses stream buffering by de-\nfault. However, such anomalies can also occur when using other cross-process tools.\nIn general terms, if your programs engage in a two-way dialog like this, there are a\nvariety of ways to avoid buffering-related deadlock problems:\n\u2022 Flushes: As demonstrated in Examples 5-22 and 5-23, manually flushing output\npipe streams by calling the file object flush method is an easy way to force buffers\nto be cleared. Use sys.stdout.flush for the output stream used by print.\n\u2022 Arguments: As introduced earlier in this chapter, the -u Python command-line flag\nturns off full buffering for the sys.stdout stream in Python programs. Setting your\nPYTHONUNBUFFERED environment variable to a nonempty value is equivalent to pass-\ning this flag but applies to every program run.\n\u2022 Open modes: It\u2019s possible to use pipes themselves in unbuffered mode. Either use\nlow-level os module calls to read and write pipe descriptors directly, or pass a buffer\nsize argument of 0 (for unbuffered) or 1 (for line-buffered) to os.fdopen to disable\nbuffering in the file object used to wrap the descriptor. You can use open arguments\nthe same way to control buffering for output to fifo files (described in the next\nsection). Note that in Python 3.X, fully unbuffered mode is allowed only for binary\nmode files, not text.\n\u2022 Command pipes: As mentioned earlier in this chapter, you can similarly specify\nbuffering mode arguments for command-line pipes when they are created by\nos.popen and subprocess.Popen, but this pertains to the caller\u2019s end of the pipe, not\nthose of the spawned program. Hence it cannot prevent delayed outputs from the\nlatter, but can be used for text sent to another program\u2019s input pipe.\n\u2022 Sockets: As we\u2019ll see later, the socket.makefile call accepts a similar buffering mode\nargument for sockets (described later in this chapter and book), but in Python 3.X\nthis call requires buffering for text-mode access and appears to not support line-\nbuffered mode (more on this on Chapter 12).\n\u2022 Tools: For more complex tasks, we can also use higher-level tools that essentially\nfool a program into believing it is connected to a terminal. These address programs\n232 | Chapter 5:\u2002Parallel System Toolsnot written in Python, for which neither manual flush calls nor -u are an option.\nSee \u201cMore on Stream Buffering: pty and Pexpect\u201d on page 233.\nThread can avoid blocking a main GUI, too, but really just delegate the problem (the\nspawned thread will still be deadlocked). Of the options listed, the first two\u2014manual\nflushes and command-line arguments\u2014are often the simplest solutions. In fact, be-\ncause it is so useful, the second technique listed above merits a few more words. Try\nthis: comment-out all the sys.stdout.flush calls in Examples 5-22 and 5-23 (the files\npipes.py and pipes-testchild.py) and change the parent\u2019s spawn call in pipes.py to this\n(i.e., add a -u command-line argument):\nspawn('python', '-u', 'pipes-testchild.py', 'spam')\nThen start the program with a command line like this: python -u pipes.py. It will work\nas it did with the manual stdout flush calls, because stdout will be operating in unbuf-\nfered mode in both parent and child.\nWe\u2019ll revisit the effects of unbuffered output streams in Chapter 10, where we\u2019ll code\na simple GUI that displays the output of a non-GUI program by reading it over both a\nnonblocking socket and a pipe in a thread. We\u2019ll explore the topic again in more depth\nin Chapter 12, where we will redirect standard streams to sockets in more general ways.\nDeadlock in general, though, is a bigger problem than we have space to address fully\nhere. On the other hand, if you know enough that you want to do IPC in Python, you\u2019re\nprobably already a veteran of the deadlock wars.\nAnonymous pipes allow related tasks to communicate but are not directly suited for\nindependently launched programs. To allow the latter group to converse, we need to\nmove on to the next section and explore devices that have broader visibility.\nMore on Stream Buffering: pty and Pexpect\nOn Unix-like platforms, you may also be able to use the Python pty standard library\nmodule to force another program\u2019s standard output to be unbuffered, especially if it\u2019s\nnot a Python program and you cannot change its code.\nTechnically, default buffering for stdout in other programs is determined outside Py-\nthon by whether the underlying file descriptor refers to a terminal. This occurs in the\nstdio file system library and cannot be controlled by the spawning program. In general,\noutput to terminals is line buffered, and output to nonterminals (including files, pipes,\nand sockets) is fully buffered. This policy is used for efficiency. Files and streams created\nwithin a Python script follow the same defaults, but you can specify buffering policies\nin Python\u2019s file creation tools.\nThe pty module essentially fools the spawned program into thinking it is connected to\na terminal so that only one line is buffered for stdout. The net effect is that each newline\nflushes the prior line\u2014typical of interactive programs, and what you need if you wish\nto grab each piece of the printed output as it is produced.\nNote, however, that the pty module is not required for this role when spawning Python\nscripts with pipes: simply use the -u Python command-line flag, pass line-buffered mode\nInterprocess Communication | 233arguments to file creation tools, or manually call sys.stdout.flush() in the spawned\nprogram. The pty module is also not available on all Python platforms today (most\nnotably, it runs on Cygwin but not the standard Windows Python).\nThe Pexpect package, a pure-Python equivalent of the Unix expect program, uses pty\nto provide additional functionality and to handle interactions that bypass standard\nstreams (e.g., password inputs). See the Python library manual for more on pty, and\nsearch the Web for Pexpect.\nNamed Pipes (Fifos)\nOn some platforms, it is also possible to create a long-lived pipe that exists as a real\nnamed file in the filesystem. Such files are called named pipes (or, sometimes, fifos)\nbecause they behave just like the pipes created by the previous section\u2019s programs.\nBecause fifos are associated with a real file on your computer, though, they are external\nto any particular program\u2014they do not rely on memory shared between tasks, and so\nthey can be used as an IPC mechanism for threads, processes, and independently\nlaunched programs.\nOnce a named pipe file is created, clients open it by name and read and write data using\nnormal file operations. Fifos are unidirectional streams. In typical operation, a server\nprogram reads data from the fifo, and one or more client programs write data to it. In\naddition, a set of two fifos can be used to implement bidirectional communication just\nas we did for anonymous pipes in the prior section.\nBecause fifos reside in the filesystem, they are longer-lived than in-process anonymous\npipes and can be accessed by programs started independently. The unnamed, in-\nprocess pipe examples thus far depend on the fact that file descriptors (including pipes)\nare copied to child processes\u2019 memory. That makes it difficult to use anonymous pipes\nto connect programs started independently. With fifos, pipes are accessed instead by\na filename visible to all programs running on the computer, regardless of any parent/\nchild process relationships. In fact, like normal files, fifos typically outlive the programs\nthat access them. Unlike normal files, though, the operating system synchronizes fifo\naccess, making them ideal for IPC.\nBecause of their distinctions, fifo pipes are better suited as general IPC mechanisms for\nindependent client and server programs. For instance, a perpetually running server\nprogram may create and listen for requests on a fifo that can be accessed later by arbi-\ntrary clients not forked by the server. In a sense, fifos are an alternative to the socket\nport interface we\u2019ll meet in the next section. Unlike sockets, though, fifos do not directly\nsupport remote network connections, are not available in standard Windows Python\ntoday, and are accessed using the standard file interface instead of the more unique\nsocket port numbers and calls we\u2019ll study later.\n234 | Chapter 5:\u2002Parallel System ToolsNamed pipe basics\nIn Python, named pipe files are created with the os.mkfifo call, which is available today\non Unix-like platforms, including Cygwin\u2019s Python on Windows, but is not currently\navailable in standard Windows Python. This call creates only the external file, though;\nto send and receive data through a fifo, it must be opened and processed as if it were a\nstandard file.\nTo illustrate, Example 5-24 is a derivation of the pipe2.py script listed in Exam-\nple 5-20, but rewritten here to use fifos rather than anonymous pipes. Much like\npipe2.py, this script opens the fifo using os.open in the child for low-level byte string\naccess, but with the open built-in in the parent to treat the pipe as text; in general, either\nend may use either technique to treat the pipe\u2019s data as bytes or text.\nExample 5-24. PP4E\\System\\Processes\\pipefifo.py\n\"\"\"\nnamed pipes; os.mkfifo is not available on Windows (without Cygwin);\nthere is no reason to fork here, since fifo file pipes are external\nto processes--shared fds in parent/child processes are irrelevent;\n\"\"\"\nimport os, time, sys\nfifoname = '/tmp/pipefifo'                       # must open same name\ndef child():\n    pipeout = os.open(fifoname, os.O_WRONLY)     # open fifo pipe file as fd\n    zzz = 0\n    while True:\n        time.sleep(zzz)\n        msg = ('Spam %03d\\n' % zzz).encode()     # binary as opened here\n        os.write(pipeout, msg)\n        zzz = (zzz+1) % 5\ndef parent():\n    pipein = open(fifoname, 'r')                 # open fifo as text file object\n    while True:\n        line = pipein.readline()[:-1]            # blocks until data sent\n        print('Parent %d got \"%s\" at %s' % (os.getpid(), line, time.time()))\nif __name__ == '__main__':\n    if not os.path.exists(fifoname):\n        os.mkfifo(fifoname)                      # create a named pipe file\n    if len(sys.argv) == 1:\n        parent()                                 # run as parent if no args\n    else:                                        # else run as child process\n        child()\nBecause the fifo exists independently of both parent and child, there\u2019s no reason to fork\nhere. The child may be started independently of the parent as long as it opens a fifo file\nby the same name. Here, for instance, on Cygwin the parent is started in one shell\nInterprocess Communication | 235window and then the child is started in another. Messages start appearing in the parent\nwindow only after the child is started and begins writing messages onto the fifo file:\n[C:\\...\\PP4E\\System\\Processes] $ python pipefifo.py           # parent window\nParent 8324 got \"Spam 000\" at 1268003696.07\nParent 8324 got \"Spam 001\" at 1268003697.06\nParent 8324 got \"Spam 002\" at 1268003699.07\nParent 8324 got \"Spam 003\" at 1268003702.08\nParent 8324 got \"Spam 004\" at 1268003706.09\nParent 8324 got \"Spam 000\" at 1268003706.09\nParent 8324 got \"Spam 001\" at 1268003707.11\nParent 8324 got \"Spam 002\" at 1268003709.12\nParent 8324 got \"Spam 003\" at 1268003712.13\nParent 8324 got \"Spam 004\" at 1268003716.14\nParent 8324 got \"Spam 000\" at 1268003716.14\nParent 8324 got \"Spam 001\" at 1268003717.15\n...etc: Ctrl-C to exit...\n[C:\\...\\PP4E\\System\\Processes]$ file /tmp/pipefifo            # child window\n/tmp/pipefifo: fifo (named pipe)\n[C:\\...\\PP4E\\System\\Processes]$ python pipefifo.py -child\n...Ctrl-C to exit...\nNamed pipe use cases\nBy mapping communication points to a file system entity accessible to all programs run\non a machine, fifos can address a broad range of IPC goals on platforms where they are\nsupported. For instance, although this section\u2019s example runs independent programs,\nnamed pipes can also be used as an IPC device by both in-process threads and directly\nforked related processes, much as we saw for anonymous pipes earlier.\nBy also supporting unrelated programs, though, fifo files are more widely applicable to\ngeneral client/server models. For example, named pipes can make the GUI and\ncommand-line debugger integration I described earlier for anonymous pipes even more\nflexible\u2014by using fifo files to connect the GUI to the non-GUI debugger\u2019s streams, the\nGUI could be started independently when needed.\nSockets provide similar functionality but also buy us both inherent network awareness\nand broader portability to Windows\u2014as the next section explains.\nSockets: A First Look\nSockets, implemented by the Python socket module, are a more general IPC device\nthan the pipes we\u2019ve seen so far. Sockets let us transfer data between programs running\non the same computer, as well as programs located on remote networked machines.\nWhen used as an IPC mechanism on the same machine, programs connect to sockets\nby a machine-global port number and transfer data. When used as a networking con-\nnection, programs provide both a machine name and port number to transfer data to\na remotely-running program.\n236 | Chapter 5:\u2002Parallel System ToolsSocket basics\nAlthough sockets are one of the most commonly used IPC tools, it\u2019s impossible to fully\ngrasp their API without also seeing its role in networking. Because of that, we\u2019ll defer\nmost of our socket coverage until we can explore their use in network scripting in\nChapter 12. This section provides a brief introduction and preview, so you can compare\nwith the prior section\u2019s named pipes (a.k.a. fifos). In short:\n\u2022 Like fifos, sockets are global across a machine; they do not require shared memory\namong threads or processes, and are thus applicable to independent programs.\n\u2022 Unlike fifos, sockets are identified by port number, not filesystem path name; they\nemploy a very different nonfile API, though they can be wrapped in a file-like object;\nand they are more portable: they work on nearly every Python platform, including\nstandard Windows Python.\nIn addition, sockets support networking roles that go beyond both IPC and this chap-\nter\u2019s scope. To illustrate the basics, though, Example 5-25 launches a server and 5\nclients in threads running in parallel on the same machine, to communicate over a\nsocket\u2014because all threads connect to the same port, the server consumes the data\nadded by each of the clients.\nExample 5-25. PP4E\\System\\Processes\\socket_preview.py\n\"\"\"\nsockets for cross-task communication: start threads to communicate over sockets;\nindependent programs can too, because sockets are system-wide, much like fifos;\nsee the GUI and Internet parts of the book for more realistic socket use cases;\nsome socket servers may also need to talk to clients in threads or processes;\nsockets pass byte strings, but can be pickled objects or encoded Unicode text;\ncaveat: prints in threads may need to be synchronized if their output overlaps;\n\"\"\"\nfrom socket import socket, AF_INET, SOCK_STREAM     # portable socket api\nport = 50008                 # port number identifies socket on machine\nhost = 'localhost'           # server and client run on same local machine here\ndef server():\n    sock = socket(AF_INET, SOCK_STREAM)         # ip addresses tcp connection\n    sock.bind(('', port))                       # bind to port on this machine\n    sock.listen(5)                              # allow up to 5 pending clients\n    while True:\n        conn, addr = sock.accept()              # wait for client to connect\n        data = conn.recv(1024)                  # read bytes data from this client\n        reply = 'server got: [%s]' % data       # conn is a new connected socket\n        conn.send(reply.encode())               # send bytes reply back to client\ndef client(name):\n    sock = socket(AF_INET, SOCK_STREAM)\n    sock.connect((host, port))                  # connect to a socket port\n    sock.send(name.encode())                    # send bytes data to listener\n    reply = sock.recv(1024)                     # receive bytes data from listener\nInterprocess Communication | 237sock.close()                                # up to 1024 bytes in message\n    print('client got: [%s]' % reply)\nif __name__ == '__main__':\n    from threading import Thread\n    sthread = Thread(target=server)\n    sthread.daemon = True                       # don't wait for server thread\n    sthread.start()                             # do wait for children to exit\n    for i in range(5):\n         Thread(target=client, args=('client%s' % i,)).start()\nStudy this script\u2019s code and comments to see how the socket objects\u2019 methods are used\nto transfer data. In a nutshell, with this type of socket the server accepts a client con-\nnection, which by default blocks until a client requests service, and returns a new socket\nconnected to the client. Once connected, the client and server transfer byte strings by\nusing send and receive calls instead of writes and reads, though as we\u2019ll see later in the\nbook, sockets can be wrapped in file objects much as we did earlier for pipe descriptors.\nAlso like pipe descriptors, unwrapped sockets deal in binary bytes strings, not text\nstr; that\u2019s why string formatting results are manually encoded again here.\nHere is this script\u2019s output on Windows:\nC:\\...\\PP4E\\System\\Processes> socket_preview.py\nclient got: [b\"server got: [b'client1']\"]\nclient got: [b\"server got: [b'client3']\"]\nclient got: [b\"server got: [b'client4']\"]\nclient got: [b\"server got: [b'client2']\"]\nclient got: [b\"server got: [b'client0']\"]\nThis output isn\u2019t much to look at, but each line reflects data sent from client to server,\nand then back again: the server receives a bytes string from a connected client and\nechoes it back in a larger reply string. Because all threads run in parallel, the order in\nwhich the clients are served is random on this machine.\nSockets and independent programs\nAlthough sockets work for threads, the shared memory model of threads often allows\nthem to employ simpler communication devices such as shared names and objects and\nqueues. Sockets tend to shine brighter when used for IPC by separate processes and\nindependently launched programs. Example 5-26, for instance, reuses the server\nand client functions of the prior example, but runs them in both processes and threads\nof independently launched programs.\nExample 5-26. PP4E\\System\\Processes\\socket-preview-progs.py\n\"\"\"\nsame socket, but talk between independent programs too, not just threads;\nserver here runs in a process and serves both process and thread clients;\nsockets are machine-global, much like fifos: don't require shared memory\n\"\"\"\nfrom socket_preview import server, client         # both use same port number\n238 | Chapter 5:\u2002Parallel System Toolsimport sys, os\nfrom threading import Thread\nmode = int(sys.argv[1])\nif mode == 1:                                     # run server in this process\n    server()\nelif mode == 2:                                   # run client in this process\n    client('client:process=%s' % os.getpid())\nelse:                                             # run 5 client threads in process\n    for i in range(5):\n        Thread(target=client, args=('client:thread=%s' % i,)).start()\nLet\u2019s run this script on Windows, too (again, this portability is a major advantage of\nsockets). First, start the server in a process as an independently launched program in\nits own window; this process runs perpetually waiting for clients to request connections\n(and as for our prior pipe example you may need to use Task Manager or a window\nclose to kill the server process eventually):\nC:\\...\\PP4E\\System\\Processes> socket-preview-progs.py 1\nNow, in another window, run a few clients in both processes and thread, by launching\nthem as independent programs\u2014using 2 as the command-line argument runs a single\nclient process, but 3 spawns five threads to converse with the server on parallel:\nC:\\...\\PP4E\\System\\Processes> socket-preview-progs.py 2\nclient got: [b\"server got: [b'client:process=7384']\"]\nC:\\...\\PP4E\\System\\Processes> socket-preview-progs.py 2\nclient got: [b\"server got: [b'client:process=7604']\"]\nC:\\...\\PP4E\\System\\Processes> socket-preview-progs.py 3\nclient got: [b\"server got: [b'client:thread=1']\"]\nclient got: [b\"server got: [b'client:thread=2']\"]\nclient got: [b\"server got: [b'client:thread=0']\"]\nclient got: [b\"server got: [b'client:thread=3']\"]\nclient got: [b\"server got: [b'client:thread=4']\"]\nC:\\..\\PP4E\\System\\Processes> socket-preview-progs.py 3\nclient got: [b\"server got: [b'client:thread=3']\"]\nclient got: [b\"server got: [b'client:thread=1']\"]\nclient got: [b\"server got: [b'client:thread=2']\"]\nclient got: [b\"server got: [b'client:thread=4']\"]\nclient got: [b\"server got: [b'client:thread=0']\"]\nC:\\...\\PP4E\\System\\Processes> socket-preview-progs.py 2\nclient got: [b\"server got: [b'client:process=6428']\"]\nSocket use cases\nThis section\u2019s examples illustrate the basic IPC role of sockets, but this only hints at\ntheir full utility. Despite their seemingly limited byte string nature, higher-order use\ncases for sockets are not difficult to imagine. With a little extra work, for instance:\nInterprocess Communication | 239\u2022 Arbitrary Python objects like lists and dictionaries (or at least copies of them) can\nbe transferred over sockets, too, by shipping the serialized byte strings produced\nby Python\u2019s pickle module introduced in Chapter 1 and covered in full in\nChapter 17.\n\u2022 As we\u2019ll see in Chapter 10, the printed output of a simple script can be redirected\nto a GUI window, by connecting the script\u2019s output stream to a socket on which\na GUI is listening in nonblocking mode.\n\u2022 Programs that fetch arbitrary text off the Web might read it as byte strings over\nsockets, but manually decode it using encoding names embedded in content-type\nheaders or tags in the data itself.\n\u2022 In fact, the entire Internet can be seen as a socket use case\u2014as we\u2019ll see in Chap-\nter 12, at the bottom, email, FTP, and web pages are largely just formatted byte\nstring messages shipped over sockets.\nPlus any other context in which programs exchange data\u2014sockets are a general, port-\nable, and flexible tool. For instance, they would provide the same utility as fifos for the\nGUI/debugger example used earlier, but would also work in Python on Windows and\nwould even allow the GUI to connect to a debugger running on a different computer\naltogether. As such, they are seen by many as a more powerful IPC tool.\nAgain, you should consider this section just a preview; because the grander socket story\nalso entails networking concepts, we\u2019ll defer a more in-depth look at the socket API\nuntil Chapter 12. We\u2019ll also see sockets again briefly in Chapter 10 in the GUI stream\nredirection use case listed above, and we\u2019ll explore a variety of additional socket use\ncases in the Internet part of this book. In Part IV, for instance, we\u2019ll use sockets to\ntransfer entire files and write more robust socket servers that spawn threads or processes\nto converse with clients to avoid denying connections. For the purposes of this chapter,\nlet\u2019s move on to one last traditional IPC tool\u2014the signal.\nSignals\nFor lack of a better analogy, signals are a way to poke a stick at a process. Programs\ngenerate signals to trigger a handler for that signal in another process. The operating\nsystem pokes, too\u2014some signals are generated on unusual system events and may kill\nthe program if not handled. If this sounds a little like raising exceptions in Python, it\nshould; signals are software-generated events and the cross-process analog of excep-\ntions. Unlike exceptions, though, signals are identified by number, are not stacked, and\nare really an asynchronous event mechanism outside the scope of the Python interpreter\ncontrolled by the operating system.\nIn order to make signals available to scripts, Python provides a signal module that\nallows Python programs to register Python functions as handlers for signal events. This\nmodule is available on both Unix-like platforms and Windows (though the Windows\nversion may define fewer kinds of signals to be caught). To illustrate the basic signal\n240 | Chapter 5:\u2002Parallel System Toolsinterface, the script in Example 5-27 installs a Python handler function for the signal\nnumber passed in as a command-line argument.\nExample 5-27. PP4E\\System\\Processes\\signal1.py\n\"\"\"\ncatch signals in Python; pass signal number N as a command-line arg,\nuse a \"kill -N pid\" shell command to send this process a signal;  most\nsignal handlers restored by Python after caught (see network scripting\nchapter for SIGCHLD details); on Windows, signal module is available,\nbut it defines only a few signal types there, and os.kill is missing;\n\"\"\"\nimport sys, signal, time\ndef now(): return time.ctime(time.time())        # current time string\ndef onSignal(signum, stackframe):                # python signal handler\n    print('Got signal', signum, 'at', now())     # most handlers stay in effect\nsignum = int(sys.argv[1])\nsignal.signal(signum, onSignal)                  # install signal handler\nwhile True: signal.pause()                       # wait for signals (or: pass)\nThere are only two signal module calls at work here:\nsignal.signal\nTakes a signal number and function object and installs that function to handle that\nsignal number when it is raised. Python automatically restores most signal handlers\nwhen signals occur, so there is no need to recall this function within the signal\nhandler itself to reregister the handler. That is, except for SIGCHLD, a signal handler\nremains installed until explicitly reset (e.g., by setting the handler to SIG_DFL to\nrestore default behavior or to SIG_IGN to ignore the signal). SIGCHLD behavior is\nplatform specific.\nsignal.pause\nMakes the process sleep until the next signal is caught. A time.sleep call is similar\nbut doesn\u2019t work with signals on my Linux box; it generates an interrupted system\ncall error. A busy while True: pass loop here would pause the script, too, but may\nsquander CPU resources.\nHere is what this script looks like running on Cygwin on Windows (it works the same\non other Unix-like platforms like Linux): a signal number to watch for (12) is passed\nin on the command line, and the program is made to run in the background with an\n& shell operator (available in most Unix-like shells):\n[C:\\...\\PP4E\\System\\Processes]$ python signal1.py 12 &\n[1] 8224\n$ ps\n      PID    PPID    PGID     WINPID  TTY  UID    STIME COMMAND\nI    8944       1    8944       8944  con 1004 18:09:54 /usr/bin/bash\n     8224    7336    8224      10020  con 1004 18:26:47 /usr/local/bin/python\nInterprocess Communication | 2418380    7336    8380        428  con 1004 18:26:50 /usr/bin/ps\n$ kill \u221212 8224\nGot signal 12 at Sun Mar  7 18:27:28 2010\n$ kill \u221212 8224\nGot signal 12 at Sun Mar  7 18:27:30 2010\n$ kill \u22129 8224\n[1]+  Killed                  python signal1.py 12\nInputs and outputs can be a bit jumbled here because the process prints to the same\nscreen used to type new shell commands. To send the program a signal, the kill shell\ncommand takes a signal number and a process ID to be signaled (8224); every time a\nnew kill command sends a signal, the process replies with a message generated by a\nPython signal handler function. Signal 9 always kills the process altogether.\nThe signal module also exports a signal.alarm function for scheduling a SIGALRM signal\nto occur at some number of seconds in the future. To trigger and catch timeouts, set\nthe alarm and install a SIGALRM handler as shown in Example 5-28.\nExample 5-28. PP4E\\System\\Processes\\signal2.py\n\"\"\"\nset and catch alarm timeout signals in Python; time.sleep doesn't play\nwell with alarm (or signal in general in my Linux PC), so we call\nsignal.pause here to do nothing until a signal is received;\n\"\"\"\nimport sys, signal, time\ndef now(): return time.asctime()\ndef onSignal(signum, stackframe):                 # python signal handler\n    print('Got alarm', signum, 'at', now())       # most handlers stay in effect\nwhile True:\n    print('Setting at', now())\n    signal.signal(signal.SIGALRM, onSignal)       # install signal handler\n    signal.alarm(5)                               # do signal in 5 seconds\n    signal.pause()                                # wait for signals\nRunning this script on Cygwin on Windows causes its onSignal handler function to be\ninvoked every five seconds:\n[C:\\...\\PP4E\\System\\Processes]$ python signal2.py\nSetting at Sun Mar  7 18:37:10 2010\nGot alarm 14 at Sun Mar  7 18:37:15 2010\nSetting at Sun Mar  7 18:37:15 2010\nGot alarm 14 at Sun Mar  7 18:37:20 2010\nSetting at Sun Mar  7 18:37:20 2010\nGot alarm 14 at Sun Mar  7 18:37:25 2010\nSetting at Sun Mar  7 18:37:25 2010\nGot alarm 14 at Sun Mar  7 18:37:30 2010\n242 | Chapter 5:\u2002Parallel System ToolsSetting at Sun Mar  7 18:37:30 2010\n...Ctrl-C to exit...\nGenerally speaking, signals must be used with cautions not made obvious by the ex-\namples we\u2019ve just seen. For instance, some system calls don\u2019t react well to being inter-\nrupted by signals, and only the main thread can install signal handlers and respond to\nsignals in a multithreaded program.\nWhen used well, though, signals provide an event-based communication mechanism.\nThey are less powerful than data streams such as pipes, but are sufficient in situations\nin which you just need to tell a program that something important has occurred and\ndon\u2019t need to pass along any details about the event itself. Signals are sometimes also\ncombined with other IPC tools. For example, an initial signal may inform a program\nthat a client wishes to communicate over a named pipe\u2014the equivalent of tapping\nsomeone\u2019s shoulder to get their attention before speaking. Most platforms reserve one\nor more SIGUSR signal numbers for user-defined events of this sort. Such an integration\nstructure is sometimes an alternative to running a blocking input call in a spawned\nthread.\nSee also the os.kill(pid, sig) call for sending signals to known processes from within\na Python script on Unix-like platforms, much like the kill shell command used earlier;\nthe required process ID can be obtained from the os.fork call\u2019s child process ID return\nvalue or from other interfaces. Like os.fork, this call is also available in Cygwin Python,\nbut not in standard Windows Python. Also watch for the discussion about using signal\nhandlers to clean up \u201czombie\u201d processes in Chapter 12.\nThe multiprocessing Module\nNow that you know about IPC alternatives and have had a chance to explore processes,\nthreads, and both process nonportability and thread GIL limitations, it turns out that\nthere is another alternative, which aims to provide just the best of both worlds. As\nmentioned earlier, Python\u2019s standard library multiprocessing module package allows\nscripts to spawn processes using an API very similar to the threading module.\nThis relatively new package works on both Unix and Windows, unlike low-level process\nforks. It supports a process spawning model which is largely platform-neutral, and\nprovides tools for related goals, such as IPC, including locks, pipes, and queues. In\naddition, because it uses processes instead of threads to run code in parallel, it effec-\ntively works around the limitations of the thread GIL. Hence, multiprocessing allows\nthe programmer to leverage the capacity of multiple processors for parallel tasks, while\nretaining much of the simplicity and portability of the threading model.\nWhy multiprocessing?\nSo why learn yet another parallel processing paradigm and toolkit, when we already\nhave the threads, processes, and IPC tools like sockets, pipes, and thread queues that\nThe multiprocessing Module | 243we\u2019ve already studied? Before we get into the details, I want to begin with a few words\nabout why you may (or may not) care about this package. In more specific terms,\nalthough this module\u2019s performance may not compete with that of pure threads or\nprocess forks for some applications, this module offers a compelling solution for many:\n\u2022 Compared to raw process forks, you gain cross-platform portability and powerful\nIPC tools.\n\u2022 Compared to threads, you essentially trade some potential and platform-\ndependent extra task start-up time for the ability to run tasks in truly parallel fash-\nion on multi-core or multi-CPU machines.\nOn the other hand, this module imposes some constraints and tradeoffs that threads\ndo not:\n\u2022 Since objects are copied across process boundaries, shared mutable state does not\nwork as it does for threads\u2014changes in one process are not generally noticed in\nthe other. Really, freely shared state may be the most compelling reason to use\nthreads; its absence in this module may prove limiting in some threading contexts.\n\u2022 Because this module requires pickleability for both its processes on Windows, as\nwell as some of its IPC tools in general, some coding paradigms are difficult or\nnonportable\u2014especially if they use bound methods or pass unpickleable objects\nsuch as sockets to spawned processes.\nFor instance, common coding patterns with lambda that work for the threading module\ncannot be used as process target callables in this module on Windows, because they\ncannot be pickled. Similarly, because bound object methods are also not pickleable, a\nthreaded program may require a more indirect design if it either runs bound methods\nin its threads or implements thread exit actions by posting arbitrary callables (possibly\nincluding bound methods) on shared queues. The in-process model of threads supports\nsuch direct lambda and bound method use, but the separate processes of\nmultiprocessing do not.\nIn fact we\u2019ll write a thread manager for GUIs in Chapter 10 that relies on queueing\nin-process callables this way to implement thread exit actions\u2014the callables are queued\nby worker threads, and fetched and dispatched by the main thread. Because the\nthreaded PyMailGUI program we\u2019ll code in Chapter 14 both uses this manager to queue\nbound methods for thread exit actions and runs bound methods as the main action of\na thread itself, it could not be directly translated to the separate process model implied\nby multiprocessing.\nWithout getting into too many details here, to use multiprocessing, PyMailGUI\u2019s ac-\ntions might have to be coded as simple functions or complete process subclasses for\npickleability. Worse, they may have to be implemented as simpler action identifiers\ndispatched in the main process, if they update either the GUI itself or object state in\ngeneral \u2014pickling results in an object copy in the receiving process, not a reference to\nthe original, and forks on Unix essentially copy an entire process. Updating the state\n244 | Chapter 5:\u2002Parallel System Toolsof a mutable message cache copied by pickling it to pass to a new process, for example,\nhas no effect on the original.\nThe pickleability constraints for process arguments on Windows can limit\nmultiprocessing\u2019s scope in other contexts as well. For instance, in Chapter 12, we\u2019ll\nfind that this module doesn\u2019t directly solve the lack of portability for the os.fork call\nfor traditionally coded socket servers on Windows, because connected sockets are not\npickled correctly when passed into a new process created by this module to converse\nwith a client. In this context, threads provide a more portable and likely more efficient\nsolution.\nApplications that pass simpler types of messages, of course, may fare better. Message\nconstraints are easier to accommodate when they are part of an initial process-based\ndesign. Moreover, other tools in this module, such as its managers and shared memory\nAPI, while narrowly focused and not as general as shared thread state, offer additional\nmutable state options for some programs.\nFundamentally, though, because multiprocessing is based on separate processes, it\nmay be best geared for tasks which are relatively independent, do not share mutable\nobject state freely, and can make do with the message passing and shared memory tools\nprovided by this module. This includes many applications, but this module is not nec-\nessarily a direct replacement for every threaded program, and it is not an alternative to\nprocess forks in all contexts.\nTo truly understand both this module package\u2019s benefits, as well as its tradeoffs, let\u2019s\nturn to a first example and explore this package\u2019s implementation along the way.\nThe Basics: Processes and Locks\nWe don\u2019t have space to do full justice to this sophisticated module in this book; see its\ncoverage in the Python library manual for the full story. But as a brief introduction, by\ndesign most of this module\u2019s interfaces mirror the threading and queue modules we\u2019ve\nalready met, so they should already seem familiar. For example, the multiprocessing\nmodule\u2019s Process class is intended to mimic the threading module\u2019s Thread class we\nmet earlier\u2014it allows us to launch a function call in parallel with the calling script;\nwith this module, though, the function runs in a process instead of a thread. Exam-\nple 5-29 illustrates these basics in action:\nExample 5-29. PP4E\\System\\Processes\\multi1.py\n\"\"\"\nmultiprocess basics: Process works like threading.Thread, but\nruns function call in parallel in a process instead of a thread;\nlocks can be used to synchronize, e.g. prints on some platforms;\nstarts new interpreter on windows, forks a new process on unix;\n\"\"\"\nimport os\nfrom multiprocessing import Process, Lock\nThe multiprocessing Module | 245def whoami(label, lock):\n    msg = '%s: name:%s, pid:%s'\n    with lock:\n        print(msg % (label, __name__, os.getpid()))\nif __name__ == '__main__':\n    lock = Lock()\n    whoami('function call', lock)\n    p = Process(target=whoami, args=('spawned child', lock))\n    p.start()\n    p.join()\n    for i in range(5):\n        Process(target=whoami, args=(('run process %s' % i), lock)).start()\n    with lock:\n        print('Main process exit.')\nWhen run, this script first calls a function directly and in-process; then launches a call\nto that function in a new process and waits for it to exit; and finally spawns five function\ncall processes in parallel in a loop\u2014all using an API identical to that of the\nthreading.Thread model we studied earlier in this chapter. Here\u2019s this script\u2019s output\non Windows; notice how the five child processes spawned at the end of this script\noutlive their parent, as is the usual case for processes:\nC:\\...\\PP4E\\System\\Processes> multi1.py\nfunction call: name:__main__, pid:8752\nspawned child: name:__main__, pid:9268\nMain process exit.\nrun process 3: name:__main__, pid:9296\nrun process 1: name:__main__, pid:8792\nrun process 4: name:__main__, pid:2224\nrun process 2: name:__main__, pid:8716\nrun process 0: name:__main__, pid:6936\nJust like the threading.Thread class we met earlier, the multiprocessing.Process object\ncan either be passed a target with arguments (as done here) or subclassed to redefine\nits run action method. Its start method invokes its run method in a new process, and\nthe default run simply calls the passed-in target. Also like threading, a join method\nwaits for child process exit, and a Lock object is provided as one of a handful of process\nsynchronization tools; it\u2019s used here to ensure that prints don\u2019t overlap among pro-\ncesses on platforms where this might matter (it may not on Windows).\nImplementation and usage rules\nTechnically, to achieve its portability, this module currently works by selecting from\nplatform-specific alternatives:\n\u2022 On Unix, it forks a new child process and invokes the Process object\u2019s run method\nin the new child.\n246 | Chapter 5:\u2002Parallel System Tools\u2022 On Windows, it spawns a new interpreter by using Windows-specific process cre-\nation tools, passing the pickled Process object in to the new process over a pipe,\nand starting a \u201cpython -c\u201d command line in the new process, which runs a special\nPython-coded function in this package that reads and unpickles the Process and\ninvokes its run method.\nWe met pickling briefly in Chapter 1, and we will study it further later in this book.\nThe implementation is a bit more complex than this, and is prone to change over time,\nof course, but it\u2019s really quite an amazing trick. While the portable API generally hides\nthese details from your code, its basic structure can still have subtle impacts on the way\nyou\u2019re allowed to use it. For instance:\n\u2022 On Windows, the main process\u2019s logic should generally be nested under a __name__\n== __main__ test as done here when using this module, so it can be imported freely\nby a new interpreter without side effects. As we\u2019ll learn in more detail in Chap-\nter 17, unpickling classes and functions requires an import of their enclosing mod-\nule, and this is the root of this requirement.\n\u2022 Moreover, when globals are accessed in child processes on Windows, their values\nmay not be the same as that in the parent at start time, because their module will\nbe imported into a new process.\n\u2022 Also on Windows, all arguments to Process must be pickleable. Because this in-\ncludes target, targets should be simple functions so they can be pickled; they can-\nnot be bound or unbound object methods and cannot be functions created with a\nlambda. See pickle in Python\u2019s library manual for more on pickleability rules;\nnearly every object type works, but callables like functions and classes must be\nimportable\u2014they are pickled by name only, and later imported to recreate byte-\ncode. On Windows, objects with system state, such as connected sockets, won\u2019t\ngenerally work as arguments to a process target either, because they are not\npickleable.\n\u2022 Similarly, instances of custom Process subclasses must be pickleable on Windows\nas well. This includes all their attribute values. Objects available in this package\n(e.g., Lock in Example 5-29) are pickleable, and so may be used as both Process\nconstructor arguments and subclass attributes.\n\u2022 IPC objects in this package that appear in later examples like Pipe and Queue accept\nonly pickleable objects, because of their implementation (more on this in the next\nsection).\n\u2022 On Unix, although a child process can make use of a shared global item created in\nthe parent, it\u2019s better to pass the object as an argument to the child process\u2019s con-\nstructor, both for portability to Windows and to avoid potential problems if such\nobjects were garbage collected in the parent.\nThere are additional rules documented in the library manual. In general, though, if you\nstick to passing in shared objects to processes and using the synchronization and\nThe multiprocessing Module | 247communication tools provided by this package, your code will usually be portable and\ncorrect. Let\u2019s look next at a few of those tools in action.\nIPC Tools: Pipes, Shared Memory, and Queues\nWhile the processes created by this package can always communicate using general\nsystem-wide tools like the sockets and fifo files we met earlier, the multiprocessing\nmodule also provides portable message passing tools specifically geared to this purpose\nfor the processes it spawns:\n\u2022 Its Pipe object provides an anonymous pipe, which serves as a connection between\ntwo processes. When called, Pipe returns two Connection objects that represent the\nends of the pipe. Pipes are bidirectional by default, and allow arbitrary pickleable\nPython objects to be sent and received. On Unix they are implemented internally\ntoday with either a connected socket pair or the os.pipe call we met earlier, and\non Windows with named pipes specific to that platform. Much like the Process\nobject described earlier, though, the Pipe object\u2019s portable API spares callers from\nsuch things.\n\u2022 Its Value and Array objects implement shared process/thread-safe memory for\ncommunication between processes. These calls return scalar and array objects\nbased in the ctypes module and created in shared memory, with access synchron-\nized by default.\n\u2022 Its Queue object serves as a FIFO list of Python objects, which allows multiple pro-\nducers and consumers. A queue is essentially a pipe with extra locking mechanisms\nto coordinate more arbitrary accesses, and inherits the pickleability constraints of\nPipe.\nBecause these devices are safe to use across multiple processes, they can often serve to\nsynchronize points of communication and obviate lower-level tools like locks, much\nthe same as the thread queues we met earlier. As usual, a pipe (or a pair of them) may\nbe used to implement a request/reply model. Queues support more flexible models; in\nfact, a GUI that wishes to avoid the limitations of the GIL might use the\nmultiprocessing module\u2019s Process and Queue to spawn long-running tasks that post\nresults, rather than threads. As mentioned, although this may incur extra start-up\noverhead on some platforms, unlike threads today, tasks coded this way can be as truly\nparallel as the underlying platform allows.\nOne constraint worth noting here: this package\u2019s pipes (and by proxy, queues) pickle\nthe objects passed through them, so that they can be reconstructed in the receiving\nprocess (as we\u2019ve seen, on Windows the receiver process may be a fully independent\nPython interpreter). Because of that, they do not support unpickleable objects; as sug-\ngested earlier, this includes some callables like bound methods and lambda functions\n(see file multi-badq.py in the book examples package for a demonstration of code that\nviolates this constraint). Objects with system state, such as sockets, may fail as well.\n248 | Chapter 5:\u2002Parallel System ToolsMost other Python object types, including classes and simple functions, work fine on\npipes and queues.\nAlso keep in mind that because they are pickled, objects transferred this way are effec-\ntively copied in the receiving process; direct in-place changes to mutable objects\u2019 state\nwon\u2019t be noticed in the sender. This makes sense if you remember that this package\nruns independent processes with their own memory spaces; state cannot be as freely\nshared as in threading, regardless of which IPC tools you use.\nmultiprocessing pipes\nTo demonstrate the IPC tools listed above, the next three examples implement three\nflavors of communication between parent and child processes. Example 5-30 uses a\nsimple shared pipe object to send and receive data between parent and child processes.\nExample 5-30. PP4E\\System\\Processes\\multi2.py\n\"\"\"\nUse multiprocess anonymous pipes to communicate. Returns 2 connection\nobject representing ends of the pipe: objects are sent on one end and\nreceived on the other, though pipes are bidirectional by default\n\"\"\"\nimport os\nfrom multiprocessing import Process, Pipe\ndef sender(pipe):\n    \"\"\"\n    send object to parent on anonymous pipe\n    \"\"\"\n    pipe.send(['spam'] +  [42, 'eggs'])\n    pipe.close()\ndef talker(pipe):\n    \"\"\"\n    send and receive objects on a pipe\n    \"\"\"\n    pipe.send(dict(name='Bob', spam=42))\n    reply = pipe.recv()\n    print('talker got:', reply)\nif __name__ == '__main__':\n    (parentEnd, childEnd) = Pipe()\n    Process(target=sender, args=(childEnd,)).start()        # spawn child with pipe\n    print('parent got:', parentEnd.recv())                  # receive from child\n    parentEnd.close()                                       # or auto-closed on gc\n    (parentEnd, childEnd) = Pipe()\n    child = Process(target=talker, args=(childEnd,))\n    child.start()\n    print('parent got:', parentEnd.recv())                  # receieve from child\n    parentEnd.send({x * 2 for x in 'spam'})                 # send to child\nThe multiprocessing Module | 249child.join()                                            # wait for child exit\n    print('parent exit')\nWhen run on Windows, here\u2019s this script\u2019s output\u2014one child passes an object to the\nparent, and the other both sends and receives on the same pipe:\nC:\\...\\PP4E\\System\\Processes> multi2.py\nparent got: ['spam', 42, 'eggs']\nparent got: {'name': 'Bob', 'spam': 42}\ntalker got: {'ss', 'aa', 'pp', 'mm'}\nparent exit\nThis module\u2019s pipe objects make communication between two processes portable (and\nnearly trivial).\nShared memory and globals\nExample 5-31 uses shared memory to serve as both inputs and outputs of spawned\nprocesses. To make this work portably, we must create objects defined by the package\nand pass them to Process constructors. The last test in this demo (\u201cloop4\u201d) probably\nrepresents the most common use case for shared memory\u2014that of distributing com-\nputation work to multiple parallel processes.\nExample 5-31. PP4E\\System\\Processes\\multi3.py\n\"\"\"\nUse multiprocess shared memory objects to communicate.\nPassed objects are shared, but globals are not on Windows.\nLast test here reflects common use case: distributing work.\n\"\"\"\nimport os\nfrom multiprocessing import Process, Value, Array\nprocs = 3\ncount = 0    # per-process globals, not shared\ndef showdata(label, val, arr):\n    \"\"\"\n    print data values in this process\n    \"\"\"\n    msg = '%-12s: pid:%4s, global:%s, value:%s, array:%s'\n    print(msg % (label, os.getpid(), count, val.value, list(arr)))\ndef updater(val, arr):\n    \"\"\"\n    communicate via shared memory\n    \"\"\"\n    global count\n    count += 1                         # global count not shared\n    val.value += 1                     # passed in objects are\n    for i in range(3): arr[i] += 1\nif __name__ == '__main__':\n250 | Chapter 5:\u2002Parallel System Toolsscalar = Value('i', 0)             # shared memory: process/thread safe\n    vector = Array('d', procs)         # type codes from ctypes: int, double\n    # show start value in parent process\n    showdata('parent start', scalar, vector)\n    # spawn child, pass in shared memory\n    p = Process(target=showdata, args=('child ', scalar, vector))\n    p.start(); p.join()\n    # pass in shared memory updated in parent, wait for each to finish\n    # each child sees updates in parent so far for args (but not global)\n    print('\\nloop1 (updates in parent, serial children)...')\n    for i in range(procs):\n        count += 1\n        scalar.value += 1\n        vector[i] += 1\n        p = Process(target=showdata, args=(('process %s' % i), scalar, vector))\n        p.start(); p.join()\n    # same as prior, but allow children to run in parallel\n    # all see the last iteration's result because all share objects\n    print('\\nloop2 (updates in parent, parallel children)...')\n    ps = []\n    for i in range(procs):\n        count += 1\n        scalar.value += 1\n        vector[i] += 1\n        p = Process(target=showdata, args=(('process %s' % i), scalar, vector))\n        p.start()\n        ps.append(p)\n    for p in ps: p.join()\n    # shared memory updated in spawned children, wait for each\n    print('\\nloop3 (updates in serial children)...')\n    for i in range(procs):\n        p = Process(target=updater, args=(scalar, vector))\n        p.start()\n        p.join()\n    showdata('parent temp', scalar, vector)\n    # same, but allow children to update in parallel\n    ps = []\n    print('\\nloop4 (updates in parallel children)...')\n    for i in range(procs):\n        p = Process(target=updater, args=(scalar, vector))\n        p.start()\n        ps.append(p)\n    for p in ps: p.join()\n                                           # global count=6 in parent only\nThe multiprocessing Module | 251# show final results here              # scalar=12:  +6 parent, +6 in 6 children\n    showdata('parent end', scalar, vector) # array[i]=8: +2 parent, +6 in 6 children\nThe following is this script\u2019s output on Windows. Trace through this and the code to\nsee how it runs; notice how the changed value of the global variable is not shared by\nthe spawned processes on Windows, but passed-in Value and Array objects are. The\nfinal output line reflects changes made to shared memory in both the parent and\nspawned children\u2014the array\u2019s final values are all 8.0, because they were incremented\ntwice in the parent, and once in each of six spawned children; the scalar value similarly\nreflects changes made by both parent and child; but unlike for threads, the global is\nper-process data on Windows:\nC:\\...\\PP4E\\System\\Processes> multi3.py\nparent start: pid:6204, global:0, value:0, array:[0.0, 0.0, 0.0]\nchild       : pid:9660, global:0, value:0, array:[0.0, 0.0, 0.0]\nloop1 (updates in parent, serial children)...\nprocess 0   : pid:3900, global:0, value:1, array:[1.0, 0.0, 0.0]\nprocess 1   : pid:5072, global:0, value:2, array:[1.0, 1.0, 0.0]\nprocess 2   : pid:9472, global:0, value:3, array:[1.0, 1.0, 1.0]\nloop2 (updates in parent, parallel children)...\nprocess 1   : pid:9468, global:0, value:6, array:[2.0, 2.0, 2.0]\nprocess 2   : pid:9036, global:0, value:6, array:[2.0, 2.0, 2.0]\nprocess 0   : pid:9548, global:0, value:6, array:[2.0, 2.0, 2.0]\nloop3 (updates in serial children)...\nparent temp : pid:6204, global:6, value:9, array:[5.0, 5.0, 5.0]\nloop4 (updates in parallel children)...\nparent end  : pid:6204, global:6, value:12, array:[8.0, 8.0, 8.0]\nIf you imagine the last test here run with a much larger array and many more parallel\nchildren, you might begin to sense some of the power of this package for distributing\nwork.\nQueues and subclassing\nFinally, besides basic spawning and IPC tools, the multiprocessing module also:\n\u2022 Allows its Process class to be subclassed to provide structure and state retention\n(much like threading.Thread, but for processes).\n\u2022 Implements a process-safe Queue object which may be shared by any number of\nprocesses for more general communication needs (much like queue.Queue, but for\nprocesses).\nQueues support a more flexible multiple client/server model. Example 5-32, for in-\nstance, spawns three producer threads to post to a shared queue and repeatedly polls\nfor results to appear\u2014in much the same fashion that a GUI might collect results in\nparallel with the display itself, though here the concurrency is achieved with processes\ninstead of threads.\n252 | Chapter 5:\u2002Parallel System ToolsExample 5-32. PP4E\\System\\Processes\\multi4.py\n\"\"\"\nProcess class can also be subclassed just like threading.Thread;\nQueue works like queue.Queue but for cross-process, not cross-thread\n\"\"\"\nimport os, time, queue\nfrom multiprocessing import Process, Queue           # process-safe shared queue\n                                                     # queue is a pipe + locks/semas\nclass Counter(Process):\n    label = '  @'\n    def __init__(self, start, queue):                # retain state for use in run\n        self.state = start\n        self.post  = queue\n        Process.__init__(self)\n    def run(self):                                   # run in newprocess on start()\n        for i in range(3):\n            time.sleep(1)\n            self.state += 1\n            print(self.label ,self.pid, self.state)  # self.pid is this child's pid\n            self.post.put([self.pid, self.state])    # stdout file is shared by all\n        print(self.label, self.pid, '-')\nif __name__ == '__main__':\n    print('start', os.getpid())\n    expected = 9\n    post = Queue()\n    p = Counter(0, post)                        # start 3 processes sharing queue\n    q = Counter(100, post)                      # children are producers\n    r = Counter(1000, post)\n    p.start(); q.start(); r.start()\n    while expected:                             # parent consumes data on queue\n        time.sleep(0.5)                         # this is essentially like a GUI,\n        try:                                    # though GUIs often use threads\n            data = post.get(block=False)\n        except queue.Empty:\n            print('no data...')\n        else:\n            print('posted:', data)\n            expected -= 1\n    p.join(); q.join(); r.join()                # must get before join putter\n    print('finish', os.getpid(), r.exitcode)    # exitcode is child exit status\nNotice in this code how:\n\u2022 The time.sleep calls in this code\u2019s producer simulate long-running tasks.\n\u2022 All four processes share the same output stream; print calls go the same place and\ndon\u2019t overlap badly on Windows (as we saw earlier, the multiprocessing module\nalso has a shareable Lock object to synchronize access if required).\nThe multiprocessing Module | 253\u2022 The exit status of child process is available after they finish in their exitcode\nattribute.\nWhen run, the output of the main consumer process traces its queue fetches, and the\n(indented) output of spawned child producer processes gives process IDs and state.\nC:\\...\\PP4E\\System\\Processes> multi4.py\nstart 6296\nno data...\nno data...\n  @ 8008 101\nposted: [8008, 101]\n  @ 6068 1\n  @ 3760 1001\nposted: [6068, 1]\n  @ 8008 102\nposted: [3760, 1001]\n  @ 6068 2\n  @ 3760 1002\nposted: [8008, 102]\n  @ 8008 103\n  @ 8008 -\nposted: [6068, 2]\n  @ 6068 3\n  @ 6068 -\n  @ 3760 1003\n  @ 3760 -\nposted: [3760, 1002]\nposted: [8008, 103]\nposted: [6068, 3]\nposted: [3760, 1003]\nfinish 6296 0\nIf you imagine the \u201c@\u201d lines here as results of long-running operations and the others\nas a main GUI thread, the wide relevance of this package may become more apparent.\nStarting Independent Programs\nAs we learned earlier, independent programs generally communicate with system-\nglobal tools such as sockets and the fifo files we studied earlier. Although processes\nspawned by multiprocessing can leverage these tools, too, their closer relationship\naffords them the host of additional IPC communication devices provided by this\nmodule.\nLike threads, multiprocessing is designed to run function calls in parallel, not to start\nentirely separate programs directly. Spawned functions might use tools like os.system,\nos.popen, and subprocess to start a program if such an operation might block the caller,\nbut there\u2019s otherwise often no point in starting a process that just starts a program\n(you might as well start the program and skip a step). In fact, on Windows,\nmultiprocessing today uses the same process creation call as subprocess, so there\u2019s little\npoint in starting two processes to run one.\n254 | Chapter 5:\u2002Parallel System ToolsIt is, however, possible to start new programs in the child processes spawned, using\ntools like the os.exec* calls we met earlier\u2014by spawning a process portably with\nmultiprocessing and overlaying it with a new program this way, we start a new inde-\npendent program, and effectively work around the lack of the os.fork call in standard\nWindows Python.\nThis generally assumes that the new program doesn\u2019t require any resources passed in\nby the Process API, of course (once a new program starts, it erases that which was\nrunning), but it offers a portable equivalent to the fork/exec combination on Unix.\nFurthermore, programs started this way can still make use of more traditional IPC tools,\nsuch as sockets and fifos, we met earlier in this chapter. Example 5-33 illustrates the\ntechnique.\nExample 5-33. PP4E\\System\\Processes\\multi5.py\n\"Use multiprocessing to start independent programs, os.fork or not\"\nimport os\nfrom multiprocessing import Process\ndef runprogram(arg):\n    os.execlp('python', 'python', 'child.py', str(arg))\nif __name__ == '__main__':\n    for i in range(5):\n        Process(target=runprogram, args=(i,)).start()\n    print('parent exit')\nThis script starts 5 instances of the child.py script we wrote in Example 5-4 as inde-\npendent processes, without waiting for them to finish. Here\u2019s this script at work on\nWindows, after deleting a superfluous system prompt that shows up arbitrarily in the\nmiddle of its output (it runs the same on Cygwin, but the output is not interleaved\nthere):\nC:\\...\\PP4E\\System\\Processes> type child.py\nimport os, sys\nprint('Hello from child', os.getpid(), sys.argv[1])\nC:\\...\\PP4E\\System\\Processes> multi5.py\nparent exit\nHello from child 9844 2\nHello from child 8696 4\nHello from child 1840 0\nHello from child 6724 1\nHello from child 9368 3\nThis technique isn\u2019t possible with threads, because all threads run in the same process;\noverlaying it with a new program would kill all its threads. Though this is unlikely to\nbe as fast as a fork/exec combination on Unix, it at least provides similar and portable\nfunctionality on Windows when required.\nThe multiprocessing Module | 255And Much More\nFinally, multiprocessing provides many more tools than these examples deploy, in-\ncluding condition, event, and semaphore synchronization tools, and local and remote\nmanagers that implement servers for shared object. For instance, Example 5-34 dem-\nonstrates its support for pools\u2014spawned children that work in concert on a given task.\nExample 5-34. PP4E\\System\\Processes\\multi6.py\n\"Plus much more: process pools, managers, locks, condition,...\"\nimport os\nfrom multiprocessing import Pool\ndef powers(x):\n    #print(os.getpid())                  # enable to watch children\n    return 2 ** x\nif __name__ == '__main__':\n    workers = Pool(processes=5)\n    results = workers.map(powers, [2]*100)\n    print(results[:16])\n    print(results[-2:])\n    results = workers.map(powers, range(100))\n    print(results[:16])\n    print(results[-2:])\nWhen run, Python arranges to delegate portions of the task to workers run in parallel:\nC:\\...\\PP4E\\System\\Processes> multi6.py\n[4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]\n[4, 4]\n[1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768]\n[316912650057057350374175801344, 633825300114114700748351602688]\nAnd a little less\u2026\nTo be fair, besides such additional features and tools, multiprocessing also comes with\nadditional constraints beyond those we\u2019ve already covered (pickleability, mutable state,\nand so on). For example, consider the following sort of code:\ndef action(arg1, arg2):\n    print(arg1, arg2)\nif __name__ == '__main__':\n    Process(target=action, args=('spam', 'eggs')).start()    # shell waits for child\nThis works as expected, but if we change the last line to the following it fails on Win-\ndows because lambdas are not pickleable (really, not importable):\nProcess(target=(lambda: action('spam', 'eggs'))).start()  # fails!-not pickleable\n256 | Chapter 5:\u2002Parallel System ToolsThis precludes a common coding pattern that uses lambda to add data to calls, which\nwe\u2019ll use often for callbacks in the GUI part of this book. Moreover, this differs from\nthe threading module that is the model for this package\u2014calls like the following which\nwork for threads must be translated to a callable and arguments:\nthreading.Thread(target=(lambda: action(2, 4))).start()   # but lambdas work here\nConversely, some behavior of the threading module is mimicked by multiprocessing,\nwhether you wish it did or not. Because programs using this package wait for child\nprocesses to end by default, we must mark processes as daemon if we don\u2019t want to block\nthe shell where the following sort of code is run (technically, parents attempt to ter-\nminate daemonic children on exit, which means that the program can exit when only\ndaemonic children remain, much like threading):\ndef action(arg1, arg2):\n   print(arg1, arg2)\n   time.sleep(5)          # normally prevents the parent from exiting\nif __name__ == '__main__':\n    p = Process(target=action, args=('spam', 'eggs'))\n    p.daemon = True                                        # don't wait for it\n    p.start()\nThere\u2019s more on some of these issues in the Python library manual; they are not show-\nstoppers by any stretch, but special cases and potential pitfalls to some. We\u2019ll revisit\nthe lambda and daemon issues in a more realistic context in Chapter 8, where we\u2019ll use\nmultiprocessing to launch GUI demos independently.\nWhy multiprocessing? The Conclusion\nAs this section\u2019s examples suggest, multiprocessing provides a powerful alternative\nwhich aims to combine the portability and much of the utility of threads with the fully\nparallel potential of processes and offers additional solutions to IPC, exit status, and\nother parallel processing goals.\nHopefully, this section has also given you a better understanding of this module\u2019s\ntradeoffs discussed at its beginning. In particular, its separate process model precludes\nthe freely shared mutable state of threads, and bound methods and lambdas are pro-\nhibited by both the pickleability requirements of its IPC pipes and queues, as well as\nits process action implementation on Windows. Moreover, its requirement of pickle-\nability for process arguments on Windows also precludes it as an option for conversing\nwith clients in socket servers portably.\nWhile not a replacement for threading in all applications, though, multiprocessing\noffers compelling solutions for many. Especially for parallel-programming tasks which\ncan be designed to avoid its limitations, this module can offer both performance and\nportability that Python\u2019s more direct multitasking tools cannot.\nThe multiprocessing Module | 257Unfortunately, beyond this brief introduction, we don\u2019t have space for a more complete \ntreatment of this module in this book. For more details, refer to the Python library \nmanual. Here, we turn next to a handful of additional program launching tools and a \nwrap up of this chapter.\nOther Ways to Start Programs\nWe\u2019ve seen a variety of ways to launch programs in this book so far\u2014from the os.fork/ \nexec combination on Unix, to portable shell command-line launchers like os.system, \nos.popen, and subprocess, to the portable multiprocessing module options of the last \nsection. There are still other ways to start programs in the Python standard library, \nsome of which are more platform neutral or obscure than others. This section wraps \nup this chapter with a quick tour through this set.\nThe os.spawn Calls\nThe os.spawnv and os.spawnve calls were originally introduced to launch programs on \nWindows, much like a fork/exec call combination on Unix-like platforms. Today, these \ncalls work on both Windows and Unix-like systems, and additional variants have been \nadded to parrot os.exec.\nIn recent versions of Python, the portable subprocess module has started to supersede \nthese calls. In fact, Python\u2019s library manual includes a note stating that this module has \nmore powerful and equivalent tools and should be preferred to os.spawn calls. More-\nover, the newer multiprocessing module can achieve similarly portable results today \nwhen combined with os.exec calls, as we saw earlier. Still, the os.spawn calls continue \nto work as advertised and may appear in Python code you encounter.\nThe os.spawn family of calls execute a program named by a command line in a new \nprocess, on both Windows and Unix-like systems. In basic operation, they are similar \nto the fork/exec call combination on Unix and can be used as alternatives to the \nsystem and popen calls we\u2019ve already learned. In the following interaction, for instance, \nwe start a Python program with a command line in two traditional ways (the second \nalso reads its output):\nC:\\...\\PP4E\\System\\Processes> python\n>>> print(open('makewords.py').read())\nprint('spam')\nprint('eggs')\nprint('ham')\n>>> import os\n>>> os.system('python makewords.py')\nspam\neggs\nham\n0\n258 | Chapter 5:\u2002Parallel System Tools>>> result = os.popen('python makewords.py').read()\n>>> print(result)\nspam\neggs\nham\nThe equivalent os.spawn calls achieve the same effect, with a slightly more complex call\nsignature that provides more control over the way the program is launched:\n>>> os.spawnv(os.P_WAIT, r'C:\\Python31\\python', ('python', 'makewords.py'))\nspam\neggs\nham\n0\n>>> os.spawnl(os.P_NOWAIT, r'C:\\Python31\\python', 'python', 'makewords.py')\n1820\n>>> spam\neggs\nham\nThe spawn calls are also much like forking programs in Unix. They don\u2019t actually copy\nthe calling process (so shared descriptor operations won\u2019t work), but they can be used\nto start a program running completely independent of the calling program, even on\nWindows. The script in Example 5-35 makes the similarity to Unix programming pat-\nterns more obvious. It launches a program with a fork/exec combination on Unix-like\nplatforms (including Cygwin), or an os.spawnv call on Windows.\nExample 5-35. PP4E\\System\\Processes\\spawnv.py\n\"\"\"\nstart up 10 copies of child.py running in parallel;\nuse spawnv to launch a program on Windows (like fork+exec);\nP_OVERLAY replaces, P_DETACH makes child stdout go nowhere;\nor use portable subprocess or multiprocessing options today!\n\"\"\"\nimport os, sys\nfor i in range(10):\n    if sys.platform[:3] == 'win':\n        pypath = sys.executable\n        os.spawnv(os.P_NOWAIT, pypath, ('python', 'child.py', str(i)))\n    else:\n        pid = os.fork()\n        if pid != 0:\n            print('Process %d spawned' % pid)\n        else:\n            os.execlp('python', 'python', 'child.py', str(i))\nprint('Main process exiting.')\nTo make sense of these examples, you have to understand the arguments being passed\nto the spawn calls. In this script, we call os.spawnv with a process mode flag, the full\ndirectory path to the Python interpreter, and a tuple of strings representing the shell\ncommand line with which to start a new program. The path to the Python interpreter\nOther Ways to Start Programs | 259executable program running a script is available as sys.executable. In general, the\nprocess mode flag is taken from these predefined values:\nos.P_NOWAIT and os.P_NOWAITO\nThe spawn functions will return as soon as the new process has been created, with\nthe process ID as the return value. Available on Unix and Windows.\nos.P_WAIT\nThe spawn functions will not return until the new process has run to completion\nand will return the exit code of the process if the run is successful or \u201c-signal\u201d if a\nsignal kills the process. Available on Unix and Windows.\nos.P_DETACH and os.P_OVERLAY\nP_DETACH is similar to P_NOWAIT, but the new process is detached from the console\nof the calling process. If P_OVERLAY is used, the current program will be replaced\n(much like os.exec). Available on Windows.\nIn fact, there are eight different calls in the spawn family, which all start a program but\nvary slightly in their call signatures. In their names, an \u201cl\u201d means you list arguments\nindividually, \u201cp\u201d means the executable file is looked up on the system path, and \u201ce\u201d\nmeans a dictionary is passed in to provide the shelled environment of the spawned\nprogram: the os.spawnve call, for example, works the same way as os.spawnv but accepts\nan extra fourth dictionary argument to specify a different shell environment for the\nspawned program (which, by default, inherits all of the parent\u2019s settings):\nos.spawnl(mode, path, ...)\nos.spawnle(mode, path, ..., env)\nos.spawnlp(mode, file, ...)                 # Unix only\nos.spawnlpe(mode, file, ..., env)           # Unix only\nos.spawnv(mode, path, args)\nos.spawnve(mode, path, args, env)\nos.spawnvp(mode, file, args)                # Unix only\nos.spawnvpe(mode, file, args, env)          # Unix only\nBecause these calls mimic the names and call signatures of the os.exec variants, see\nearlier in this chapter for more details on the differences between these call forms.\nUnlike the os.exec calls, only half of the os.spawn forms\u2014those without system path\nchecking (and hence without a \u201cp\u201d in their names)\u2014are currently implemented on\nWindows. All the process mode flags are supported on Windows, but detach and\noverlay modes are not available on Unix. Because this sort of detail may be prone to\nchange, to verify which are present, be sure to see the library manual or run a dir built-\nin function call on the os module after an import.\nHere is the script in Example 5-35 at work on Windows, spawning 10 independent\ncopies of the child.py Python program we met earlier in this chapter:\nC:\\...\\PP4E\\System\\Processes> type child.py\nimport os, sys\nprint('Hello from child', os.getpid(), sys.argv[1])\nC:\\...\\PP4E\\System\\Processes> python spawnv.py\n260 | Chapter 5:\u2002Parallel System ToolsHello from child \u2212583587 0\nHello from child \u2212558199 2\nHello from child \u2212586755 1\nHello from child \u2212562171 3\nMain process exiting.\nHello from child \u2212581867 6\nHello from child \u2212588651 5\nHello from child \u2212568247 4\nHello from child \u2212563527 7\nHello from child \u2212543163 9\nHello from child \u2212587083 8\nNotice that the copies print their output in random order, and the parent program exits\nbefore all children do; all of these programs are really running in parallel on Windows.\nAlso observe that the child program\u2019s output shows up in the console box where\nspawnv.py was run; when using P_NOWAIT, standard output comes to the parent\u2019s con-\nsole, but it seems to go nowhere when using P_DETACH (which is most likely a feature\nwhen spawning GUI programs).\nBut having shown you this call, I need to again point out that both the subprocess and\nmultiprocessing modules offer more portable alternatives for spawning programs with\ncommand lines today. In fact, unless os.spawn calls provide unique behavior you can\u2019t\nlive without (e.g., control of shell window pop ups on Windows), the platform-specific\nalternatives code of Example 5-35 can be replaced altogether with the portable multi\nprocessing code in Example 5-33.\nThe os.startfile call on Windows\nAlthough os.spawn calls may be largely superfluous today, there are other tools that\ncan still make a strong case for themselves. For instance, the os.system call can be used\non Windows to launch a DOS start command, which opens (i.e., runs) a file inde-\npendently based on its Windows filename associations, as though it were clicked.\nos.startfile makes this even simpler in recent Python releases, and it can avoid block-\ning its caller, unlike some other tools.\nUsing the DOS start command\nTo understand why, first you need to know how the DOS start command works in\ngeneral. Roughly, a DOS command line of the form start command works as if command\nwere typed in the Windows Run dialog box available in the Start button menu. If\ncommand is a filename, it is opened exactly as if its name was double-clicked in the\nWindows Explorer file selector GUI.\nFor instance, the following three DOS commands automatically start Internet Explorer,\nmy registered image viewer program, and my sound media player program on the files\nnamed in the commands. Windows simply opens the file with whatever program is\nassociated to handle filenames of that form. Moreover, all three of these programs run\nindependently of the DOS console box where the command is typed:\nOther Ways to Start Programs | 261C:\\...\\PP4E\\System\\Media> start lp4e-preface-preview.html\nC:\\...\\PP4E\\System\\Media> start ora-lp4e.jpg\nC:\\...\\PP4E\\System\\Media> start sousa.au\nBecause the start command can run any file and command line, there is no reason it\ncannot also be used to start an independently running Python program:\nC:\\...\\PP4E\\System\\Processes> start child.py 1\nThis works because Python is registered to open names ending in .py when it is installed.\nThe script child.py is launched independently of the DOS console window even though\nwe didn\u2019t provide the name or path of the Python interpreter program. Because\nchild.py simply prints a message and exits, though, the result isn\u2019t exactly satisfying: a\nnew DOS window pops up to serve as the script\u2019s standard output, and it immediately\ngoes away when the child exits. To do better, add an input call at the bottom of the\nprogram file to wait for a key press before exiting:\nC:\\...\\PP4E\\System\\Processes> type child-wait.py\nimport os, sys\nprint('Hello from child', os.getpid(), sys.argv[1])\ninput(\"Press <Enter>\")       # don't flash on Windows\nC:\\...\\PP4E\\System\\Processes> start child-wait.py 2\nNow the child\u2019s DOS window pops up and stays up after the start command has\nreturned. Pressing the Enter key in the pop-up DOS window makes it go away.\nUsing start in Python scripts\nSince we know that Python\u2019s os.system and os.popen can be called by a script to run\nany command line that can be typed at a DOS shell prompt, we can also start inde-\npendently running programs from a Python script by simply running a DOS start\ncommand line. For instance:\nC:\\...\\PP4E\\System\\Media> python\n>>> import os\n>>> cmd = 'start lp4e-preface-preview.html'            # start IE browser\n>>> os.system(cmd)                                     # runs independent\n0\nThe Python os.system calls here start whatever web page browser is registered on your\nmachine to open .html files (unless these programs are already running). The launched\nprograms run completely independent of the Python session\u2014when running a DOS\nstart command, os.system does not wait for the spawned program to exit.\n262 | Chapter 5:\u2002Parallel System ToolsThe os.startfile call\nIn fact, start is so useful that recent Python releases also include an os.startfile call,\nwhich is essentially the same as spawning a DOS start command with os.system and\nworks as though the named file were double-clicked. The following calls, for instance,\nhave a similar effect:\n>>> os.startfile('lp-code-readme.txt')\n>>> os.system('start lp-code-readme.txt')\nBoth pop up the text file in Notepad on my Windows computer. Unlike the second of\nthese calls, though, os.startfile provides no option to wait for the application to close\n(the DOS start command\u2019s /WAIT option does) and no way to retrieve the application\u2019s\nexit status (returned from os.system).\nOn recent versions of Windows, the following has a similar effect, too, because the\nregistry is used at the command line (though this form pauses until the file\u2019s viewer is\nclosed\u2014like using start /WAIT):\n>>> os.system('lp-code-readme.txt')       # 'start' is optional today\nThis is a convenient way to open arbitrary document and media files, but keep in mind\nthat the os.startfile call works only on Windows, because it uses the Windows reg-\nistry to know how to open a file. In fact, there are even more obscure and nonportable\nways to launch programs, including Windows-specific options in the PyWin32 pack-\nage, which we\u2019ll finesse here. If you want to be more platform neutral, consider using\none of the other many program launcher tools we\u2019ve seen, such as os.popen or\nos.spawnv. Or better yet, write a module to hide the details\u2014as the next and final \nsection demonstrates.\nA Portable Program-Launch Framework\nWith all of these different ways to start programs on different platforms, it can be\ndifficult to remember what tools to use in a given situation. Moreover, some of these\ntools are called in ways that are complicated and thus easy to forget. Although modules\nlike subprocess and multiprocessing offer fully portable options today, other tools\nsometimes provide more specific behavior that\u2019s better on a given platform; shell win-\ndow pop ups on Windows, for example, are often better suppressed.\nI write scripts that need to launch Python programs often enough that I eventually wrote\na module to try to hide most of the underlying details. By encapsulating the details in\nthis module, I\u2019m free to change them to use new tools in the future without breaking\ncode that relies on them. While I was at it, I made this module smart enough to auto-\nmatically pick a \u201cbest\u201d launch scheme based on the underlying platform. Laziness is\nthe mother of many a useful module.\nA Portable Program-Launch Framework | 263Example 5-36 collects in a single module many of the techniques we\u2019ve met in this\nchapter. It implements an abstract superclass, LaunchMode, which defines what it means\nto start a Python program named by a shell command line, but it doesn\u2019t define how.\nInstead, its subclasses provide a run method that actually starts a Python program ac-\ncording to a given scheme and (optionally) define an announce method to display a\nprogram\u2019s name at startup time.\nExample 5-36. PP4E\\launchmodes.py\n\"\"\"\n###################################################################################\nlaunch Python programs with command lines and reusable launcher scheme classes;\nauto inserts \"python\" and/or path to Python executable at front of command line;\nsome of this module may assume 'python' is on your system path (see Launcher.py);\nsubprocess module would work too, but os.popen() uses it internally, and the goal\nis to start a program running independently here, not to connect to its streams;\nmultiprocessing module also is an option, but this is command-lines, not functions:\ndoesn't make sense to start a process which would just do one of the options here;\nnew in this edition: runs script filename path through normpath() to change any\n/ to \\ for Windows tools where required; fix is inherited by PyEdit and others;\non Windows, / is generally allowed for file opens, but not by all launcher tools;\n###################################################################################\n\"\"\"\nimport sys, os\npyfile = (sys.platform[:3] == 'win' and 'python.exe') or 'python'\npypath = sys.executable     # use sys in newer pys\ndef fixWindowsPath(cmdline):\n    \"\"\"\n    change all / to \\ in script filename path at front of cmdline;\n    used only by classes which run tools that require this on Windows;\n    on other platforms, this does not hurt (e.g., os.system on Unix);\n    \"\"\"\n    splitline = cmdline.lstrip().split(' ')           # split on spaces\n    fixedpath = os.path.normpath(splitline[0])        # fix forward slashes\n    return ' '.join([fixedpath] + splitline[1:])      # put it back together\nclass LaunchMode:\n    \"\"\"\n    on call to instance, announce label and run command;\n    subclasses format command lines as required in run();\n    command should begin with name of the Python script\n    file to run, and not with \"python\" or its full path;\n    \"\"\"\n    def __init__(self, label, command):\n        self.what  = label\n        self.where = command\n    def __call__(self):                     # on call, ex: button press callback\n        self.announce(self.what)\n        self.run(self.where)                # subclasses must define run()\n    def announce(self, text):               # subclasses may redefine announce()\n264 | Chapter 5:\u2002Parallel System Toolsprint(text)                         # methods instead of if/elif logic\n    def run(self, cmdline):\n        assert False, 'run must be defined'\nclass System(LaunchMode):\n    \"\"\"\n    run Python script named in shell command line\n    caveat: may block caller, unless & added on Unix\n    \"\"\"\n    def run(self, cmdline):\n        cmdline = fixWindowsPath(cmdline)\n        os.system('%s %s' % (pypath, cmdline))\nclass Popen(LaunchMode):\n    \"\"\"\n    run shell command line in a new process\n    caveat: may block caller, since pipe closed too soon\n    \"\"\"\n    def run(self, cmdline):\n        cmdline = fixWindowsPath(cmdline)\n        os.popen(pypath + ' ' + cmdline)           # assume nothing to be read\nclass Fork(LaunchMode):\n    \"\"\"\n    run command in explicitly created new process\n    for Unix-like systems only, including cygwin\n    \"\"\"\n    def run(self, cmdline):\n        assert hasattr(os, 'fork')\n        cmdline = cmdline.split()                  # convert string to list\n        if os.fork() == 0:                         # start new child process\n            os.execvp(pypath, [pyfile] + cmdline)  # run new program in child\nclass Start(LaunchMode):\n    \"\"\"\n    run command independent of caller\n    for Windows only: uses filename associations\n    \"\"\"\n    def run(self, cmdline):\n        assert sys.platform[:3] == 'win'\n        cmdline = fixWindowsPath(cmdline)\n        os.startfile(cmdline)\nclass StartArgs(LaunchMode):\n    \"\"\"\n    for Windows only: args may require real start\n    forward slashes are okay here\n    \"\"\"\n    def run(self, cmdline):\n        assert sys.platform[:3] == 'win'\n        os.system('start ' + cmdline)              # may create pop-up window\nclass Spawn(LaunchMode):\n    \"\"\"\n    run python in new process independent of caller\nA Portable Program-Launch Framework | 265for Windows or Unix; use P_NOWAIT for dos box;\n    forward slashes are okay here\n    \"\"\"\n    def run(self, cmdline):\n        os.spawnv(os.P_DETACH, pypath, (pyfile, cmdline))\nclass Top_level(LaunchMode):\n    \"\"\"\n    run in new window, same process\n    tbd: requires GUI class info too\n    \"\"\"\n    def run(self, cmdline):\n        assert False, 'Sorry - mode not yet implemented'\n#\n# pick a \"best\" launcher for this platform\n# may need to specialize the choice elsewhere\n#\nif sys.platform[:3] == 'win':\n    PortableLauncher = Spawn\nelse:\n    PortableLauncher = Fork\nclass QuietPortableLauncher(PortableLauncher):\n    def announce(self, text):\n        pass\ndef selftest():\n    file = 'echo.py'\n    input('default mode...')\n    launcher = PortableLauncher(file, file)\n    launcher()                                             # no block\n    input('system mode...')\n    System(file, file)()                                   # blocks\n    if sys.platform[:3] == 'win':\n        input('DOS start mode...')                         # no block\n        StartArgs(file, file)()\nif __name__ == '__main__': selftest()\nNear the end of the file, the module picks a default class based on the sys.platform\nattribute: PortableLauncher is set to a class that uses spawnv on Windows and one that\nuses the fork/exec combination elsewhere; in recent Pythons, we could probably just\nuse the spawnv scheme on most platforms, but the alternatives in this module are used\nin additional contexts. If you import this module and always use its Portable\nLauncher attribute, you can forget many of the platform-specific details enumerated in\nthis chapter.\nTo run a Python program, simply import the PortableLauncher class, make an instance\nby passing a label and command line (without a leading \u201cpython\u201d word), and then call\n266 | Chapter 5:\u2002Parallel System Toolsthe instance object as though it were a function. The program is started by a call op-\neration\u2014by its __call__ operator-overloading method, instead of a normally named\nmethod\u2014so that the classes in this module can also be used to generate callback han-\ndlers in tkinter-based GUIs. As we\u2019ll see in the upcoming chapters, button-presses in\ntkinter invoke a callable object with no arguments; by registering a PortableLauncher\ninstance to handle the press event, we can automatically start a new program from\nanother program\u2019s GUI. A GUI might associate a launcher with a GUI\u2019s button press\nwith code like this:\n Button(root, text=name, command=PortableLauncher(name, commandLine))\nWhen run standalone, this module\u2019s selftest function is invoked as usual. As coded,\nSystem blocks the caller until the program exits, but PortableLauncher (really, Spawn or\nFork) and Start do not:\nC:\\...\\PP4E> type echo.py\nprint('Spam')\ninput('press Enter')\nC:\\...\\PP4E> python launchmodes.py\ndefault mode...\necho.py\nsystem mode...\necho.py\nSpam\npress Enter\nDOS start mode...\necho.py\nAs more practical applications, this file is also used in Chapter 8 to launch GUI dialog\ndemos independently, and again in a number of Chapter 10\u2019s examples, including\nPyDemos and PyGadgets\u2014launcher scripts designed to run major examples in this\nbook in a portable fashion, which live at the top of this book\u2019s examples distribution\ndirectory. Because these launcher scripts simply import PortableLauncher and register\ninstances to respond to GUI events, they run on both Windows and Unix unchanged\n(tkinter\u2019s portability helps, too, of course). The PyGadgets script even customizes\nPortableLauncher to update a GUI label at start time:\nclass Launcher(launchmodes.PortableLauncher):    # use wrapped launcher class\n    def announce(self, text):                    # customize to set GUI label\n        Info.config(text=text)\nWe\u2019ll explore these two client scripts, and others, such as Chapter 11\u2019s PyEdit after we\nstart coding GUIs in Part III. Partly because of its role in PyEdit, this edition extends\nthis module to automatically replace forward slashes with backward slashes in the\nscript\u2019s file path name. PyEdit uses forward slashes in some filenames because they are\nallowed in file opens on Windows, but some Windows launcher tools require the\nbackslash form instead. Specifically, system, popen, and startfile in os require back-\nslashes, but spawnv does not. PyEdit and others inherit the new pathname fix of\nfixWindowsPath here simply by importing and using this module\u2019s classes; PyEdit\nA Portable Program-Launch Framework | 267eventually changed so as to make this fix irrelevant for its own use case (see Chap-\nter 11), but other clients still acquire the fix for free.\nAlso notice how some of the classes in this example use the sys.executable path string\nto obtain the Python executable\u2019s full path name. This is partly due to their role in user-\nfriendly demo launchers. In prior versions that predated sys.executable, these classes\ninstead called two functions exported by a module named Launcher.py to find a suitable\nPython executable, regardless of whether the user had added its directory to the system\nPATH variable\u2019s setting.\nThis search is no longer required. Since I\u2019ll describe this module\u2019s other roles in the\nnext chapter, and since this search has been largely precluded by Python\u2019s perpetual\npandering to programmers\u2019 professional proclivities, I\u2019ll postpone any pointless peda-\ngogical presentation here. (Period.)\nOther System Tools Coverage\nThat concludes our tour of Python system tools. In this and the prior three chapters,\nwe\u2019ve met most of the commonly used system tools in the Python library. Along the\nway, we\u2019ve also learned how to use them to do useful things such as start programs,\nprocess directories, and so on. The next chapter wraps up this domain by using the\ntools we\u2019ve just met to implement scripts that do useful and more realistic system-level\nwork.\nStill other system-related tools in Python appear later in this text. For instance:\n\u2022 Sockets, used to communicate with other programs and networks and introduced\nbriefly here, show up again in Chapter 10 in a common GUI use case and are\ncovered in full in Chapter 12.\n\u2022 Select calls, used to multiplex among tasks, are also introduced in Chapter 12 as a\nway to implement servers.\n\u2022 File locking with os.open, introduced in Chapter 4, is discussed again in conjunc-\ntion with later examples.\n\u2022 Regular expressions, string pattern matching used by many text processing tools\nin the system administration domain, don\u2019t appear until Chapter 19.\nMoreover, things like forks and threads are used extensively in the Internet scripting\nchapters: see the discussion of threaded GUIs in Chapters 9 and 10; the server imple-\nmentations in Chapter 12; the FTP client GUI in Chapter 13; and the PyMailGUI pro-\ngram in Chapter 14. Along the way, we\u2019ll also meet higher-level Python modules, such\nas socketserver, which implement fork and thread-based socket server code for us. In\nfact, many of the last four chapters\u2019 tools will pop up constantly in later examples in\nthis book\u2014about what one would expect of general-purpose portable libraries.\n268 | Chapter 5:\u2002Parallel System ToolsLast, but not necessarily least, I\u2019d like to point out one more time that many additional\ntools in the Python library don\u2019t appear in this book at all. With hundreds of library\nmodules, more appearing all the time, and even more in the third-party domain, Python\nbook authors have to pick and choose their topics frugally! As always, be sure to browse\nthe Python library manuals and Web early and often in your Python career.\nOther System Tools Coverage | 269", "6": "CHAPTER 6\nComplete System Programs\n\u201cThe Greps of Wrath\u201d\nThis chapter wraps up our look at the system interfaces domain in Python by presenting \na collection of larger Python scripts that do real systems work\u2014comparing and copying \ndirectory trees, splitting files, searching files and directories, testing other programs, \nconfiguring launched programs\u2019 shell environments, and so on. The examples here are \nPython system utility programs that illustrate typical tasks and techniques in this do-\nmain and focus on applying built-in tools, such as file and directory tree processing.\nAlthough the main point of this case-study chapter is to give you a feel for realistic \nscripts in action, the size of these examples also gives us an opportunity to see Python\u2019s \nsupport for development paradigms like object-oriented programming (OOP) and re-\nuse at work. It\u2019s really only in the context of nontrivial programs such as the ones we\u2019ll \nmeet here that such tools begin to bear tangible fruit. This chapter also emphasizes the \n\u201cwhy\u201d of system tools, not just the \u201chow\u201d; along the way, I\u2019ll point out real-world needs \nmet by the examples we\u2019ll study, to help you put the details in context.\nOne note up front: this chapter moves quickly, and a few of its examples are largely \nlisted just for independent study. Because all the scripts here are heavily documented \nand use Python system tools described in the preceding chapters, I won\u2019t go through \nall the code in exhaustive detail. You should read the source code listings and experi-\nment with these programs on your own computer to get a better feel for how to combine \nsystem interfaces to accomplish realistic tasks. All are available in source code form in \nthe book\u2019s examples distribution and most work on all major platforms.\nI should also mention that most of these are programs I have really used, not examples \nwritten just for this book. They were coded over a period of years and perform widely \ndiffering tasks, so there is no obvious common thread to connect the dots here other \nthan need. On the other hand, they help explain why system tools are useful in the first \nplace, demonstrate larger development concepts that simpler examples cannot, and \nbear collective witness to the simplicity and portability of automating system tasks with \nPython. Once you\u2019ve mastered the basics, you\u2019ll wish you had done so sooner.\n271A Quick Game of \u201cFind the Biggest Python File\u201d\nQuick: what\u2019s the biggest Python source file on your computer? This was the query\ninnocently posed by a student in one of my Python classes. Because I didn\u2019t know either,\nit became an official exercise in subsequent classes, and it provides a good example of\nways to apply Python system tools for a realistic purpose in this book. Really, the query\nis a bit vague, because its scope is unclear. Do we mean the largest Python file in a\ndirectory, in a full directory tree, in the standard library, on the module import search\npath, or on your entire hard drive? Different scopes imply different solutions.\nScanning the Standard Library Directory\nFor instance, Example 6-1 is a first-cut solution that looks for the biggest Python file\nin one directory\u2014a limited scope, but enough to get started.\nExample 6-1. PP4E\\System\\Filetools\\bigpy-dir.py\n\"\"\"\nFind the largest Python source file in a single directory.\nSearch Windows Python source lib, unless dir command-line arg.\n\"\"\"\nimport os, glob, sys\ndirname = r'C:\\Python31\\Lib' if len(sys.argv) == 1 else sys.argv[1]\nallsizes = []\nallpy = glob.glob(dirname + os.sep + '*.py')\nfor filename in allpy:\n    filesize = os.path.getsize(filename)\n    allsizes.append((filesize, filename))\nallsizes.sort()\nprint(allsizes[:2])\nprint(allsizes[-2:])\nThis script uses the glob module to run through a directory\u2019s files and detects the largest\nby storing sizes and names on a list that is sorted at the end\u2014because size appears first\nin the list\u2019s tuples, it will dominate the ascending value sort, and the largest percolates\nto the end of the list. We could instead keep track of the currently largest as we go, but\nthe list scheme is more flexible. When run, this script scans the Python standard li-\nbrary\u2019s source directory on Windows, unless you pass a different directory on the com-\nmand line, and it prints both the two smallest and largest files it finds:\nC:\\...\\PP4E\\System\\Filetools> bigpy-dir.py\n[(0, 'C:\\\\Python31\\\\Lib\\\\build_class.py'), (56, 'C:\\\\Python31\\\\Lib\\\\struct.py')]\n[(147086, 'C:\\\\Python31\\\\Lib\\\\turtle.py'), (211238, 'C:\\\\Python31\\\\Lib\\\\decimal.\npy')]\nC:\\...\\PP4E\\System\\Filetools> bigpy-dir.py .\n[(21, '.\\\\__init__.py'), (461, '.\\\\bigpy-dir.py')]\n272 | Chapter 6:\u2002Complete System Programs[(1940, '.\\\\bigext-tree.py'), (2547, '.\\\\split.py')]\nC:\\...\\PP4E\\System\\Filetools> bigpy-dir.py ..\n[(21, '..\\\\__init__.py'), (29, '..\\\\testargv.py')]\n[(541, '..\\\\testargv2.py'), (549, '..\\\\more.py')]\nScanning the Standard Library Tree\nThe prior section\u2019s solution works, but it\u2019s obviously a partial answer\u2014Python files\nare usually located in more than one directory. Even within the standard library, there\nare many subdirectories for module packages, and they may be arbitrarily nested. We\nreally need to traverse an entire directory tree. Moreover, the first output above is dif-\nficult to read; Python\u2019s pprint (for \u201cpretty print\u201d) module can help here. Exam-\nple 6-2 puts these extensions into code.\nExample 6-2. PP4E\\System\\Filetools\\bigpy-tree.py\n\"\"\"\nFind the largest Python source file in an entire directory tree.\nSearch the Python source lib, use pprint to display results nicely.\n\"\"\"\nimport sys, os, pprint\ntrace = False\nif sys.platform.startswith('win'):\n    dirname = r'C:\\Python31\\Lib'                 # Windows\nelse:\n    dirname = '/usr/lib/python'                  # Unix, Linux, Cygwin\nallsizes = []\nfor (thisDir, subsHere, filesHere) in os.walk(dirname):\n    if trace: print(thisDir)\n    for filename in filesHere:\n        if filename.endswith('.py'):\n            if trace: print('...', filename)\n            fullname = os.path.join(thisDir, filename)\n            fullsize = os.path.getsize(fullname)\n            allsizes.append((fullsize, fullname))\nallsizes.sort()\npprint.pprint(allsizes[:2])\npprint.pprint(allsizes[-2:])\nWhen run, this new version uses os.walk to search an entire tree of directories for the\nlargest Python source file. Change this script\u2019s trace variable if you want to track its\nprogress through the tree. As coded, it searches the Python standard library\u2019s source\ntree, tailored for Windows and Unix-like locations:\nC:\\...\\PP4E\\System\\Filetools> bigpy-tree.py\n[(0, 'C:\\\\Python31\\\\Lib\\\\build_class.py'),\n (0, 'C:\\\\Python31\\\\Lib\\\\email\\\\mime\\\\__init__.py')]\n[(211238, 'C:\\\\Python31\\\\Lib\\\\decimal.py'),\n (380582, 'C:\\\\Python31\\\\Lib\\\\pydoc_data\\\\topics.py')]\nA Quick Game of \u201cFind the Biggest Python File\u201d | 273Scanning the Module Search Path\nSure enough\u2014the prior section\u2019s script found smallest and largest files in subdirecto-\nries. While searching Python\u2019s entire standard library tree this way is more inclusive,\nit\u2019s still incomplete: there may be additional modules installed elsewhere on your com-\nputer, which are accessible from the module import search path but outside Python\u2019s\nsource tree. To be more exhaustive, we could instead essentially perform the same tree\nsearch, but for every directory on the module import search path. Example 6-3 adds\nthis extension to include every importable Python-coded module on your computer\u2014\nlocated both on the path directly and nested in package directory trees.\nExample 6-3. PP4E\\System\\Filetools\\bigpy-path.py\n\"\"\"\nFind the largest Python source file on the module import search path.\nSkip already-visited directories, normalize path and case so they will\nmatch properly, and include line counts in pprinted result. It's not\nenough to use os.environ['PYTHONPATH']: this is a subset of sys.path.\n\"\"\"\nimport sys, os, pprint\ntrace = 0  # 1=dirs, 2=+files\nvisited  = {}\nallsizes = []\nfor srcdir in sys.path:\n    for (thisDir, subsHere, filesHere) in os.walk(srcdir):\n        if trace > 0: print(thisDir)\n        thisDir = os.path.normpath(thisDir)\n        fixcase = os.path.normcase(thisDir)\n        if fixcase in visited:\n            continue\n        else:\n            visited[fixcase] = True\n        for filename in filesHere:\n            if filename.endswith('.py'):\n                if trace > 1: print('...', filename)\n                pypath = os.path.join(thisDir, filename)\n                try:\n                    pysize = os.path.getsize(pypath)\n                except os.error:\n                    print('skipping', pypath, sys.exc_info()[0])\n                else:\n                    pylines = len(open(pypath, 'rb').readlines())\n                    allsizes.append((pysize, pylines, pypath))\nprint('By size...')\nallsizes.sort()\npprint.pprint(allsizes[:3])\npprint.pprint(allsizes[-3:])\nprint('By lines...')\nallsizes.sort(key=lambda x: x[1])\n274 | Chapter 6:\u2002Complete System Programspprint.pprint(allsizes[:3])\npprint.pprint(allsizes[-3:])\nWhen run, this script marches down the module import path and, for each valid di-\nrectory it contains, attempts to search the entire tree rooted there. In fact, it nests loops\nthree deep\u2014for items on the path, directories in the item\u2019s tree, and files in the direc-\ntory. Because the module path may contain directories named in arbitrary ways, along\nthe way this script must take care to:\n\u2022 Normalize directory paths\u2014fixing up slashes and dots to map directories to a\ncommon form.\n\u2022 Normalize directory name case\u2014converting to lowercase on case-insensitive Win-\ndows, so that same names match by string equality, but leaving case unchanged\non Unix, where it matters.\n\u2022 Detect repeats to avoid visiting the same directory twice (the same directory might\nbe reached from more than one entry on sys.path).\n\u2022 Skip any file-like item in the tree for which os.path.getsize fails (by default\nos.walk itself silently ignores things it cannot treat as directories, both at the top\nof and within the tree).\n\u2022 Avoid potential Unicode decoding errors in file content by opening files in binary\nmode in order to count their lines. Text mode requires decodable content, and\nsome files in Python 3.1\u2019s library tree cannot be decoded properly on Windows.\nCatching Unicode exceptions with a try statement would avoid program exits, too,\nbut might skip candidate files.\nThis version also adds line counts; this might add significant run time to this script too,\nbut it\u2019s a useful metric to report. In fact, this version uses this value as a sort key to\nreport the three largest and smallest files by line counts too\u2014this may differ from results\nbased upon raw file size. Here\u2019s the script in action in Python 3.1 on my Windows 7\nmachine; since these results depend on platform, installed extensions, and path set-\ntings, your sys.path and largest and smallest files may vary:\nC:\\...\\PP4E\\System\\Filetools> bigpy-path.py\nBy size...\n[(0, 0, 'C:\\\\Python31\\\\lib\\\\build_class.py'),\n (0, 0, 'C:\\\\Python31\\\\lib\\\\email\\\\mime\\\\__init__.py'),\n (0, 0, 'C:\\\\Python31\\\\lib\\\\email\\\\test\\\\__init__.py')]\n[(161613, 3754, 'C:\\\\Python31\\\\lib\\\\tkinter\\\\__init__.py'),\n (211238, 5768, 'C:\\\\Python31\\\\lib\\\\decimal.py'),\n (380582, 78, 'C:\\\\Python31\\\\lib\\\\pydoc_data\\\\topics.py')]\nBy lines...\n[(0, 0, 'C:\\\\Python31\\\\lib\\\\build_class.py'),\n (0, 0, 'C:\\\\Python31\\\\lib\\\\email\\\\mime\\\\__init__.py'),\n (0, 0, 'C:\\\\Python31\\\\lib\\\\email\\\\test\\\\__init__.py')]\n[(147086, 4132, 'C:\\\\Python31\\\\lib\\\\turtle.py'),\n (150069, 4268, 'C:\\\\Python31\\\\lib\\\\test\\\\test_descr.py'),\n (211238, 5768, 'C:\\\\Python31\\\\lib\\\\decimal.py')]\nA Quick Game of \u201cFind the Biggest Python File\u201d | 275Again, change this script\u2019s trace variable if you want to track its progress through the\ntree. As you can see, the results for largest files differ when viewed by size and lines\u2014\na disparity which we\u2019ll probably have to hash out in our next requirements meeting.\nScanning the Entire Machine\nFinally, although searching trees rooted in the module import path normally includes\nevery Python source file you can import on your computer, it\u2019s still not complete.\nTechnically, this approach checks only modules; Python source files which are top-\nlevel scripts run directly do not need to be included in the module path. Moreover, the\nmodule search path may be manually changed by some scripts dynamically at runtime\n(for example, by direct sys.path updates in scripts that run on web servers) to include\nadditional directories that Example 6-3 won\u2019t catch.\nUltimately, finding the largest source file on your computer requires searching your\nentire drive\u2014a feat which our tree searcher in Example 6-2 almost supports, if we\ngeneralize it to accept the root directory name as an argument and add some of the bells\nand whistles of the path searcher version (we really want to avoid visiting the same\ndirectory twice if we\u2019re scanning an entire machine, and we might as well skip errors\nand check line-based sizes if we\u2019re investing the time). Example 6-4 implements such\ngeneral tree scans, outfitted for the heavier lifting required for scanning drives.\nExample 6-4. PP4E\\System\\Filetools\\bigext-tree.py\n\"\"\"\nFind the largest file of a given type in an arbitrary directory tree.\nAvoid repeat paths, catch errors, add tracing and line count size.\nAlso uses sets, file iterators and generator to avoid loading entire\nfile, and attempts to work around undecodable dir/file name prints.\n\"\"\"\nimport os, pprint\nfrom sys import argv, exc_info\ntrace = 1                                    # 0=off, 1=dirs, 2=+files\ndirname, extname = os.curdir, '.py'          # default is .py files in cwd\nif len(argv) > 1: dirname = argv[1]          # ex: C:\\, C:\\Python31\\Lib\nif len(argv) > 2: extname = argv[2]          # ex: .pyw, .txt\nif len(argv) > 3: trace   = int(argv[3])     # ex: \". .py 2\"\ndef tryprint(arg):\n    try:\n        print(arg)                           # unprintable filename?\n    except UnicodeEncodeError:\n        print(arg.encode())                  # try raw byte string\nvisited  = set()\nallsizes = []\nfor (thisDir, subsHere, filesHere) in os.walk(dirname):\n    if trace: tryprint(thisDir)\n    thisDir = os.path.normpath(thisDir)\n276 | Chapter 6:\u2002Complete System Programsfixname = os.path.normcase(thisDir)\n    if fixname in visited:\n        if trace: tryprint('skipping ' + thisDir)\n    else:\n        visited.add(fixname)\n        for filename in filesHere:\n            if filename.endswith(extname):\n                if trace > 1: tryprint('+++' + filename)\n                fullname = os.path.join(thisDir, filename)\n                try:\n                    bytesize = os.path.getsize(fullname)\n                    linesize = sum(+1 for line in open(fullname, 'rb'))\n                except Exception:\n                    print('error', exc_info()[0])\n                else:\n                    allsizes.append((bytesize, linesize, fullname))\nfor (title, key) in [('bytes', 0), ('lines', 1)]:\n    print('\\nBy %s...' % title)\n    allsizes.sort(key=lambda x: x[key])\n    pprint.pprint(allsizes[:3])\n    pprint.pprint(allsizes[-3:])\nUnlike the prior tree version, this one allows us to search in specific directories, and\nfor specific extensions. The default is to simply search the current working directory\nfor Python files:\nC:\\...\\PP4E\\System\\Filetools> bigext-tree.py\n.\nBy bytes...\n[(21, 1, '.\\\\__init__.py'),\n (461, 17, '.\\\\bigpy-dir.py'),\n (818, 25, '.\\\\bigpy-tree.py')]\n[(1696, 48, '.\\\\join.py'),\n (1940, 49, '.\\\\bigext-tree.py'),\n (2547, 57, '.\\\\split.py')]\nBy lines...\n[(21, 1, '.\\\\__init__.py'),\n (461, 17, '.\\\\bigpy-dir.py'),\n (818, 25, '.\\\\bigpy-tree.py')]\n[(1696, 48, '.\\\\join.py'),\n (1940, 49, '.\\\\bigext-tree.py'),\n (2547, 57, '.\\\\split.py')]\nFor more custom work, we can pass in a directory name, extension type, and trace level\non the command-line now (trace level 0 disables tracing, and 1, the default, shows\ndirectories visited along the way):\nC:\\...\\PP4E\\System\\Filetools> bigext-tree.py .. .py 0\nBy bytes...\n[(21, 1, '..\\\\__init__.py'),\n (21, 1, '..\\\\Filetools\\\\__init__.py'),\nA Quick Game of \u201cFind the Biggest Python File\u201d | 277(28, 1, '..\\\\Streams\\\\hello-out.py')]\n[(2278, 67, '..\\\\Processes\\\\multi2.py'),\n (2547, 57, '..\\\\Filetools\\\\split.py'),\n (4361, 105, '..\\\\Tester\\\\tester.py')]\nBy lines...\n[(21, 1, '..\\\\__init__.py'),\n (21, 1, '..\\\\Filetools\\\\__init__.py'),\n (28, 1, '..\\\\Streams\\\\hello-out.py')]\n[(2547, 57, '..\\\\Filetools\\\\split.py'),\n (2278, 67, '..\\\\Processes\\\\multi2.py'),\n (4361, 105, '..\\\\Tester\\\\tester.py')]\nThis script also lets us scan for different file types; here it is picking out the smallest\nand largest text file from one level up (at the time I ran this script, at least):\nC:\\...\\PP4E\\System\\Filetools> bigext-tree.py .. .txt 1\n..\n..\\Environment\n..\\Filetools\n..\\Processes\n..\\Streams\n..\\Tester\n..\\Tester\\Args\n..\\Tester\\Errors\n..\\Tester\\Inputs\n..\\Tester\\Outputs\n..\\Tester\\Scripts\n..\\Tester\\xxold\n..\\Threads\nBy bytes...\n[(4, 2, '..\\\\Streams\\\\input.txt'),\n (13, 1, '..\\\\Streams\\\\hello-in.txt'),\n (20, 4, '..\\\\Streams\\\\data.txt')]\n[(104, 4, '..\\\\Streams\\\\output.txt'),\n (172, 3, '..\\\\Tester\\\\xxold\\\\README.txt.txt'),\n (435, 4, '..\\\\Filetools\\\\temp.txt')]\nBy lines...\n[(13, 1, '..\\\\Streams\\\\hello-in.txt'),\n (22, 1, '..\\\\spam.txt'),\n (4, 2, '..\\\\Streams\\\\input.txt')]\n[(20, 4, '..\\\\Streams\\\\data.txt'),\n (104, 4, '..\\\\Streams\\\\output.txt'),\n (435, 4, '..\\\\Filetools\\\\temp.txt')]\nAnd now, to search your entire system, simply pass in your machine\u2019s root directory\nname (use / instead of C:\\ on Unix-like machines), along with an optional file extension\ntype (.py is just the default now). The winner is\u2026(please, no wagering):\nC:\\...\\PP4E\\dev\\Examples\\PP4E\\System\\Filetools> bigext-tree.py C:\\\nC:\\\nC:\\$Recycle.Bin\nC:\\$Recycle.Bin\\S-1-5-21-3951091421-2436271001-910485044-1004\nC:\\cygwin\n278 | Chapter 6:\u2002Complete System ProgramsC:\\cygwin\\bin\nC:\\cygwin\\cygdrive\nC:\\cygwin\\dev\nC:\\cygwin\\dev\\mqueue\nC:\\cygwin\\dev\\shm\nC:\\cygwin\\etc\n...MANY more lines omitted...\nBy bytes...\n[(0, 0, 'C:\\\\cygwin\\\\...\\\\python31\\\\Python-3.1.1\\\\Lib\\\\build_class.py'),\n (0, 0, 'C:\\\\cygwin\\\\...\\\\python31\\\\Python-3.1.1\\\\Lib\\\\email\\\\mime\\\\__init__.py'),\n (0, 0, 'C:\\\\cygwin\\\\...\\\\python31\\\\Python-3.1.1\\\\Lib\\\\email\\\\test\\\\__init__.py')]\n[(380582, 78, 'C:\\\\Python31\\\\Lib\\\\pydoc_data\\\\topics.py'),\n (398157, 83, 'C:\\\\...\\\\Install\\\\Source\\\\Python-2.6\\\\Lib\\\\pydoc_topics.py'),\n (412434, 83, 'C:\\\\Python26\\\\Lib\\\\pydoc_topics.py')]\nBy lines...\n[(0, 0, 'C:\\\\cygwin\\\\...\\\\python31\\\\Python-3.1.1\\\\Lib\\\\build_class.py'),\n (0, 0, 'C:\\\\cygwin\\\\...\\\\python31\\\\Python-3.1.1\\\\Lib\\\\email\\\\mime\\\\__init__.py'),\n (0, 0, 'C:\\\\cygwin\\\\...\\\\python31\\\\Python-3.1.1\\\\Lib\\\\email\\\\test\\\\__init__.py')]\n[(204107, 5589, 'C:\\\\...\\Install\\\\Source\\\\Python-3.0\\\\Lib\\\\decimal.py'),\n (205470, 5768, 'C:\\\\cygwin\\\\...\\\\python31\\\\Python-3.1.1\\\\Lib\\\\decimal.py'),\n (211238, 5768, 'C:\\\\Python31\\\\Lib\\\\decimal.py')]\nThe script\u2019s trace logic is preset to allow you to monitor its directory progress. I\u2019ve\nshortened some directory names to protect the innocent here (and to fit on this page).\nThis command may take a long time to finish on your computer\u2014on my sadly under-\npowered Windows 7 netbook, it took 11 minutes to scan a solid state drive with some\n59G of data, 200K files, and 25K directories when the system was lightly loaded (8\nminutes when not tracing directory names, but half an hour when many other appli-\ncations were running). Nevertheless, it provides the most exhaustive solution to the\noriginal query of all our attempts.\nThis is also as complete a solution as we have space for in this book. For more fun,\nconsider that you may need to scan more than one drive, and some Python source files\nmay also appear in zip archives, both on the module path or not (os.walk silently ignores\nzip files in Example 6-3). They might also be named in other ways\u2014with .pyw exten-\nsions to suppress shell pop ups on Windows, and with arbitrary extensions for some\ntop-level scripts. In fact, top-level scripts might have no filename extension at all, even\nthough they are Python source files. And while they\u2019re generally not Python files, some\nimportable modules may also appear in frozen binaries or be statically linked into the\nPython executable. In the interest of space, we\u2019ll leave such higher resolution (and\npotentially intractable!) search extensions as suggested exercises.\nPrinting Unicode Filenames\nOne fine point before we move on: notice the seemingly superfluous exception handling\nin Example 6-4\u2019s tryprint function. When I first tried to scan an entire drive as shown\nin the preceding section, this script died on a Unicode encoding error while trying to\nA Quick Game of \u201cFind the Biggest Python File\u201d | 279print a directory name of a saved web page. Adding the exception handler skips the\nerror entirely.\nThis demonstrates a subtle but pragmatically important issue: Python 3.X\u2019s Unicode\norientation extends to filenames, even if they are just printed. As we learned in Chap-\nter 4, because filenames may contain arbitrary text, os.listdir returns filenames in two\ndifferent ways\u2014we get back decoded Unicode strings when we pass in a normal str\nargument, and still-encoded byte strings when we send a bytes:\n>>> import os\n>>> os.listdir('.')[:4]\n['bigext-tree.py', 'bigpy-dir.py', 'bigpy-path.py', 'bigpy-tree.py']\n>>> os.listdir(b'.')[:4]\n[b'bigext-tree.py', b'bigpy-dir.py', b'bigpy-path.py', b'bigpy-tree.py']\nBoth os.walk (used in the Example 6-4 script) and glob.glob inherit this behavior for\nthe directory and file names they return, because they work by calling os.listdir in-\nternally at each directory level. For all these calls, passing in a byte string argument\nsuppresses Unicode decoding of file and directory names. Passing a normal string as-\nsumes that filenames are decodable per the file system\u2019s Unicode scheme.\nThe reason this potentially mattered to this section\u2019s example is that running the tree\nsearch version over an entire hard drive eventually reached an undecodable filename\n(an old saved web page with an odd name), which generated an exception when the\nprint function tried to display it. Here\u2019s a simplified recreation of the error, run in a\nshell window (Command Prompt) on Windows:\n>>> root = r'C:\\py3000'\n>>> for (dir, subs, files) in os.walk(root): print(dir)\n...\nC:\\py3000\nC:\\py3000\\FutureProofPython - PythonInfo Wiki_files\nC:\\py3000\\Oakwinter_com  Code \u00bb Porting setuptools to py3k_files\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"C:\\Python31\\lib\\encodings\\cp437.py\", line 19, in encode\n    return codecs.charmap_encode(input,self.errors,encoding_map)[0]\nUnicodeEncodeError: 'charmap' codec can't encode character '\\u2019' in position\n45: character maps to <undefined>\nOne way out of this dilemma is to use bytes strings for the directory root name\u2014this\nsuppresses filename decoding in the os.listdir calls run by os.walk, and effectively\nlimits the scope of later printing to raw bytes. Since printing does not have to deal with\nencodings, it works without error. Manually encoding to bytes prior to printing works\ntoo, but the results are slightly different:\n>>> root.encode()\nb'C:\\\\py3000'\n>>> for (dir, subs, files) in os.walk(root.encode()): print(dir)\n...\n280 | Chapter 6:\u2002Complete System Programsb'C:\\\\py3000'\nb'C:\\\\py3000\\\\FutureProofPython - PythonInfo Wiki_files'\nb'C:\\\\py3000\\\\Oakwinter_com  Code \\xbb Porting setuptools to py3k_files'\nb'C:\\\\py3000\\\\What\\x92s New in Python 3_0 \\x97 Python Documentation'\n>>> for (dir, subs, files) in os.walk(root): print(dir.encode())\n...\nb'C:\\\\py3000'\nb'C:\\\\py3000\\\\FutureProofPython - PythonInfo Wiki_files'\nb'C:\\\\py3000\\\\Oakwinter_com  Code \\xc2\\xbb Porting setuptools to py3k_files'\nb'C:\\\\py3000\\\\What\\xe2\\x80\\x99s New in Python 3_0 \\xe2\\x80\\x94 Python Documentation'\nUnfortunately, either approach means that all the directory names printed during the\nwalk display as cryptic byte strings. To maintain the better readability of normal strings,\nI instead opted for the exception handler approach used in the script\u2019s code. This avoids\nthe issues entirely:\n >>> for (dir, subs, files) in os.walk(root):\n...     try:\n...         print(dir)\n...     except UnicodeEncodeError:\n...         print(dir.encode())           # or simply punt if enocde may fail too\n...\nC:\\py3000\nC:\\py3000\\FutureProofPython - PythonInfo Wiki_files\nC:\\py3000\\Oakwinter_com  Code \u00bb Porting setuptools to py3k_files\nb'C:\\\\py3000\\\\What\\xe2\\x80\\x99s New in Python 3_0 \\xe2\\x80\\x94 Python Documentation'\nOddly, though, the error seems more related to printing than to Unicode encodings of\nfilenames\u2014because the filename did not fail until printed, it must have been decodable\nwhen its string was created initially. That\u2019s why wrapping up the print in a try suffices;\notherwise, the error would occur earlier.\nMoreover, this error does not occur if the script\u2019s output is redirected to a file, either\nat the shell level (bigext-tree.py c:\\ > out), or by the print call itself (print(dir,\nfile=F)). In the latter case the output file must later be read back in binary mode, as\ntext mode triggers the same error when printing the file\u2019s content to the shell window\n(but again, not until printed). In fact, the exact same code that fails when run in a system\nshell Command Prompt on Windows works without error when run in the IDLE GUI\non the same platform\u2014the tkinter GUI used by IDLE handles display of characters that\nprinting to standard output connected to a shell terminal window does not:\n>>> import os                  # run in IDLE (a tkinter GUI), not system shell\n>>> root = r'C:\\py3000'\n>>> for (dir, subs, files) in os.walk(root): print(dir)\nC:\\py3000\nC:\\py3000\\FutureProofPython - PythonInfo Wiki_files\nC:\\py3000\\Oakwinter_com  Code \u00bb Porting setuptools to py3k_files\nC:\\py3000\\What's New in Python 3_0 \u2014 Python Documentation_files\nIn other words, the exception occurs only when printing to a shell window, and long\nafter the file name string is created. This reflects an artifact of extra translations\nA Quick Game of \u201cFind the Biggest Python File\u201d | 281performed by the Python printer, not of Unicode file names in general. Because we have\nno room for further exploration here, though, we\u2019ll have to be satisfied with the fact\nthat our exception handler sidesteps the printing problem altogether. You should still\nbe aware of the implications of Unicode filename decoding, though; on some platforms\nyou may need to pass byte strings to os.walk in this script to prevent decoding errors\nas filenames are created.*\nSince Unicode is still relatively new in 3.1, be sure to test for such errors on your com-\nputer and your Python. Also see also Python\u2019s manuals for more on the treatment of\nUnicode filenames, and the text Learning Python for more on Unicode in general. As\nnoted earlier, our scripts also had to open text files in binary mode because some might\ncontain undecodable content too. It might seem surprising that Unicode issues can crop\nup in basic printing like this too, but such is life in the brave new Unicode world. Many\nreal-world scripts don\u2019t need to care much about Unicode, of course\u2014including those\nwe\u2019ll explore in the next section.\nSplitting and Joining Files\nLike most kids, mine spent a lot of time on the Internet when they were growing up.\nAs far as I could tell, it was the thing to do. Among their generation, computer geeks\nand gurus seem to have been held in the same sort of esteem that my generation once\nheld rock stars. When kids disappeared into their rooms, chances were good that they\nwere hacking on computers, not mastering guitar riffs (well, real ones, at least). It may\nor may not be healthier than some of the diversions of my own misspent youth, but\nthat\u2019s a topic for another kind of book.\nDespite the rhetoric of techno-pundits about the Web\u2019s potential to empower an up-\ncoming generation in ways unimaginable by their predecessors, my kids seemed to\nspend most of their time playing games. To fetch new ones in my house at the time,\nthey had to download to a shared computer which had Internet access and transfer\nthose games to their own computers to install. (Their own machines did not have\nInternet access until later, for reasons that most parents in the crowd could probably\nexpand upon.)\nThe problem with this scheme is that game files are not small. They were usually much\ntoo big to fit on a floppy or memory stick of the time, and burning a CD or DVD took\naway valuable game-playing time. If all the machines in my house ran Linux, this would\nhave been a nonissue. There are standard command-line programs on Unix for chop-\nping a file into pieces small enough to fit on a transfer device (split), and others for\n* For a related print issue, see Chapter 14\u2019s workaround for program aborts when printing stack tracebacks\nto standard output from spawned programs. Unlike the problem described here, that issue does not appear\nto be related to Unicode characters that may be unprintable in shell windows but reflects another regression\nfor standard output prints in general in Python 3.1, which may or may not be repaired by the time you read\nthis text. See also the Python environment variable PYTHONIOENCODING, which can override the default\nencoding used for standard streams.\n282 | Chapter 6:\u2002Complete System Programsputting the pieces back together to re-create the original file (cat). Because we had all\nsorts of different machines in the house, though, we needed a more portable solution.\u2020\nSplitting Files Portably\nSince all the computers in my house ran Python, a simple portable Python script came\nto the rescue. The Python program in Example 6-5 distributes a single file\u2019s contents\namong a set of part files and stores those part files in a directory.\nExample 6-5. PP4E\\System\\Filetools\\split.py\n#!/usr/bin/python\n\"\"\"\n################################################################################\nsplit a file into a set of parts; join.py puts them back together;\nthis is a customizable version of the standard Unix split command-line\nutility; because it is written in Python, it also works on Windows and\ncan be easily modified; because it exports a function, its logic can\nalso be imported and reused in other applications;\n################################################################################\n\"\"\"\nimport sys, os\nkilobytes = 1024\nmegabytes = kilobytes * 1000\nchunksize = int(1.4 * megabytes)                   # default: roughly a floppy\ndef split(fromfile, todir, chunksize=chunksize):\n    if not os.path.exists(todir):                  # caller handles errors\n        os.mkdir(todir)                            # make dir, read/write parts\n    else:\n        for fname in os.listdir(todir):            # delete any existing files\n            os.remove(os.path.join(todir, fname))\n    partnum = 0\n    input = open(fromfile, 'rb')                   # binary: no decode, endline\n    while True:                                    # eof=empty string from read\n        chunk = input.read(chunksize)              # get next part <= chunksize\n        if not chunk: break\n        partnum += 1\n        filename = os.path.join(todir, ('part%04d' % partnum))\n        fileobj  = open(filename, 'wb')\n        fileobj.write(chunk)\n        fileobj.close()                            # or simply open().write()\n    input.close()\n    assert partnum <= 9999                         # join sort fails if 5 digits\n    return partnum\n\u2020 I should note that this background story stems from the second edition of this book, written in 2000. Some\nten years later, floppies have largely gone the way of the parallel port and the dinosaur. Moreover, burning\na CD or DVD is no longer as painful as it once was; there are new options today such as large flash memory\ncards, wireless home networks, and simple email; and naturally, my home computers configuration isn\u2019t\nwhat it once was. For that matter, some of my kids are no longer kids (though they\u2019ve retained some backward\ncompatibility with their former selves).\nSplitting and Joining Files | 283if __name__ == '__main__':\n    if len(sys.argv) == 2 and sys.argv[1] == '-help':\n        print('Use: split.py [file-to-split target-dir [chunksize]]')\n    else:\n        if len(sys.argv) < 3:\n            interactive = True\n            fromfile = input('File to be split? ')           # input if clicked\n            todir    = input('Directory to store part files? ')\n        else:\n            interactive = False\n            fromfile, todir = sys.argv[1:3]                  # args in cmdline\n            if len(sys.argv) == 4: chunksize = int(sys.argv[3])\n        absfrom, absto = map(os.path.abspath, [fromfile, todir])\n        print('Splitting', absfrom, 'to', absto, 'by', chunksize)\n        try:\n            parts = split(fromfile, todir, chunksize)\n        except:\n            print('Error during split:')\n            print(sys.exc_info()[0], sys.exc_info()[1])\n        else:\n            print('Split finished:', parts, 'parts are in', absto)\n        if interactive: input('Press Enter key') # pause if clicked\nBy default, this script splits the input file into chunks that are roughly the size of a\nfloppy disk\u2014perfect for moving big files between the electronically isolated machines\nof the time. Most importantly, because this is all portable Python code, this script will\nrun on just about any machine, even ones without their own file splitter. All it requires\nis an installed Python. Here it is at work splitting a Python 3.1 self-installer executable\nlocated in the current working directory on Windows (I\u2019ve omitted a few dir output\nlines to save space here; use ls -l on Unix):\nC:\\temp> cd C:\\temp\nC:\\temp> dir python-3.1.msi\n...more...\n06/27/2009  04:53 PM        13,814,272 python-3.1.msi\n               1 File(s)     13,814,272 bytes\n               0 Dir(s)  188,826,189,824 bytes free\nC:\\temp> python C:\\...\\PP4E\\System\\Filetools\\split.py -help\nUse: split.py [file-to-split target-dir [chunksize]]\nC:\\temp> python C:\\...\\P4E\\System\\Filetools\\split.py python-3.1.msi pysplit\nSplitting C:\\temp\\python-3.1.msi to C:\\temp\\pysplit by 1433600\nSplit finished: 10 parts are in C:\\temp\\pysplit\nC:\\temp> dir pysplit\n...more...\n02/21/2010  11:13 AM    <DIR>          .\n02/21/2010  11:13 AM    <DIR>          ..\n02/21/2010  11:13 AM         1,433,600 part0001\n02/21/2010  11:13 AM         1,433,600 part0002\n284 | Chapter 6:\u2002Complete System Programs02/21/2010  11:13 AM         1,433,600 part0003\n02/21/2010  11:13 AM         1,433,600 part0004\n02/21/2010  11:13 AM         1,433,600 part0005\n02/21/2010  11:13 AM         1,433,600 part0006\n02/21/2010  11:13 AM         1,433,600 part0007\n02/21/2010  11:13 AM         1,433,600 part0008\n02/21/2010  11:13 AM         1,433,600 part0009\n02/21/2010  11:13 AM           911,872 part0010\n              10 File(s)     13,814,272 bytes\n               2 Dir(s)  188,812,328,960 bytes free\nEach of these generated part files represents one binary chunk of the file\npython-3.1.msi\u2014a chunk small enough to fit comfortably on a floppy disk of the time.\nIn fact, if you add the sizes of the generated part files given by the ls command, you\u2019ll\ncome up with exactly the same number of bytes as the original file\u2019s size. Before we see\nhow to put these files back together again, here are a few points to ponder as you study\nthis script\u2019s code:\nOperation modes\nThis script is designed to input its parameters in either interactive or command-\nline mode; it checks the number of command-line arguments to find out the mode\nin which it is being used. In command-line mode, you list the file to be split and\nthe output directory on the command line, and you can optionally override the\ndefault part file size with a third command-line argument.\nIn interactive mode, the script asks for a filename and output directory at the con-\nsole window with input and pauses for a key press at the end before exiting. This\nmode is nice when the program file is started by clicking on its icon; on Windows,\nparameters are typed into a pop-up DOS box that doesn\u2019t automatically disappear.\nThe script also shows the absolute paths of its parameters (by running them\nthrough os.path.abspath) because they may not be obvious in interactive mode.\nBinary file mode\nThis code is careful to open both input and output files in binary mode (rb, wb),\nbecause it needs to portably handle things like executables and audio files, not just\ntext. In Chapter 4, we learned that on Windows, text-mode files automatically map\n\\r\\n end-of-line sequences to \\n on input and map \\n to \\r\\n on output. For true\nbinary data, we really don\u2019t want any \\r characters in the data to go away when\nread, and we don\u2019t want any superfluous \\r characters to be added on output.\nBinary-mode files suppress this \\r mapping when the script is run on Windows\nand so avoid data corruption.\nIn Python 3.X, binary mode also means that file data is bytes objects in our script,\nnot encoded str text, though we don\u2019t need to do anything special\u2014this script\u2019s\nfile processing code runs the same on Python 3.X as it did on 2.X. In fact, binary\nmode is required in 3.X for this program, because the target file\u2019s data may not be\nencoded text at all; text mode requires that file content must be decodable in 3.X,\nand that might fail both for truly binary data and text files obtained from other\nSplitting and Joining Files | 285platforms. On output, binary mode accepts bytes and suppresses Unicode encod-\ning and line-end translations.\nManually closing files\nThis script also goes out of its way to manually close its files. As we also saw\nin Chapter 4, we can often get by with a single line: open(partname,\n'wb').write(chunk). This shorter form relies on the fact that the current Python\nimplementation automatically closes files for you when file objects are reclaimed\n(i.e., when they are garbage collected, because there are no more references to the\nfile object). In this one-liner, the file object would be reclaimed immediately, be-\ncause the open result is temporary in an expression and is never referenced by a\nlonger-lived name. Similarly, the input file is reclaimed when the split function\nexits.\nHowever, it\u2019s not impossible that this automatic-close behavior may go away in\nthe future. Moreover, the Jython Java-based Python implementation does not re-\nclaim unreferenced objects as immediately as the standard Python. You should\nclose manually if you care about the Java port, your script may potentially create\nmany files in a short amount of time, and it may run on a machine that has a limit\non the number of open files per program. Because the split function in this module\nis intended to be a general-purpose tool, it accommodates such worst-case\nscenarios. Also see Chapter 4\u2019s mention of the file context manager and the with\nstatement; this provides an alternative way to guarantee file closes.\nJoining Files Portably\nBack to moving big files around the house: after downloading a big game program file,\nyou can run the previous splitter script by clicking on its name in Windows Explorer\nand typing filenames. After a split, simply copy each part file onto its own floppy (or\nother more modern medium), walk the files to the destination machine, and re-create\nthe split output directory on the target computer by copying the part files. Finally, the\nscript in Example 6-6 is clicked or otherwise run to put the parts back together.\nExample 6-6. PP4E\\System\\Filetools\\join.py\n#!/usr/bin/python\n\"\"\"\n################################################################################\njoin all part files in a dir created by split.py, to re-create file.\nThis is roughly like a 'cat fromdir/* > tofile' command on unix, but is\nmore portable and configurable, and exports the join operation as a\nreusable function.  Relies on sort order of filenames: must be same\nlength.  Could extend split/join to pop up Tkinter file selectors.\n################################################################################\n\"\"\"\nimport os, sys\nreadsize = 1024\n286 | Chapter 6:\u2002Complete System Programsdef join(fromdir, tofile):\n    output = open(tofile, 'wb')\n    parts  = os.listdir(fromdir)\n    parts.sort()\n    for filename in parts:\n        filepath = os.path.join(fromdir, filename)\n        fileobj  = open(filepath, 'rb')\n        while True:\n            filebytes = fileobj.read(readsize)\n            if not filebytes: break\n            output.write(filebytes)\n        fileobj.close()\n    output.close()\nif __name__ == '__main__':\n    if len(sys.argv) == 2 and sys.argv[1] == '-help':\n        print('Use: join.py [from-dir-name to-file-name]')\n    else:\n        if len(sys.argv) != 3:\n            interactive = True\n            fromdir = input('Directory containing part files? ')\n            tofile  = input('Name of file to be recreated? ')\n        else:\n            interactive = False\n            fromdir, tofile = sys.argv[1:]\n        absfrom, absto = map(os.path.abspath, [fromdir, tofile])\n        print('Joining', absfrom, 'to make', absto)\n        try:\n            join(fromdir, tofile)\n        except:\n            print('Error joining files:')\n            print(sys.exc_info()[0], sys.exc_info()[1])\n        else:\n           print('Join complete: see', absto)\n        if interactive: input('Press Enter key') # pause if clicked\nHere is a join in progress on Windows, combining the split files we made a moment\nago; after running the join script, you still may need to run something like zip, gzip,\nor tar to unpack an archive file unless it\u2019s shipped as an executable, but at least the\noriginal downloaded file is set to go\u2021:\nC:\\temp> python C:\\...\\PP4E\\System\\Filetools\\join.py -help\nUse: join.py [from-dir-name to-file-name]\n\u2021 It turns out that the zip, gzip, and tar commands can all be replaced with pure Python code today, too. The\ngzip module in the Python standard library provides tools for reading and writing compressed gzip files,\nusually named with a .gz filename extension. It can serve as an all-Python equivalent of the standard gzip\nand gunzip command-line utility programs. This built-in module uses another module called zlib that\nimplements gzip-compatible data compressions. In recent Python releases, the zipfile module can be\nimported to make and use ZIP format archives (zip is an archive and compression format, gzip is a\ncompression scheme), and the tarfile module allows scripts to read and write tar archives. See the Python\nlibrary manual for details.\nSplitting and Joining Files | 287C:\\temp> python C:\\...\\PP4E\\System\\Filetools\\join.py pysplit mypy31.msi\nJoining C:\\temp\\pysplit to make C:\\temp\\mypy31.msi\nJoin complete: see C:\\temp\\mypy31.msi\nC:\\temp> dir *.msi\n...more...\n02/21/2010  11:21 AM        13,814,272 mypy31.msi\n06/27/2009  04:53 PM        13,814,272 python-3.1.msi\n               2 File(s)     27,628,544 bytes\n               0 Dir(s)  188,798,611,456 bytes free\nC:\\temp> fc /b mypy31.msi python-3.1.msi\nComparing files mypy31.msi and PYTHON-3.1.MSI\nFC: no differences encountered\nThe join script simply uses os.listdir to collect all the part files in a directory created\nby split, and sorts the filename list to put the parts back together in the correct order.\nWe get back an exact byte-for-byte copy of the original file (proved by the DOS fc\ncommand in the code; use cmp on Unix).\nSome of this process is still manual, of course (I never did figure out how to script the\n\u201cwalk the floppies to your bedroom\u201d step), but the split and join scripts make it both\nquick and simple to move big files around. Because this script is also portable Python\ncode, it runs on any platform to which we cared to move split files. For instance, my\nhome computers ran both Windows and Linux at the time; since this script runs on\neither platform, the gamers were covered. Before we move on, here are a couple of\nimplementation details worth underscoring in the join script\u2019s code:\nReading by blocks or files\nFirst of all, notice that this script deals with files in binary mode but also reads each\npart file in blocks of 1 KB each. In fact, the readsize setting here (the size of each\nblock read from an input part file) has no relation to chunksize in split.py (the total\nsize of each output part file). As we learned in Chapter 4, this script could instead\nread each part file all at once: output.write(open(filepath, 'rb').read()). The\ndownside to this scheme is that it really does load all of a file into memory at once.\nFor example, reading a 1.4 MB part file into memory all at once with the file object\nread method generates a 1.4 MB string in memory to hold the file\u2019s bytes. Since\nsplit allows users to specify even larger chunk sizes, the join script plans for the\nworst and reads in terms of limited-size blocks. To be completely robust, the\nsplit script could read its input data in smaller chunks too, but this hasn\u2019t become\na concern in practice (recall that as your program runs, Python automatically re-\nclaims strings that are no longer referenced, so this isn\u2019t as wasteful as it might\nseem).\nSorting filenames\nIf you study this script\u2019s code closely, you may also notice that the join scheme it\nuses relies completely on the sort order of filenames in the parts directory. Because\nit simply calls the list sort method on the filenames list returned by os.listdir, it\nimplicitly requires that filenames have the same length and format when created\n288 | Chapter 6:\u2002Complete System Programsby split. To satisfy this requirement, the splitter uses zero-padding notation in a\nstring formatting expression ('part%04d') to make sure that filenames all have the\nsame number of digits at the end (four). When sorted, the leading zero characters\nin small numbers guarantee that part files are ordered for joining correctly.\nAlternatively, we could strip off digits in filenames, convert them with int, and sort\nnumerically, by using the list sort method\u2019s keys argument, but that would still\nimply that all filenames must start with the some type of substring, and so doesn\u2019t\nquite remove the file-naming dependency between the split and join scripts. Be-\ncause these scripts are designed to be two steps of the same process, though, some\ndependencies between them seem reasonable.\nUsage Variations\nFinally, let\u2019s run a few more experiments with these Python system utilities to demon-\nstrate other usage modes. When run without full command-line arguments, both\nsplit and join are smart enough to input their parameters interactively. Here they are\nchopping and gluing the Python self-installer file on Windows again, with parameters\ntyped in the DOS console window:\nC:\\temp> python C:\\...\\PP4E\\System\\Filetools\\split.py\nFile to be split? python-3.1.msi\nDirectory to store part files? splitout\nSplitting C:\\temp\\python-3.1.msi to C:\\temp\\splitout by 1433600\nSplit finished: 10 parts are in C:\\temp\\splitout\nPress Enter key\nC:\\temp> python C:\\...\\PP4E\\System\\Filetools\\join.py\nDirectory containing part files? splitout\nName of file to be recreated? newpy31.msi\nJoining C:\\temp\\splitout to make C:\\temp\\newpy31.msi\nJoin complete: see C:\\temp\\newpy31.msi\nPress Enter key\nC:\\temp> fc /B python-3.1.msi newpy31.msi\nComparing files python-3.1.msi and NEWPY31.MSI\nFC: no differences encountered\nWhen these program files are double-clicked in a Windows file explorer GUI, they work\nthe same way (there are usually no command-line arguments when they are launched\nthis way). In this mode, absolute path displays help clarify where files really are. Re-\nmember, the current working directory is the script\u2019s home directory when clicked like\nthis, so a simple name actually maps to a source code directory; type a full path to make\nthe split files show up somewhere else:\n[in a pop-up DOS console box when split.py is clicked]\nFile to be split? c:\\temp\\python-3.1.msi\nDirectory to store part files? c:\\temp\\parts\nSplitting c:\\temp\\python-3.1.msi to c:\\temp\\parts by 1433600\nSplit finished: 10 parts are in c:\\temp\\parts\nPress Enter key\nSplitting and Joining Files | 289[in a pop-up DOS console box when join.py is clicked]\nDirectory containing part files? c:\\temp\\parts\nName of file to be recreated? c:\\temp\\morepy31.msi\nJoining c:\\temp\\parts to make c:\\temp\\morepy31.msi\nJoin complete: see c:\\temp\\morepy31.msi\nPress Enter key\nBecause these scripts package their core logic in functions, though, it\u2019s just as easy to\nreuse their code by importing and calling from another Python component (make sure\nyour module import search path includes the directory containing the PP4E root first;\nthe first abbreviated line here is one way to do so):\nC:\\temp> set PYTHONPATH=C:\\...\\dev\\Examples\nC:\\temp> python\n>>> from PP4E.System.Filetools.split import split\n>>> from PP4E.System.Filetools.join  import join\n>>>\n>>> numparts = split('python-3.1.msi', 'calldir')\n>>> numparts\n10\n>>> join('calldir', 'callpy31.msi')\n>>>\n>>> import os\n>>> os.system('fc /B python-3.1.msi callpy31.msi')\nComparing files python-3.1.msi and CALLPY31.msi\nFC: no differences encountered\n0\nA word about performance: all the split and join tests shown so far process a 13 MB\nfile, but they take less than one second of real wall-clock time to finish on my Windows\n7 2GHz Atom processor laptop computer\u2014plenty fast for just about any use I could\nimagine. Both scripts run just as fast for other reasonable part file sizes, too; here is the\nsplitter chopping up the file into 4MB and 500KB parts:\nC:\\temp> C:\\...\\PP4E\\System\\Filetools\\split.py python-3.1.msi tempsplit 4000000\nSplitting C:\\temp\\python-3.1.msi to C:\\temp\\tempsplit by 4000000\nSplit finished: 4 parts are in C:\\temp\\tempsplit\nC:\\temp> dir tempsplit\n...more...\nDirectory of C:\\temp\\tempsplit\n02/21/2010  01:27 PM    <DIR>          .\n02/21/2010  01:27 PM    <DIR>          ..\n02/21/2010  01:27 PM         4,000,000 part0001\n02/21/2010  01:27 PM         4,000,000 part0002\n02/21/2010  01:27 PM         4,000,000 part0003\n02/21/2010  01:27 PM         1,814,272 part0004\n               4 File(s)     13,814,272 bytes\n               2 Dir(s)  188,671,983,616 bytes free\n290 | Chapter 6:\u2002Complete System ProgramsC:\\temp> C:\\...\\PP4E\\System\\Filetools\\split.py python-3.1.msi tempsplit 500000\nSplitting C:\\temp\\python-3.1.msi to C:\\temp\\tempsplit by 500000\nSplit finished: 28 parts are in C:\\temp\\tempsplit\nC:\\temp> dir tempsplit\n...more...\nDirectory of C:\\temp\\tempsplit\n02/21/2010  01:27 PM    <DIR>          .\n02/21/2010  01:27 PM    <DIR>          ..\n02/21/2010  01:27 PM           500,000 part0001\n02/21/2010  01:27 PM           500,000 part0002\n02/21/2010  01:27 PM           500,000 part0003\n02/21/2010  01:27 PM           500,000 part0004\n02/21/2010  01:27 PM           500,000 part0005\n...more lines omitted...\n02/21/2010  01:27 PM           500,000 part0024\n02/21/2010  01:27 PM           500,000 part0025\n02/21/2010  01:27 PM           500,000 part0026\n02/21/2010  01:27 PM           500,000 part0027\n02/21/2010  01:27 PM           314,272 part0028\n              28 File(s)     13,814,272 bytes\n               2 Dir(s)  188,671,946,752 bytes free\nThe split can take noticeably longer to finish, but only if the part file\u2019s size is set small\nenough to generate thousands of part files\u2014splitting into 1,382 parts works but runs\nslower (though some machines today are quick enough that you might not notice):\nC:\\temp> C:\\...\\PP4E\\System\\Filetools\\split.py python-3.1.msi tempsplit 10000\nSplitting C:\\temp\\python-3.1.msi to C:\\temp\\tempsplit by 10000\nSplit finished: 1382 parts are in C:\\temp\\tempsplit\nC:\\temp> C:\\...\\PP4E\\System\\Filetools\\join.py tempsplit manypy31.msi\nJoining C:\\temp\\tempsplit to make C:\\temp\\manypy31.msi\nJoin complete: see C:\\temp\\manypy31.msi\nC:\\temp> fc /B python-3.1.msi manypy31.msi\nComparing files python-3.1.msi and MANYPY31.MSI\nFC: no differences encountered\nC:\\temp> dir tempsplit\n...more...\nDirectory of C:\\temp\\tempsplit\n02/21/2010  01:40 PM    <DIR>          .\n02/21/2010  01:40 PM    <DIR>          ..\n02/21/2010  01:39 PM            10,000 part0001\n02/21/2010  01:39 PM            10,000 part0002\n02/21/2010  01:39 PM            10,000 part0003\n02/21/2010  01:39 PM            10,000 part0004\n02/21/2010  01:39 PM            10,000 part0005\nSplitting and Joining Files | 291...over 1,000 lines deleted...\n02/21/2010  01:40 PM            10,000 part1378\n02/21/2010  01:40 PM            10,000 part1379\n02/21/2010  01:40 PM            10,000 part1380\n02/21/2010  01:40 PM            10,000 part1381\n02/21/2010  01:40 PM             4,272 part1382\n            1382 File(s)     13,814,272 bytes\n               2 Dir(s)  188,651,008,000 bytes free\nFinally, the splitter is also smart enough to create the output directory if it doesn\u2019t yet\nexist and to clear out any old files there if it does exist\u2014the following, for example,\nleaves only new files in the output directory. Because the joiner combines whatever files\nexist in the output directory, this is a nice ergonomic touch. If the output directory was\nnot cleared before each split, it would be too easy to forget that a prior run\u2019s files are\nstill there. Given that target audience for these scripts, they needed to be as forgiving\nas possible; your user base may vary (though you often shouldn\u2019t assume so).\nC:\\temp> C:\\...\\PP4E\\System\\Filetools\\split.py python-3.1.msi tempsplit 5000000\nSplitting C:\\temp\\python-3.1.msi to C:\\temp\\tempsplit by 5000000\nSplit finished: 3 parts are in C:\\temp\\tempsplit\nC:\\temp> dir tempsplit\n...more...\nDirectory of C:\\temp\\tempsplit\n02/21/2010  01:47 PM    <DIR>          .\n02/21/2010  01:47 PM    <DIR>          ..\n02/21/2010  01:47 PM         5,000,000 part0001\n02/21/2010  01:47 PM         5,000,000 part0002\n02/21/2010  01:47 PM         3,814,272 part0003\n               3 File(s)     13,814,272 bytes\n               2 Dir(s)  188,654,452,736 bytes free\nOf course, the dilemma that these scripts address might today be more easily addressed\nby simply buying a bigger memory stick or giving kids their own Internet access. Still,\nonce you catch the scripting bug, you\u2019ll find the ease and flexibility of Python to be\npowerful and enabling tools, especially for writing custom automation scripts like\nthese. When used well, Python may well become your Swiss Army knife of\ncomputing.\nGenerating Redirection Web Pages\nMoving is rarely painless, even in cyberspace. Changing your website\u2019s Internet address\ncan lead to all sorts of confusion. You need to ask known contacts to use the new\naddress and hope that others will eventually stumble onto it themselves. But if you rely\non the Internet, moves are bound to generate at least as much confusion as an address\nchange in the real world.\nUnfortunately, such site relocations are often unavoidable. Both Internet Service Pro-\nviders (ISPs) and server machines can come and go over the years. Moreover, some ISPs\n292 | Chapter 6:\u2002Complete System Programslet their service fall to intolerably low levels; if you are unlucky enough to have signed\nup with such an ISP, there is not much recourse but to change providers, and that often\nimplies a change of web addresses.\u00a7\nImagine, though, that you are an O\u2019Reilly author and have published your website\u2019s\naddress in multiple books sold widely all over the world. What do you do when your\nISP\u2019s service level requires a site change? Notifying each of the hundreds of thousands\nof readers out there isn\u2019t exactly a practical solution.\nProbably the best you can do is to leave forwarding instructions at the old site for some\nreasonably long period of time\u2014the virtual equivalent of a \u201cWe\u2019ve Moved\u201d sign in a\nstorefront window. On the Web, such a sign can also send visitors to the new site\nautomatically: simply leave a page at the old site containing a hyperlink to the page\u2019s\naddress at the new site, along with timed auto-relocation specifications. With such\nforward-link files in place, visitors to the old addresses will be only one click or a few\nseconds away from reaching the new ones.\nThat sounds simple enough. But because visitors might try to directly access the address\nof any file at your old site, you generally need to leave one forward-link file for every\nold file\u2014HTML pages, images, and so on. Unless your prior server supports auto-\nredirection (and mine did not), this represents a dilemma. If you happen to enjoy doing\nlots of mindless typing, you could create each forward-link file by hand. But given that\nmy home site contained over 100 HTML files at the time I wrote this paragraph, the\nprospect of running one editor session per file was more than enough motivation for\nan automated solution.\nPage Template File\nHere\u2019s what I came up with. First of all, I create a general page template text file, shown\nin Example 6-7, to describe how all the forward-link files should look, with parts to be\nfilled in later.\nExample 6-7. PP4E\\System\\Filetools\\template.html\n<HTML>\n<head>\n<META HTTP-EQUIV=\"Refresh\" CONTENT=\"10; URL=http://$server$/$home$/$file$\">\n<title>Site Redirection Page: $file$</title>\n</head>\n<BODY>\n<H1>This page has moved</H1>\n<P>This page now lives at this address:\n\u00a7 It happens. In fact, most people who spend any substantial amount of time in cyberspace could probably tell\na horror story or two. Mine goes like this: a number of years ago, I had an account with an ISP that went\ncompletely offline for a few weeks in response to a security breach by an ex-employee. Worse, not only was\npersonal email disabled, but queued up messages were permanently lost. If your livelihood depends on email\nand the Web as much as mine does, you\u2019ll appreciate the havoc such an outage can wreak.\nGenerating Redirection Web Pages | 293<P><A HREF=\"http://$server$/$home$/$file$\">\nhttp://$server$/$home$/$file$</A>\n<P>Please click on the new address to jump to this page, and\nupdate any links accordingly.  You will be redirectly shortly.\n</P>\n<HR>\n</BODY></HTML>\nTo fully understand this template, you have to know something about HTML, a web\npage description language that we\u2019ll explore in Part IV. But for the purposes of this\nexample, you can ignore most of this file and focus on just the parts surrounded by\ndollar signs: the strings $server$, $home$, and $file$ are targets to be replaced with real\nvalues by global text substitutions. They represent items that vary per site relocation\nand file.\nPage Generator Script\nNow, given a page template file, the Python script in Example 6-8 generates all the\nrequired forward-link files automatically.\nExample 6-8. PP4E\\System\\Filetools\\site-forward.py\n\"\"\"\n################################################################################\nCreate forward-link pages for relocating a web site.\nGenerates one page for every existing site html file; upload the generated\nfiles to your old web site.  See ftplib later in the book for ways to run\nuploads in scripts either after or during page file creation.\n################################################################################\n\"\"\"\nimport os\nservername   = 'learning-python.com'     # where site is relocating to\nhomedir      = 'books'                   # where site will be rooted\nsitefilesdir = r'C:\\temp\\public_html'    # where site files live locally\nuploaddir    = r'C:\\temp\\isp-forward'    # where to store forward files\ntemplatename = 'template.html'           # template for generated pages\ntry:\n    os.mkdir(uploaddir)                  # make upload dir if needed\nexcept OSError: pass\ntemplate  = open(templatename).read()    # load or import template text\nsitefiles = os.listdir(sitefilesdir)     # filenames, no directory prefix\ncount = 0\nfor filename in sitefiles:\n    if filename.endswith('.html') or filename.endswith('.htm'):\n        fwdname = os.path.join(uploaddir, filename)\n        print('creating', filename, 'as', fwdname)\n294 | Chapter 6:\u2002Complete System Programsfiletext = template.replace('$server$', servername)   # insert text\n        filetext = filetext.replace('$home$',   homedir)      # and write\n        filetext = filetext.replace('$file$',   filename)     # file varies\n        open(fwdname, 'w').write(filetext)\n        count += 1\nprint('Last file =>\\n', filetext, sep='')\nprint('Done:', count, 'forward files created.')\nNotice that the template\u2019s text is loaded by reading a file; it would work just as well to\ncode it as an imported Python string variable (e.g., a triple-quoted string in a module\nfile). Also observe that all configuration options are assignments at the top of the\nscript, not command-line arguments; since they change so seldom, it\u2019s convenient to\ntype them just once in the script itself.\nBut the main thing worth noticing here is that this script doesn\u2019t care what the template\nfile looks like at all; it simply performs global substitutions blindly in its text, with a\ndifferent filename value for each generated file. In fact, we can change the template file\nany way we like without having to touch the script. Though a fairly simple technique,\nsuch a division of labor can be used in all sorts of contexts\u2014generating \u201cmakefiles,\u201d\nform letters, HTML replies from CGI scripts on web servers, and so on. In terms of\nlibrary tools, the generator script:\n\u2022 Uses os.listdir to step through all the filenames in the site\u2019s directory\n(glob.glob would work too, but may require stripping directory prefixes from file\nnames)\n\u2022 Uses the string object\u2019s replace method to perform global search-and-replace op-\nerations that fill in the $-delimited targets in the template file\u2019s text, and endswith\nto skip non-HTML files (e.g., images\u2014most browsers won\u2019t know what to do with\nHTML text in a \u201c.jpg\u201d file)\n\u2022 Uses os.path.join and built-in file objects to write the resulting text out to a\nforward-link file of the same name in an output directory\nThe end result is a mirror image of the original website directory, containing only\nforward-link files generated from the page template. As an added bonus, the generator\nscript can be run on just about any Python platform\u2014I can run it on my Windows\nlaptop (where I\u2019m writing this book), as well as on a Linux server (where my http://\nlearning-python.com domain is hosted). Here it is in action on Windows:\nC:\\...\\PP4E\\System\\Filetools> python site-forward.py\ncreating about-lp.html as C:\\temp\\isp-forward\\about-lp.html\ncreating about-lp1e.html as C:\\temp\\isp-forward\\about-lp1e.html\ncreating about-lp2e.html as C:\\temp\\isp-forward\\about-lp2e.html\ncreating about-lp3e.html as C:\\temp\\isp-forward\\about-lp3e.html\ncreating about-lp4e.html as C:\\temp\\isp-forward\\about-lp4e.html\n...many more lines deleted...\ncreating training.html as C:\\temp\\isp-forward\\training.html\ncreating whatsnew.html as C:\\temp\\isp-forward\\whatsnew.html\nGenerating Redirection Web Pages | 295creating whatsold.html as C:\\temp\\isp-forward\\whatsold.html\ncreating xlate-lp.html as C:\\temp\\isp-forward\\xlate-lp.html\ncreating zopeoutline.htm as C:\\temp\\isp-forward\\zopeoutline.htm\nLast file =>\n<HTML>\n<head>\n<META HTTP-EQUIV=\"Refresh\" CONTENT=\"10; URL=http://learning-python.com/books/zop\neoutline.htm\">\n<title>Site Redirection Page: zopeoutline.htm</title>\n</head>\n<BODY>\n<H1>This page has moved</H1>\n<P>This page now lives at this address:\n<P><A HREF=\"http://learning-python.com/books/zopeoutline.htm\">\nhttp://learning-python.com/books/zopeoutline.htm</A>\n<P>Please click on the new address to jump to this page, and\nupdate any links accordingly.  You will be redirectly shortly.\n</P>\n<HR>\n</BODY></HTML>\nDone: 124 forward files created.\nTo verify this script\u2019s output, double-click on any of the output files to see what they\nlook like in a web browser (or run a start command in a DOS console on Windows\u2014\ne.g., start isp-forward\\about-lp4e.html). Figure 6-1 shows what one generated page\nlooks like on my machine.\nFigure 6-1. Site-forward output file page\nTo complete the process, you still need to install the forward links: upload all the\ngenerated files in the output directory to your old site\u2019s web directory. If that\u2019s too\nmuch to do by hand, too, be sure to see the FTP site upload scripts in Chapter 13 for\n296 | Chapter 6:\u2002Complete System Programsan automatic way to do that step with Python as well (PP4E\\Internet\\Ftp\\upload-\nflat.py will do the job). Once you\u2019ve started scripting in earnest, you\u2019ll be amazed at\nhow much manual labor Python can automate. The next section provides another\nprime example.\nA Regression Test Script\nMistakes happen. As we\u2019ve seen, Python provides interfaces to a variety of system serv-\nices, along with tools for adding others. Example 6-9 shows some of the more com-\nmonly used system tools in action. It implements a simple regression test system for\nPython scripts\u2014it runs each in a directory of Python scripts with provided input and\ncommand-line arguments, and compares the output of each run to the prior run\u2019s re-\nsults. As such, this script can be used as an automated testing system to catch errors\nintroduced by changes in program source files; in a big system, you might not know\nwhen a fix is really a bug in disguise.\nExample 6-9. PP4E\\System\\Tester\\tester.py\n\"\"\"\n################################################################################\nTest a directory of Python scripts, passing command-line arguments,\npiping in stdin, and capturing stdout, stderr, and exit status to\ndetect failures and regressions from prior run outputs.  The subprocess\nmodule spawns and controls streams (much like os.popen3 in Python 2.X),\nand is cross-platform.  Streams are always binary bytes in subprocess.\nTest inputs, args, outputs, and errors map to files in subdirectories.\nThis is a command-line script, using command-line arguments for\noptional test directory name, and force-generation flag.  While we\ncould package it as a callable function, the fact that its results\nare messages and output files makes a call/return model less useful.\nSuggested enhancement: could be extended to allow multiple sets\nof command-line arguments and/or inputs per test script, to run a\nscript multiple times (glob for multiple \".in*\" files in Inputs?).\nMight also seem simpler to store all test files in same directory\nwith different extensions, but this could grow large over time.\nCould also save both stderr and stdout to Errors on failures, but\nI prefer to have expected/actual output in Outputs on regressions.\n################################################################################\n\"\"\"\nimport os, sys, glob, time\nfrom subprocess import Popen, PIPE\n# configuration args\ntestdir  = sys.argv[1] if len(sys.argv) > 1 else os.curdir\nforcegen = len(sys.argv) > 2\nprint('Start tester:', time.asctime())\nprint('in', os.path.abspath(testdir))\nA Regression Test Script | 297def verbose(*args):\n    print('-'*80)\n    for arg in args: print(arg)\ndef quiet(*args): pass\ntrace = quiet\n# glob scripts to be tested\ntestpatt  = os.path.join(testdir, 'Scripts', '*.py')\ntestfiles = glob.glob(testpatt)\ntestfiles.sort()\ntrace(os.getcwd(), *testfiles)\nnumfail = 0\nfor testpath in testfiles:                      # run all tests in dir\n    testname = os.path.basename(testpath)       # strip directory path\n    # get input and args\n    infile = testname.replace('.py', '.in')\n    inpath = os.path.join(testdir, 'Inputs', infile)\n    indata = open(inpath, 'rb').read() if os.path.exists(inpath) else b''\n    argfile = testname.replace('.py', '.args')\n    argpath = os.path.join(testdir, 'Args', argfile)\n    argdata = open(argpath).read() if os.path.exists(argpath) else ''\n    # locate output and error, scrub prior results\n    outfile = testname.replace('.py', '.out')\n    outpath = os.path.join(testdir, 'Outputs', outfile)\n    outpathbad = outpath + '.bad'\n    if os.path.exists(outpathbad): os.remove(outpathbad)\n    errfile = testname.replace('.py', '.err')\n    errpath = os.path.join(testdir, 'Errors', errfile)\n    if os.path.exists(errpath): os.remove(errpath)\n    # run test with redirected streams\n    pypath = sys.executable\n    command = '%s %s %s' % (pypath, testpath, argdata)\n    trace(command, indata)\n    process = Popen(command, shell=True, stdin=PIPE, stdout=PIPE, stderr=PIPE)\n    process.stdin.write(indata)\n    process.stdin.close()\n    outdata = process.stdout.read()\n    errdata = process.stderr.read()                          # data are bytes\n    exitstatus = process.wait()                              # requires binary files\n    trace(outdata, errdata, exitstatus)\n    # analyze results\n    if exitstatus != 0:\n        print('ERROR status:', testname, exitstatus)         # status and/or stderr\n    if errdata:\n        print('ERROR stream:', testname, errpath)            # save error text\n        open(errpath, 'wb').write(errdata)\n298 | Chapter 6:\u2002Complete System Programsif exitstatus or errdata:                                # consider both failure\n        numfail += 1                                         # can get status+stderr\n        open(outpathbad, 'wb').write(outdata)                # save output to view\n    elif not os.path.exists(outpath) or forcegen:\n        print('generating:', outpath)                        # create first output\n        open(outpath, 'wb').write(outdata)\n    else:\n        priorout = open(outpath, 'rb').read()                # or compare to prior\n        if priorout == outdata:\n            print('passed:', testname)\n        else:\n            numfail += 1\n            print('FAILED output:', testname, outpathbad)\n            open(outpathbad, 'wb').write(outdata)\nprint('Finished:', time.asctime())\nprint('%s tests were run, %s tests failed.' % (len(testfiles), numfail))\nWe\u2019ve seen the tools used by this script earlier in this part of the book\u2014subprocess,\nos.path, glob, files, and the like. This example largely just pulls these tools together to\nsolve a useful purpose. Its core operation is comparing new outputs to old, in order to\nspot changes (\u201cregressions\u201d). Along the way, it also manages command-line arguments,\nerror messages, status codes, and files.\nThis script is also larger than most we\u2019ve seen so far, but it\u2019s a realistic and representative\nsystem administration tool (in fact, it\u2019s derived from a similar tool I actually used in the\npast to detect changes in a compiler). Probably the best way to understand how it works\nis to demonstrate what it does. The next section steps through a testing session to be\nread in conjunction with studying the test script\u2019s code.\nRunning the Test Driver\nMuch of the magic behind the test driver script in Example 6-9 has to do with its\ndirectory structure. When you run it for the first time in a test directory (or force it to\nstart from scratch there by passing a second command-line argument), it:\n\u2022 Collects scripts to be run in the Scripts subdirectory\n\u2022 Fetches any associated script input and command-line arguments from the\nInputs and Args subdirectories\n\u2022 Generates initial stdout output files for tests that exit normally in the Outputs\nsubdirectory\n\u2022 Reports tests that fail either by exit status code or by error messages appearing in\nstderr\nOn all failures, the script also saves any stderr error message text, as well as any\nstdout data generated up to the point of failure; standard error text is saved to a file in\nthe Errors subdirectory, and standard output of failed tests is saved with a special\nA Regression Test Script | 299\u201c.bad\u201d filename extension in Outputs (saving this normally in the Outputs subdirectory\nwould trigger a failure when the test is later fixed!). Here\u2019s a first run:\nC:\\...\\PP4E\\System\\Tester> python tester.py . 1\nStart tester: Mon Feb 22 22:13:38 2010\nin C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\System\\Tester\ngenerating: .\\Outputs\\test-basic-args.out\ngenerating: .\\Outputs\\test-basic-stdout.out\ngenerating: .\\Outputs\\test-basic-streams.out\ngenerating: .\\Outputs\\test-basic-this.out\nERROR status: test-errors-runtime.py 1\nERROR stream: test-errors-runtime.py .\\Errors\\test-errors-runtime.err\nERROR status: test-errors-syntax.py 1\nERROR stream: test-errors-syntax.py .\\Errors\\test-errors-syntax.err\nERROR status: test-status-bad.py 42\ngenerating: .\\Outputs\\test-status-good.out\nFinished: Mon Feb 22 22:13:41 2010\n8 tests were run, 3 tests failed.\nTo run each script, the tester configures any preset command-line arguments provided,\npipes in fetched canned input (if any), and captures the script\u2019s standard output and\nerror streams, along with its exit status code. When I ran this example, there were 8\ntest scripts, along with a variety of inputs and outputs. Since the directory and file\nnaming structures are the key to this example, here is a listing of the test directory I\nused\u2014the Scripts directory is primary, because that\u2019s where tests to be run are\ncollected:\nC:\\...\\PP4E\\System\\Tester> dir /B\nArgs\nErrors\nInputs\nOutputs\nScripts\ntester.py\nxxold\nC:\\...\\PP4E\\System\\Tester> dir /B Scripts\ntest-basic-args.py\ntest-basic-stdout.py\ntest-basic-streams.py\ntest-basic-this.py\ntest-errors-runtime.py\ntest-errors-syntax.py\ntest-status-bad.py\ntest-status-good.py\nThe other subdirectories contain any required inputs and any generated outputs asso-\nciated with scripts to be tested:\nC:\\...\\PP4E\\System\\Tester> dir /B Args\ntest-basic-args.args\ntest-status-good.args\n300 | Chapter 6:\u2002Complete System ProgramsC:\\...\\PP4E\\System\\Tester> dir /B Inputs\ntest-basic-args.in\ntest-basic-streams.in\nC:\\...\\PP4E\\System\\Tester> dir /B Outputs\ntest-basic-args.out\ntest-basic-stdout.out\ntest-basic-streams.out\ntest-basic-this.out\ntest-errors-runtime.out.bad\ntest-errors-syntax.out.bad\ntest-status-bad.out.bad\ntest-status-good.out\nC:\\...\\PP4E\\System\\Tester> dir /B Errors\ntest-errors-runtime.err\ntest-errors-syntax.err\nI won\u2019t list all these files here (as you can see, there are many, and all are available in\nthe book examples distribution package), but to give you the general flavor, here are\nthe files associated with the test script test-basic-args.py:\nC:\\...\\PP4E\\System\\Tester> type Scripts\\test-basic-args.py\n# test args, streams\nimport sys, os\nprint(os.getcwd())                  # to Outputs\nprint(sys.path[0])\nprint('[argv]')\nfor arg in sys.argv:                # from Args\n    print(arg)                      # to Outputs\nprint('[interaction]')              # to Outputs\ntext = input('Enter text:')         # from Inputs\nrept = sys.stdin.readline()         # from Inputs\nsys.stdout.write(text * int(rept))  # to Outputs\nC:\\...\\PP4E\\System\\Tester> type Args\\test-basic-args.args\n-command -line --stuff\nC:\\...\\PP4E\\System\\Tester> type Inputs\\test-basic-args.in\nEggs\n10\nC:\\...\\PP4E\\System\\Tester> type Outputs\\test-basic-args.out\nC:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\System\\Tester\nC:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\System\\Tester\\Scripts\n[argv]\n.\\Scripts\\test-basic-args.py\n-command\n-line\n--stuff\n[interaction]\nEnter text:EggsEggsEggsEggsEggsEggsEggsEggsEggsEggs\nA Regression Test Script | 301And here are two files related to one of the detected errors\u2014the first is its captured\nstderr, and the second is its stdout generated up to the point where the error occurred;\nthese are for human (or other tools) inspection, and are automatically removed the next\ntime the tester script runs:\nC:\\...\\PP4E\\System\\Tester> type Errors\\test-errors-runtime.err\nTraceback (most recent call last):\n  File \".\\Scripts\\test-errors-runtime.py\", line 3, in <module>\n    print(1 / 0)\nZeroDivisionError: int division or modulo by zero\nC:\\...\\PP4E\\System\\Tester> type Outputs\\test-errors-runtime.out.bad\nstarting\nNow, when run again without making any changes to the tests, the test driver script\ncompares saved prior outputs to new ones and detects no regressions; failures desig-\nnated by exit status and stderr messages are still reported as before, but there are no\ndeviations from other tests\u2019 saved expected output:\nC:\\...\\PP4E\\System\\Tester> python tester.py\nStart tester: Mon Feb 22 22:26:41 2010\nin C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\System\\Tester\npassed: test-basic-args.py\npassed: test-basic-stdout.py\npassed: test-basic-streams.py\npassed: test-basic-this.py\nERROR status: test-errors-runtime.py 1\nERROR stream: test-errors-runtime.py .\\Errors\\test-errors-runtime.err\nERROR status: test-errors-syntax.py 1\nERROR stream: test-errors-syntax.py .\\Errors\\test-errors-syntax.err\nERROR status: test-status-bad.py 42\npassed: test-status-good.py\nFinished: Mon Feb 22 22:26:43 2010\n8 tests were run, 3 tests failed.\nBut when I make a change in one of the test scripts that will produce different output\n(I changed a loop counter to print fewer lines), the regression is caught and reported;\nthe new and different output of the script is reported as a failure, and saved in\nOutputs as a \u201c.bad\u201d for later viewing:\nC:\\...\\PP4E\\System\\Tester> python tester.py\nStart tester: Mon Feb 22 22:28:35 2010\nin C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\System\\Tester\npassed: test-basic-args.py\nFAILED output: test-basic-stdout.py .\\Outputs\\test-basic-stdout.out.bad\npassed: test-basic-streams.py\npassed: test-basic-this.py\nERROR status: test-errors-runtime.py 1\nERROR stream: test-errors-runtime.py .\\Errors\\test-errors-runtime.err\nERROR status: test-errors-syntax.py 1\nERROR stream: test-errors-syntax.py .\\Errors\\test-errors-syntax.err\nERROR status: test-status-bad.py 42\npassed: test-status-good.py\nFinished: Mon Feb 22 22:28:38 2010\n302 | Chapter 6:\u2002Complete System Programs8 tests were run, 4 tests failed.\nC:\\...\\PP4E\\System\\Tester> type Outputs\\test-basic-stdout.out.bad\nbegin\nSpam!\nSpam!Spam!\nSpam!Spam!Spam!\nSpam!Spam!Spam!Spam!\nend\nOne last usage note: if you change the trace variable in this script to be verbose, you\u2019ll\nget much more output designed to help you trace the programs operation (but probably\ntoo much for real testing runs):\nC:\\...\\PP4E\\System\\Tester> tester.py\nStart tester: Mon Feb 22 22:34:51 2010\nin C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\System\\Tester\n--------------------------------------------------------------------------------\nC:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\System\\Tester\n.\\Scripts\\test-basic-args.py\n.\\Scripts\\test-basic-stdout.py\n.\\Scripts\\test-basic-streams.py\n.\\Scripts\\test-basic-this.py\n.\\Scripts\\test-errors-runtime.py\n.\\Scripts\\test-errors-syntax.py\n.\\Scripts\\test-status-bad.py\n.\\Scripts\\test-status-good.py\n--------------------------------------------------------------------------------\nC:\\Python31\\python.exe .\\Scripts\\test-basic-args.py -command -line --stuff\nb'Eggs\\r\\n10\\r\\n'\n--------------------------------------------------------------------------------\nb'C:\\\\Users\\\\mark\\\\Stuff\\\\Books\\\\4E\\\\PP4E\\\\dev\\\\Examples\\\\PP4E\\\\System\\\\Tester\\r\n\\nC:\\\\Users\\\\mark\\\\Stuff\\\\Books\\\\4E\\\\PP4E\\\\dev\\\\Examples\\\\PP4E\\\\System\\\\Tester\\\\\nScripts\\r\\n[argv]\\r\\n.\\\\Scripts\\\\test-basic-args.py\\r\\n-command\\r\\n-line\\r\\n--st\nuff\\r\\n[interaction]\\r\\nEnter text:EggsEggsEggsEggsEggsEggsEggsEggsEggsEggs'\nb''\n0\npassed: test-basic-args.py\n...more lines deleted...\nStudy the test driver\u2019s code for more details. Naturally, there is much more to the\ngeneral testing story than we have space for here. For example, in-process tests don\u2019t\nneed to spawn programs and can generally make do with importing modules and testing\nthem in try exception handler statements. There is also ample room for expansion and\ncustomization in our testing script (see its docstring for starters). Moreover, Python\ncomes with two testing frameworks, doctest and unittest (a.k.a. PyUnit), which pro-\nvide techniques and structures for coding regression and unit tests:\nunittest\nAn object-oriented framework that specifies test cases, expected results, and test\nsuites. Subclasses provide test methods and use inherited assertion calls to specify\nexpected results.\nA Regression Test Script | 303doctest\nParses out and reruns tests from an interactive session log that is pasted into a\nmodule\u2019s docstrings. The logs give test calls and expected results; doctest essen-\ntially reruns the interactive session.\nSee the Python library manual, the PyPI website, and your favorite Web search engine\nfor additional testing toolkits in both Python itself and the third-party domain.\nFor automated testing of Python command-line scripts that run as independent pro-\ngrams and tap into standard script execution context, though, our tester does the job.\nBecause the test driver is fully independent of the scripts it tests, we can drop in new\ntest cases without having to update the driver\u2019s code. And because it is written in Py-\nthon, it\u2019s quick and easy to change as our testing needs evolve. As we\u2019ll see again in the\nnext section, this \u201cscriptability\u201d that Python provides can be a decided advantage for\nreal tasks.\nTesting Gone Bad?\nOnce we learn about sending email from Python scripts in Chapter 13, you might also\nwant to augment this script to automatically send out email when regularly run tests\nfail (e.g., when run from a cron job on Unix). That way, you don\u2019t even need to re-\nmember to check results. Of course, you could go further still.\nOne company I worked for added sound effects to compiler test scripts; you got an\naudible round of applause if no regressions were found and an entirely different noise\notherwise. (See playfile.py at the end of this chapter for hints.)\nAnother company in my development past ran a nightly test script that automatically\nisolated the source code file check-in that triggered a test regression and sent a nasty\nemail to the guilty party (and his or her supervisor). Nobody expects the Spanish\nInquisition!\nCopying Directory Trees\nMy CD writer sometimes does weird things. In fact, copies of files with odd names can\nbe totally botched on the CD, even though other files show up in one piece. That\u2019s not\nnecessarily a showstopper; if just a few files are trashed in a big CD backup copy, I can\nalways copy the offending files elsewhere one at a time. Unfortunately, drag-and-drop\ncopies on some versions of Windows don\u2019t play nicely with such a CD: the copy op-\neration stops and exits the moment the first bad file is encountered. You get only as\nmany files as were copied up to the error, but no more.\nIn fact, this is not limited to CD copies. I\u2019ve run into similar problems when trying to\nback up my laptop\u2019s hard drive to another drive\u2014the drag-and-drop copy stops with\nan error as soon as it reaches a file with a name that is too long or odd to copy (common\n304 | Chapter 6:\u2002Complete System Programsin saved web pages). The last 30 minutes spent copying is wasted time; frustrating, to\nsay the least!\nThere may be some magical Windows setting to work around this feature, but I gave\nup hunting for one as soon as I realized that it would be easier to code a copier in Python.\nThe cpall.py script in Example 6-10 is one way to do it. With this script, I control what\nhappens when bad files are found\u2014I can skip over them with Python exception han-\ndlers, for instance. Moreover, this tool works with the same interface and effect on\nother platforms. It seems to me, at least, that a few minutes spent writing a portable\nand reusable Python script to meet a need is a better investment than looking for sol-\nutions that work on only one platform (if at all).\nExample 6-10. PP4E\\System\\Filetools\\cpall.py\n\"\"\"\n################################################################################\nUsage: \"python cpall.py dirFrom dirTo\".\nRecursive copy of a directory tree.  Works like a \"cp -r dirFrom/* dirTo\"\nUnix command, and assumes that dirFrom and dirTo are both directories.\nWas written to get around fatal error messages under Windows drag-and-drop\ncopies (the first bad file ends the entire copy operation immediately),\nbut also allows for coding more customized copy operations in Python.\n################################################################################\n\"\"\"\nimport os, sys\nmaxfileload = 1000000\nblksize = 1024 * 500\ndef copyfile(pathFrom, pathTo, maxfileload=maxfileload):\n    \"\"\"\n    Copy one file pathFrom to pathTo, byte for byte;\n    uses binary file modes to supress Unicde decode and endline transform\n    \"\"\"\n    if os.path.getsize(pathFrom) <= maxfileload:\n        bytesFrom = open(pathFrom, 'rb').read()   # read small file all at once\n        open(pathTo, 'wb').write(bytesFrom)\n    else:\n        fileFrom = open(pathFrom, 'rb')           # read big files in chunks\n        fileTo   = open(pathTo,   'wb')           # need b mode for both\n        while True:\n            bytesFrom = fileFrom.read(blksize)    # get one block, less at end\n            if not bytesFrom: break               # empty after last chunk\n            fileTo.write(bytesFrom)\ndef copytree(dirFrom, dirTo, verbose=0):\n    \"\"\"\n    Copy contents of dirFrom and below to dirTo, return (files, dirs) counts;\n    may need to use bytes for dirnames if undecodable on other platforms;\n    may need to do more file type checking on Unix: skip links, fifos, etc.\n    \"\"\"\n    fcount = dcount = 0\n    for filename in os.listdir(dirFrom):                  # for files/dirs here\nCopying Directory Trees | 305pathFrom = os.path.join(dirFrom, filename)\n        pathTo   = os.path.join(dirTo,   filename)        # extend both paths\n        if not os.path.isdir(pathFrom):                   # copy simple files\n            try:\n                if verbose > 1: print('copying', pathFrom, 'to', pathTo)\n                copyfile(pathFrom, pathTo)\n                fcount += 1\n            except:\n                print('Error copying', pathFrom, 'to', pathTo, '--skipped')\n                print(sys.exc_info()[0], sys.exc_info()[1])\n        else:\n            if verbose: print('copying dir', pathFrom, 'to', pathTo)\n            try:\n                os.mkdir(pathTo)                          # make new subdir\n                below = copytree(pathFrom, pathTo)        # recur into subdirs\n                fcount += below[0]                        # add subdir  counts\n                dcount += below[1]\n                dcount += 1\n            except:\n                print('Error creating', pathTo, '--skipped')\n                print(sys.exc_info()[0], sys.exc_info()[1])\n    return (fcount, dcount)\ndef getargs():\n    \"\"\"\n    Get and verify directory name arguments, returns default None on errors\n    \"\"\"\n    try:\n        dirFrom, dirTo = sys.argv[1:]\n    except:\n        print('Usage error: cpall.py dirFrom dirTo')\n    else:\n        if not os.path.isdir(dirFrom):\n            print('Error: dirFrom is not a directory')\n        elif not os.path.exists(dirTo):\n            os.mkdir(dirTo)\n            print('Note: dirTo was created')\n            return (dirFrom, dirTo)\n        else:\n            print('Warning: dirTo already exists')\n            if hasattr(os.path, 'samefile'):\n                same = os.path.samefile(dirFrom, dirTo)\n            else:\n                same = os.path.abspath(dirFrom) == os.path.abspath(dirTo)\n            if same:\n                print('Error: dirFrom same as dirTo')\n            else:\n                return (dirFrom, dirTo)\nif __name__ == '__main__':\n    import time\n    dirstuple = getargs()\n    if dirstuple:\n        print('Copying...')\n        start = time.clock()\n306 | Chapter 6:\u2002Complete System Programsfcount, dcount = copytree(*dirstuple)\n        print('Copied', fcount, 'files,', dcount, 'directories', end=' ')\n        print('in', time.clock() - start, 'seconds')\nThis script implements its own recursive tree traversal logic and keeps track of both\nthe \u201cfrom\u201d and \u201cto\u201d directory paths as it goes. At every level, it copies over simple files,\ncreates directories in the \u201cto\u201d path, and recurs into subdirectories with \u201cfrom\u201d and \u201cto\u201d\npaths extended by one level. There are other ways to code this task (e.g., we might\nchange the working directory along the way with os.chdir calls or there is probably an\nos.walk solution which replaces from and to path prefixes as it walks), but extending\npaths on recursive descent works well in this script.\nNotice this script\u2019s reusable copyfile function\u2014just in case there are multigigabyte\nfiles in the tree to be copied, it uses a file\u2019s size to decide whether it should be read all\nat once or in chunks (remember, the file read method without arguments actually loads\nthe entire file into an in-memory string). We choose fairly large file and block sizes,\nbecause the more we read at once in Python, the faster our scripts will typically run.\nThis is more efficient than it may sound; strings left behind by prior reads will be\ngarbage collected and reused as we go. We\u2019re using binary file modes here again, too,\nto suppress the Unicode encodings and end-of-line translations of text files\u2014trees may\ncontain arbitrary kinds of files.\nAlso notice that this script creates the \u201cto\u201d directory if needed, but it assumes that the\ndirectory is empty when a copy starts up; for accuracy, be sure to remove the target\ndirectory before copying a new tree to its name, or old files may linger in the target tree\n(we could automatically remove the target first, but this may not always be desired).\nThis script also tries to determine if the source and target are the same; on Unix-like\nplatforms with oddities such as links, os.path.samefile does a more accurate job than\ncomparing absolute file names (different file names may be the same file).\nHere is a copy of a big book examples tree (I use the tree from the prior edition\nthroughout this chapter) in action on Windows; pass in the name of the \u201cfrom\u201d and\n\u201cto\u201d directories to kick off the process, redirect the output to a file if there are too many\nerror messages to read all at once (e.g., > output.txt), and run an rm \u2013r or rmdir /S\nshell command (or similar platform-specific tool) to delete the target directory first if\nneeded:\nC:\\...\\PP4E\\System\\Filetools> rmdir /S copytemp\ncopytemp, Are you sure (Y/N)? y\nC:\\...\\PP4E\\System\\Filetools> cpall.py C:\\temp\\PP3E\\Examples copytemp\nNote: dirTo was created\nCopying...\nCopied 1430 files, 185 directories in 10.4470980971 seconds\nC:\\...\\PP4E\\System\\Filetools> fc /B copytemp\\PP3E\\Launcher.py\n                                    C:\\temp\\PP3E\\Examples\\PP3E\\Launcher.py\nComparing files COPYTEMP\\PP3E\\Launcher.py and C:\\TEMP\\PP3E\\EXAMPLES\\PP3E\\LAUNCHER.PY\nFC: no differences encountered\nCopying Directory Trees | 307You can use the copy function\u2019s verbose argument to trace the process if you wish. At \nthe time I wrote this edition in 2010, this test run copied a tree of 1,430 files and 185 \ndirectories in 10 seconds on my woefully underpowered netbook machine (the built-\nin time.clock call is used to query the system time in seconds); it may run arbitrarily \nfaster or slower for you. Still, this is at least as fast as the best drag-and-drop I\u2019ve timed \non this machine.\nSo how does this script work around bad files on a CD backup? The secret is that it \ncatches and ignores file exceptions, and it keeps walking. To copy all the files that are \ngood on a CD, I simply run a command line such as this one:\nC:\\...\\PP4E\\System\\Filetools> python cpall.py G:\\Examples C:\\PP3E\\Examples\nBecause the CD is addressed as \u201cG:\u201d on my Windows machine, this is the command-\nline equivalent of drag-and-drop copying from an item in the CD\u2019s top-level folder, \nexcept that the Python script will recover from errors on the CD and get the rest. On \ncopy errors, it prints a message to standard output and continues; for big copies, you\u2019ll \nprobably want to redirect the script\u2019s output to a file for later inspection.\nIn general, cpall can be passed any absolute directory path on your machine, even those \nthat indicate devices such as CDs. To make this go on Linux, try a root directory such \nas /dev/cdrom or something similar to address your CD drive. Once you\u2019ve copied a \ntree this way, you still might want to verify; to see how, let\u2019s move on to the next \nexample.\nComparing Directory Trees\nEngineers can be a paranoid sort (but you didn\u2019t hear that from me). At least I am. It \ncomes from decades of seeing things go terribly wrong, I suppose. When I create a CD \nbackup of my hard drive, for instance, there\u2019s still something a bit too magical about \nthe process to trust the CD writer program to do the right thing. Maybe I should, but \nit\u2019s tough to have a lot of faith in tools that occasionally trash files and seem to crash \nmy Windows machine every third Tuesday of the month. When push comes to shove, \nit\u2019s nice to be able to verify that data copied to a backup CD is the same as the original\u2014 \nor at least to spot deviations from the original\u2014as soon as possible. If a backup is ever \nneeded, it will be really needed.\nBecause data CDs are accessible as simple directory trees in the file system, we are once \nagain in the realm of tree walkers\u2014to verify a backup CD, we simply need to walk its \ntop-level directory. If our script is general enough, we will also be able to use it to verify \nother copy operations as well\u2014e.g., downloaded tar files, hard-drive backups, and so \non. In fact, the combination of the cpall script of the prior section and a general tree \ncomparison would provide a portable and scriptable way to copy and verify data sets.\nWe\u2019ve already studied generic directory tree walkers, but they won\u2019t help us here di-\nrectly: we need to walk two directories in parallel and inspect common files along the \nway. Moreover, walking either one of the two directories won\u2019t allow us to spot files\n308 | Chapter 6:\u2002Complete System Programsand directories that exist only in the other. Something more custom and recursive seems\nin order here.\nFinding Directory Differences\nBefore we start coding, the first thing we need to clarify is what it means to compare\ntwo directory trees. If both trees have exactly the same branch structure and depth, this\nproblem reduces to comparing corresponding files in each tree. In general, though, the\ntrees can have arbitrarily different shapes, depths, and so on.\nMore generally, the contents of a directory in one tree may have more or fewer entries\nthan the corresponding directory in the other tree. If those differing contents are file-\nnames, there is no corresponding file to compare with; if they are directory names, there\nis no corresponding branch to descend through. In fact, the only way to detect files and\ndirectories that appear in one tree but not the other is to detect differences in each level\u2019s\ndirectory.\nIn other words, a tree comparison algorithm will also have to perform directory com-\nparisons along the way. Because this is a nested and simpler operation, let\u2019s start by\ncoding and debugging a single-directory comparison of filenames in Example 6-11.\nExample 6-11. PP4E\\System\\Filetools\\dirdiff.py\n\"\"\"\n################################################################################\nUsage: python dirdiff.py dir1-path dir2-path\nCompare two directories to find files that exist in one but not the other.\nThis version uses the os.listdir function and list difference.  Note that\nthis script checks only filenames, not file contents--see diffall.py for an\nextension that does the latter by comparing .read() results.\n################################################################################\n\"\"\"\nimport os, sys\ndef reportdiffs(unique1, unique2, dir1, dir2):\n    \"\"\"\n    Generate diffs report for one dir: part of comparedirs output\n    \"\"\"\n    if not (unique1 or unique2):\n        print('Directory lists are identical')\n    else:\n        if unique1:\n            print('Files unique to', dir1)\n            for file in unique1:\n                print('...', file)\n        if unique2:\n            print('Files unique to', dir2)\n            for file in unique2:\n                print('...', file)\ndef difference(seq1, seq2):\nComparing Directory Trees | 309\"\"\"\n    Return all items in seq1 only;\n    a set(seq1) - set(seq2) would work too, but sets are randomly\n    ordered, so any platform-dependent directory order would be lost\n    \"\"\"\n    return [item for item in seq1 if item not in seq2]\ndef comparedirs(dir1, dir2, files1=None, files2=None):\n    \"\"\"\n    Compare directory contents, but not actual files;\n    may need bytes listdir arg for undecodable filenames on some platforms\n    \"\"\"\n    print('Comparing', dir1, 'to', dir2)\n    files1  = os.listdir(dir1) if files1 is None else files1\n    files2  = os.listdir(dir2) if files2 is None else files2\n    unique1 = difference(files1, files2)\n    unique2 = difference(files2, files1)\n    reportdiffs(unique1, unique2, dir1, dir2)\n    return not (unique1 or unique2)               # true if no diffs\ndef getargs():\n    \"Args for command-line mode\"\n    try:\n        dir1, dir2 = sys.argv[1:]                 # 2 command-line args\n    except:\n        print('Usage: dirdiff.py dir1 dir2')\n        sys.exit(1)\n    else:\n        return (dir1, dir2)\nif __name__ == '__main__':\n    dir1, dir2 = getargs()\n    comparedirs(dir1, dir2)\nGiven listings of names in two directories, this script simply picks out unique names\nin the first and unique names in the second, and reports any unique names found as\ndifferences (that is, files in one directory but not the other). Its comparedirs function \nreturns a true result if no differences were found, which is useful for detecting differ-\nences in callers.\nLet\u2019s run this script on a few directories; differences are detected and reported as names\nunique in either passed-in directory pathname. Notice that this is only a structural\ncomparison that just checks names in listings, not file contents (we\u2019ll add the latter in\na moment):\nC:\\...\\PP4E\\System\\Filetools> dirdiff.py C:\\temp\\PP3E\\Examples copytemp\nComparing C:\\temp\\PP3E\\Examples to copytemp\nDirectory lists are identical\nC:\\...\\PP4E\\System\\Filetools> dirdiff.py C:\\temp\\PP3E\\Examples\\PP3E\\System ..\nComparing C:\\temp\\PP3E\\Examples\\PP3E\\System to ..\nFiles unique to C:\\temp\\PP3E\\Examples\\PP3E\\System\n... App\n310 | Chapter 6:\u2002Complete System Programs... Exits\n... Media\n... moreplus.py\nFiles unique to ..\n... more.pyc\n... spam.txt\n... Tester\n... __init__.pyc\nThe unique function is the heart of this script: it performs a simple list difference\noperation. When applied to directories, unique items represent tree differences, and\ncommon items are names of files or subdirectories that merit further comparisons or\ntraversals. In fact, in Python 2.4 and later, we could also use the built-in set object type\nif we don\u2019t care about the order in the results\u2014because sets are not sequences, they\nwould not maintain any original and possibly platform-specific left-to-right order of\nthe directory listings provided by os.listdir. For that reason (and to avoid requiring\nusers to upgrade), we\u2019ll keep using our own comprehension-based function instead\nof sets.\nFinding Tree Differences\nWe\u2019ve just coded a directory comparison tool that picks out unique files and directories.\nNow all we need is a tree walker that applies dirdiff at each level to report unique\nitems, explicitly compares the contents of files in common, and descends through di-\nrectories in common. Example 6-12 fits the bill.\nExample 6-12. PP4E\\System\\Filetools\\diffall.py\n\"\"\"\n################################################################################\nUsage: \"python diffall.py dir1 dir2\".\nRecursive directory tree comparison: report unique files that exist in only\ndir1 or dir2, report files of the same name in dir1 and dir2 with differing\ncontents, report instances of same name but different type in dir1 and dir2,\nand do the same for all subdirectories of the same names in and below dir1\nand dir2.  A summary of diffs appears at end of output, but search redirected\noutput for \"DIFF\" and \"unique\" strings for further details.  New: (3E) limit\nreads to 1M for large files, (3E) catch same name=file/dir, (4E) avoid extra\nos.listdir() calls in dirdiff.comparedirs() by passing results here along.\n################################################################################\n\"\"\"\nimport os, dirdiff\nblocksize = 1024 * 1024              # up to 1M per read\ndef intersect(seq1, seq2):\n    \"\"\"\n    Return all items in both seq1 and seq2;\n    a set(seq1) & set(seq2) woud work too, but sets are randomly\n    ordered, so any platform-dependent directory order would be lost\n    \"\"\"\n    return [item for item in seq1 if item in seq2]\nComparing Directory Trees | 311def comparetrees(dir1, dir2, diffs, verbose=False):\n    \"\"\"\n    Compare all subdirectories and files in two directory trees;\n    uses binary files to prevent Unicode decoding and endline transforms,\n    as trees might contain arbitrary binary files as well as arbitrary text;\n    may need bytes listdir arg for undecodable filenames on some platforms\n    \"\"\"\n    # compare file name lists\n    print('-' * 20)\n    names1 = os.listdir(dir1)\n    names2 = os.listdir(dir2)\n    if not dirdiff.comparedirs(dir1, dir2, names1, names2):\n        diffs.append('unique files at %s - %s' % (dir1, dir2))\n    print('Comparing contents')\n    common = intersect(names1, names2)\n    missed = common[:]\n    # compare contents of files in common\n    for name in common:\n        path1 = os.path.join(dir1, name)\n        path2 = os.path.join(dir2, name)\n        if os.path.isfile(path1) and os.path.isfile(path2):\n            missed.remove(name)\n            file1 = open(path1, 'rb')\n            file2 = open(path2, 'rb')\n            while True:\n                bytes1 = file1.read(blocksize)\n                bytes2 = file2.read(blocksize)\n                if (not bytes1) and (not bytes2):\n                    if verbose: print(name, 'matches')\n                    break\n                if bytes1 != bytes2:\n                    diffs.append('files differ at %s - %s' % (path1, path2))\n                    print(name, 'DIFFERS')\n                    break\n    # recur to compare directories in common\n    for name in common:\n        path1 = os.path.join(dir1, name)\n        path2 = os.path.join(dir2, name)\n        if os.path.isdir(path1) and os.path.isdir(path2):\n            missed.remove(name)\n            comparetrees(path1, path2, diffs, verbose)\n    # same name but not both files or dirs?\n    for name in missed:\n        diffs.append('files missed at %s - %s: %s' % (dir1, dir2, name))\n        print(name, 'DIFFERS')\nif __name__ == '__main__':\n    dir1, dir2 = dirdiff.getargs()\n    diffs = []\n312 | Chapter 6:\u2002Complete System Programscomparetrees(dir1, dir2, diffs, True)      # changes diffs in-place\n    print('=' * 40)                            # walk, report diffs list\n    if not diffs:\n        print('No diffs found.')\n    else:\n        print('Diffs found:', len(diffs))\n        for diff in diffs: print('-', diff)\nAt each directory in the tree, this script simply runs the dirdiff tool to detect unique\nnames, and then compares names in common by intersecting directory lists. It uses\nrecursive function calls to traverse the tree and visits subdirectories only after compar-\ning all the files at each level so that the output is more coherent to read (the trace output\nfor subdirectories appears after that for files; it is not intermixed).\nNotice the misses list, added in the third edition of this book; it\u2019s very unlikely, but not\nimpossible, that the same name might be a file in one directory and a subdirectory in\nthe other. Also notice the blocksize variable; much like the tree copy script we saw\nearlier, instead of blindly reading entire files into memory all at once, we limit each read\nto grab up to 1 MB at a time, just in case any files in the directories are too big to be\nloaded into available memory. Without this limit, I ran into MemoryError exceptions on\nsome machines with a prior version of this script that read both files all at once, like this:\n    bytes1 = open(path1, 'rb').read()\n    bytes2 = open(path2, 'rb').read()\n    if bytes1 == bytes2: ...\nThis code was simpler, but is less practical for very large files that can\u2019t fit into your\navailable memory space (consider CD and DVD image files, for example). In the new\nversion\u2019s loop, the file reads return what is left when there is less than 1 MB present or\nremaining and return empty strings at end-of-file. Files match if all blocks read are the\nsame, and they reach end-of-file at the same time.\nWe\u2019re also dealing in binary files and byte strings again to suppress Unicode decoding\nand end-line translations for file content, because trees may contain arbitrary binary\nand text files. The usual note about changing this to pass byte strings to os.listdir on\nplatforms where filenames may generate Unicode decoding errors applies here as well\n(e.g. pass dir1.encode()). On some platforms, you may also want to detect and skip\ncertain kinds of special files in order to be fully general, but these were not in my trees,\nso they are not in my script.\nOne minor change for the fourth edition of this book: os.listdir results are now gath-\nered just once per subdirectory and passed along, to avoid extra calls in dirdiff\u2014not\na huge win, but every cycle counts on the pitifully underpowered netbook I used when\nwriting this edition.\nComparing Directory Trees | 313Running the Script\nSince we\u2019ve already studied the tree-walking tools this script employs, let\u2019s jump right\ninto a few example runs. When run on identical trees, status messages scroll during the\ntraversal, and a No diffs found. message appears at the end:\nC:\\...\\PP4E\\System\\Filetools> diffall.py C:\\temp\\PP3E\\Examples copytemp > diffs.txt\nC:\\...\\PP4E\\System\\Filetools> type diffs.txt | more\n--------------------\nComparing C:\\temp\\PP3E\\Examples to copytemp\nDirectory lists are identical\nComparing contents\nREADME-root.txt matches\n--------------------\nComparing C:\\temp\\PP3E\\Examples\\PP3E to copytemp\\PP3E\nDirectory lists are identical\nComparing contents\nechoEnvironment.pyw matches\nLaunchBrowser.pyw matches\nLauncher.py matches\nLauncher.pyc matches\n...over 2,000 more lines omitted...\n--------------------\nComparing C:\\temp\\PP3E\\Examples\\PP3E\\TempParts to copytemp\\PP3E\\TempParts\nDirectory lists are identical\nComparing contents\n109_0237.JPG matches\nlawnlake1-jan-03.jpg matches\npart-001.txt matches\npart-002.html matches\n========================================\nNo diffs found.\nI usually run this with the verbose flag passed in as True, and redirect output to a file\n(for big trees, it produces too much output to scroll through comfortably); use False\nto watch fewer status messages fly by. To show how differences are reported, we need\nto generate a few; for simplicity, I\u2019ll manually change a few files scattered about one of\nthe trees, but you could also run a global search-and-replace script like the one we\u2019ll\nwrite later in this chapter. While we\u2019re at it, let\u2019s remove a few common files so that\ndirectory uniqueness differences show up on the scope, too; the last two removal com-\nmands in the following will generate one difference in the same directory in different\ntrees:\nC:\\...\\PP4E\\System\\Filetools> notepad copytemp\\PP3E\\README-PP3E.txt\nC:\\...\\PP4E\\System\\Filetools> notepad copytemp\\PP3E\\System\\Filetools\\commands.py\nC:\\...\\PP4E\\System\\Filetools> notepad C:\\temp\\PP3E\\Examples\\PP3E\\__init__.py\nC:\\...\\PP4E\\System\\Filetools> del copytemp\\PP3E\\System\\Filetools\\cpall_visitor.py\nC:\\...\\PP4E\\System\\Filetools> del copytemp\\PP3E\\Launcher.py\nC:\\...\\PP4E\\System\\Filetools> del C:\\temp\\PP3E\\Examples\\PP3E\\PyGadgets.py\nNow, rerun the comparison walker to pick out differences and redirect its output report\nto a file for easy inspection. The following lists just the parts of the output report that\n314 | Chapter 6:\u2002Complete System Programsidentify differences. In typical use, I inspect the summary at the bottom of the report\nfirst, and then search for the strings \"DIFF\" and \"unique\" in the report\u2019s text if I need\nmore information about the differences summarized; this interface could be much more\nuser-friendly, of course, but it does the job for me:\nC:\\...\\PP4E\\System\\Filetools> diffall.py C:\\temp\\PP3E\\Examples copytemp > diff2.txt\nC:\\...\\PP4E\\System\\Filetools> notepad diff2.txt\n--------------------\nComparing C:\\temp\\PP3E\\Examples to copytemp\nDirectory lists are identical\nComparing contents\nREADME-root.txt matches\n--------------------\nComparing C:\\temp\\PP3E\\Examples\\PP3E to copytemp\\PP3E\nFiles unique to C:\\temp\\PP3E\\Examples\\PP3E\n... Launcher.py\nFiles unique to copytemp\\PP3E\n... PyGadgets.py\nComparing contents\nechoEnvironment.pyw matches\nLaunchBrowser.pyw matches\nLauncher.pyc matches\n...more omitted...\nPyGadgets_bar.pyw matches\nREADME-PP3E.txt DIFFERS\ntodos.py matches\ntounix.py matches\n__init__.py DIFFERS\n__init__.pyc matches\n--------------------\nComparing C:\\temp\\PP3E\\Examples\\PP3E\\System\\Filetools to copytemp\\PP3E\\System\\Fil...\nFiles unique to C:\\temp\\PP3E\\Examples\\PP3E\\System\\Filetools\n... cpall_visitor.py\nComparing contents\ncommands.py DIFFERS\ncpall.py matches\n...more omitted...\n--------------------\nComparing C:\\temp\\PP3E\\Examples\\PP3E\\TempParts to copytemp\\PP3E\\TempParts\nDirectory lists are identical\nComparing contents\n109_0237.JPG matches\nlawnlake1-jan-03.jpg matches\npart-001.txt matches\npart-002.html matches\n========================================\nDiffs found: 5\n- unique files at C:\\temp\\PP3E\\Examples\\PP3E - copytemp\\PP3E\n- files differ at C:\\temp\\PP3E\\Examples\\PP3E\\README-PP3E.txt \u2013\n         copytemp\\PP3E\\README-PP3E.txt\n- files differ at C:\\temp\\PP3E\\Examples\\PP3E\\__init__.py \u2013\n         copytemp\\PP3E\\__init__.py\n- unique files at C:\\temp\\PP3E\\Examples\\PP3E\\System\\Filetools \u2013\n         copytemp\\PP3E\\System\\Filetools\nComparing Directory Trees | 315- files differ at C:\\temp\\PP3E\\Examples\\PP3E\\System\\Filetools\\commands.py \u2013\n         copytemp\\PP3E\\System\\Filetools\\commands.py\nI added line breaks and tabs in a few of these output lines to make them fit on this page,\nbut the report is simple to understand. In a tree with 1,430 files and 185 directories,\nwe found five differences\u2014the three files we changed by edits, and the two directories\nwe threw out of sync with the three removal commands.\nVerifying Backups\nSo how does this script placate CD backup paranoia? To double-check my CD writer\u2019s\nwork, I run a command such as the following. I can also use a command like this to\nfind out what has been changed since the last backup. Again, since the CD is \u201cG:\u201d on\nmy machine when plugged in, I provide a path rooted there; use a root such as /dev/\ncdrom or /mnt/cdrom on Linux:\nC:\\...\\PP4E\\System\\Filetools> python diffall.py Examples g:\\PP3E\\Examples > diff0226\nC:\\...\\PP4E\\System\\Filetools> more diff0226\n...output omitted...\nThe CD spins, the script compares, and a summary of differences appears at the end\nof the report. For an example of a full difference report, see the file diff*.txt files in the\nbook\u2019s examples distribution package. And to be really sure, I run the following global\ncomparison command to verify the entire book development tree backed up to a mem-\nory stick (which works just like a CD in terms of the filesystem):\nC:\\...\\PP4E\\System\\Filetools> diffall.py F:\\writing-backups\\feb-26-10\\dev\n                                 C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev > diff3.txt\nC:\\...\\PP4E\\System\\Filetools> more diff3.txt\n--------------------\nComparing F:\\writing-backups\\feb-26-10\\dev to C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\nDirectory lists are identical\nComparing contents\nch00.doc DIFFERS\nch01.doc matches\nch02.doc DIFFERS\nch03.doc matches\nch04.doc DIFFERS\nch05.doc matches\nch06.doc DIFFERS\n...more output omitted...\n--------------------\nComparing F:\\writing-backups\\feb-26-10\\dev\\Examples\\PP4E\\System\\Filetools to C:\\\u2026\nFiles unique to C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\System\\Filetools\n... copytemp\n... cpall.py\n... diff2.txt\n... diff3.txt\n... diffall.py\n... diffs.txt\n... dirdiff.py\n... dirdiff.pyc\n316 | Chapter 6:\u2002Complete System ProgramsComparing contents\nbigext-tree.py matches\nbigpy-dir.py matches\n...more output omitted...\n========================================\nDiffs found: 7\n- files differ at F:\\writing-backups\\feb-26-10\\dev\\ch00.doc \u2013\n         C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\ch00.doc\n- files differ at F:\\writing-backups\\feb-26-10\\dev\\ch02.doc \u2013\n         C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\ch02.doc\n- files differ at F:\\writing-backups\\feb-26-10\\dev\\ch04.doc \u2013\n         C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\ch04.doc\n- files differ at F:\\writing-backups\\feb-26-10\\dev\\ch06.doc \u2013\n         C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\ch06.doc\n- files differ at F:\\writing-backups\\feb-26-10\\dev\\TOC.txt \u2013\n         C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\TOC.txt\n- unique files at F:\\writing-backups\\feb-26-10\\dev\\Examples\\PP4E\\System\\Filetools \u2013\n         C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\System\\Filetools\n- files differ at F:\\writing-backups\\feb-26-10\\dev\\Examples\\PP4E\\Tools\\visitor.py \u2013\n         C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\Tools\\visitor.py\nThis particular run indicates that I\u2019ve added a few examples and changed some chapter\nfiles since the last backup; if run immediately after a backup, nothing should show up\non diffall radar except for any files that cannot be copied in general. This global\ncomparison can take a few minutes. It performs byte-for-byte comparisons of all chap-\nter files and screenshots, the examples tree, and more, but it\u2019s an accurate and complete\nverification. Given that this book development tree contained many files, a more man-\nual verification procedure without Python\u2019s help would be utterly impossible.\nAfter writing this script, I also started using it to verify full automated backups of my\nlaptops onto an external hard-drive device. To do so, I run the cpall copy script we\nwrote earlier in the preceding section of this chapter, and then the comparison script\ndeveloped here to check results and get a list of files that didn\u2019t copy correctly. The last\ntime I did this, this procedure copied and compared 225,000 files and 15,000 directories\nin 20 GB of space\u2014not the sort of task that lends itself to manual labor!\nHere are the magic incantations on my Windows laptop. f:\\ is a partition on my ex-\nternal hard drive, and you shouldn\u2019t be surprised if each of these commands runs for\nhalf an hour or more on currently common hardware. A drag-and-drop copy takes at\nleast as long (assuming it works at all!):\nC:\\...\\System\\Filetools> cpall.py c:\\ f:\\   > f:\\copy-log.txt\nC:\\...\\System\\Filetools> diffall.py f:\\ c:\\ > f:\\diff-log.txt\nReporting Differences and Other Ideas\nFinally, it\u2019s worth noting that this script still only detects differences in the tree but does\nnot give any further details about individual file differences. In fact, it simply loads and\ncompares the binary contents of corresponding files with string comparisons. It\u2019s a\nsimple yes/no result.\nComparing Directory Trees | 317If and when I need more details about how two reported files actually differ, I either\nedit the files or run the file-comparison command on the host platform (e.g., fc on\nWindows/DOS, diff or cmp on Unix and Linux). That\u2019s not a portable solution for this\nlast step; but for my purposes, just finding the differences in a 1,400-file tree was much\nmore critical than reporting which lines differ in files flagged in the report.\nOf course, since we can always run shell commands in Python, this last step could be\nautomated by spawning a diff or fc command with os.popen as differences are en-\ncountered (or after the traversal, by scanning the report summary). The output of these\nsystem calls could be displayed verbatim, or parsed for relevant parts.\nWe also might try to do a bit better here by opening true text files in text mode to ignore\nline-terminator differences caused by transferring across platforms, but it\u2019s not clear\nthat such differences should be ignored (what if the caller wants to know whether line-\nend markers have been changed?). For example, after downloading a website with an\nFTP script we\u2019ll meet in Chapter 13, the diffall script detected a discrepancy between\nthe local copy of a file and the one at the remote server. To probe further, I simply ran\nsome interactive Python code:\n>>> a = open('lp2e-updates.html', 'rb').read()\n>>> b = open(r'C:\\Mark\\WEBSITE\\public_html\\lp2e-updates.html', 'rb').read()\n>>> a == b\nFalse\nThis verifies that there really is a binary difference in the downloaded and local versions\nof the file; to see whether it\u2019s because a Unix or DOS line end snuck into the file, try\nagain in text mode so that line ends are all mapped to the standard \\n character:\n>>> a = open('lp2e-updates.html', 'r').read()\n>>> b = open(r'C:\\Mark\\WEBSITE\\public_html\\lp2e-updates.html', 'r').read()\n>>> a == b\nTrue\nSure enough; now, to find where the difference is, the following code checks character\nby character until the first mismatch is found (in binary mode, so we retain the\ndifference):\n>>> a = open('lp2e-updates.html', 'rb').read()\n>>> b = open(r'C:\\Mark\\WEBSITE\\public_html\\lp2e-updates.html', 'rb').read()\n>>> for (i, (ac, bc)) in enumerate(zip(a, b)):\n...     if ac != bc:\n...         print(i, repr(ac), repr(bc))\n...         break\n...\n37966 '\\r' '\\n'\nThis means that at byte offset 37,966, there is a \\r in the downloaded file, but a \\n in\nthe local copy. This line has a DOS line end in one and a Unix line end in the other. To\nsee more, print text around the mismatch:\n318 | Chapter 6:\u2002Complete System Programs>>> for (i, (ac, bc)) in enumerate(zip(a, b)):\n...     if ac != bc:\n...         print(i, repr(ac), repr(bc))\n...         print(repr(a[i-20:i+20]))\n...         print(repr(b[i-20:i+20]))\n...         break\n...\n37966 '\\r' '\\n'\n're>\\r\\ndef min(*args):\\r\\n    tmp = list(arg'\n're>\\r\\ndef min(*args):\\n    tmp = list(args'\nApparently, I wound up with a Unix line end at one point in the local copy and a DOS\nline end in the version I downloaded\u2014the combined effect of the text mode used by\nthe download script itself (which translated \\n to \\r\\n) and years of edits on both Linux\nand Windows PDAs and laptops (I probably coded this change on Linux and copied\nit to my local Windows copy in binary mode). Code such as this could be integrated\ninto the diffall script to make it more intelligent about text files and difference\nreporting.\nBecause Python excels at processing files and strings, it\u2019s even possible to go one step\nfurther and code a Python equivalent of the fc and diff commands. In fact, much of\nthe work has already been done; the standard library module difflib could make this\ntask simple. See the Python library manual for details and usage examples.\nWe could also be smarter by avoiding the load and compare steps for files that differ\nin size, and we might use a smaller block size to reduce the script\u2019s memory require-\nments. For most trees, such optimizations are unnecessary; reading multimegabyte files\ninto strings is very fast in Python, and garbage collection reclaims the space as you go.\nSince such extensions are beyond both this script\u2019s scope and this chapter\u2019s size limits,\nthough, they will have to await the attention of a curious reader (this book doesn\u2019t have\nformal exercises, but that almost sounds like one, doesn\u2019t it?). For now, let\u2019s move on\nto explore ways to code one more common directory task: search.\nSearching Directory Trees\nEngineers love to change things. As I was writing this book, I found it almost irresisti-\nble to move and rename directories, variables, and shared modules in the book exam-\nples tree whenever I thought I\u2019d stumbled onto a more coherent structure. That was\nfine early on, but as the tree became more intertwined, this became a maintenance\nnightmare. Things such as program directory paths and module names were hardcoded\nall over the place\u2014in package import statements, program startup calls, text notes,\nconfiguration files, and more.\nOne way to repair these references, of course, is to edit every file in the directory by\nhand, searching each for information that has changed. That\u2019s so tedious as to be utterly\nimpossible in this book\u2019s examples tree, though; the examples of the prior edition con-\ntained 186 directories and 1,429 files! Clearly, I needed a way to automate updates after\nSearching Directory Trees | 319changes. There are a variety of solutions to such goals\u2014from shell commands, to find\noperations, to custom tree walkers, to general-purpose frameworks. In this and the next\nsection, we\u2019ll explore each option in turn, just as I did while refining solutions to this\nreal-world dilemma.\nGreps and Globs and Finds\nIf you work on Unix-like systems, you probably already know that there is a standard\nway to search files for strings on such platforms\u2014the command-line program grep and\nits relatives list all lines in one or more files containing a string or string pattern.\u2016 Given\nthat shells expand (i.e., \u201cglob\u201d) filename patterns automatically, a command such as\nthe following will search a single directory\u2019s Python files for a string named on the\ncommand line (this uses the grep command installed with the Cygwin Unix-like system\nfor Windows that I described in the prior chapter):\nC:\\...\\PP4E\\System\\Filetools> c:\\cygwin\\bin\\grep.exe walk *.py\nbigext-tree.py:for (thisDir, subsHere, filesHere) in os.walk(dirname):\nbigpy-path.py:    for (thisDir, subsHere, filesHere) in os.walk(srcdir):\nbigpy-tree.py:for (thisDir, subsHere, filesHere) in os.walk(dirname):\nAs we\u2019ve seen, we can often accomplish the same within a Python script by running\nsuch a shell command with os.system or os.popen. And if we search its results manually,\nwe can also achieve similar results with the Python glob module we met in Chapter 4;\nit expands a filename pattern into a list of matching filename strings much like a shell:\nC:\\...\\PP4E\\System\\Filetools> python\n>>> import os\n>>> for line in os.popen(r'c:\\cygwin\\bin\\grep.exe walk *.py'):\n...     print(line, end='')\n...\nbigext-tree.py:for (thisDir, subsHere, filesHere) in os.walk(dirname):\nbigpy-path.py:    for (thisDir, subsHere, filesHere) in os.walk(srcdir):\nbigpy-tree.py:for (thisDir, subsHere, filesHere) in os.walk(dirname):\n>>> from glob import glob\n>>> for filename in glob('*.py'):\n...     if 'walk' in open(filename).read():\n...         print(filename)\n...\nbigext-tree.py\nbigpy-path.py\nbigpy-tree.py\nUnfortunately, these tools are generally limited to a single directory. glob can visit\nmultiple directories given the right sort of pattern string, but it\u2019s not a general directory\nwalker of the sort I need to maintain a large examples tree. On Unix-like systems, a\nfind shell command can go the extra mile to traverse an entire directory tree. For\n\u2016 In fact, the act of searching files often goes by the colloquial name \u201cgrepping\u201d among developers who have\nspent any substantial time in the Unix ghetto.\n320 | Chapter 6:\u2002Complete System Programsinstance, the following Unix command line would pinpoint lines and files at and below\nthe current directory that mention the string popen:\nfind . -name \"*.py\" -print -exec fgrep popen {} \\;\nIf you happen to have a Unix-like find command on every machine you will ever use,\nthis is one way to process directories.\nRolling Your Own find Module\nBut if you don\u2019t happen to have a Unix find on all your computers, not to worry\u2014it\u2019s\neasy to code a portable one in Python. Python itself used to have a find module in its\nstandard library, which I used frequently in the past. Although that module was re-\nmoved between the second and third editions of this book, the newer os.walk makes\nwriting your own simple. Rather than lamenting the demise of a module, I decided to\nspend 10 minutes coding a custom equivalent.\nExample 6-13 implements a find utility in Python, which collects all matching filenames\nin a directory tree. Unlike glob.glob, its find.find automatically matches through an\nentire tree. And unlike the tree walk structure of os.walk, we can treat find.find results\nas a simple linear group.\nExample 6-13. PP4E\\Tools\\find.py\n#!/usr/bin/python\n\"\"\"\n################################################################################\nReturn all files matching a filename pattern at and below a root directory;\ncustom version of the now deprecated find module in the standard library:\nimport as \"PP4E.Tools.find\"; like original, but uses os.walk loop, has no\nsupport for pruning subdirs, and is runnable as a top-level script;\nfind() is a generator that uses the os.walk() generator to yield just\nmatching filenames: use findlist() to force results list generation;\n################################################################################\n\"\"\"\nimport fnmatch, os\ndef find(pattern, startdir=os.curdir):\n    for (thisDir, subsHere, filesHere) in os.walk(startdir):\n        for name in subsHere + filesHere:\n            if fnmatch.fnmatch(name, pattern):\n                fullpath = os.path.join(thisDir, name)\n                yield fullpath\ndef findlist(pattern, startdir=os.curdir, dosort=False):\n    matches = list(find(pattern, startdir))\n    if dosort: matches.sort()\n    return matches\nSearching Directory Trees | 321if __name__ == '__main__':\n    import sys\n    namepattern, startdir = sys.argv[1], sys.argv[2]\n    for name in find(namepattern, startdir): print(name)\nThere\u2019s not much to this file\u2014it\u2019s largely just a minor extension to os.walk\u2014but calling\nits find function provides the same utility as both the deprecated find standard library\nmodule and the Unix utility of the same name. It\u2019s also much more portable, and no-\nticeably easier than repeating all of this file\u2019s code every time you need to perform a\nfind-type search. Because this file is instrumented to be both a script and a library, it\ncan also be both run as a command-line tool or called from other programs.\nFor instance, to process every Python file in the directory tree rooted one level up from\nthe current working directory, I simply run the following command line from a system\nconsole window. Run this yourself to watch its progress; the script\u2019s standard output\nis piped into the more command to page it here, but it can be piped into any processing\nprogram that reads its input from the standard input stream:\nC:\\...\\PP4E\\Tools> python find.py *.py .. | more\n..\\LaunchBrowser.py\n..\\Launcher.py\n..\\__init__.py\n..\\Preview\\attachgui.py\n..\\Preview\\customizegui.py\n...more lines omitted...\nFor more control, run the following sort of Python code from a script or interactive\nprompt. In this mode, you can apply any operation to the found files that the Python\nlanguage provides:\nC:\\...\\PP4E\\System\\Filetools> python\n>>> from PP4E.Tools import find                  # or just import find if in cwd\n>>> for filename in find.find('*.py', '..'):\n...     if 'walk' in open(filename).read():\n...         print(filename)\n...\n..\\Launcher.py\n..\\System\\Filetools\\bigext-tree.py\n..\\System\\Filetools\\bigpy-path.py\n..\\System\\Filetools\\bigpy-tree.py\n..\\Tools\\cleanpyc.py\n..\\Tools\\find.py\n..\\Tools\\visitor.py\nNotice how this avoids having to recode the nested loop structure required for\nos.walk every time you want a list of matching file names; for many use cases, this seems\nconceptually simpler. Also note that because this finder is a generator function, your\nscript doesn\u2019t have to wait until all matching files have been found and collected;\nos.walk yields results as it goes, and find.find yields matching files among that set.\nHere\u2019s a more complex example of our find module at work: the following system\ncommand line lists all Python files in directory C:\\temp\\PP3E whose names begin with\n322 | Chapter 6:\u2002Complete System Programsthe letter q or t. Note how find returns full directory paths that begin with the start\ndirectory specification:\nC:\\...\\PP4E\\Tools> find.py [qx]*.py C:\\temp\\PP3E\nC:\\temp\\PP3E\\Examples\\PP3E\\Database\\SQLscripts\\querydb.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Gui\\Tools\\queuetest-gui-class.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Gui\\Tools\\queuetest-gui.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Gui\\Tour\\quitter.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Other\\Grail\\Question.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Other\\XML\\xmlrpc.py\nC:\\temp\\PP3E\\Examples\\PP3E\\System\\Threads\\queuetest.py\nAnd here\u2019s some Python code that does the same find but also extracts base names and\nfile sizes for each file found:\nC:\\...\\PP4E\\Tools> python\n>>> import os\n>>> from find import find\n>>> for name in find('[qx]*.py', r'C:\\temp\\PP3E'):\n...     print(os.path.basename(name), os.path.getsize(name))\n...\nquerydb.py 635\nqueuetest-gui-class.py 1152\nqueuetest-gui.py 963\nquitter.py 801\nQuestion.py 817\nxmlrpc.py 705\nqueuetest.py 1273\nThe fnmatch module\nTo achieve such code economy, the find module calls os.walk to walk the tree and\nsimply yields matching filenames along the way. New here, though, is the fnmatch\nmodule\u2014yet another Python standard library module that performs Unix-like pattern\nmatching against filenames. This module supports common operators in name pattern\nstrings: * to match any number of characters, ? to match any single character, and\n[...] and [!...] to match any character inside the bracket pairs or not; other characters\nmatch themselves. Unlike the re module, fnmatch supports only common Unix shell\nmatching operators, not full-blown regular expression patterns; we\u2019ll see why this dis-\ntinction matters in Chapter 19.\nInterestingly, Python\u2019s glob.glob function also uses the fnmatch module to match\nnames: it combines os.listdir and fnmatch to match in directories in much the same\nway our find.find combines os.walk and fnmatch to match in trees (though os.walk\nultimately uses os.listdir as well). One ramification of all this is that you can pass\nbyte strings for both pattern and start-directory to find.find if you need to suppress\nUnicode filename decoding, just as you can for os.walk and glob.glob; you\u2019ll receive\nbyte strings for filenames in the result. See Chapter 4 for more details on Unicode\nfilenames.\nSearching Directory Trees | 323By comparison, find.find with just \u201c*\u201d for its name pattern is also roughly equivalent\nto platform-specific directory tree listing shell commands such as dir /B /S on DOS\nand Windows. Since all files match \u201c*\u201d, this just exhaustively generates all the file names\nin a tree with a single traversal. Because we can usually run such shell commands in a\nPython script with os.popen, the following do the same work, but the first is inherently\nnonportable and must start up a separate program along the way:\n>>> import os\n>>> for line in os.popen('dir /B /S'): print(line, end='')\n>>> from PP4E.Tools.find import find\n>>> for name in find(pattern='*', startdir='.'): print(name)\nWatch for this utility to show up in action later in this chapter and book, including an\narguably strong showing in the next section and a cameo appearance in the Grep dialog\nof Chapter 11\u2019s PyEdit text editor GUI, where it will serve a central role in a threaded\nexternal files search tool. The standard library\u2019s find module may be gone, but it need\nnot be forgotten.\nIn fact, you must pass a bytes pattern string for a bytes filename to\nfnnmatch (or pass both as str), because the re pattern matching module\nit uses does not allow the string types of subject and pattern to be mixed.\nThis rule is inherited by our find.find for directory and pattern. See\nChapter 19 for more on re.\nCuriously, the fnmatch module in Python 3.1 also converts a bytes pat-\ntern string to and from Unicode str in order to perform internal text\nprocessing, using the Latin-1 encoding. This suffices for many contexts,\nbut may not be entirely sound for some encodings which do not map to\nLatin-1 cleanly. sys.getfilesystemencoding might be a better encoding\nchoice in such contexts, as this reflects the underlying file system\u2019s con-\nstraints (as we learned in Chapter 4, sys.getdefaultencoding reflects file\ncontent, not names).\nIn the absence of bytes, os.walk assumes filenames follow the platform\u2019s\nconvention and does not ignore decoding errors triggered by os.list\ndir. In the \u201cgrep\u201d utility of Chapter 11\u2019s PyEdit, this picture is further\nclouded by the fact that a str pattern string from a GUI would have to\nbe encoded to bytes using a potentially inappropriate encoding for some\nfiles present. See fnmatch.py and os.py in Python\u2019s library and the Py-\nthon library manual for more details. Unicode can be a very subtle affair.\nCleaning Up Bytecode Files\nThe find module of the prior section isn\u2019t quite the general string searcher we\u2019re after,\nbut it\u2019s an important first step\u2014it collects files that we can then search in an automated\nscript. In fact, the act of collecting matching files in a tree is enough by itself to support\na wide variety of day-to-day system tasks.\n324 | Chapter 6:\u2002Complete System ProgramsFor example, one of the other common tasks I perform on a regular basis is removing\nall the bytecode files in a tree. Because these are not always portable across major Python\nreleases, it\u2019s usually a good idea to ship programs without them and let Python create\nnew ones on first imports. Now that we\u2019re expert os.walk users, we could cut out the\nmiddleman and use it directly. Example 6-14 codes a portable and general command-\nline tool, with support for arguments, exception processing, tracing, and list-only\nmode.\nExample 6-14. PP4E\\Tools\\cleanpyc.py\n\"\"\"\ndelete all .pyc bytecode files in a directory tree: use the\ncommand line arg as root if given, else current working dir\n\"\"\"\nimport os, sys\nfindonly = False\nrootdir = os.getcwd() if len(sys.argv) == 1 else sys.argv[1]\nfound = removed = 0\nfor (thisDirLevel, subsHere, filesHere) in os.walk(rootdir):\n    for filename in filesHere:\n        if filename.endswith('.pyc'):\n            fullname = os.path.join(thisDirLevel, filename)\n            print('=>', fullname)\n            if not findonly:\n                try:\n                    os.remove(fullname)\n                    removed += 1\n                except:\n                    type, inst = sys.exc_info()[:2]\n                    print('*'*4, 'Failed:', filename, type, inst)\n            found += 1\nprint('Found', found, 'files, removed', removed)\nWhen run, this script walks a directory tree (the CWD by default, or else one passed\nin on the command line), deleting any and all bytecode files along the way:\nC:\\...\\Examples\\PP4E> Tools\\cleanpyc.py\n=> C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\__init__.pyc\n=> C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\Preview\\initdata.pyc\n=> C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\Preview\\make_db_file.pyc\n=> C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\Preview\\manager.pyc\n=> C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\Preview\\person.pyc\n...more lines here...\nFound 24 files, removed 24\nC:\\...\\PP4E\\Tools> cleanpyc.py .\n=> .\\find.pyc\n=> .\\visitor.pyc\n=> .\\__init__.pyc\nFound 3 files, removed 3\nSearching Directory Trees | 325This script works, but it\u2019s a bit more manual and code-y than it needs to be. In fact,\nnow that we also know about find operations, writing scripts based upon them is almost\ntrivial when we just need to match filenames. Example 6-15, for instance, falls back on\nspawning shell find commands if you have them.\nExample 6-15. PP4E\\Tools\\cleanpyc-find-shell.py\n\"\"\"\nfind and delete all \"*.pyc\" bytecode files at and below the directory\nnamed on the command-line; assumes a nonportable Unix-like find command\n\"\"\"\nimport os, sys\nrundir = sys.argv[1]\nif sys.platform[:3] == 'win':\n    findcmd = r'c:\\cygwin\\bin\\find %s -name \"*.pyc\" -print' % rundir\nelse:\n    findcmd = 'find %s -name \"*.pyc\" -print' % rundir\nprint(findcmd)\ncount = 0\nfor fileline in os.popen(findcmd):                  # for all result lines\n    count += 1                                      # have \\n at the end\n    print(fileline, end='')\n    os.remove(fileline.rstrip())\nprint('Removed %d .pyc files' % count)\nWhen run, files returned by the shell command are removed:\nC:\\...\\PP4E\\Tools> cleanpyc-find-shell.py .\nc:\\cygwin\\bin\\find . -name \"*.pyc\" -print\n./find.pyc\n./visitor.pyc\n./__init__.pyc\nRemoved 3 .pyc files\nThis script uses os.popen to collect the output of a Cygwin find program installed on\none of my Windows computers, or else the standard find tool on the Linux side. It\u2019s\nalso completely nonportable to Windows machines that don\u2019t have the Unix-like find\nprogram installed, and that includes other computers of my own (not to mention those\nthroughout most of the world at large). As we\u2019ve seen, spawning shell commands also\nincurs performance penalties for starting a new program.\nWe can do much better on the portability and performance fronts and still retain code\nsimplicity, by applying the find tool we wrote in Python in the prior section. The new\nscript is shown in Example 6-16.\nExample 6-16. PP4E\\Tools\\cleanpyc-find-py.py\n\"\"\"\nfind and delete all \"*.pyc\" bytecode files at and below the directory\nnamed on the command-line; this uses a Python-coded find utility, and\n326 | Chapter 6:\u2002Complete System Programsso is portable; run this to delete .pyc's from an old Python release;\n\"\"\"\nimport os, sys, find   # here, gets Tools.find\ncount = 0\nfor filename in find.find('*.pyc', sys.argv[1]):\n    count += 1\n    print(filename)\n    os.remove(filename)\nprint('Removed %d .pyc files' % count)\nWhen run, all bytecode files in the tree rooted at the passed-in directory name are\nremoved as before; this time, though, our script works just about everywhere Python\ndoes:\nC:\\...\\PP4E\\Tools> cleanpyc-find-py.py .\n.\\find.pyc\n.\\visitor.pyc\n.\\__init__.pyc\nRemoved 3 .pyc files\nThis works portably, and it avoids external program startup costs. But find is really\njust half the story\u2014it collects files matching a name pattern but doesn\u2019t search their\ncontent. Although extra code can add such searching to a find\u2019s result, a more manual\napproach can allow us to tap into the search process more directly. The next section\nshows how.\nA Python Tree Searcher\nAfter experimenting with greps and globs and finds, in the end, to help ease the task\nof performing global searches on all platforms I might ever use, I wound up coding a\ntask-specific Python script to do most of the work for me. Example 6-17 employs the\nfollowing standard Python tools that we met in the preceding chapters: os.walk to visit\nfiles in a directory, os.path.splitext to skip over files with binary-type extensions, and\nos.path.join to portably combine a directory path and filename.\nBecause it\u2019s pure Python code, it can be run the same way on both Linux and Windows.\nIn fact, it should work on any computer where Python has been installed. Moreover,\nbecause it uses direct system calls, it will likely be faster than approaches that rely on\nunderlying shell commands.\nExample 6-17. PP4E\\Tools\\search_all.py\n\"\"\"\n################################################################################\nUse: \"python ...\\Tools\\search_all.py dir string\".\nSearch all files at and below a named directory for a string; uses the\nos.walk interface, rather than doing a find.find to collect names first;\nsimilar to calling visitfile for each find.find result for \"*\" pattern;\nSearching Directory Trees | 327################################################################################\n\"\"\"\nimport os, sys\nlistonly = False\ntextexts = ['.py', '.pyw', '.txt', '.c', '.h']             # ignore binary files\ndef searcher(startdir, searchkey):\n    global fcount, vcount\n    fcount = vcount = 0\n    for (thisDir, dirsHere, filesHere) in os.walk(startdir):\n        for fname in filesHere:                            # do non-dir files here\n            fpath = os.path.join(thisDir, fname)           # fnames have no dirpath\n            visitfile(fpath, searchkey)\ndef visitfile(fpath, searchkey):                           # for each non-dir file\n    global fcount, vcount                                  # search for string\n    print(vcount+1, '=>', fpath)                           # skip protected files\n    try:\n        if not listonly:\n            if os.path.splitext(fpath)[1] not in textexts:\n                print('Skipping', fpath)\n            elif searchkey in open(fpath).read():\n                input('%s has %s' % (fpath, searchkey))\n                fcount += 1\n    except:\n        print('Failed:', fpath, sys.exc_info()[0])\n    vcount += 1\nif __name__ == '__main__':\n    searcher(sys.argv[1], sys.argv[2])\n    print('Found in %d files, visited %d' % (fcount, vcount))\nOperationally, this script works roughly the same as calling its visitfile function for\nevery result generated by our find.find tool with a pattern of \u201c*\u201d; but because this\nversion is specific to searching content it can better tailored for its goal. Really, this\nequivalence holds only because a \u201c*\u201d pattern invokes an exhaustive traversal in\nfind.find, and that\u2019s all that this new script\u2019s searcher function does. The finder is\ngood at selecting specific file types, but this script benefits from a more custom single\ntraversal.\nWhen run standalone, the search key is passed on the command line; when imported,\nclients call this module\u2019s searcher function directly. For example, to search (that is,\ngrep) for all appearances of a string in the book examples tree, I run a command line\nlike this in a DOS or Unix shell:\nC:\\\\PP4E> Tools\\search_all.py . mimetypes\n1 => .\\LaunchBrowser.py\n2 => .\\Launcher.py\n3 => .\\Launch_PyDemos.pyw\n4 => .\\Launch_PyGadgets_bar.pyw\n5 => .\\__init__.py\n6 => .\\__init__.pyc\n328 | Chapter 6:\u2002Complete System ProgramsSkipping .\\__init__.pyc\n7 => .\\Preview\\attachgui.py\n8 => .\\Preview\\bob.pkl\nSkipping .\\Preview\\bob.pkl\n...more lines omitted: pauses for Enter key press at matches...\nFound in 2 files, visited 184\nThe script lists each file it checks as it goes, tells you which files it is skipping (names\nthat end in extensions not listed in the variable textexts that imply binary data), and\npauses for an Enter key press each time it announces a file containing the search string.\nThe search_all script works the same way when it is imported rather than run, but\nthere is no final statistics output line (fcount and vcount live in the module and so would\nhave to be imported to be inspected here):\nC:\\...\\PP4E\\dev\\Examples\\PP4E> python\n>>> import Tools.search_all\n>>> search_all.searcher(r'C:\\temp\\PP3E\\Examples', 'mimetypes')\n...more lines omitted: 8 pauses for Enter key press along the way...\n>>> search_all.fcount, search_all.vcount     # matches, files\n(8, 1429)\nHowever launched, this script tracks down all references to a string in an entire directory\ntree: a name of a changed book examples file, object, or directory, for instance. It\u2019s\nexactly what I was looking for\u2014or at least I thought so, until further deliberation drove\nme to seek more complete and better structured solutions, the topic of the next section.\nBe sure to also see the coverage of regular expressions in Chapter 19.\nThe search_all script here searches for a simple string in each file with\nthe in string membership expression, but it would be trivial to extend\nit to search for a regular expression pattern match instead (roughly, just\nreplace in with a call to a regular expression object\u2019s search method).\nOf course, such a mutation will be much more trivial after we\u2019ve learned\nhow.\nAlso notice the textexts list in Example 6-17, which attempts to list all\npossible binary file types: it would be more general and robust to use\nthe mimetypes logic we will meet near the end of this chapter in order to\nguess file content type from its name, but the skips list provides more\ncontrol and sufficed for the trees I used this script against.\nFinally note that for simplicity many of the directory searches in this\nchapter assume that text is encoded per the underlying platform\u2019s Uni-\ncode default. They could open text in binary mode to avoid decoding\nerrors, but searches might then be inaccurate because of encoding\nscheme differences in the raw encoded bytes. To see how to do better,\nwatch for the \u201cgrep\u201d utility in Chapter 11\u2019s PyEdit GUI, which will apply\nan encoding name to all the files in a searched tree and ignore those text\nor binary files that fail to decode.\nSearching Directory Trees | 329Visitor: Walking Directories \u201c++\u201d\nLaziness is the mother of many a framework. Armed with the portable search_all script\nfrom Example 6-17, I was able to better pinpoint files to be edited every time I changed\nthe book examples tree content or structure. At least initially, in one window I ran\nsearch_all to pick out suspicious files and edited each along the way by hand in another\nwindow.\nPretty soon, though, this became tedious, too. Manually typing filenames into editor\ncommands is no fun, especially when the number of files to edit is large. Since I occa-\nsionally have better things to do than manually start dozens of text editor sessions, I\nstarted looking for a way to automatically run an editor on each suspicious file.\nUnfortunately, search_all simply prints results to the screen. Although that text could\nbe intercepted with os.popen and parsed by another program, a more direct approach\nthat spawns edit sessions during the search may be simpler. That would require major\nchanges to the tree search script as currently coded, though, and make it useful for just\none specific purpose. At this point, three thoughts came to mind:\nRedundancy\nAfter writing a few directory walking utilities, it became clear that I was rewriting\nthe same sort of code over and over again. Traversals could be even further sim-\nplified by wrapping common details for reuse. Although the os.walk tool avoids\nhaving to write recursive functions, its model tends to foster redundant operations\nand code (e.g., directory name joins, tracing prints).\nExtensibility\nPast experience informed me that it would be better in the long run to add features\nto a general directory searcher as external components, rather than changing the\noriginal script itself. Because editing files was just one possible extension (what\nabout automating text replacements, too?), a more general, customizable, and re-\nusable approach seemed the way to go. Although os.walk is straightforward to use,\nits nested loop-based structure doesn\u2019t quite lend itself to customization the way\na class can.\nEncapsulation\nBased on past experience, I also knew that it\u2019s a generally good idea to insulate\nprograms from implementation details as much as possible. While os.walk hides\nthe details of recursive traversal, it still imposes a very specific interface on its cli-\nents, which is prone to change over time. Indeed it has\u2014as I\u2019ll explain further at\nthe end of this section, one of Python\u2019s tree walkers was removed altogether in 3.X,\ninstantly breaking code that relied upon it. It would be better to hide such de-\npendencies behind a more neutral interface, so that clients won\u2019t break as our needs\nchange.\nOf course, if you\u2019ve studied Python in any depth, you know that all these goals point\nto using an object-oriented framework for traversals and searching. Example 6-18 is a\n330 | Chapter 6:\u2002Complete System Programsconcrete realization of these goals. It exports a general FileVisitor class that mostly\njust wraps os.walk for easier use and extension, as well as a generic SearchVisitor class\nthat generalizes the notion of directory searches.\nBy itself, SearchVisitor simply does what search_all did, but it also opens up the search\nprocess to customization\u2014bits of its behavior can be modified by overloading its\nmethods in subclasses. Moreover, its core search logic can be reused everywhere we\nneed to search. Simply define a subclass that adds extensions for a specific task. The\nsame goes for FileVisitor\u2014by redefining its methods and using its attributes, we can\ntap into tree search using OOP coding techniques. As is usual in programming, once\nyou repeat tactical tasks often enough, they tend to inspire this kind of strategic\nthinking.\nExample 6-18. PP4E\\Tools\\visitor.py\n\"\"\"\n####################################################################################\nTest: \"python ...\\Tools\\visitor.py dir testmask [string]\".  Uses classes and\nsubclasses to wrap some of the details of os.walk call usage to walk and search;\ntestmask is an integer bitmask with 1 bit per available self-test; see also:\nvisitor_*/.py subclasses use cases; frameworks should generally use__X pseudo\nprivate names, but all names here are exported for use in subclasses and clients;\nredefine reset to support multiple independent walks that require subclass updates;\n####################################################################################\n\"\"\"\nimport os, sys\nclass FileVisitor:\n    \"\"\"\n    Visits all nondirectory files below startDir (default '.');\n    override visit* methods to provide custom file/dir handlers;\n    context arg/attribute is optional subclass-specific state;\n    trace switch: 0 is silent, 1 is directories, 2 adds files\n    \"\"\"\n    def __init__(self, context=None, trace=2):\n        self.fcount   = 0\n        self.dcount   = 0\n        self.context  = context\n        self.trace    = trace\n    def run(self, startDir=os.curdir, reset=True):\n        if reset: self.reset()\n        for (thisDir, dirsHere, filesHere) in os.walk(startDir):\n            self.visitdir(thisDir)\n            for fname in filesHere:                          # for non-dir files\n                fpath = os.path.join(thisDir, fname)         # fnames have no path\n                self.visitfile(fpath)\n    def reset(self):                                         # to reuse walker\n        self.fcount = self.dcount = 0                        # for independent walks\n    def visitdir(self, dirpath):                             # called for each dir\nVisitor: Walking Directories \u201c++\u201d | 331self.dcount += 1                                     # override or extend me\n        if self.trace > 0: print(dirpath, '...')\n    def visitfile(self, filepath):                           # called for each file\n        self.fcount += 1                                     # override or extend me\n        if self.trace > 1: print(self.fcount, '=>', filepath)\nclass SearchVisitor(FileVisitor):\n    \"\"\"\n    Search files at and below startDir for a string;\n    subclass: redefine visitmatch, extension lists, candidate as needed;\n    subclasses can use testexts to specify file types to search (but can\n    also redefine candidate to use mimetypes for text content: see ahead)\n    \"\"\"\n    skipexts = []\n    testexts = ['.txt', '.py', '.pyw', '.html', '.c', '.h']  # search these exts\n   #skipexts = ['.gif', '.jpg', '.pyc', '.o', '.a', '.exe']  # or skip these exts\n    def __init__(self, searchkey, trace=2):\n        FileVisitor.__init__(self, searchkey, trace)\n        self.scount = 0\n    def reset(self):                                         # on independent walks\n        self.scount = 0\n    def candidate(self, fname):                              # redef for mimetypes\n        ext = os.path.splitext(fname)[1]\n        if self.testexts:\n            return ext in self.testexts                      # in test list\n        else:                                                # or not in skip list\n            return ext not in self.skipexts\n    def visitfile(self, fname):                              # test for a match\n        FileVisitor.visitfile(self, fname)\n        if not self.candidate(fname):\n            if self.trace > 0: print('Skipping', fname)\n        else:\n            text = open(fname).read()                        # 'rb' if undecodable\n            if self.context in text:                         # or text.find() != \u22121\n                self.visitmatch(fname, text)\n                self.scount += 1\n    def visitmatch(self, fname, text):                       # process a match\n        print('%s has %s' % (fname, self.context))           # override me lower\nif __name__ == '__main__':\n    # self-test logic\n    dolist   = 1\n    dosearch = 2    # 3=do list and search\n    donext   = 4    # when next test added\n    def selftest(testmask):\n332 | Chapter 6:\u2002Complete System Programsif testmask & dolist:\n           visitor = FileVisitor(trace=2)\n           visitor.run(sys.argv[2])\n           print('Visited %d files and %d dirs' % (visitor.fcount, visitor.dcount))\n        if testmask & dosearch:\n           visitor = SearchVisitor(sys.argv[3], trace=0)\n           visitor.run(sys.argv[2])\n           print('Found in %d files, visited %d' % (visitor.scount, visitor.fcount))\n    selftest(int(sys.argv[1]))    # e.g., 3 = dolist | dosearch\nThis module primarily serves to export classes for external use, but it does something\nuseful when run standalone, too. If you invoke it as a script with a test mask of 1 and\na root directory name, it makes and runs a FileVisitor object and prints an exhaustive\nlisting of every file and directory at and below the root:\nC:\\...\\PP4E\\Tools> visitor.py 1 C:\\temp\\PP3E\\Examples\nC:\\temp\\PP3E\\Examples ...\n1 => C:\\temp\\PP3E\\Examples\\README-root.txt\nC:\\temp\\PP3E\\Examples\\PP3E ...\n2 => C:\\temp\\PP3E\\Examples\\PP3E\\echoEnvironment.pyw\n3 => C:\\temp\\PP3E\\Examples\\PP3E\\LaunchBrowser.pyw\n4 => C:\\temp\\PP3E\\Examples\\PP3E\\Launcher.py\n5 => C:\\temp\\PP3E\\Examples\\PP3E\\Launcher.pyc\n...more output omitted (pipe into more or a file)...\n1424 => C:\\temp\\PP3E\\Examples\\PP3E\\System\\Threads\\thread-count.py\n1425 => C:\\temp\\PP3E\\Examples\\PP3E\\System\\Threads\\thread1.py\nC:\\temp\\PP3E\\Examples\\PP3E\\TempParts ...\n1426 => C:\\temp\\PP3E\\Examples\\PP3E\\TempParts\\109_0237.JPG\n1427 => C:\\temp\\PP3E\\Examples\\PP3E\\TempParts\\lawnlake1-jan-03.jpg\n1428 => C:\\temp\\PP3E\\Examples\\PP3E\\TempParts\\part-001.txt\n1429 => C:\\temp\\PP3E\\Examples\\PP3E\\TempParts\\part-002.html\nVisited 1429 files and 186 dirs\nIf you instead invoke this script with a 2 as its first command-line argument, it makes\nand runs a SearchVisitor object using the third argument as the search key. This form\nis similar to running the search_all.py script we met earlier, but it simply reports each\nmatching file without pausing:\nC:\\...\\PP4E\\Tools> visitor.py 2 C:\\temp\\PP3E\\Examples mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\extras\\LosAlamosAdvancedClass\\day1-system\\data.txt ha\ns mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Email\\mailtools\\mailParser.py has mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Email\\mailtools\\mailSender.py has mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\downloadflat.py has mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\downloadflat_modular.py has mimet\nypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\ftptools.py has mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\uploadflat.py has mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\System\\Media\\playfile.py has mimetypes\nFound in 8 files, visited 1429\nVisitor: Walking Directories \u201c++\u201d | 333Technically, passing this script a first argument of 3 runs both a FileVisitor and a\nSearchVisitor (two separate traversals are performed). The first argument is really used\nas a bit mask to select one or more supported self-tests; if a test\u2019s bit is on in the binary\nvalue of the argument, the test will be run. Because 3 is 011 in binary, it selects both a\nsearch (010) and a listing (001). In a more user-friendly system, we might want to be\nmore symbolic about that (e.g., check for -search and -list arguments), but bit masks\nwork just as well for this script\u2019s scope.\nAs usual, this module can also be used interactively. The following is one way to de-\ntermine how many files and directories you have in specific directories; the last com-\nmand walks over your entire drive (after a generally noticeable delay!). See also the\n\u201cbiggest file\u201d example at the start of this chapter for issues such as potential repeat visits\nnot handled by this walker:\nC:\\...\\PP4E\\Tools> python\n>>> from visitor import FileVisitor\n>>> V = FileVisitor(trace=0)\n>>> V.run(r'C:\\temp\\PP3E\\Examples')\n>>> V.dcount, V.fcount\n(186, 1429)\n>>> V.run('..')                        # independent walk (reset counts)\n>>> V.dcount, V.fcount\n(19, 181)\n>>> V.run('..', reset=False)           # accumulative walk (keep counts)\n>>> V.dcount, V.fcount\n(38, 362)\n>>> V = FileVisitor(trace=0)           # new independent walker (own counts)\n>>> V.run(r'C:\\\\')                     # entire drive: try '/' on Unix-en\n>>> V.dcount, V.fcount\n(24992, 198585)\nAlthough the visitor module is useful by itself for listing and searching trees, it was\nreally designed to be extended. In the rest of this section, let\u2019s quickly step through a\nhandful of visitor clients which add more specific tree operations, using normal OO\ncustomization techniques.\nEditing Files in Directory Trees (Visitor)\nAfter genericizing tree traversals and searches, it\u2019s easy to add automatic file editing in\na brand-new, separate component. Example 6-19 defines a new EditVisitor class that\nsimply customizes the visitmatch method of the SearchVisitor class to open a text\neditor on the matched file. Yes, this is the complete program\u2014it needs to do something\nspecial only when visiting matched files, and so it needs to provide only that behavior.\nThe rest of the traversal and search logic is unchanged and inherited.\n334 | Chapter 6:\u2002Complete System ProgramsExample 6-19. PP4E\\Tools\\visitor_edit.py\n\"\"\"\nUse: \"python ...\\Tools\\visitor_edit.py string rootdir?\".\nAdd auto-editor startup to SearchVisitor in an external subclass component;\nAutomatically pops up an editor on each file containing string as it traverses;\ncan also use editor='edit' or 'notepad' on Windows; to use texteditor from\nlater in the book, try r'python Gui\\TextEditor\\textEditor.py'; could also\nsend a search command to go to the first match on start in some editors;\n\"\"\"\nimport os, sys\nfrom visitor import SearchVisitor\nclass EditVisitor(SearchVisitor):\n    \"\"\"\n    edit files at and below startDir having string\n    \"\"\"\n    editor = r'C:\\cygwin\\bin\\vim-nox.exe'  # ymmv!\n    def visitmatch(self, fpathname, text):\n        os.system('%s %s' % (self.editor, fpathname))\nif __name__  == '__main__':\n    visitor = EditVisitor(sys.argv[1])\n    visitor.run('.' if len(sys.argv) < 3 else sys.argv[2])\n    print('Edited %d files, visited %d' % (visitor.scount, visitor.fcount))\nWhen we make and run an EditVisitor, a text editor is started with the os.system\ncommand-line spawn call, which usually blocks its caller until the spawned program\nfinishes. As coded, when run on my machines, each time this script finds a matched\nfile during the traversal, it starts up the vi text editor within the console window where\nthe script was started; exiting the editor resumes the tree walk.\nLet\u2019s find and edit some files. When run as a script, we pass this program the search\nstring as a command argument (here, the string mimetypes is the search key). The root\ndirectory passed to the run method is either the second argument or \u201c.\u201d (the current\nrun directory) by default. Traversal status messages show up in the console, but each\nmatched file now automatically pops up in a text editor along the way. In the following,\nthe editor is started eight times\u2014try this with an editor and tree of your own to get a\nbetter feel for how it works:\nC:\\...\\PP4E\\Tools> visitor_edit.py mimetypes C:\\temp\\PP3E\\Examples\nC:\\temp\\PP3E\\Examples ...\n1 => C:\\temp\\PP3E\\Examples\\README-root.txt\nC:\\temp\\PP3E\\Examples\\PP3E ...\n2 => C:\\temp\\PP3E\\Examples\\PP3E\\echoEnvironment.pyw\n3 => C:\\temp\\PP3E\\Examples\\PP3E\\LaunchBrowser.pyw\n4 => C:\\temp\\PP3E\\Examples\\PP3E\\Launcher.py\n5 => C:\\temp\\PP3E\\Examples\\PP3E\\Launcher.pyc\nSkipping C:\\temp\\PP3E\\Examples\\PP3E\\Launcher.pyc\n...more output omitted...\n1427 => C:\\temp\\PP3E\\Examples\\PP3E\\TempParts\\lawnlake1-jan-03.jpg\nVisitor: Walking Directories \u201c++\u201d | 335Skipping C:\\temp\\PP3E\\Examples\\PP3E\\TempParts\\lawnlake1-jan-03.jpg\n1428 => C:\\temp\\PP3E\\Examples\\PP3E\\TempParts\\part-001.txt\n1429 => C:\\temp\\PP3E\\Examples\\PP3E\\TempParts\\part-002.html\nEdited 8 files, visited 1429\nThis, finally, is the exact tool I was looking for to simplify global book examples tree\nmaintenance. After major changes to things such as shared modules and file and di-\nrectory names, I run this script on the examples root directory with an appropriate\nsearch string and edit any files it pops up as needed. I still need to change files by hand\nin the editor, but that\u2019s often safer than blind global replacements.\nGlobal Replacements in Directory Trees (Visitor)\nBut since I brought it up: given a general tree traversal class, it\u2019s easy to code a global\nsearch-and-replace subclass, too. The ReplaceVisitor class in Example 6-20 is a Search\nVisitor subclass that customizes the visitfile method to globally replace any appear-\nances of one string with another, in all text files at and below a root directory. It also\ncollects the names of all files that were changed in a list just in case you wish to go\nthrough and verify the automatic edits applied (a text editor could be automatically\npopped up on each changed file, for instance).\nExample 6-20. PP4E\\Tools\\visitor_replace.py\n\"\"\"\nUse: \"python ...\\Tools\\visitor_replace.py rootdir fromStr toStr\".\nDoes global search-and-replace in all files in a directory tree: replaces\nfromStr with toStr in all text files; this is powerful but dangerous!!\nvisitor_edit.py runs an editor for you to verify and make changes, and so\nis safer; use visitor_collect.py to simply collect matched files list;\nlistonly mode here is similar to both SearchVisitor and CollectVisitor;\n\"\"\"\nimport sys\nfrom visitor import SearchVisitor\nclass ReplaceVisitor(SearchVisitor):\n    \"\"\"\n    Change fromStr to toStr in files at and below startDir;\n    files changed available in obj.changed list after a run\n    \"\"\"\n    def __init__(self, fromStr, toStr, listOnly=False, trace=0):\n        self.changed  = []\n        self.toStr    = toStr\n        self.listOnly = listOnly\n        SearchVisitor.__init__(self, fromStr, trace)\n    def visitmatch(self, fname, text):\n        self.changed.append(fname)\n        if not self.listOnly:\n            fromStr, toStr = self.context, self.toStr\n            text = text.replace(fromStr, toStr)\n            open(fname, 'w').write(text)\n336 | Chapter 6:\u2002Complete System Programsif __name__  == '__main__':\n    listonly = input('List only?') == 'y'\n    visitor  = ReplaceVisitor(sys.argv[2], sys.argv[3], listonly)\n    if listonly or input('Proceed with changes?') == 'y':\n        visitor.run(startDir=sys.argv[1])\n        action = 'Changed' if not listonly else 'Found'\n        print('Visited %d files'  % visitor.fcount)\n        print(action, '%d files:' % len(visitor.changed))\n        for fname in visitor.changed: print(fname)\nTo run this script over a directory tree, run the following sort of command line with\nappropriate \u201cfrom\u201d and \u201cto\u201d strings. On my shockingly underpowered netbook ma-\nchine, doing this on a 1429-file tree and changing 101 files along the way takes roughly\nthree seconds of real clock time when the system isn\u2019t particularly busy.\nC:\\...\\PP4E\\Tools> visitor_replace.py C:\\temp\\PP3E\\Examples PP3E PP4E\nList only?y\nVisited 1429 files\nFound 101 files:\nC:\\temp\\PP3E\\Examples\\README-root.txt\nC:\\temp\\PP3E\\Examples\\PP3E\\echoEnvironment.pyw\nC:\\temp\\PP3E\\Examples\\PP3E\\Launcher.py\n...more matching filenames omitted...\nC:\\...\\PP4E\\Tools> visitor_replace.py C:\\temp\\PP3E\\Examples PP3E PP4E\nList only?n\nProceed with changes?y\nVisited 1429 files\nChanged 101 files:\nC:\\temp\\PP3E\\Examples\\README-root.txt\nC:\\temp\\PP3E\\Examples\\PP3E\\echoEnvironment.pyw\nC:\\temp\\PP3E\\Examples\\PP3E\\Launcher.py\n...more changed filenames omitted...\nC:\\...\\PP4E\\Tools> visitor_replace.py C:\\temp\\PP3E\\Examples PP3E PP4E\nList only?n\nProceed with changes?y\nVisited 1429 files\nChanged 0 files:\nNaturally, we can also check our work by running the visitor script (and\nSearchVisitor superclass):\nC:\\...\\PP4E\\Tools> visitor.py 2 C:\\temp\\PP3E\\Examples PP3E\nFound in 0 files, visited 1429\nC:\\...\\PP4E\\Tools> visitor.py 2 C:\\temp\\PP3E\\Examples PP4E\nC:\\temp\\PP3E\\Examples\\README-root.txt has PP4E\nC:\\temp\\PP3E\\Examples\\PP3E\\echoEnvironment.pyw has PP4E\nC:\\temp\\PP3E\\Examples\\PP3E\\Launcher.py has PP4E\n...more matching filenames omitted...\nFound in 101 files, visited 1429\nVisitor: Walking Directories \u201c++\u201d | 337This is both wildly powerful and dangerous. If the string to be replaced can show up\nin places you didn\u2019t anticipate, you might just ruin an entire tree of files by running the\nReplaceVisitor object defined here. On the other hand, if the string is something very\nspecific, this object can obviate the need to manually edit suspicious files. For instance,\nwebsite addresses in HTML files are likely too specific to show up in other places by \nchance.\nCounting Source Code Lines (Visitor)\nThe two preceding visitor module clients were both search-oriented, but it\u2019s just as\neasy to extend the basic walker class for more specific goals. Example 6-21, for instance,\nextends FileVisitor to count the number of lines in program source code files of various\ntypes throughout an entire tree. The effect is much like calling the visitfile method\nof this class for each filename returned by the find tool we wrote earlier in this chapter,\nbut the OO structure here is arguably more flexible and extensible.\nExample 6-21. PP4E\\Tools\\visitor_sloc.py\n\"\"\"\nCount lines among all program source files in a tree named on the command\nline, and report totals grouped by file types (extension).  A simple SLOC\n(source lines of code) metric: skip blank and comment lines if desired.\n\"\"\"\nimport sys, pprint, os\nfrom visitor import FileVisitor\nclass LinesByType(FileVisitor):\n    srcExts = [] # define in subclass\n    def __init__(self, trace=1):\n        FileVisitor.__init__(self, trace=trace)\n        self.srcLines = self.srcFiles = 0\n        self.extSums = {ext: dict(files=0, lines=0) for ext in self.srcExts}\n    def visitsource(self, fpath, ext):\n        if self.trace > 0: print(os.path.basename(fpath))\n        lines = len(open(fpath, 'rb').readlines())\n        self.srcFiles += 1\n        self.srcLines += lines\n        self.extSums[ext]['files'] += 1\n        self.extSums[ext]['lines'] += lines\n    def visitfile(self, filepath):\n        FileVisitor.visitfile(self, filepath)\n        for ext in self.srcExts:\n            if filepath.endswith(ext):\n                self.visitsource(filepath, ext)\n                break\nclass PyLines(LinesByType):\n    srcExts = ['.py', '.pyw']   # just python files\n338 | Chapter 6:\u2002Complete System Programsclass SourceLines(LinesByType):\n    srcExts = ['.py', '.pyw', '.cgi', '.html', '.c', '.cxx', '.h', '.i']\nif __name__ == '__main__':\n    walker = SourceLines()\n    walker.run(sys.argv[1])\n    print('Visited %d files and %d dirs' % (walker.fcount, walker.dcount))\n    print('-'*80)\n    print('Source files=>%d, lines=>%d'  % (walker.srcFiles, walker.srcLines))\n    print('By Types:')\n    pprint.pprint(walker.extSums)\n    print('\\nCheck sums:', end=' ')\n    print(sum(x['lines'] for x in walker.extSums.values()), end=' ')\n    print(sum(x['files'] for x in walker.extSums.values()))\n    print('\\nPython only walk:')\n    walker = PyLines(trace=0)\n    walker.run(sys.argv[1])\n    pprint.pprint(walker.extSums)\nWhen run as a script, we get trace messages during the walk (omitted here to save\nspace), and a report with line counts grouped by file type. Run this on trees of your\nown to watch its progress; my tree has 907 source files and 48K source lines, including\n783 files and 34K lines of \u201c.py\u201d Python code:\nC:\\...\\PP4E\\Tools> visitor_sloc.py C:\\temp\\PP3E\\Examples\nVisited 1429 files and 186 dirs\n--------------------------------------------------------------------------------\nSource files=>907, lines=>48047\nBy Types:\n{'.c': {'files': 45, 'lines': 7370},\n '.cgi': {'files': 5, 'lines': 122},\n '.cxx': {'files': 4, 'lines': 2278},\n '.h': {'files': 7, 'lines': 297},\n '.html': {'files': 48, 'lines': 2830},\n '.i': {'files': 4, 'lines': 49},\n '.py': {'files': 783, 'lines': 34601},\n '.pyw': {'files': 11, 'lines': 500}}\nCheck sums: 48047 907\nPython only walk:\n{'.py': {'files': 783, 'lines': 34601}, '.pyw': {'files': 11, 'lines': 500}}\nRecoding Copies with Classes (Visitor)\nLet\u2019s peek at one more visitor use case. When I first wrote the cpall.py script earlier in\nthis chapter, I couldn\u2019t see a way that the visitor class hierarchy we met earlier would\nhelp. Two directories needed to be traversed in parallel (the original and the copy), and\nvisitor is based on walking just one tree with os.walk. There seemed no easy way to\nkeep track of where the script was in the copy directory.\nVisitor: Walking Directories \u201c++\u201d | 339The trick I eventually stumbled onto is not to keep track at all. Instead, the script in\nExample 6-22 simply replaces the \u201cfrom\u201d directory path string with the \u201cto\u201d directory\npath string, at the front of all directory names and pathnames passed in from os.walk.\nThe results of the string replacements are the paths to which the original files and\ndirectories are to be copied.\nExample 6-22. PP4E\\Tools\\visitor_cpall.py\n\"\"\"\nUse: \"python ...\\Tools\\visitor_cpall.py fromDir toDir trace?\"\nLike System\\Filetools\\cpall.py, but with the visitor classes and os.walk;\ndoes string replacement of fromDir with toDir at the front of all the names\nthat the walker passes in; assumes that the toDir does not exist initially;\n\"\"\"\nimport os\nfrom visitor import FileVisitor                       # visitor is in '.'\nfrom PP4E.System.Filetools.cpall import copyfile      # PP4E is in a dir on path\nclass CpallVisitor(FileVisitor):\n    def __init__(self, fromDir, toDir, trace=True):\n        self.fromDirLen = len(fromDir) + 1\n        self.toDir      = toDir\n        FileVisitor.__init__(self, trace=trace)\n    def visitdir(self, dirpath):\n        toPath = os.path.join(self.toDir, dirpath[self.fromDirLen:])\n        if self.trace: print('d', dirpath, '=>', toPath)\n        os.mkdir(toPath)\n        self.dcount += 1\n    def visitfile(self, filepath):\n        toPath = os.path.join(self.toDir, filepath[self.fromDirLen:])\n        if self.trace: print('f', filepath, '=>', toPath)\n        copyfile(filepath, toPath)\n        self.fcount += 1\nif __name__ == '__main__':\n    import sys, time\n    fromDir, toDir = sys.argv[1:3]\n    trace = len(sys.argv) > 3\n    print('Copying...')\n    start = time.clock()\n    walker = CpallVisitor(fromDir, toDir, trace)\n    walker.run(startDir=fromDir)\n    print('Copied', walker.fcount, 'files,', walker.dcount, 'directories', end=' ')\n    print('in', time.clock() - start, 'seconds')\n340 | Chapter 6:\u2002Complete System ProgramsThis version accomplishes roughly the same goal as the original, but it has made a few\nassumptions to keep the code simple. The \u201cto\u201d directory is assumed not to exist initially,\nand exceptions are not ignored along the way. Here it is copying the book examples\ntree from the prior edition again on Windows:\nC:\\...\\PP4E\\Tools> set PYTHONPATH\nPYTHONPATH=C:\\Users\\Mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\nC:\\...\\PP4E\\Tools> rmdir /S copytemp\ncopytemp, Are you sure (Y/N)? y\nC:\\...\\PP4E\\Tools> visitor_cpall.py C:\\temp\\PP3E\\Examples copytemp\nCopying...\nCopied 1429 files, 186 directories in 11.1722033777 seconds\nC:\\...\\PP4E\\Tools> fc /B copytemp\\PP3E\\Launcher.py\n                         C:\\temp\\PP3E\\Examples\\PP3E\\Launcher.py\nComparing files COPYTEMP\\PP3E\\Launcher.py and C:\\TEMP\\PP3E\\EXAMPLES\\PP3E\\LAUNCHER.PY\nFC: no differences encountered\nDespite the extra string slicing going on, this version seems to run just as fast as the\noriginal (the actual difference can be chalked up to system load variations). For tracing\npurposes, this version also prints all the \u201cfrom\u201d and \u201cto\u201d copy paths during the traversal\nif you pass in a third argument on the command line:\nC:\\...\\PP4E\\Tools> rmdir /S copytemp\ncopytemp, Are you sure (Y/N)? y\nC:\\...\\PP4E\\Tools> visitor_cpall.py C:\\temp\\PP3E\\Examples copytemp 1\nCopying...\nd C:\\temp\\PP3E\\Examples => copytemp\\\nf C:\\temp\\PP3E\\Examples\\README-root.txt => copytemp\\README-root.txt\nd C:\\temp\\PP3E\\Examples\\PP3E => copytemp\\PP3E\n...more lines omitted: try this on your own for the full output...\nOther Visitor Examples (External)\nAlthough the visitor is widely applicable, we don\u2019t have space to explore additional\nsubclasses in this book. For more example clients and use cases, see the following\nexamples in book\u2019s examples distribution package described in the Preface:\n\u2022 Tools\\visitor_collect.py collects and/or prints files containing a search string\n\u2022 Tools\\visitor_poundbang.py replaces directory paths in \u201c#!\u201d lines at the top of Unix\nscripts\n\u2022 Tools\\visitor_cleanpyc.py is a visitor-based recoding of our earlier bytecode cleanup\nscripts\n\u2022 Tools\\visitor_bigpy.py is a visitor-based version of the \u201cbiggest file\u201d example at the\nstart of this chapter\nVisitor: Walking Directories \u201c++\u201d | 341Most of these are almost as trivial as the visitor_edit.py code in Example 6-19, because\nthe visitor framework handles walking details automatically. The collector, for in-\nstance, simply appends to a list as a search visitor detects matched files and allows the\ndefault list of text filename extensions in the search visitor to be overridden per\ninstance\u2014it\u2019s roughly like a combination of find and grep on Unix:\n>>> from visitor_collect import CollectVisitor\n>>> V = CollectVisitor('mimetypes', testexts=['.py', '.pyw'], trace=0)\n>>> V.run(r'C:\\temp\\PP3E\\Examples')\n>>> for name in V.matches: print(name)        # .py and .pyw files with 'mimetypes'\n...\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Email\\mailtools\\mailParser.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Email\\mailtools\\mailSender.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\downloadflat.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\downloadflat_modular.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\ftptools.py\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\uploadflat.py\nC:\\temp\\PP3E\\Examples\\PP3E\\System\\Media\\playfile.py\nC:\\...\\PP4E\\Tools> visitor_collect.py mimetypes C:\\temp\\PP3E\\Examples   # as script\nThe core logic of the biggest-file visitor is similarly straightforward, and harkens back\nto chapter start:\nclass BigPy(FileVisitor):\n    def __init__(self, trace=0):\n        FileVisitor.__init__(self, context=[], trace=trace)\n    def visitfile(self, filepath):\n        FileVisitor.visitfile(self, filepath)\n        if filepath.endswith('.py'):\n            self.context.append((os.path.getsize(filepath), filepath))\nAnd the bytecode-removal visitor brings us back full circle, showing an additional al-\nternative to those we met earlier in this chapter. It\u2019s essentially the same code, but it\nruns os.remove on \u201c.pyc\u201d file visits.\nIn the end, while the visitor classes are really just simple wrappers for os.walk, they\nfurther automate walking chores and provide a general framework and alternative class-\nbased structure which may seem more natural to some than simple unstructured loops.\nThey\u2019re also representative of how Python\u2019s OOP support maps well to real-world\nstructures like file systems. Although os.walk works well for one-off scripts, the better\nextensibility, reduced redundancy, and greater encapsulation possible with OOP can\nbe a major asset in real work as our needs change and evolve over time.\n342 | Chapter 6:\u2002Complete System ProgramsIn fact, those needs have changed over time. Between the third and\nfourth editions of this book, the original os.path.walk call was removed\nin Python 3.X, and os.walk became the only automated way to perform\ntree walks in the standard library. Examples from the prior edition that\nused os.path.walk were effectively broken. By contrast, although the\nvisitor classes used this call, too, its clients did not. Because updating\nthe visitor classes to use os.walk internally did not alter those classes\u2019\ninterfaces, visitor-based tools continued to work unchanged.\nThis seems a prime example of the benefits of OOP\u2019s support for en-\ncapsulation. Although the future is never completely predictable, in\npractice, user-defined tools like visitor tend to give you more control\nover changes than standard library tools like os.walk. Trust me on that;\nas someone who has had to update three Python books over the last 15\nyears, I can say with some certainty that Python change is a constant!\nPlaying Media Files\nWe have space for just one last, quick example in this chapter, so we\u2019ll close with a bit\nof fun. Did you notice how the file extensions for text and binary file types were hard-\ncoded in the directory search scripts of the prior two sections? That approach works\nfor the trees they were applied to, but it\u2019s not necessarily complete or portable. It would\nbe better if we could deduce file type from file name automatically. That\u2019s exactly what\nPython\u2019s mimetypes module can do for us. In this section, we\u2019ll use it to build a script\nthat attempts to launch a file based upon its media type, and in the process develop\ngeneral tools for opening media portably with specific or generic players.\nAs we\u2019ve seen, on Windows this task is trivial\u2014the os.startfile call opens files per\nthe Windows registry, a system-wide mapping of file extension types to handler pro-\ngrams. On other platforms, we can either run specific media handlers per media type,\nor fall back on a resident web browser to open the file generically using Python\u2019s\nwebbrowser module. Example 6-23 puts these ideas into code.\nExample 6-23. PP4E\\System\\Media\\playfile.py\n#!/usr/local/bin/python\n\"\"\"\n##################################################################################\nTry to play an arbitrary media file.  Allows for specific players instead of\nalways using general web browser scheme.  May not work on your system as is;\naudio files use filters and command lines on Unix, and filename associations\non Windows via the start command (i.e., whatever you have on your machine to\nrun .au files--an audio player, or perhaps a web browser).  Configure and\nextend as needed.  playknownfile assumes you know what sort of media you wish\nto open, and playfile tries to determine media type automatically using Python\nmimetypes module; both try to launch a web browser with Python webbrowser module\nas a last resort when mimetype or platform unknown.\n##################################################################################\n\"\"\"\nPlaying Media Files | 343import os, sys, mimetypes, webbrowser\nhelpmsg = \"\"\"\nSorry: can't find a media player for '%s' on your system!\nAdd an entry for your system to the media player dictionary\nfor this type of file in playfile.py, or play the file manually.\n\"\"\"\ndef trace(*args): print(*args)   # with spaces between\n##################################################################################\n# player techniques: generic and otherwise: extend me\n##################################################################################\nclass MediaTool:\n    def __init__(self, runtext=''):\n        self.runtext = runtext\n    def run(self, mediafile, **options):            # most ignore options\n        fullpath = os.path.abspath(mediafile)       # cwd may be anything\n        self.open(fullpath, **options)\nclass Filter(MediaTool):\n    def open(self, mediafile, **ignored):\n        media  = open(mediafile, 'rb')\n        player = os.popen(self.runtext, 'w')        # spawn shell tool\n        player.write(media.read())                  # send to its stdin\nclass Cmdline(MediaTool):\n    def open(self, mediafile, **ignored):\n        cmdline = self.runtext % mediafile          # run any cmd line\n        os.system(cmdline)                          # use %s for filename\nclass Winstart(MediaTool):                          # use Windows registry\n    def open(self, mediafile, wait=False, **other): # or os.system('start file')\n        if not wait:                                # allow wait for curr media\n            os.startfile(mediafile)\n        else:\n            os.system('start /WAIT ' + mediafile)\nclass Webbrowser(MediaTool):\n    # file:// requires abs path\n    def open(self, mediafile, **options):\n        webbrowser.open_new('file://%s' % mediafile, **options)\n##################################################################################\n# media- and platform-specific policies: change me, or pass one in\n##################################################################################\n# map platform to player: change me!\naudiotools = {\n    'sunos5':  Filter('/usr/bin/audioplay'),             # os.popen().write()\n    'linux2':  Cmdline('cat %s > /dev/audio'),           # on zaurus, at least\n    'sunos4':  Filter('/usr/demo/SOUND/play'),           # yes, this is that old!\n344 | Chapter 6:\u2002Complete System Programs'win32':   Winstart()                                # startfile or system\n   #'win32':   Cmdline('start %s')\n    }\nvideotools = {\n    'linux2':  Cmdline('tkcVideo_c700 %s'),              # zaurus pda\n    'win32':   Winstart(),                               # avoid DOS pop up\n    }\nimagetools = {\n    'linux2':  Cmdline('zimager %s'),                    # zaurus pda\n    'win32':   Winstart(),\n    }\ntexttools = {\n    'linux2':  Cmdline('vi %s'),                         # zaurus pda\n    'win32':   Cmdline('notepad %s')                     # or try PyEdit?\n    }\napptools = {\n    'win32':   Winstart()   # doc, xls, etc: use at your own risk!\n    }\n# map mimetype of filenames to player tables\nmimetable = {'audio':       audiotools,\n             'video':       videotools,\n             'image':       imagetools,\n             'text':        texttools,                   # not html text: browser\n             'application': apptools}\n##################################################################################\n# top-level interfaces\n##################################################################################\ndef trywebbrowser(filename, helpmsg=helpmsg, **options):\n    \"\"\"\n    try to open a file in a web browser\n    last resort if unknown mimetype or platform, and for text/html\n    \"\"\"\n    trace('trying browser', filename)\n    try:\n        player = Webbrowser()                            # open in local browser\n        player.run(filename, **options)\n    except:\n        print(helpmsg % filename)                        # else nothing worked\ndef playknownfile(filename, playertable={}, **options):\n    \"\"\"\n    play media file of known type: uses platform-specific\n    player objects, or spawns a web browser if nothing for\n    this platform; accepts a media-specific player table\n    \"\"\"\n    if sys.platform in playertable:\n        playertable[sys.platform].run(filename, **options)     # specific tool\nPlaying Media Files | 345else:\n        trywebbrowser(filename, **options)                     # general scheme\ndef playfile(filename, mimetable=mimetable, **options):\n    \"\"\"\n    play media file of any type: uses mimetypes to guess media\n    type and map to platform-specific player tables; spawn web\n    browser if text/html, media type unknown, or has no table\n    \"\"\"\n    contenttype, encoding = mimetypes.guess_type(filename)        # check name\n    if contenttype == None or encoding is not None:               # can't guess\n        contenttype = '?/?'                                       # poss .txt.gz\n    maintype, subtype = contenttype.split('/', 1)                 # 'image/jpeg'\n    if maintype == 'text' and subtype == 'html':\n        trywebbrowser(filename, **options)                        # special case\n    elif maintype in mimetable:\n        playknownfile(filename, mimetable[maintype], **options)   # try table\n    else:\n        trywebbrowser(filename, **options)                        # other types\n###############################################################################\n# self-test code\n###############################################################################\nif __name__ == '__main__':\n    # media type known\n    playknownfile('sousa.au', audiotools, wait=True)\n    playknownfile('ora-pp3e.gif', imagetools, wait=True)\n    playknownfile('ora-lp4e.jpg', imagetools)\n    # media type guessed\n    input('Stop players and press Enter')\n    playfile('ora-lp4e.jpg')                     # image/jpeg\n    playfile('ora-pp3e.gif')                     # image/gif\n    playfile('priorcalendar.html')               # text/html\n    playfile('lp4e-preface-preview.html')        # text/html\n    playfile('lp-code-readme.txt')               # text/plain\n    playfile('spam.doc')                         # app\n    playfile('spreadsheet.xls')                  # app\n    playfile('sousa.au', wait=True)              # audio/basic\n    input('Done')                                # stay open if clicked\nAlthough it\u2019s generally possible to open most media files by passing their names to a\nweb browser these days, this module provides a simple framework for launching media\nfiles with more specific tools, tailored by both media type and platform. A web browser\nis used only as a fallback option, if more specific tools are not available. The net result\nis an extendable media file player, which is as specific and portable as the customiza-\ntions you provide for its tables.\nWe\u2019ve seen the program launch tools employed by this script in prior chapters. The\nscript\u2019s main new concepts have to do with the modules it uses: the webbrowser module\nto open some files in a local web browser, as well as the Python mimetypes module to\n346 | Chapter 6:\u2002Complete System Programsdetermine media type from file name. Since these are the heart of this code\u2019s matter,\nlet\u2019s explore these briefly before we run the script.\nThe Python webbrowser Module\nThe standard library webbrowser module used by this example provides a portable in-\nterface for launching web browsers from Python scripts. It attempts to locate a suitable\nweb browser on your local machine to open a given URL (file or web address) for\ndisplay. Its interface is straightforward:\n>>> import webbrowser\n>>> webbrowser.open_new('file://' + fullfilename)         # use os.path.abspath()\nThis code will open the named file in a new web browser window using whatever\nbrowser is found on the underlying computer, or raise an exception if it cannot. You\ncan tailor the browsers used on your platform, and the order in which they are attemp-\nted, by using the BROWSER environment variable and register function. By default,\nwebbrowser attempts to be automatically portable across platforms.\nUse an argument string of the form \u201cfile://...\u201d or \u201chttp://...\u201d to open a file on the local\ncomputer or web server, respectively. In fact, you can pass in any URL that the browser\nunderstands. The following pops up Python\u2019s home page in a new locally-running\nbrowser window, for example:\n>>> webbrowser.open_new('http://www.python.org')\nAmong other things, this is an easy way to display HTML documents as well as media\nfiles, as demonstrated by this section\u2019s example. For broader applicability, this module\ncan be used as both command-line script (Python\u2019s -m module search path flag helps\nhere) and as importable tool:\nC:\\Users\\mark\\Stuff\\Websites\\public_html> python -m webbrowser about-pp.html\nC:\\Users\\mark\\Stuff\\Websites\\public_html> python -m webbrowser -n about-pp.html\nC:\\Users\\mark\\Stuff\\Websites\\public_html> python -m webbrowser -t about-pp.html\nC:\\Users\\mark\\Stuff\\Websites\\public_html> python\n>>> import webbrowser\n>>> webbrowser.open('about-pp.html')            # reuse, new window, new tab\nTrue\n>>> webbrowser.open_new('about-pp.html')        # file:// optional on Windows\nTrue\n>>> webbrowser.open_new_tab('about-pp.html')\nTrue\nIn both modes, the difference between the three usage forms is that the first tries to\nreuse an already-open browser window if possible, the second tries to open a new\nwindow, and the third tries to open a new tab. In practice, though, their behavior is\ntotally dependent on what the browser selected on your platform supports, and even\non the platform in general. All three forms may behave the same.\nPlaying Media Files | 347On Windows, for example, all three simply run os.startfile by default and thus create\na new tab in an existing window under Internet Explorer 8. This is also why I didn\u2019t\nneed the \u201cfile://\u201d full URL prefix in the preceding listing. Technically, Internet Explorer\nis only run if this is what is registered on your computer for the file type being opened;\nif not, that file type\u2019s handler is opened instead. Some images, for example, may open\nin a photo viewer instead. On other platforms, such as Unix and Mac OS X, browser\nbehavior differs, and non-URL file names might not be opened; use \u201cfile://\u201d for\nportability.\nWe\u2019ll use this module again later in this book. For example, the PyMailGUI program\nin Chapter 14 will employ it as a way to display HTML-formatted email messages and\nattachments, as well as program help. See the Python library manual for more details.\nIn Chapters 13 and 15, we\u2019ll also meet a related call, urllib.request.urlopen, which\nfetches a web page\u2019s text given a URL, but does not open it in a browser; it may be\nparsed, saved, or otherwise used.\nThe Python mimetypes Module\nTo make this media player module even more useful, we also use the Python\nmimetypes standard library module to automatically determine the media type from the\nfilename. We get back a type/subtype MIME content-type string if the type can be\ndetermined or None if the guess failed:\n>>> import mimetypes\n>>> mimetypes.guess_type('spam.jpg')\n('image/jpeg', None)\n>>> mimetypes.guess_type('TheBrightSideOfLife.mp3')\n('audio/mpeg', None)\n>>> mimetypes.guess_type('lifeofbrian.mpg')\n('video/mpeg', None)\n>>> mimetypes.guess_type('lifeofbrian.xyz')       # unknown type\n(None, None)\nStripping off the first part of the content-type string gives the file\u2019s general media type,\nwhich we can use to select a generic player; the second part (subtype) can tell us if text\nis plain or HTML:\n>>> contype, encoding = mimetypes.guess_type('spam.jpg')\n>>> contype.split('/')[0]\n'image'\n>>> mimetypes.guess_type('spam.txt')              # subtype is 'plain'\n('text/plain', None)\n>>> mimetypes.guess_type('spam.html')\n('text/html', None)\n348 | Chapter 6:\u2002Complete System Programs>>> mimetypes.guess_type('spam.html')[0].split('/')[1]\n'html'\nA subtle thing: the second item in the tuple returned from the mimetypes guess is an\nencoding type we won\u2019t use here for opening purposes. We still have to pay attention\nto it, though\u2014if it is not None, it means the file is compressed (gzip or compress), even\nif we receive a media content type. For example, if the filename is something like\nspam.gif.gz, it\u2019s a compressed image that we don\u2019t want to try to open directly:\n>>> mimetypes.guess_type('spam.gz')              # content unknown\n(None, 'gzip')\n>>> mimetypes.guess_type('spam.gif.gz')          # don't play me!\n('image/gif', 'gzip')\n>>> mimetypes.guess_type('spam.zip')             # archives\n('application/zip', None)\n>>> mimetypes.guess_type('spam.doc')             # office app files\n('application/msword', None)\nIf the filename you pass in contains a directory path, the path portion is ignored (only\nthe extension is used). This module is even smart enough to give us a filename extension\nfor a type\u2014useful if we need to go the other way, and create a file name from a content\ntype:\n>>> mimetypes.guess_type(r'C:\\songs\\sousa.au')\n('audio/basic', None)\n>>> mimetypes.guess_extension('audio/basic')\n'.au'\nTry more calls on your own for more details. We\u2019ll use the mimetypes module again in\nFTP examples in Chapter 13 to determine transfer type (text or binary), and in our\nemail examples in Chapters 13, 14, and 16 to send, save, and open mail attachments.\nIn Example 6-23, we use mimetypes to select a table of platform-specific player com-\nmands for the media type of the file to be played. That is, we pick a player table for the\nfile\u2019s media type, and then pick a command from the player table for the platform. At\nboth steps, we give up and run a web browser if there is nothing more specific to be\ndone.\nUsing mimetypes guesses for SearchVisitor\nTo use this module for directing our text file search scripts we wrote earlier in this\nchapter, simply extract the first item in the content-type returned for a file\u2019s name. For\ninstance, all in the following list are considered text (except \u201c.pyw\u201d, which we may\nhave to special-case if we must care):\n>>> for ext in ['.txt', '.py', '.pyw', '.html', '.c', '.h', '.xml']:\n...     print(ext, mimetypes.guess_type('spam' + ext))\n...\nPlaying Media Files | 349.txt ('text/plain', None)\n.py ('text/x-python', None)\n.pyw (None, None)\n.html ('text/html', None)\n.c ('text/plain', None)\n.h ('text/plain', None)\n.xml ('text/xml', None)\nWe can add this technique to our earlier SearchVisitor class by redefining its candidate\nselection method, in order to replace its default extension lists with mimetypes guesses\u2014\nyet more evidence of the power of OOP customization at work:\nC:\\...\\PP4E\\Tools> python\n>>> import mimetypes\n>>> from visitor import SearchVisitor             # or PP4E.Tools.visitor if not .\n>>>\n>>> class SearchMimeVisitor(SearchVisitor):\n...     def candidate(self, fname):\n...         contype, encoding = mimetypes.guess_type(fname)\n...         return (contype and\n...                 contype.split('/')[0] == 'text' and\n...                 encoding == None)\n...\n>>> V = SearchMimeVisitor('mimetypes', trace=0)             # search key\n>>> V.run(r'C:\\temp\\PP3E\\Examples')                         # root dir\nC:\\temp\\PP3E\\Examples\\PP3E\\extras\\LosAlamosAdvancedClass\\day1-system\\data.txt ha\ns mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Email\\mailtools\\mailParser.py has mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Email\\mailtools\\mailSender.py has mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\downloadflat.py has mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\downloadflat_modular.py has mimet\nypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\ftptools.py has mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\Internet\\Ftp\\mirror\\uploadflat.py has mimetypes\nC:\\temp\\PP3E\\Examples\\PP3E\\System\\Media\\playfile.py has mimetypes\n>>> V.scount, V.fcount, V.dcount\n(8, 1429, 186)\nBecause this is not completely accurate, though (you may need to add logic to include\nextensions like \u201c.pyw\u201d missed by the guess), and because it\u2019s not even appropriate for\nall search clients (some may want to search specific kinds of text only), this scheme was\nnot used for the original class. Using and tailoring it for your own searches is left as\noptional exercise.\nRunning the Script\nNow, when Example 6-23 is run from the command line, if all goes well its canned self-\ntest code at the end opens a number of audio, image, text, and other file types located\nin the script\u2019s directory, using either platform-specific players or a general web browser.\nOn my Windows 7 laptop, GIF and HTML files open in new IE browser tabs; JPEG\nfiles in Windows Photo Viewer; plain text files in Notepad; DOC and XLS files in\nMicrosoft Word and Excel; and audio files in Windows Media Player.\n350 | Chapter 6:\u2002Complete System ProgramsBecause the programs used and their behavior may vary widely from machine to ma-\nchine, though, you\u2019re best off studying this script\u2019s code and running it on your own\ncomputer and with your own test files to see what happens. As usual, you can also test\nit interactively (use the package path like this one to import from a different directory,\nassuming your module search path includes the PP4E root):\n>>> from PP4E.System.Media.playfile import playfile\n>>> playfile(r'C:\\movies\\mov10428.mpg')                       # video/mpeg\nWe\u2019ll use the playfile module again as an imported library like this in Chapter 13 to\nopen media files downloaded by FTP. Again, you may want to tweak this script\u2019s tables\nfor your players. This script also assumes the media file is located on the local machine\n(even though the webbrowser module supports remote files with \u201chttp://\u201d names), and\nit does not currently allow different players for most different MIME subtypes (it spe-\ncial-cases text to handle \u201cplain\u201d and \u201chtml\u201d differently, but no others). In fact, this\nscript is really just something of a simple framework that was designed to be extended.\nAs always, hack on; this is Python, after all.\nAutomated Program Launchers (External)\nFinally, some optional reading\u2014in the examples distribution package for this book\n(available at sites listed in the Preface) you can find additional system-related scripts\nwe do not have space to cover here:\n\u2022 PP4E\\Launcher.py\u2014contains tools used by some GUI programs later in the book\nto start Python programs without any environment configuration. Roughly, it sets\nup both the system path and module import search paths as needed to run book\nexamples, which are inherited by spawned programs. By using this module to\nsearch for files and configure environments automatically, users can avoid (or at\nleast postpone) having to learn the intricacies of manual environment configura-\ntion before running programs. Though there is not much new in this example from\na system interfaces perspective, we\u2019ll refer back to it later, when we explore GUI\nprograms that use its tools, as well as those of its launchmodes cousin, which we\nwrote in Chapter 5.\n\u2022 PP4E\\Launch_PyDemos.pyw \nand \nPP4E\\Launch_PyGadgets_bar.pyw\u2014use\nLauncher.py to start major GUI book examples without any environment config-\nuration. Because all spawned processes inherit configurations performed by the\nlauncher, they all run with proper search path settings. When run directly, the\nunderlying PyDemos2.pyw and PyGadgets_bar.pyw scripts (which we\u2019ll explore\nbriefly at the end of Chapter 10) instead rely on the configuration settings on the\nunderlying machine. In other words, Launcher effectively hides configuration de-\ntails from the GUI interfaces by enclosing them in a configuration program layer.\n\u2022 PP4E\\LaunchBrowser.pyw\u2014portably locates and starts an Internet web browser\nprogram on the host machine in order to view a local file or remote web page. In\nAutomated Program Launchers (External) | 351prior versions, it used tools in Launcher.py to search for a reasonable browser to\nrun. The original version of this example has now been largely superseded by the\nstandard library\u2019s webbrowser module, which arose after this example had been\ndeveloped (reptilian minds think alike!). In this edition, LaunchBrowser simply par-\nses command-line arguments for backward compatibility and invokes the open\nfunction in webbrowser. See this module\u2019s help text, or PyGadgets and PyDemos in\nChapter 10, for example command-line usage.\nThat\u2019s the end of our system tools exploration. In the next part of this book we leave\nthe realm of the system shell and move on to explore ways to add graphical user inter-\nfaces to our program. Later, we\u2019ll do the same using web-based approaches. As we\ncontinue, keep in mind that the system tools we\u2019ve studied in this part of the book see\naction in a wide variety of programs. For instance, we\u2019ll put threads to work to spawn\nlong-running tasks in the GUI part, use both threads and processes when exploring\nserver implementations in the Internet part, and use files and file-related system calls\nthroughout the remainder of the book.\nWhether your interfaces are command lines, multiwindow GUIs, or distributed client/\nserver websites, Python\u2019s system interfaces toolbox is sure to play a important part in\nyour Python programming future.\n352 | Chapter 6:\u2002Complete System ProgramsPART III\nGUI Programming\nThis part of the book shows you how to apply Python to build portable graphical user \ninterfaces, primarily with Python\u2019s standard tkinter library. The following chapters \ncover this topic in depth:\nChapter 7 \nThis chapter outlines GUI options available to Python developers, and then \npresents a brief tutorial that illustrates core tkinter coding concepts.\nChapter 8 \nThis chapter begins a two-part tour of the tkinter library\u2014its widget set and related \ntools. This first tour chapter covers simpler library tools and widgets: pop-up win-\ndows, various types of buttons, images, and so on.\nChapter 9 \nThis chapter continues the library tour begun in the prior chapter. It presents the \nrest of the tkinter widget library, including menus, text, canvases, scroll bars, grids, \nand time-based events and animation.\nChapter 10 \nThis chapter takes a look at GUI programming techniques: we\u2019ll learn how to build \nmenus automatically from object templates, spawn GUIs as separate programs, \nrun long-running tasks in parallel with threads and queues, and more.\nChapter 11 \nThis chapter pulls the earlier chapters\u2019 ideas together to implement a collection of \nuser interfaces. It presents a number of larger GUIs\u2014clocks, text editors, drawing \nprograms, image viewers, and so on\u2014which also demonstrate general Python \nprogramming-in-the-large concepts along the way.\nAs in the first part of this book, the material presented here is applicable to a wide \nvariety of domains and will be utilized again to build domain-specific user interfaces \nin later chapters of this book. For instance, the PyMailGUI and PyCalc examples of \nlater chapters will assume that you\u2019ve covered the basics here.", "7": "CHAPTER 7\nGraphical User Interfaces\n\u201cHere\u2019s Looking at You, Kid\u201d\nFor most software systems, a graphical user interface (GUI) has become an expected \npart of the package. Even if the GUI acronym is new to you, chances are that you are \nalready familiar with such interfaces\u2014the windows, buttons, and menus that we use \nto interact with software programs. In fact, most of what we do on computers today is \ndone with some sort of point-and-click graphical interface. From web browsers to sys-\ntem tools, programs are routinely dressed up with a GUI component to make them \nmore flexible and easier to use.\nIn this part of the book, we will learn how to make Python scripts sprout such graphical \ninterfaces, too, by studying examples of programming with the tkinter module, a port-\nable GUI library that is a standard part of the Python system and the toolkit most widely \nused by Python programmers. As we\u2019ll see, it\u2019s easy to program user interfaces in Python \nscripts thanks to both the simplicity of the language and the power of its GUI libraries. \nAs an added bonus, GUIs programmed in Python with tkinter are automatically port-\nable to all major computer systems.\nGUI Programming Topics\nBecause GUIs are a major area, I want to say a few more words about this part of the \nbook before we get started. To make them easier to absorb, GUI programming topics \nare split over the next five chapters:\n\u2022 This chapter begins with a quick tkinter tutorial to teach coding basics. Interfaces \nare kept simple here on purpose, so you can master the fundamentals before mov-\ning on to the following chapter\u2019s interfaces. On the other hand, this chapter covers \nall the basics: event processing, the pack geometry manager, using inheritance and \ncomposition in GUIs, and more. As we\u2019ll see, object-oriented programming (OOP) \nisn\u2019t required for tkinter, but it makes GUIs structured and reusable.\n355\u2022 Chapters 8 and 9 take you on a tour of the tkinter widget set.* Roughly, Chap-\nter 8 presents simple widgets and Chapter 9 covers more advanced widgets and\nrelated tools. Most of the interface devices you\u2019re accustomed to seeing\u2014sliders,\nmenus, dialogs, images, and their kin\u2014show up here. These two chapters are not\na fully complete tkinter reference (which could easily fill a large book by itself), but\nthey should be enough to help you get started coding substantial Python GUIs.\nThe examples in these chapters are focused on widgets and tkinter tools, but Py-\nthon\u2019s support for code reuse is also explored along the way.\n\u2022 Chapter 10 covers more advanced GUI programming techniques. It includes an\nexploration of techniques for automating common GUI tasks with Python. Al-\nthough tkinter is a full-featured library, a small amount of reusable Python code\ncan make its interfaces even more powerful and easier to use.\n\u2022 Chapter 11 wraps up by presenting a handful of complete GUI programs that make\nuse of coding and widget techniques presented in the four preceding chapters.\nWe\u2019ll learn how to implement text editors, image viewers, clocks, and more.\nBecause GUIs are actually cross-domain tools, other GUI examples will also show up\nthroughout the remainder of this book. For example, we\u2019ll later see complete email\nGUIs and calculators, as well as a basic FTP client GUI; additional examples such as\ntree viewers and table browsers are available externally in the book examples package.\nChapter 11 gives a list of forward pointers to other tkinter examples in this text.\nAfter we explore GUIs, in Part IV we\u2019ll also learn how to build basic user interfaces\nwithin a web browser using HTML and Python scripts that run on a server\u2014a very\ndifferent model with advantages and tradeoffs all its own that are important to under-\nstand. Newer technologies such as the RIAs described later in this chapter build on the\nweb browser model to offer even more interface choices.\nFor now, though, our focus here is on more traditional GUIs\u2014known as \u201cdesktop\u201d\napplications to some, and as \u201cstandalone\u201d GUIs to others. As we\u2019ll see when we meet\nFTP and email client GUIs in the Internet part of this book, though, such programs\noften connect to a network to do their work as well.\n* The term \u201cwidget set\u201d refers to the objects used to build familiar point-and-click user interface devices\u2014\npush buttons, sliders, input fields, and so on. tkinter comes with Python classes that correspond to all the\nwidgets you\u2019re accustomed to seeing in graphical displays. Besides widgets, tkinter also comes with tools for\nother activities, such as scheduling events to occur, waiting for socket data to arrive, and so on.\n356 | Chapter 7:\u2002Graphical User InterfacesRunning the Examples\nOne other point I\u2019d like to make right away: most GUIs are dynamic and interactive\ninterfaces, and the best I can do here is show static screenshots representing selected\nstates in the interactions such programs implement. This really won\u2019t do justice to most\nexamples. If you are not working along with the examples already, I encourage you to\nrun the GUI examples in this and later chapters on your own.\nOn Windows, the standard Python install comes with tkinter support built in, so all\nthese examples should work immediately. Mac OS X comes bundled with a tkinter-\naware Python as well. For other systems, Pythons with tkinter support are either pro-\nvided with the system itself or are readily available (see the top-level\nREADME-PP4E.txt file in the book examples distribution for more details). Getting\ntkinter to work on your computer is worth whatever extra install details you may need\nto absorb, though; experimenting with these programs is a great way to learn about\nboth GUI programming and Python itself.\nAlso see the description of book example portability in general in this book\u2019s Preface.\nAlthough Python and tkinter are both largely platform neutral, you may run into some\nminor platform-specific issues if you try to run this book\u2019s examples on platforms other\nthan that used to develop this book. Mac OS X, for example, might pose subtle differ-\nences in some of the examples\u2019 operation. Be sure to watch this book\u2019s website for\npointers and possible future patches for using the examples on other platforms.\nHas Anyone Noticed That G-U-I Are the First Three Letters of \u201cGUIDO\u201d?\nPython creator Guido van Rossum didn\u2019t originally set out to build a GUI development\ntool, but Python\u2019s ease of use and rapid turnaround have made this one of its primary\nroles. From an implementation perspective, GUIs in Python are really just instances of\nC extensions, and extensibility was one of the main ideas behind Python. When a script\nbuilds push buttons and menus, it ultimately talks to a C library; and when a script\nresponds to a user event, a C library ultimately talks back to Python. It\u2019s really just an\nexample of what is possible when Python is used to script external libraries.\nBut from a practical point of view, GUIs are a critical part of modern systems and an\nideal domain for a tool like Python. As we\u2019ll see, Python\u2019s simple syntax and object-\noriented flavor blend well with the GUI model\u2014it\u2019s natural to represent each device\ndrawn on a screen as a Python class. Moreover, Python\u2019s quick turnaround lets pro-\ngrammers experiment with alternative layouts and behavior rapidly, in ways not pos-\nsible with traditional development techniques. In fact, you can usually make a change\nto a Python-based GUI and observe its effects in a matter of seconds. Don\u2019t try this with\nC++!\n\u201cHere\u2019s Looking at You, Kid\u201d | 357Python GUI Development Options\nBefore we start wading into the tkinter pond, let\u2019s begin with some perspective on \nPython GUI options in general. Because Python has proven to be such a good match \nfor GUI work, this domain has seen much activity over the years. In fact, although \ntkinter is by most accounts still the most widely used GUI toolkit in the Python world, \nthere are a variety of ways to program user interfaces in Python today. Some are specific \nto Windows or X Windows,\u2020 some are cross-platform solutions, and all have followings \nand strong points of their own. To be fair to all the alternatives, here is a brief inventory \nof GUI toolkits available to Python programmers as I write these words:\ntkinter \nAn open source GUI library and the continuing de facto standard for portable GUI \ndevelopment in Python. Python scripts that use tkinter to build GUIs run portably \non Windows, X Windows (Unix and Linux), and Macintosh OS X, and they display \na native look-and-feel on each of these platforms today. tkinter makes it easy to \nbuild simple and portable GUIs quickly. Moreover, it can be easily augmented with \nPython code, as well as with larger extension packages such as Pmw (a third-party \nwidget library); Tix (another widget library, and now a standard part of Python); \nPIL (an image-processing extension); and ttk (Tk themed widgets, also now a \nstandard part of Python as of version 3.1). More on such extensions like these later \nin this introduction.\nThe underlying Tk library used by tkinter is a standard in the open source world \nat large and is also used by the Perl, Ruby, PHP, Common Lisp, and Tcl scripting \nlanguages, giving it a user base that likely numbers in the millions. The Python \nbinding to Tk is enhanced by Python\u2019s simple object model\u2014Tk widgets become \ncustomizable and embeddable objects, instead of string commands. tkinter takes \nthe form of a module package in Python 3.X, with nested modules that group some \nof its tools by functionality (it was formerly known as module Tkinter in Python\n2.X, but was renamed to follow naming conventions, and restructured to provide \na more hierarchical organization).\ntkinter is mature, robust, widely used, and well documented. It includes roughly \n25 basic widget types, plus various dialogs and other tools. Moreover, there is a \ndedicated book on the subject, plus a large library of published tkinter and Tk \ndocumentation. Perhaps most importantly, because it is based on a library\n\u2020 In this book, \u201cWindows\u201d refers to the Microsoft Windows interface common on PCs, and \u201cX Windows\u201d \nrefers to the X11 interface most commonly found on Unix and Linux platforms. These two interfaces are \ngenerally tied to the Microsoft and Unix (and Unix-like) platforms, respectively. It\u2019s possible to run X \nWindows on top of a Microsoft operating system and Windows emulators on Unix and Linux, but it\u2019s not \ncommon. As if to muddy the waters further, Mac OS X supports Python\u2019s tkinter on both X Windows and \nthe native Aqua GUI system directly, in addition to platform-specific cocoa options (though it\u2019s usually not \ntoo misleading to lump OS X in with the \u201cUnix-like\u201d crowd).\n358 | Chapter 7:\u2002Graphical User Interfacesdeveloped for scripting languages, tkinter is also a relatively lightweight toolkit,\nand as such it meshes well with a scripting language like Python.\nBecause of such attributes, Python\u2019s tkinter module ships with Python as a standard\nlibrary module and is the basis of Python\u2019s standard IDLE integrated development\nenvironment GUI. In fact, tkinter is the only GUI toolkit that is part of Python; all\nothers on this list are third-party extensions. The underlying Tk library is also\nshipped with Python on some platforms (including Windows, Mac OS X, and most\nLinux and Unix-like systems). You can be reasonably sure that tkinter will be\npresent when your script runs, and you can guarantee this if needed by freezing\nyour GUI into a self-contained binary executable with tools like PyInstaller and\npy2exe (see the Web for details).\nAlthough tkinter is easy to use, its text and canvas widgets are powerful enough to\nimplement web pages, three-dimensional visualization, and animation. In addi-\ntion, a variety of systems aim to provide GUI builders for Python/tkinter today,\nincluding GUI Builder (formerly part of the Komodo IDE and relative of SpecTCL),\nRapyd-Tk, xRope, and others (though this set has historically tended to change\nmuch over time; see http://wiki.python.org/moin/GuiProgramming or search the\nWeb for updates). As we will see, though, tkinter is usually so easy to code that\nGUI builders are not widely used. This is especially true once we leave the realm\nof the static layouts that builders typically support.\nwxPython\nA Python interface for the open source wxWidgets (formerly called wxWindows)\nlibrary, which is a portable GUI class framework originally written to be used from\nthe C++ programming language. The wxPython system is an extension module\nthat wraps wxWidgets classes. This library is generally considered to excel at\nbuilding sophisticated interfaces and is probably the second most popular Python\nGUI toolkit today, behind tkinter. GUIs coded in Python with wxPython are port-\nable to Windows, Unix-like platforms, and Mac OS X.\nBecause wxPython is based on a C++ class library, most observers consider it to\nbe more complex than tkinter: it provides hundreds of classes, generally requires\nan object-oriented coding style, and has a design that some find reminiscent of the\nMFC class library on Windows. wxPython often expects programmers to write\nmore code, partly because it is a more functional and thus complex system, and\npartly because it inherits this mindset from its underlying C++ library.\nMoreover, some of wxPython\u2019s documentation is oriented toward C++, though\nthis story has been improved recently with the publication of a book dedicated to\nwxPython. By contrast, tkinter is covered by one book dedicated to it, large sections\nof other Python books, and an even larger library of existing literature on the un-\nderlying Tk toolkit. Since the world of Python books has been remarkably dynamic\nover the years, though, you should investigate the accuracy of these observations\nat the time that you read these words; some books fade, while new Python books\nappear on a regular basis.\nPython GUI Development Options | 359On the other hand, in exchange for its added complexity, wxPython provides a\npowerful toolkit. wxPython comes with a richer set of widgets out of the box than\ntkinter, including trees and HTML viewers\u2014things that may require extensions\nsuch as Pmw, Tix, or ttk in tkinter. In addition, some prefer the appearance of the\ninterfaces it renders. BoaConstructor and wxDesigner, among other options, pro-\nvide a GUI builder that generates wxPython code. Some wxWidgets tools also\nsupport non-GUI Python work as well. For a quick look at wxPython widgets and\ncode, run the demo that comes with the system (see http://wxpython.org/, or search\nthe Web for links).\nPyQt\nA Python interface to the Qt toolkit (now from Nokia, formerly by Trolltech), and\nperhaps the third most widely used GUI toolkit for Python today. PyQt is a full-\nfeatured GUI library and runs portably today on Windows, Mac OS X, and Unix\nand Linux. Like wxPython, Qt is generally more complex, yet more feature rich,\nthan tkinter; it contains hundreds of classes and thousands of functions and meth-\nods. Qt grew up on Linux but became portable to other systems over time; reflect-\ning this heritage, the PyQt and PyKDE extension packages provide access to KDE\ndevelopment libraries (PyKDE requires PyQt). The BlackAdder and Qt Designer\nsystems provide GUI builders for PyQt.\nPerhaps Qt\u2019s most widely cited drawback in the past has been that it was not\ncompletely open source for full commercial use. Today, Qt provides both GPL and\nLGPL open source licensing, as well as commercial license options. The LGPL and\nGPL versions are open source, but conform to GPL licensing constraints (GPL may\nalso impose requirements beyond those of the Python BSD-style license; you must,\nfor example, make your source code freely available to end users).\nPyGTK\nA Python interface to GTK, a portable GUI library originally used as the core of\nthe Gnome window system on Linux. The gnome-python and PyGTK extension\npackages export Gnome and GTK toolkit calls. At this writing, PyGTK runs port-\nably on Windows and POSIX systems such as Linux and Mac OS X (according to\nits documentation, it currently requires that an X server for Mac OS X has been\ninstalled, though a native Mac version is in the works).\nJython\nJython (the system formerly known as JPython) is a Python implementation for\nJava, which compiles Python source code to Java bytecode, and gives Python scripts\nseamless access to Java class libraries on the local machine. Because of that, Java\nGUI libraries such as swing and awt become another way to construct GUIs in\nPython code run by the JPython system. Such solutions are obviously Java specific\nand limited in portability to that of Java and its libraries. Furthermore, swing may\nbe one of the largest and most complex GUI option for Python work. A new pack-\nage named jTkinter also provides a tkinter port to Jython using Java\u2019s JNI; if\n360 | Chapter 7:\u2002Graphical User Interfacesinstalled, Python scripts may also use tkinter to build GUIs under Jython. Jython\nalso has Internet roles we\u2019ll meet briefly in Chapter 12.\nIronPython\nIn a very similar vein, the IronPython system\u2014an implementation of the Python\nlanguage for the .NET environment and runtime engine, which, among other\nthings, compiles Python programs to .NET bytecode\u2014also offers Python scripts\nGUI construction options in the .NET framework. You write Python code, but use\nC#/.NET components to construct interfaces, and applications at large.\nIronPython code can be run on .NET on Windows, but also on Linux under the\nMono implementation of .NET, and in the Silverlight client-side RIA framework\nfor web browsers (discussed ahead).\nPythonCard\nAn open source GUI builder and library built on top of the wxPython toolkit and\nconsidered by some to be one of Python\u2019s closest equivalents to the kind of GUI\nbuilders familiar to Visual Basic developers. PythonCard describes itself as a GUI\nconstruction kit for building cross-platform desktop applications on Windows,\nMac OS X, and Linux, using the Python language.\nDabo\nAn open source GUI builder also built on wxPython, and a bit more. Dabo is a\nportable, three-tier, cross-platform desktop application development framework,\ninspired by Visual FoxPro and written in Python. Its tiers support database access,\nbusiness logic, and user interface. Its open design is intended to eventually support\na variety of databases and multiple user interfaces (wxPython, tkinter, and even\nHTML over HTTP).\nRich Internet Applications (RIAs)\nAlthough web pages rendered with HTML are also a kind of user interface, they\nhave historically been too limited to include in the general GUI category. However,\nsome observers would extend this category today to include systems which allow\nbrowser-based interfaces to be much more dynamic than traditional web pages\nhave allowed. Because such systems provide widget toolkits rendered by web\nbrowsers, they can offer some of the same portability benefits as web pages in\ngeneral.\nThe going buzzword for this brave new breed of toolkits is rich Internet applica-\ntions (RIAs). It includes AJAX and JavaScript-oriented frameworks for use on the\nclient, such as:\nFlex\nAn open source framework from Adobe and part of the Flash platform\nSilverlight\nA Microsoft framework which is also usable on Linux with Mono\u2019s Moonlight,\nand can be accessed by Python code with the IronPython system described\nabove\nPython GUI Development Options | 361JavaFX\nA Java platform for building RIAs which can run across a variety of connected\ndevices\npyjamas\nAn AJAX-based port of the Google Web Toolkit to Python, which comes with\na set of interface widgets and compiles Python code that uses those widgets\ninto JavaScript, to be run in a browser on a client\nThe HTML5 standard under development proposes to address this domain as well.\nWeb browsers ultimately are \u201cdesktop\u201d GUI applications, too, but are more per-\nvasive than GUI libraries, and can be generalized with RIA tools to render other\nGUIs. While it\u2019s possible to build a widget-based GUI with such frameworks, they\ncan also add overheads associated with networking in general and often imply a\nsubstantially heavier software stack than traditional GUI toolkits. Indeed, in order\nto morph browsers into general GUI platforms, RIAs may imply extra software\nlayers and dependencies, and even multiple programming languages. Because of\nthat, and because not everyone codes for the Web today (despite what you may\nhave heard), we won\u2019t include them in our look at traditional standalone/desktop\nGUIs in this part of the book.\nSee the Internet part for more on RIAs and user interfaces based on browsers, and\nbe sure to watch for news and trends on this front over time. The interactivity these\ntools provide is also a key part of what some refer to as \u201cWeb 2.0\u201d when viewed\nmore from the perspective of the Web than GUIs. Since we\u2019re concerned with the\nlatter here (and since user interaction is user interaction regardless of what jargon\nwe use for it), we\u2019ll postpone further enumeration of this topic until the next part\nof the book.\nPlatform-specific options\nBesides the portable toolkits like tkinter, wxPython, and PyQt, and platform-\nagnostic approaches such as RIAs, most major platforms have nonportable options\nfor Python-coded GUIs as well. For instance, on Macintosh OS X, PyObjC provides\na Python binding to Apple\u2019s Objective-C/Cocoa framework, which is the basis for\nmuch Mac development. On Windows, the PyWin32 extensions package for Py-\nthon includes wrappers for the C++ Microsoft Foundation Classes (MFC) frame-\nwork (a library that includes interface components), as well as Pythonwin, an MFC\nsample program that implements a Python development GUI. Although .NET\ntechnically runs on Linux, too, the IronPython system mentioned earlier offers\nadditional Windows-focused options.\nSee the websites of these toolkits for more details. There are other lesser-known GUI\ntoolkits for Python, and new ones are likely to emerge by the time you read this book\n(in fact, IronPython was new in the third edition, and RIAs are new in the fourth).\nMoreover, packages like those in this list are prone to mutate over time. For an up-to-\ndate list of available tools, search the Web or browse http://www.python.org and the\nPyPI third-party packages index maintained there.\n362 | Chapter 7:\u2002Graphical User Interfacestkinter Overview\nOf all the prior section\u2019s GUI options, though, tkinter is by far the de facto standard\nway to implement portable user interfaces in Python today, and the focus of this part\nof the book. The rationale for this approach was explained in Chapter 1; in short, we\nelected to present one toolkit in satisfying depth instead of many toolkits in less-than-\nuseful fashion. Moreover, most of the tkinter programming concepts you learn here\nwill translate directly to any other GUI toolkit you choose to utilize.\ntkinter Pragmatics\nPerhaps more to the point, though, there are pragmatic reasons that the Python world\nstill gravitates to tkinter as its de facto standard portable GUI toolkit. Among them,\ntkinter\u2019s accessibility, portability, availability, documentation, and extensions have\nmade it the most widely used Python GUI solution for many years running:\nAccessibility\ntkinter is generally regarded as a lightweight toolkit and one of the simplest GUI\nsolutions for Python available today. Unlike larger frameworks, it is easy to get\nstarted in tkinter right away, without first having to grasp a much larger class in-\nteraction model. As we\u2019ll see, programmers can create simple tkinter GUIs in a few\nlines of Python code and scale up to writing industrial-strength GUIs gradually.\nAlthough the tkinter API is basic, additional widgets can be coded in Python or\nobtained in extension packages such as Pmw, Tix, and ttk.\nPortability\nA Python script that builds a GUI with tkinter will run without source code changes\non all major windowing platforms today: Microsoft Windows, X Windows (on\nUnix and Linux), and the Macintosh OS X (and also ran on Mac classics). Further,\nthat same script will provide a native look-and-feel to its users on each of these\nplatforms. In fact, this feature became more apparent as Tk matured. A Python/\ntkinter script today looks like a Windows program on Windows; on Unix and\nLinux, it provides the same interaction but sports an appearance familiar to X\nWindows users; and on the Mac, it looks like a Mac program should.\nAvailability\ntkinter is a standard module in the Python library, shipped with the interpreter. If\nyou have Python, you have tkinter. Moreover, most Python installation packages\n(including the standard Python self-installer for Windows, that provided on Mac\nOS X, and many Linux distributions) come with tkinter support bundled. Because\nof that, scripts written to use the tkinter module work immediately on most Python\ninterpreters, without any extra installation steps. tkinter is also generally better\nsupported than its alternatives today. Because the underlying Tk library is also used\nby the Tcl and Perl programming languages (and others), it tends to receive more\ndevelopment resources than other toolkits available.\ntkinter Overview | 363Naturally, other factors such as documentation and extensions are important when\nusing a GUI toolkit, too; let\u2019s take a quick look at the story tkinter has to tell on these\nfronts as well.\ntkinter Documentation\nThis book explores tkinter fundamentals and most widgets tools, and it should be\nenough to get started with substantial GUI development in Python. On the other hand,\nit is not an exhaustive reference to the tkinter library or extensions to it. Happily, at\nleast one book dedicated to using tkinter in Python is now commercially available as I\nwrite this paragraph, and others are on the way (search the Web for details). Besides\nbooks, you can also find tkinter documentation online; a complete set of tkinter man-\nuals is currently maintained on the Web at http://www.pythonware.com/library.\nIn addition, because the underlying Tk toolkit used by tkinter is also a de facto standard\nin the open source scripting community at large, other documentation sources apply.\nFor instance, because Tk has also been adopted by the Tcl and Perl programming lan-\nguages, Tk-oriented books and documentation written for both of these are directly\napplicable to Python/tkinter as well (albeit, with some syntactic mapping).\nFrankly, I learned tkinter by studying Tcl/Tk texts and references\u2014just replace Tcl\nstrings with Python objects and you have additional reference libraries at your disposal\n(see Table 7-2, the Tk-to-tkinter conversion guide, at the end of this chapter for help\nreading Tk documentation). For instance, the book Tcl/Tk Pocket Reference (O\u2019Reilly)\ncan serve as a nice supplement to the tkinter tutorial material in this part of the book.\nMoreover, since Tk concepts are familiar to a large body of programmers, Tk support\nis also readily available on the Net.\nAfter you\u2019ve learned the basics, examples can help, too. You can find tkinter demo\nprograms, besides those you\u2019ll study in this book, at various locations around the Web.\nPython itself includes a set of demo programs in the Demos\\tkinter subdirectory of its\nsource distribution package. The IDLE development GUI mentioned in the next section\nmakes for an interesting code read as well.\ntkinter Extensions\nBecause tkinter is so widely used, programmers also have access to precoded Python\nextensions designed to work with or augment it. Some of these may not yet be available\nfor Python 3.X as I write this but are expected to be soon. For instance:\nPmw\nPython Mega Widgets is an extension toolkit for building high-level compound\nwidgets in Python using the tkinter module. It extends the tkinter API with a col-\nlection of more sophisticated widgets for advanced GUI development and a frame-\nwork for implementing some of your own. Among the precoded and extensible\nmegawidgets shipped with the package are notebooks, combo boxes, selection\n364 | Chapter 7:\u2002Graphical User Interfaceswidgets, paned widgets, scrolled widgets, dialog windows, button boxes, balloon\nhelp, and an interface to the Blt graph widget.\nThe interface to Pmw megawidgets is similar to that of basic tkinter widgets, so\nPython scripts can freely mix Pmw megawidgets with standard tkinter widgets.\nMoreover, Pmw is pure Python code, and so requires no C compiler or tools to\ninstall. To view its widgets and the corresponding code you use to construct them,\nrun the demos\\All.py script in the Pmw distribution package. You can find Pmw at\nhttp://pmw.sourceforge.net.\nTix\nTix is a collection of more than 40 advanced widgets, originally written for\nTcl/Tk but now available for use in Python/tkinter programs. This package is now\na Python standard library module, called tkinter.tix. Like Tk, the underlying Tix\nlibrary is also shipped today with Python on Windows. In other words, on Win-\ndows, if you install Python, you also have Tix as a preinstalled library of additional\nwidgets.\nTix includes many of the same devices as Pmw, including spin boxes, trees, tabbed\nnotebooks, balloon help pop ups, paned windows, and much more. See the Python\nlibrary manual\u2019s entry for the Tix module for more details. For a quick look at its\nwidgets, as well as the Python source code used to program them, run the\ntixwidgets.py demonstration program in the Demo\\tix directory of the Python\nsource distribution (this directory is not installed by default on Windows and is\nprone to change\u2014you can generally find it after fetching and unpacking Python\u2019s\nsource code from Python.org).\nttk\nTk themed widgets, ttk, is a relatively new widget set which attempts to separate\nthe code implementing a widget\u2019s behavior from that implementing its appearance.\nWidget classes handle state and callback invocation, whereas widget appearance\nis managed separately by themes. Much like Tix, this extension began life sepa-\nrately, but was very recently incorporated into Python\u2019s standard library in Python\n3.1, as module tkinter.ttk.\nAlso like Tix, this extension comes with advanced widget types, some of which are\nnot present in standard tkinter itself. Specifically, ttk comes with 17 widgets, 11 of\nwhich are already present in tkinter and are meant as replacements for some of\ntkinter\u2019s standard widgets, and 6 of which are new\u2014Combobox, Notebook, Pro-\ngressbar, Separator, Sizegrip and Treeview. In a nutshell, scripts import from the\nttk module after tkinter in order to use its replacement widgets and configure style\nobjects possibly shared by multiple widgets, instead of configuring widgets\nthemselves.\nAs we\u2019ll see in this chapter, it\u2019s possible to provide a common look-and-feel for a\nset of widgets with standard tkinter, by subclassing its widget classes using normal\nOOP techniques (see \u201cCustomizing Widgets with Classes\u201d on page 400). How-\never, ttk offers additional style options and advanced widget types. For more details\ntkinter Overview | 365on ttk widgets, see the entry in the Python library manual or search the Web; this\nbook focuses on tkinter fundamentals, and tix and ttk are both too large to cover\nin a useful fashion here.\nPIL\nThe Python Imaging Library (PIL) is an open source extension package that adds\nimage-processing tools to Python. Among other things, it provides tools for image\nthumbnails, transforms, and conversions, and it extends the basic tkinter image\nobject to add support for displaying many image file types. PIL, for instance, allows\ntkinter GUIs to display JPEG, TIFF, and PNG images not supported by the base\ntkinter toolkit itself (without extension, tkinter supports GIFs and a handful of\nbitmap formats). See the end of Chapter 8 for more details and examples; we\u2019ll use\nPIL in this book in a number of image-related example scripts. PIL can be found\nat http://www.pythonware.com or via a web search.\nIDLE\nThe IDLE integrated Python development environment is both written in Python\nwith tkinter and shipped and installed with the Python package (if you have a recent\nPython interpreter, you should have IDLE too; on Windows, click the Start button,\nselect the Programs menu, and click the Python entry to find it). IDLE provides\nsyntax-coloring text editors for Python code, point-and-click debugging, and more,\nand is an example of tkinter\u2019s utility.\nOthers\nMany of the extensions that provide visualization tools for Python are based on\nthe tkinter library and its canvas widget. See the PyPI website and your favorite\nweb search engine for more tkinter extension examples.\nIf you plan to do any commercial-grade GUI development with tkinter, you\u2019ll probably\nwant to explore extensions such as Pmw, PIL, Tix, and ttk after learning tkinter basics\nin this text. They can save development time and add pizzazz to your GUIs. See the\nPython-related websites mentioned earlier for up-to-date details and links.\ntkinter Structure\nFrom a more nuts-and-bolts perspective, tkinter is an integration system that implies\na somewhat unique program structure. We\u2019ll see what this means in terms of code in\na moment, but here is a brief introduction to some of the terms and concepts at the\ncore of Python GUI programming.\nImplementation structure\nStrictly speaking, tkinter is simply the name of Python\u2019s interface to Tk\u2014a GUI library\noriginally written for use with the Tcl programming language and developed by Tcl\u2019s\ncreator, John Ousterhout. Python\u2019s tkinter module talks to Tk, and the Tk library in\nturn interfaces with the underlying window system: Microsoft Windows, X Windows\n366 | Chapter 7:\u2002Graphical User Interfaceson Unix, or whatever GUI system your Python uses on your Macintosh. The portability\nof tkinter actually stems from the underling Tk library it wraps.\nPython\u2019s tkinter adds a software layer on top of Tk that allows Python scripts to call\nout to Tk to build and configure interfaces and routes control back to Python scripts\nthat handle user-generated events (e.g., mouse clicks). That is, GUI calls are internally\nrouted from Python script, to tkinter, to Tk; GUI events are routed from Tk, to tkinter,\nand back to a Python script. In Chapter 20, we\u2019ll know these transfers by their C inte-\ngration terms, extending and embedding.\nTechnically, tkinter is today structured as a combination of the Python-coded\ntkinter module package\u2019s files and an extension module called _tkinter that is written\nin C. _tkinter interfaces with the Tk library using extending tools and dispatches call-\nbacks back to Python objects using embedding tools; tkinter simply adds a class-based\ninterface on top of _tkinter. You should almost always import tkinter in your scripts,\nthough, not _tkinter; the latter is an implementation module meant for internal use\nonly (and was oddly named for that reason).\nProgramming structure\nLuckily, Python programmers don\u2019t normally need to care about all this integration\nand call routing going on internally; they simply make widgets and register Python\nfunctions to handle widget events. Because of the overall structure, though, event han-\ndlers are usually known as callback handlers, because the GUI library \u201ccalls back\u201d to\nPython code when events occur.\nIn fact, we\u2019ll find that Python/tkinter programs are entirely event driven: they build\ndisplays and register handlers for events, and then do nothing but wait for events to\noccur. During the wait, the Tk GUI library runs an event loop that watches for mouse\nclicks, keyboard presses, and so on. All application program processing happens in the\nregistered callback handlers in response to events. Further, any information needed\nacross events must be stored in long-lived references such as global variables and class\ninstance attributes. The notion of a traditional linear program control flow doesn\u2019t\nreally apply in the GUI domain; you need to think in terms of smaller chunks.\nIn Python, Tk also becomes object oriented simply because Python is object oriented:\nthe tkinter layer exports Tk\u2019s API as Python classes. With tkinter, we can either use a\nsimple function-call approach to create widgets and interfaces, or apply object-oriented\ntechniques such as inheritance and composition to customize and extend the base set\nof tkinter classes. Larger tkinter GUIs are generally constructed as trees of linked tkinter\nwidget objects and are often implemented as Python classes to provide structure and\nretain state information between events. As we\u2019ll see in this part of the book, a tkinter\nGUI coded with classes almost by default becomes a reusable software component.\ntkinter Overview | 367Climbing the GUI Learning Curve\nOn to the code; let\u2019s start out by quickly stepping through a few small examples that\nillustrate basic concepts and show the windows they create on the computer display.\nThe examples will become progressively more sophisticated as we move along, but let\u2019s\nget a handle on the fundamentals first.\n\u201cHello World\u201d in Four Lines (or Less)\nThe usual first example for GUI systems is to show how to display a \u201cHello World\u201d\nmessage in a window. As coded in Example 7-1, it\u2019s just four lines in Python.\nExample 7-1. PP4E\\Gui\\Intro\\gui1.py\nfrom tkinter import Label                               # get a widget object\nwidget = Label(None, text='Hello GUI world!')           # make one\nwidget.pack()                                           # arrange it\nwidget.mainloop()                                       # start event loop\nThis is a complete Python tkinter GUI program. When this script is run, we get a simple\nwindow with a label in the middle; it looks like Figure 7-1 on my Windows 7 laptop (I\nstretched some windows in this book horizontally to reveal their window titles; your\nplatform\u2019s window system may vary).\nFigure 7-1. \u201cHello World\u201d (gui1) on Windows\nThis isn\u2019t much to write home about yet, but notice that this is a completely functional,\nindependent window on the computer\u2019s display. It can be maximized to take up the\nentire screen, minimized to hide it in the system bar, and resized. Click on the window\u2019s\n\u201cX\u201d box in the top right to kill the window and exit the program.\nThe script that builds this window is also fully portable. Run this script on your machine\nto see how it renders. When this same file is run on Linux it produces a similar window,\nbut it behaves according to the underlying Linux window manager. Even on the same\noperating system, the same Python code might yields a different look-and-feel for dif-\nferent window systems (for instance, under KDE and Gnome on Linux). The same\nscript file would look different still when run on Macintosh and other Unix-like window\nmanagers. On all platforms, though, its basic functional behavior will be the same.\n368 | Chapter 7:\u2002Graphical User Interfacestkinter Coding Basics\nThe gui1 script is a trivial example, but it illustrates steps common to most tkinter\nprograms. This Python code does the following:\n1. Loads a widget class from the tkinter module\n2. Makes an instance of the imported Label class\n3. Packs (arranges) the new Label in its parent widget\n4. Calls mainloop to bring up the window and start the tkinter event loop\nThe mainloop method called last puts the label on the screen and enters a tkinter wait\nstate, which watches for user-generated GUI events. Within the mainloop function,\ntkinter internally monitors things such as the keyboard and mouse to detect user-\ngenerated events. In fact, the tkinter mainloop function is similar in spirit to the fol-\nlowing pseudo-Python code:\ndef mainloop():\n    while the main window has not been closed:\n        if an event has occurred:\n            run the associated event handler function\nBecause of this model, the mainloop call in Example 7-1 never returns to our script while\nthe GUI is displayed on-screen.\u2021 When we write larger scripts, the only way we can get\nanything done after calling mainloop is to register callback handlers to respond to events.\nThis is called event-driven programming, and it is perhaps one of the most unusual\naspects of GUIs. GUI programs take the form of a set of event handlers that share saved\ninformation rather than of a single main control flow. We\u2019ll see how this looks in terms\nof real code in later examples.\nNote that for code in a script file, you really need to do steps 3 and 4 in the preceding\nlist to open this script\u2019s GUI. To display a GUI\u2019s window at all, you need to call main\nloop; to display widgets within the window, they must be packed (or otherwise ar-\nranged) so that the tkinter geometry manager knows about them. In fact, if you call\neither mainloop or pack without calling the other, your window won\u2019t show up as ex-\npected: a mainloop without a pack shows an empty window, and a pack without a\nmainloop in a script shows nothing since the script never enters an event wait state (try\nit). The mainloop call is sometimes optional when you\u2019re coding interactively, but you\nshouldn\u2019t rely on this in general.\nSince the concepts illustrated by this simple script are at the core of most tkinter pro-\ngrams, let\u2019s take a deeper look at some of them before moving on.\n\u2021 Technically, the mainloop call returns to your script only after the tkinter event loop exits. This normally\nhappens when the GUI\u2019s main window is closed, but it may also occur in response to explicit quit method\ncalls that terminate nested event loops but leave open the GUI at large. You\u2019ll see why this matters in\nChapter 8.\nClimbing the GUI Learning Curve | 369Making Widgets\nWhen widgets are constructed in tkinter, we can specify how they should be configured.\nThe gui1 script passes two arguments to the Label class constructor:\n\u2022 The first is a parent-widget object, which we want the new label to be attached to.\nHere, None means \u201cattach the new Label to the default top-level window of this\nprogram.\u201d Later, we\u2019ll pass real widgets in this position to attach our labels to other\ncontainer objects.\n\u2022 The second is a configuration option for the Label, passed as a keyword argument:\nthe text option specifies a text string to appear as the label\u2019s message. Most widget\nconstructors accept multiple keyword arguments for specifying a variety of options\n(color, size, callback handlers, and so on). Most widget configuration options have\nreasonable defaults per platform, though, and this accounts for much of tkinter\u2019s\nsimplicity. You need to set most options only if you wish to do something custom.\nAs we\u2019ll see, the parent-widget argument is the hook we use to build up complex GUIs\nas widget trees. tkinter works on a \u201cwhat-you-build-is-what-you-get\u201d principle\u2014we\nconstruct widget object trees as models of what we want to see on the screen, and then\nask the tree to display itself by calling mainloop.\nGeometry Managers\nThe pack widget method called by the gui1 script invokes the packer geometry man-\nager, one of three ways to control how widgets are arranged in a window. tkinter ge-\nometry managers simply arrange one or more widgets within a container (sometimes\ncalled a parent or master). Both top-level windows and frames (a special kind of widget\nwe\u2019ll meet later) can serve as containers, and containers may be nested inside other\ncontainers to build hierarchical displays.\nThe packer geometry manager uses constraint option settings to automatically position \nwidgets in a window. Scripts supply higher-level instructions (e.g., \u201cattach this widget\nto the top of its container, and stretch it to fill its space vertically\u201d), not absolute pixel\ncoordinates. Because such constraints are so abstract, the packer provides a powerful\nand easy-to-use layout system. In fact, you don\u2019t even have to specify constraints. If\nyou don\u2019t pass any arguments to pack, you get default packing, which attaches the\nwidget to the top side of its container.\nWe\u2019ll visit the packer repeatedly in this chapter and use it in many of the examples in\nthis book. In Chapter 9, we will also meet an alternative grid geometry manager\u2014a\nlayout system that arranges widgets within a container in tabular form (i.e., by rows\nand columns) and works well for input forms. A third alternative, called the placer\ngeometry manager system, is described in Tk documentation but not in this book; it\u2019s\nless popular than the pack and grid managers and can be difficult to use for larger GUIs\ncoded by hand.\n370 | Chapter 7:\u2002Graphical User InterfacesRunning GUI Programs\nLike all Python code, the module in Example 7-1 can be started in a number of ways\u2014\nby running it as a top-level program file:\nC:\\...\\PP4E\\Gui\\Intro> python gui1.py\nby importing it from a Python session or another module file:\n>>> import gui1\nby running it as a Unix executable if we add the special #! line at the top:\n% gui1.py &\nand in any other way Python programs can be launched on your platform. For instance,\nthe script can also be run by clicking on the file\u2019s name in a Windows file explorer, and\nits code can be typed interactively at the >>> prompt.\u00a7 It can even be run from a C\nprogram by calling the appropriate embedding API function (see Chapter 20 for details\non C integration).\nIn other words, there are really no special rules to follow when launching GUI Python\ncode. The tkinter interface (and Tk itself) is linked into the Python interpreter. When\na Python program calls GUI functions, they\u2019re simply passed to the embedded GUI\nsystem behind the scenes. That makes it easy to write command-line tools that pop up\nwindows; they are run the same way as the purely text-based scripts we studied in the\nprior part of this book.\nAvoiding DOS consoles on Windows\nIn Chapters 3 and 6 we noted that if a program\u2019s name ends in a .pyw extension rather\nthan a .py extension, the Windows Python port does not pop up a DOS console box\nto serve as its standard streams when the file is launched by clicking its filename icon.\nNow that we\u2019ve finally started making windows of our own, that filename trick will\nstart to become even more useful.\nIf you just want to see the windows that your script makes no matter how it is launched,\nbe sure to name your GUI scripts with a .pyw if they might be run on Windows. For\ninstance, clicking on the file in Example 7-2 in a Windows explorer creates just the\nwindow in Figure 7-1.\nExample 7-2. PP4E\\Gui\\Intro\\gui1.pyw\n...same as gui1.py...\n\u00a7 Tip: As suggested earlier, when typing tkinter GUI code interactively, you may or may not need to call\nmainloop to display widgets. This is required in the current IDLE interface, but not from a simple interactive\nsession running in a system console window. In either case, control will return to the interactive prompt\nwhen you kill the window you created. Note that if you create an explicit main-window widget by calling\nTk() and attach widgets to it (described later), you must call this again after killing the window; otherwise,\nthe application window will not exist.\nClimbing the GUI Learning Curve | 371You can also avoid the DOS pop up on Windows by running the program with the\npythonw.exe executable, not python.exe (in fact, .pyw files are simply registered to be\nopened by pythonw). On Linux, the .pyw doesn\u2019t hurt, but it isn\u2019t necessary; there is no\nnotion of a streams pop up on Unix-like machines. On the other hand, if your GUI\nscripts might run on Windows in the future, adding an extra \u201cw\u201d at the end of their\nnames now might save porting effort later. In this book, .py filenames are still sometimes\nused to pop up console windows for viewing printed messages on Windows.\ntkinter Coding Alternatives\nAs you might expect, there are a variety of ways to code the gui1 example. For instance,\nif you want to make all your tkinter imports more explicit in your script, grab the whole\nmodule and prefix all of its names with the module\u2019s name, as in Example 7-3.\nExample 7-3. PP4E\\Gui\\Intro\\gui1b.py\u2014import versus from\nimport tkinter\nwidget = tkinter.Label(None, text='Hello GUI world!')\nwidget.pack()\nwidget.mainloop()\nThat will probably get tedious in realistic examples, though\u2014tkinter exports dozens\nof widget classes and constants that show up all over Python GUI scripts. In fact, it is\nusually easier to use a * to import everything from the tkinter module by name in one\nshot. This is demonstrated in Example 7-4.\nExample 7-4. PP4E\\Gui\\Intro\\gui1c.py\u2014roots, sides, pack in place\nfrom tkinter import *\nroot = Tk()\nLabel(root, text='Hello GUI world!').pack(side=TOP)\nroot.mainloop()\nThe tkinter module goes out of its way to export only what we really need, so it\u2019s one\nof the few for which the * import form is relatively safe to apply.\u2016 The TOP constant in\nthe pack call here, for instance, is one of those many names exported by the tkinter\nmodule. It\u2019s simply a variable name (TOP=\"top\") preassigned in constants, a module\nautomatically loaded by tkinter.\nWhen widgets are packed, we can specify which side of their parent they should be\nattached to\u2014TOP, BOTTOM, LEFT, or RIGHT. If no side option is sent to pack (as in prior\nexamples), a widget is attached to its parent\u2019s TOP by default. In general, larger tkinter\nGUIs can be constructed as sets of rectangles, attached to the appropriate sides of other,\n\u2016 If you study the main tkinter file in the Python source library (currently, Lib\\tkinter\\__init__.py), you\u2019ll notice\nthat top-level module names not meant for export start with a single underscore. Python never copies over\nsuch names when a module is accessed with the * form of the from statement. The constants module is today\nconstants.py in the same module package directory, though this can change (and has) over time.\n372 | Chapter 7:\u2002Graphical User Interfacesenclosing rectangles. As we\u2019ll see later, tkinter arranges widgets in a rectangle according\nto both their packing order and their side attachment options. When widgets are grid-\nded, they are assigned row and column numbers instead. None of this will become very\nmeaningful, though, until we have more than one widget in a window, so let\u2019s move on.\nNotice that this version calls the pack method right away after creating the label, without\nassigning it a variable. If we don\u2019t need to save a widget, we can pack it in place like\nthis to eliminate a statement. We\u2019ll use this form when a widget is attached to a larger\nstructure and never again referenced. This can be tricky if you assign the pack result,\nthough, but I\u2019ll postpone an explanation of why until we\u2019ve covered a few more basics.\nWe also use a Tk widget class instance, instead of None, as the parent here. Tk represents\nthe main (\u201croot\u201d) window of the program\u2014the one that starts when the program does.\nAn automatically created Tk instance is also used as the default parent widget, both\nwhen we don\u2019t pass any parent to other widget calls and when we pass the parent as\nNone. In other words, widgets are simply attached to the main program window by\ndefault. This script just makes this default behavior explicit by making and passing the\nTk object itself. In Chapter 8, we\u2019ll see that Toplevel widgets are typically used to gen-\nerate new pop-up windows that operate independently of the program\u2019s main window.\nIn tkinter, some widget methods are exported as functions, and this lets us shave\nExample 7-5 to just three lines of code.\nExample 7-5. PP4E\\Gui\\Intro\\gui1d.py\u2014a minimal version\nfrom tkinter import *\nLabel(text='Hello GUI world!').pack()\nmainloop()\nThe tkinter mainloop can be called with or without a widget (i.e., as a function or\nmethod). We didn\u2019t pass Label a parent argument in this version, either: it simply\ndefaults to None when omitted (which in turn defaults to the automatically created Tk\nobject). But relying on that default is less useful once we start building larger displays.\nThings such as labels are more typically attached to other widget containers.\nWidget Resizing Basics\nTop-level windows, such as the one built by all of the coding variants we have seen\nthus far, can normally be resized by the user; simply drag out the window with your\nmouse. Figure 7-2 shows how our window looks when it is expanded.\nThis isn\u2019t very good\u2014the label stays attached to the top of the parent window instead\nof staying in the middle on expansion\u2014but it\u2019s easy to improve on this with a pair of\npack options, demonstrated in Example 7-6.\ntkinter Coding Alternatives | 373Example 7-6. PP4E\\Gui\\Intro\\gui1e.py\u2014expansion\nfrom tkinter import *\nLabel(text='Hello GUI world!').pack(expand=YES, fill=BOTH)\nmainloop()\nWhen widgets are packed, we can specify whether a widget should expand to take up\nall available space, and if so, how it should stretch to fill that space. By default, widgets\nare not expanded when their parent is. But in this script, the names YES and BOTH (im-\nported from the tkinter module) specify that the label should grow along with its parent,\nthe main window. It does so in Figure 7-3.\nFigure 7-3. gui1e with widget resizing\nTechnically, the packer geometry manager assigns a size to each widget in a display\nbased on what it contains (text string lengths, etc.). By default, a widget can occupy\nonly its allocated space and is no bigger than its assigned size. The expand and fill\noptions let us be more specific about such things:\nFigure 7-2. Expanding gui1\n374 | Chapter 7:\u2002Graphical User Interfacesexpand=YES option\nAsks the packer to expand the allocated space for the widget in general into any\nunclaimed space in the widget\u2019s parent.\nfill option\nCan be used to stretch the widget to occupy all of its allocated space.\nCombinations of these two options produce different layout and resizing effects, some\nof which become meaningful only when there are multiple widgets in a window. For\nexample, using expand without fill centers the widget in the expanded space, and the\nfill option can specify vertical stretching only (fill=Y), horizontal stretching only\n(fill=X), or both (fill=BOTH). By providing these constraints and attachment sides for\nall widgets in a GUI, along with packing order, we can control the layout in fairly precise\nterms. In later chapters, we\u2019ll find that the grid geometry manager uses a different\nresizing protocol entirely, but it provides similar control when needed.\nAll of this can be confusing the first time you hear it, and we\u2019ll return to this later. But\nif you\u2019re not sure what an expand and fill combination will do, simply try it out\u2014this\nis Python, after all. For now, remember that the combination of expand=YES and\nfill=BOTH is perhaps the most common setting; it means \u201cexpand my space allocation\nto occupy all available space on my side, and stretch me to fill the expanded space in\nboth directions.\u201d For our \u201cHello World\u201d example, the net result is that the label grows\nas the window is expanded, and so is always centered.\nConfiguring Widget Options and Window Titles\nSo far, we\u2019ve been telling tkinter what to display on our label by passing its text as a\nkeyword argument in label constructor calls. It turns out that there are two other ways\nto specify widget configuration options. In Example 7-7, the text option of the label is\nset after it is constructed, by assigning to the widget\u2019s text key. Widget objects overload\n(intercept) index operations such that options are also available as mapping keys, much\nlike a dictionary.\nExample 7-7. PP4E\\Gui\\Intro\\gui1f.py\u2014option keys\nfrom tkinter import *\nwidget = Label()\nwidget['text'] = 'Hello GUI world!'\nwidget.pack(side=TOP)\nmainloop()\nMore commonly, widget options can be set after construction by calling the widget\nconfig method, as in Example 7-8.\ntkinter Coding Alternatives | 375Example 7-8. PP4E\\Gui\\Intro\\gui1g.py\u2014config and titles\nfrom tkinter import *\nroot = Tk()\nwidget = Label(root)\nwidget.config(text='Hello GUI world!')\nwidget.pack(side=TOP, expand=YES, fill=BOTH)\nroot.title('gui1g.py')\nroot.mainloop()\nThe config method (which can also be called by its synonym, configure) can be called\nat any time after construction to change the appearance of a widget on the fly. For\ninstance, we could call this label\u2019s config method again later in the script to change the\ntext that it displays; watch for such dynamic reconfigurations in later examples in this\npart of the book.\nNotice that this version also calls a root.title method; this call sets the label that\nappears at the top of the window, as pictured in Figure 7-4. In general terms, top-level\nwindows like the Tk root here export window-manager interfaces\u2014i.e., things that\nhave to do with the border around the window, not its contents.\nFigure 7-4. gui1g with expansion and a window title\nJust for fun, this version also centers the label upon resizes by setting the expand and\nfill pack options. In fact, this version makes just about everything explicit and is more\nrepresentative of how labels are often coded in full-blown interfaces; their parents,\nexpansion policies, and attachments are usually spelled out rather than defaulted.\nOne More for Old Times\u2019 Sake\nFinally, if you are a minimalist and you\u2019re nostalgic for old Python coding styles, you\ncan also program this \u201cHello World\u201d example as in Example 7-9.\nExample 7-9. PP4E\\Gui\\Intro\\gui1-old.py\u2014dictionary calls\nfrom tkinter import *\nLabel(None, {'text': 'Hello GUI world!', Pack: {'side': 'top'}}).mainloop()\n376 | Chapter 7:\u2002Graphical User InterfacesThis makes the window in just two lines, albeit arguably gruesome ones! This scheme\nrelies on an old coding style that was widely used until Python 1.3, which passed \nconfiguration options in a dictionary instead of keyword arguments.# In this scheme,\npacker options can be sent as values of the key Pack (a class in the tkinter module).\nThe dictionary call scheme still works and you may see it in old Python code, but it\u2019s\nprobably best to not do this in code you type. Use keywords to pass options, and use\nexplicit pack method calls in your tkinter scripts instead. In fact, the only reason I didn\u2019t\ncut this example completely is that dictionaries can still be useful if you want to compute\nand pass a set of options dynamically.\nOn the other hand, the func(*pargs, **kargs) syntax now also allows you to pass an\nexplicit dictionary of keyword arguments in its third argument slot:\noptions = {'text': 'Hello GUI world!'}\nlayout  = {'side': 'top'}\nLabel(None, **options).pack(**layout)        # keyword must be strings\nEven in dynamic scenarios where widget options are determined at run time, there\u2019s\nno compelling reason to ever use the pre-1.3 tkinter dictionary call form.\nPacking Widgets Without Saving Them\nIn gui1c.py (shown in Example 7-4), I started packing labels without assigning them to\nnames. This works, and it is an entirely valid coding style, but because it tends to\nconfuse beginners at first glance, I need to explain why it works in more detail here.\nIn tkinter, Python class objects correspond to real objects displayed on a screen; we\nmake the Python object to make a screen object, and we call the Python object\u2019s meth-\nods to configure that screen object. Because of this correspondence, the lifetime of the\nPython object must generally correspond to the lifetime of the corresponding object on\nthe screen.\nLuckily, Python scripts don\u2019t usually have to care about managing object lifetimes. In\nfact, they do not normally need to maintain a reference to widget objects created along\nthe way at all unless they plan to reconfigure those objects later. For instance, it\u2019s\ncommon in tkinter programming to pack a widget immediately after creating it if no\nfurther reference to the widget is required:\nLabel(text='hi').pack()                        # OK\nThis expression is evaluated left to right, as usual. It creates a new label and then im-\nmediately calls the new object\u2019s pack method to arrange it in the display. Notice,\nthough, that the Python Label object is temporary in this expression; because it is not\n#In fact, Python\u2019s pass-by-name keyword arguments were first introduced to help clean up tkinter calls such\nas this one. Internally, keyword arguments really are passed as a dictionary (which can be collected with the\n**name argument form in a def header), so the two schemes are similar in implementation. But they vary\nwidely in the number of characters you need to type and debug.\ntkinter Coding Alternatives | 377assigned to a name, it would normally be garbage collected (destroyed and reclaimed)\nby Python immediately after running its pack method.\nHowever, because tkinter emits Tk calls when objects are constructed, the label will be\ndrawn on the display as expected, even though we haven\u2019t held onto the corresponding\nPython object in our script. In fact, tkinter internally cross-links widget objects into a\nlong-lived tree used to represent the display, so the Label object made during this\nstatement actually is retained, even if not by our code.*\nIn other words, your scripts don\u2019t generally have to care about widget object lifetimes,\nand it\u2019s OK to make widgets and pack them immediately in the same statement without\nmaintaining a reference to them explicitly in your code.\nBut that does not mean that it\u2019s OK to say something like this:\nwidget = Label(text='hi').pack()               # wrong!\n...use widget...\nThis statement almost seems like it should assign a newly packed label to widget, but\nit does not do this. In fact, it\u2019s really a notorious tkinter beginner\u2019s mistake. The widget\npack method packs the widget but does not return the widget thus packed. Really,\npack returns the Python object None; after such a statement, widget will be a reference\nto None, and any further widget operations through that name will fail. For instance,\nthe following fails, too, for the same reason:\nLabel(text='hi').pack().mainloop()             # wrong!\nSince pack returns None, asking for its mainloop attribute generates an exception (as it\nshould). If you really want to both pack a widget and retain a reference to it, say this\ninstead:\nwidget = Label(text='hi')                      # OK too\nwidget.pack()\n...use widget...\nThis form is a bit more verbose but is less tricky than packing a widget in the same\nstatement that creates it, and it allows you to hold onto the widget for later processing.\nIt\u2019s probably more common in realistic scripts that perform more complex widget con-\nfiguration and layouts.\nOn the other hand, scripts that compose layouts often add some widgets once and for\nall when they are created and never need to reconfigure them later; assigning to long-\nlived names in such programs is pointless and unnecessary.\n* Ex-Tcl programmers in the audience may be interested to know that, at least at the time I was writing this\nfootnote, Python not only builds the widget tree internally, but uses it to automatically generate widget\npathname strings coded manually in Tcl/Tk (e.g., .panel.row.cmd). Python uses the addresses of widget class\nobjects to fill in the path components and records pathnames in the widget tree. A label attached to a\ncontainer, for instance, might have an assigned name such as .8220096.8219408 inside tkinter. You don\u2019t have\nto care, though. Simply make and link widget objects by passing parents, and let Python manage pathname\ndetails based on the object tree. See the end of this chapter for more on Tk/tkinter mappings.\n378 | Chapter 7:\u2002Graphical User InterfacesIn Chapter 8, we\u2019ll meet two exceptions to this rule. Scripts must man-\nually retain a reference to image objects because the underlying image\ndata is discarded if the Python image object is garbage collected. tkinter\nvariable class objects also temporarily unset an associated Tk variable if\nreclaimed, but this is uncommon and less harmful.\nAdding Buttons and Callbacks\nSo far, we\u2019ve learned how to display messages in labels, and we\u2019ve met tkinter core\nconcepts along the way. Labels are nice for teaching the basics, but user interfaces\nusually need to do a bit more\u2026like actually responding to users. To show how, the\nprogram in Example 7-10 creates the window in Figure 7-5.\nExample 7-10. PP4E\\Gui\\Intro\\gui2.py\nimport sys\nfrom tkinter import *\nwidget = Button(None, text='Hello widget world', command=sys.exit)\nwidget.pack()\nwidget.mainloop()\nFigure 7-5. A button on the top\nHere, instead of making a label, we create an instance of the tkinter Button class. It\u2019s\nattached to the default top level window as before on the default TOP packing side. But\nthe main thing to notice here is the button\u2019s configuration arguments: we set an option\ncalled command to the sys.exit function.\nFor buttons, the command option is the place where we specify a callback handler func-\ntion to be run when the button is later pressed. In effect, we use command to register an\naction for tkinter to call when a widget\u2019s event occurs. The callback handler used here\nisn\u2019t very interesting: as we learned in Chapter 5, the built-in sys.exit function simply\nshuts down the calling program. Here, that means that pressing this button makes the\nwindow go away.\nJust as for labels, there are other ways to code buttons. Example 7-11 is a version that\npacks the button in place without assigning it to a name, attaches it to the LEFT side of\nits parent window explicitly, and specifies root.quit as the callback handler\u2014a stand-\nard Tk object method that shuts down the GUI and so ends the program. Technically,\nquit ends the current mainloop event loop call, and thus the entire program here; when\nAdding Buttons and Callbacks | 379we start using multiple top-level windows in Chapter 8, we\u2019ll find that quit usually\ncloses all windows, but its relative destroy erases just one window.\nExample 7-11. PP4E\\Gui\\Intro\\gui2b.py\nfrom tkinter import *\nroot = Tk()\nButton(root, text='press', command=root.quit).pack(side=LEFT)\nroot.mainloop()\nThis version produces the window in Figure 7-6. Because we didn\u2019t tell the button to\nexpand into all available space, it does not do so.\nFigure 7-6. A button on the left\nIn both of the last two examples, pressing the button makes the GUI program exit. In\nolder tkinter code, you may sometimes see the string exit assigned to the command option\nto make the GUI go away when pressed. This exploits a tool in the underlying Tk library\nand is less Pythonic than sys.exit or root.quit.\nWidget Resizing Revisited: Expansion\nEven with a GUI this simple, there are many ways to lay out its appearance with tkinter\u2019s\nconstraint-based pack geometry manager. For example, to center the button in its win-\ndow, add an expand=YES option to the button\u2019s pack method call in Example 7-11. The\nline of changed code looks like this:\nButton(root, text='press', command=root.quit).pack(side=LEFT, expand=YES)\nThis makes the packer allocate all available space to the button but does not stretch\nthe button to fill that space. The result is the window captured in Figure 7-7.\nFigure 7-7. pack(side=LEFT, expand=YES)\nIf you want the button to be given all available space and to stretch to fill all of its\nassigned space horizontally, add expand=YES and fill=X keyword arguments to the\npack call. This will create the scene in Figure 7-8.\n380 | Chapter 7:\u2002Graphical User InterfacesThis makes the button fill the whole window initially (its allocation is expanded, and\nit is stretched to fill that allocation). It also makes the button grow as the parent window\nis resized. As shown in Figure 7-9, the button in this window does expand when its\nparent expands, but only along the X horizontal axis.\nFigure 7-9. Resizing with expand=YES, fill=X\nTo make the button grow in both directions, specify both expand=YES and fill=BOTH in\nthe pack call; now resizing the window makes the button grow in general, as shown in\nFigure 7-10. In fact, for more fun, maximize this window to fill the entire screen; you\u2019ll\nget one very big tkinter button indeed.\nFigure 7-10. Resizing with expand=YES, fill=BOTH\nFigure 7-8. pack(side=LEFT, expand=YES, fill=X)\nAdding Buttons and Callbacks | 381In more complex displays, such a button will expand only if all of the widgets it is\ncontained by are set to expand too. Here, the button\u2019s only parent is the Tk root window\nof the program, so parent expandability isn\u2019t yet an issue; in later examples, we\u2019ll need\nto make enclosing Frame widgets expandable too. We will revisit the packer geometry\nmanager when we meet multiple-widget displays that use such devices later in this\ntutorial, and again when we study the alternative grid call in Chapter 9.\nAdding User-Defined Callback Handlers\nIn the simple button examples in the preceding section, the callback handler was simply\nan existing function that killed the GUI program. It\u2019s not much more work to register\ncallback handlers that do something a bit more useful. Example 7-12 defines a callback\nhandler of its own in Python.\nExample 7-12. PP4E\\Gui\\Intro\\gui3.py\nimport sys\nfrom tkinter import *\ndef quit():                                  # a custom callback handler\n    print('Hello, I must be going...')       # kill windows and process\n    sys.exit()\nwidget = Button(None, text='Hello event world', command=quit)\nwidget.pack()\nwidget.mainloop()\nThe window created by this script is shown in Figure 7-11. This script and its GUI are\nalmost identical to the last example. But here, the command option specifies a function\nwe\u2019ve defined locally. When the button is pressed, tkinter calls the quit function in this\nfile to handle the event, passing it zero arguments. Inside quit, the print call statement\ntypes a message on the program\u2019s stdout stream, and the GUI process exits as before.\nFigure 7-11. A button that runs a Python function\nAs usual, stdout is normally the window that the program was started from unless it\u2019s\nbeen redirected to a file. It\u2019s a pop-up DOS console if you run this program by clicking\nit on Windows; add an input call before sys.exit if you have trouble seeing the message\nbefore the pop up disappears. Here\u2019s what the printed output looks like back in\nstandard stream world when the button is pressed; it is generated by a Python function\ncalled automatically by tkinter:\n382 | Chapter 7:\u2002Graphical User InterfacesC:\\...\\PP4E\\Gui\\Intro> python gui3.py\nHello, I must be going...\nC:\\...\\PP4E\\Gui\\Intro>\nNormally, such messages would be displayed in the GUI, but we haven\u2019t gotten far\nenough to know how just yet. Callback functions usually do more, of course (and may\neven pop up new independent windows altogether), but this example illustrates the\nbasics.\nIn general, callback handlers can be any callable object: functions, anonymous func-\ntions generated with lambda expressions, bound methods of class or type instances, or\nclass instances that inherit a __call__ operator overload method. For Button press call-\nbacks, callback handlers always receive no arguments (other than an automatic self,\nfor bound methods); any state information required by the callback handler must be\nprovided in other ways\u2014as global variables, class instance attributes, extra arguments\nprovided by an indirection layer, and so on.\nTo make this a bit more concrete, let\u2019s take a quick look at some other ways to code\nthe callback handler in this example.\nLambda Callback Handlers\nRecall that the Python lambda expression generates a new, unnamed function object\nwhen run. If we need extra data passed in to the handler function, we can register\nlambda expressions to defer the call to the real handler function, and specify the extra\ndata it needs.\nLater in this part of the book, we\u2019ll see how this can be more useful, but to illustrate\nthe basic idea, Example 7-13 shows what Example 7-12 looks like when recoded to use\na lambda instead of a def.\nExample 7-13. PP4E\\Gui\\Intro\\gui3b.py\nimport sys\nfrom tkinter import *                        # lambda generates a function\nwidget = Button(None,                        # but contains just an expression\n             text='Hello event world',\n             command=(lambda: print('Hello lambda world') or sys.exit()) )\nwidget.pack()\nwidget.mainloop()\nThis code is a bit tricky because lambdas can contain only an expression; to emulate\nthe original script, this version uses an or operator to force two expressions to be run\n( print works as the first, because it\u2019s a function call in Python 3.X\u2014we don\u2019t need to\nresort to using sys.stdout directly).\nAdding User-Defined Callback Handlers | 383Deferring Calls with Lambdas and Object References\nMore typically, lambdas are used to provide an indirection layer that passes along extra\ndata to a callback handler (I omit pack and mainloop calls in the following snippets for\nsimplicity):\ndef handler(A, B):              # would normally be called with no args\n    ...use A and B...\nX = 42\nButton(text='ni', command=(lambda: handler(X, 'spam')))      # lambda adds arguments\nAlthough tkinter invokes command callbacks with no arguments, such a lambda can be\nused to provide an indirect anonymous function that wraps the real handler call and\npasses along information that existed when the GUI was first constructed. The call to\nthe real handler is, in effect, deferred, so we can add the extra arguments it requires.\nHere, the value of global variable X and string 'spam' will be passed to arguments A and\nB, even though tkinter itself runs callbacks with no arguments. The net effect is that the\nlambda serves to map a no-argument function call to one with arguments supplied by\nthe lambda.\nIf lambda syntax confuses you, remember that a lambda expression such as the one in\nthe preceding code can usually be coded as a simple def statement instead, nested or\notherwise. In the following code, the second function does exactly the same work as\nthe prior lambda\u2014by referencing it in the button creation call, it effectively defers\ninvocation of the actual callback handler so that extra arguments can be passed:\ndef handler(A, B):              # would normally be called with no args\n    ...use A and B...\nX = 42\ndef func():                     # indirection layer to add arguments\n    handler(X, 'spam')\nButton(text='ni', command=func)\nTo make the need for deferrals more obvious, notice what happens if you code a handler\ncall in the button creation call itself without a lambda or other intermediate function\u2014\nthe callback runs immediately when the button is created, not when it is later clicked.\nThat\u2019s why we need to wrap the call in an intermediate function to defer its invocation:\ndef handler(name):\n    print(name)\nButton(command=handler('spam'))              # BAD: runs the callback now!\nUsing either a lambda or a callable reference serves to defer callback invocation until\nthe event later occurs. For example, using a lambda to pass extra data with an inline\nfunction definition that defers the call:\ndef handler(name):\n    print(name)\n384 | Chapter 7:\u2002Graphical User InterfacesButton(command=(lambda: handler('spam')))    # OK: wrap in a lambda to defer\nis always equivalent to the longer, and to some observers less convenient, double-\nfunction form:\ndef handler(name):\n    print(name)\ndef temp():\n    handler('spam')\nButton(command=temp)                         # OK: refence but do not call\nWe need only the zero-argument lambda or the zero-argument callable reference,\nthough, not both\u2014it makes no sense to code a lambda which simply calls a function if\nno extra data must be passed in and only adds an extra pointless call:\ndef handler(name):\n    print(name)\ndef temp():\n    handler('spam')\nButton(command=(lambda: temp()))             # BAD: this adds a pointless call!\nAs we\u2019ll see later, this includes references to other callables like bound methods and\ncallable instances which retain state in themselves\u2014if they take zero arguments when\ncalled, we can simply name them at widget construction time, and we don\u2019t need to\nwrap them in a superfluous lambda.\nCallback Scope Issues\nAlthough the prior section\u2019s lambda and intermediate function techniques defer calls\nand allow extra data to be passed in, they also raise some scoping issues that may seem\nsubtle at first glance. This is core language territory, but it comes up often in practice\nin conjunction with GUI.\nArguments versus globals\nFor instance, notice that the handler function in the prior section\u2019s initial code could\nalso refer to X directly, because it is a global variable (and would exist by the time the\ncode inside the handler is run). Because of that, we might make the handler a one-\nargument function and pass in just the string 'spam' in the lambda:\ndef handler(A):                           # X is in my global scope, implicitly\n    ...use global X and argument A...\nX = 42\nButton(text='ni', command=(lambda: handler('spam')))\nAdding User-Defined Callback Handlers | 385For that matter, A could be moved out to the global scope too, to remove the need for\nlambda here entirely; we could register the handler itself and cut out the middleman.\nAlthough simple in this trivial example, arguments are generally preferred to globals,\nbecause they make external dependencies more explicit, and so make code easier to\nunderstand and change. In fact, the same handler might be usable in other contexts, if\nwe don\u2019t couple it to global variables\u2019 values. While you\u2019ll have to take it on faith until\nwe step up to larger examples with more complex state retention needs, avoiding glob-\nals in callbacks and GUIs in general both makes them more reusable, and supports the\nnotion of multiple instances in the same program. It\u2019s good programming practice, GUI\nor not.\nPassing in enclosing scope values with default arguments\nMore subtly, notice that if the button in this example was constructed inside a func-\ntion rather than at the top level of the file, name X would no longer be global but would\nbe in the enclosing function\u2019s local scope; it seems as if it would disappear after the\nfunction exits and before the callback event occurs and runs the lambda\u2019s code:\ndef handler(A, B):\n    ...use A and B...\ndef makegui():\n    X = 42\n    Button(text='ni', command=(lambda: handler(X, 'spam')))       # remembers X\nmakegui()\nmainloop()   # makegui's scope is gone by this point\nLuckily, Python\u2019s enclosing scope reference model means that the value of X in the local\nscope enclosing the lambda function is automatically retained, for use later when the\nbutton press occurs. This usually works as we want today, and automatically handles\nvariable references in this role.\nTo make such enclosing scope usage explicit, though, default argument values can also\nbe used to remember the values of variables in the enclosing local scope, even after the\nenclosing function returns. In the following code, for instance, the default argument\nname X (on the left side of the X=X default) will remember object 42, because the variable\nname X (on the right side of the X=X) is evaluated in the enclosing scope, and the gen-\nerated function is later called without any arguments:\ndef handler(A, B):              # older Pythons: defaults save state\n    ...use A and B...\ndef makegui():\n    X = 42\n    Button(text='ni', command=(lambda X=X: handler(X, 'spam')))\nSince default arguments are evaluated and saved when the lambda runs (not when the\nfunction it creates is later called), they are a way to explicitly remember objects that\n386 | Chapter 7:\u2002Graphical User Interfacesmust be accessed again later, during event processing. Because tkinter calls the lambda\nfunction later with no arguments, all its defaults are used.\nThis was not an issue in the original version of this example because name X lived in\nthe global scope, and the code of the lambda will find it there when it is run. When\nnested within a function, though, X may have disappeared after the enclosing function\nexits.\nPassing in enclosing scope values with automatic references\nWhile they can make some external dependencies more explicit, defaults are not usually\nrequired (since Python 2.2, at least) and are not used for this role in best practice code\ntoday. Rather, lambdas simply defer the call to the actual handler and provide extra\nhandler arguments. Variables from the enclosing scope used by the lambda are auto-\nmatically retained, even after the enclosing function exits.\nThe prior code listing, for example, can today normally be coded as we did earlier\u2014\nname X in the handler will be automatically mapped to X in the enclosing scope, and so\neffectively remember what X was when the button was made:\ndef makegui():\n    X = 42                                                    # X is retained auto\n    Button(text='ni', command=(lambda: handler(X, 'spam')))   # no need for defaults\nWe\u2019ll see this technique put to more concrete use later. When using classes to build\nyour GUI, for instance, the self argument is a local variable in methods, and is thus\nautomatically available in the bodies of lambda functions. There is no need to pass it\nin explicitly with defaults:\nclass Gui:\n    def handler(self, A, B):\n        ...use self, A and B...\n    def makegui(self):\n        X = 42\n        Button(text='ni', command=(lambda: self.handler(X, 'spam')))\nGui().makegui()\nmainloop()\nWhen using classes, though, instance attributes can provide extra state for use in call-\nback handlers, and so provide an alternative to extra call arguments. We\u2019ll see how in\na moment. First, though, we need to take a quick non-GUI diversion into a dark corner\nof Python\u2019s scope rules to understand why default arguments are still sometimes nec-\nessary to pass values into nested lambda functions, especially in GUIs.\nBut you must still sometimes use defaults instead of enclosing scopes\nAlthough you may still see defaults used to pass in enclosing scope references in some\nolder Python code, automatic enclosing scope references are generally preferred today.\nIn fact, it seems as though the newer nested scope lookup rules in Python automate\nAdding User-Defined Callback Handlers | 387and replace the previously manual task of passing in enclosing scope values with de-\nfaults altogether.\nWell, almost. There is a catch. It turns out that within a lambda (or def), references to\nnames in the enclosing scope are actually resolved when the generated function is\ncalled, not when it is created. Because of this, when the function is later called, such\nname references will reflect the latest or final assignments made to the names anywhere\nin the enclosing scope, which are not necessarily the values they held when the function\nwas made. This holds true even when the callback function is nested only in a module\u2019s\nglobal scope, not in an enclosing function; in either case, all enclosing scope references\nare resolved at function call time, not at function creation time.\nThis is subtly different from default argument values, which are evaluated once when\nthe function is created, not when it is later called. Because of that, defaults can still be\nuseful for remembering the values of enclosing scope variables as they were when you\nmade the function. Unlike enclosing scope name references, defaults will not have a\ndifferent value if the variable later changes in the enclosing scope, between function\ncreation and call. (In fact, this is why mutable defaults like lists retain their state between\ncalls\u2014they are created only once, when the function is made, and attached to the\nfunction itself.)\nThis is normally a nonissue, because most enclosing scope references name a variable\nthat is assigned just once in the enclosing scope (the self argument in class methods,\nfor example). But this can lead to coding mistakes if not understood, especially if you\ncreate functions within a loop; if those functions reference the loop variable, it will\nevaluate to the value it was given on the last loop iteration in all the functions generated.\nBy contrast, if you use defaults instead, each function will remember the current value\nof the loop variable, not the last.\nBecause of this difference, nested scope references are not always sufficient to remember\nenclosing scope values, and defaults are sometimes still required today. Let\u2019s see what\nthis means in terms of code. Consider the following nested function (this section\u2019s code\nsnippets are saved in file defaults.py in the examples package, if you want to experiment\nwith them).\ndef simple():\n    spam = 'ni'\n    def action():\n        print(spam)         # name maps to enclosing function\n    return action\nact = simple()              # make and return nested function\nact()                       # then call it: prints 'ni'\nThis is the simple case for enclosing scope references, and it works the same way\nwhether the nested function is generated with a def or a lambda. But notice that this\nstill works if we assign the enclosing scope\u2019s spam variable after the nested function is\ncreated:\n388 | Chapter 7:\u2002Graphical User Interfacesdef normal():\n    def action():\n        return spam         # really, looked up when used\n    spam = 'ni'\n    return action\nact = normal()\nprint(act())                # also prints 'ni'\nAs this implies, the enclosing scope name isn\u2019t resolved when the nested function is\nmade\u2014in fact, the name hasn\u2019t even been assigned yet in this example. The name is\nresolved when the nested function is called. The same holds true for lambdas:\ndef weird():\n    spam = 42\n    return (lambda: spam * 2)       # remembers spam in enclosing scope\nact = weird()\nprint(act())                        # prints 84\nSo far, so good. The spam inside this nested lambda function remembers the value that\nthis variable had in the enclosing scope, even after the enclosing scope exits. This pat-\ntern corresponds to a registered GUI callback handler run later on events. But once\nagain, the nested scope reference really isn\u2019t being resolved when the lambda is run to\ncreate the function; it\u2019s being resolved when the generated function is later called. To\nmake that more apparent, look at this code:\ndef weird():\n    tmp = (lambda: spam * 2)        # remembers spam\n    spam = 42                       # even though not set till here\n    return tmp\nact = weird()\nprint(act())                        # prints 84\nHere again, the nested function refers to a variable that hasn\u2019t even been assigned yet\nwhen that function is made. Really, enclosing scope references yield the latest setting\nmade in the enclosing scope, whenever the function is called. Watch what happens in\nthe following code:\ndef weird():\n    spam = 42\n    handler = (lambda: spam * 2)     # func doesn't save 42 now\n    spam = 50\n    print(handler())                 # prints 100: spam looked up now\n    spam = 60\n    print(handler())                 # prints 120: spam looked up again now\nweird()\nNow, the reference to spam inside the lambda is different each time the generated func-\ntion is called! In fact, it refers to what the variable was set to last in the enclosing scope\nat the time the nested function is called, because it is resolved at function call time, not\nat function creation time.\nAdding User-Defined Callback Handlers | 389In terms of GUIs, this becomes significant most often when you generate callback han-\ndlers within loops and try to use enclosing scope references to remember extra data\ncreated within the loops. If you\u2019re going to make functions within a loop, you have to\napply the last example\u2019s behavior to the loop variable:\ndef odd():\n    funcs = []\n    for c in 'abcdefg':\n       funcs.append((lambda: c))      # c will be looked up later\n    return funcs                      # does not remember current c\nfor func in odd():\n    print(func(), end=' ')            # OOPS: print 7 g's, not a,b,c,... !\nHere, the func list simulates registered GUI callback handlers associated with widgets.\nThis doesn\u2019t work the way most people expect it to. The variable c within the nested\nfunction will always be g here, the value that the variable was set to on the final iteration\nof the loop in the enclosing scope. The net effect is that all seven generated lambda\nfunctions wind up with the same extra state information when they are later called.\nAnalogous GUI code that adds information to lambda callback handlers will have sim-\nilar problems\u2014all buttons created in a loop, for instance, may wind up doing the same\nthing when clicked! To make this work, we still have to pass values into the nested\nfunction with defaults in order to save the current value of the loop variable (not its\nfuture value):\ndef odd():\n    funcs = []\n    for c in 'abcdefg':\n       funcs.append((lambda c=c: c))    # force to remember c now\n    return funcs                        # defaults eval now\nfor func in odd():\n    print(func(), end=' ')              # OK: now prints a,b,c,...\nThis works now only because the default, unlike an external scope reference, is evalu-\nated at function creation time, not at function call time. It remembers the value that a\nname in the enclosing scope had when the function was made, not the last assignment\nmade to that name anywhere in the enclosing scope. The same is true even if the func-\ntion\u2019s enclosing scope is a module, not another function; if we don\u2019t use the default\nargument in the following code, the loop variable will resolve to the same value in all\nseven functions:\nfuncs = []                              # enclosing scope is module\nfor c in 'abcdefg':                     # force to remember c now\n   funcs.append((lambda c=c: c))        # else prints 7 g's again\nfor func in funcs:\n    print(func(), end=' ')              # OK: prints a,b,c,...\nThe moral of this story is that enclosing scope name references are a replacement for\npassing values in with defaults, but only as long as the name in the enclosing scope will\n390 | Chapter 7:\u2002Graphical User Interfacesnot change to a value you don\u2019t expect after the nested function is created. You cannot\ngenerally reference enclosing scope loop variables within a nested function, for exam-\nple, because they will change as the loop progresses. In most other cases, though, en-\nclosing scope variables will take on only one value in their scope and so can be used\nfreely.\nWe\u2019ll see this phenomenon at work in later examples that construct larger GUIs. For\nnow, remember that enclosing scopes are not a complete replacement for defaults;\ndefaults are still required in some contexts to pass values into callback functions. Also\nkeep in mind that classes are often a better and simpler way to retain extra state for use\nin callback handlers than are nested functions. Because state is explicit in classes, these\nscope issues do not apply. The next two sections cover this in detail.\nBound Method Callback Handlers\nLet\u2019s get back to coding GUIs. Although functions and lambdas suffice in many cases,\nbound methods of class instances work particularly well as callback handlers in GUIs\u2014\nthey record both an instance to send the event to and an associated method to call. For\ninstance, Example 7-14 shows Examples 7-12 and 7-13 rewritten to register a bound\nclass method rather than a function or lambda result.\nExample 7-14. PP4E\\Gui\\Intro\\gui3c.py\nimport sys\nfrom tkinter import *\nclass HelloClass:\n    def __init__(self):\n        widget = Button(None, text='Hello event world', command=self.quit)\n        widget.pack()\n    def quit(self):\n        print('Hello class method world')   # self.quit is a bound method\n        sys.exit()                          # retains the self+quit pair\nHelloClass()\nmainloop()\nOn a button press, tkinter calls this class\u2019s quit method with no arguments, as usual.\nBut really, it does receive one argument\u2014the original self object\u2014even though tkinter\ndoesn\u2019t pass it explicitly. Because the self.quit bound method retains both self and\nquit, it\u2019s compatible with a simple function call; Python automatically passes the\nself argument along to the method function. Conversely, registering an unbound in-\nstance method that expects an argument, such as HelloClass.quit, won\u2019t work, be-\ncause there is no self object to pass along when the event later occurs.\nAdding User-Defined Callback Handlers | 391Later, we\u2019ll see that class callback handler coding schemes provide a natural place to\nremember information for use on events\u2014simply assign the information to self\ninstance attributes:\nclass someGuiClass:\n    def __init__(self):\n        self.X = 42\n        self.Y = 'spam'\n        Button(text='Hi', command=self.handler)\n    def handler(self):\n        ...use self.X, self.Y...\nBecause the event will be dispatched to this class\u2019s method with a reference to the\noriginal instance object, self gives access to attributes that retain original data. In effect,\nthe instance\u2019s attributes retain state information to be used when events occur. Espe-\ncially in larger GUIs, this is a much more flexible technique than global variables or\nextra arguments added by lambdas.\nCallable Class Object Callback Handlers\nBecause Python class instance objects can also be called if they inherit a __call__\nmethod to intercept the operation, we can pass one of these to serve as a callback\nhandler too. Example 7-15 shows a class that provides the required function-like\ninterface.\nExample 7-15. PP4E\\Gui\\Intro\\gui3d.py\nimport sys\nfrom tkinter import *\nclass HelloCallable:\n    def __init__(self):                        # __init__ run on object creation\n        self.msg = 'Hello __call__ world'\n    def __call__(self):\n        print(self.msg)                        # __call__ run later when called\n        sys.exit()                             # class object looks like a function\nwidget = Button(None, text='Hello event world', command=HelloCallable())\nwidget.pack()\nwidget.mainloop()\nHere, the HelloCallable instance registered with command can be called like a normal\nfunction; Python invokes its __call__ method to handle the call operation made in\ntkinter on the button press. In effect, the general __call__ method replaces a specific\nbound method in this case. Notice how self.msg is used to retain information for use\non events here; self is the original instance when the special __call__ method is au-\ntomatically invoked.\nAll four gui3 variants create the same sort of GUI window (Figure 7-11), but print\ndifferent messages to stdout when their button is pressed:\n392 | Chapter 7:\u2002Graphical User InterfacesC:\\...\\PP4E\\Gui\\Intro> python gui3.py\nHello, I must be going...\nC:\\...\\PP4E\\Gui\\Intro> python gui3b.py\nHello lambda world\nC:\\...\\PP4E\\Gui\\Intro> python gui3c.py\nHello class method world\nC:\\...\\PP4E\\Gui\\Intro> python gui3d.py\nHello __call__ world\nThere are good reasons for each callback coding scheme (function, lambda, class\nmethod, callable class), but we need to move on to larger examples in order to uncover\nthem in less theoretical terms.\nOther tkinter Callback Protocols\nFor future reference, also keep in mind that using command options to intercept user-\ngenerated button press events is just one way to register callbacks in tkinter. In fact,\nthere are a variety of ways for tkinter scripts to catch events:\nButton command options\nAs we\u2019ve just seen, button press events are intercepted by providing a callable object\nin widget command options. This is true of other kinds of button-like widgets we\u2019ll\nmeet in Chapter 8 (e.g., radio and check buttons and scales).\nMenu command options\nIn the upcoming tkinter tour chapters, we\u2019ll also find that a command option is used\nto specify callback handlers for menu selections.\nScroll bar protocols\nScroll bar widgets register handlers with command options, too, but they have a\nunique event protocol that allows them to be cross-linked with the widget they are\nmeant to scroll (e.g., listboxes, text displays, and canvases): moving the scroll bar\nautomatically moves the widget, and vice versa.\nGeneral widget bind methods\nA more general tkinter event bind method mechanism can be used to register call-\nback handlers for lower-level interface events\u2014key presses, mouse movement and\nclicks, and so on. Unlike command callbacks, bind callbacks receive an event object\nargument (an instance of the tkinter Event class) that gives context about the\nevent\u2014subject widget, screen coordinates, and so on.\nWindow manager protocols\nIn addition, scripts can also intercept window manager events (e.g., window close\nrequests) by tapping into the window manager protocol method mechanism avail-\nable on top-level window objects. Setting a handler for WM_DELETE_WINDOW, for in-\nstance, takes over window close buttons.\nAdding User-Defined Callback Handlers | 393Scheduled event callbacks\nFinally, tkinter scripts can also register callback handlers to be run in special con-\ntexts, such as timer expirations, input data arrival, and event-loop idle states.\nScripts can also pause for state-change events related to windows and special var-\niables. We\u2019ll meet these event interfaces in more detail near the end of Chapter 9.\nBinding Events\nOf all the options listed in the prior section, bind is the most general, but also perhaps\nthe most complex. We\u2019ll study it in more detail later, but to let you sample its flavor\nnow, Example 7-16 rewrites the prior section\u2019s GUI again to use bind, not the\ncommand keyword, to catch button presses.\nExample 7-16. PP4E\\Gui\\Intro\\gui3e.py\nimport sys\nfrom tkinter import *\ndef hello(event):\n    print('Press twice to exit')             # on single-left click\ndef quit(event):                             # on double-left click\n    print('Hello, I must be going...')       # event gives widget, x/y, etc.\n    sys.exit()\nwidget = Button(None, text='Hello event world')\nwidget.pack()\nwidget.bind('<Button-1>', hello)             # bind left mouse clicks\nwidget.bind('<Double-1>', quit)              # bind double-left clicks\nwidget.mainloop()\nIn fact, this version doesn\u2019t specify a command option for the button at all. Instead, it\nbinds lower-level callback handlers for both left mouse clicks (<Button-1>) and double-\nleft mouse clicks (<Double-1>) within the button\u2019s display area. The bind method ac-\ncepts a large set of such event identifiers in a variety of formats, which we\u2019ll meet in\nChapter 8.\nWhen run, this script makes the same window as before (see Figure 7-11). Clicking on\nthe button once prints a message but doesn\u2019t exit; you need to double-click on the\nbutton now to exit as before. Here is the output after clicking twice and double-clicking\nonce (a double-click fires the single-click callback first):\nC:\\...\\PP4E\\Gui\\Intro> python gui3e.py\nPress twice to exit\nPress twice to exit\nPress twice to exit\nHello, I must be going...\nAlthough this script intercepts button clicks manually, the end result is roughly the\nsame; widget-specific protocols such as button command options are really just higher-\nlevel interfaces to events you can also catch with bind.\n394 | Chapter 7:\u2002Graphical User InterfacesWe\u2019ll meet bind and all of the other tkinter event callback handler hooks again in more\ndetail later in this book. First, though, let\u2019s focus on building GUIs that are larger than\na single button and explore a few other ways to use classes in GUI work.\nAdding Multiple Widgets\nIt\u2019s time to start building user interfaces with more than one widget. Example 7-17\nmakes the window shown in Figure 7-12.\nExample 7-17. PP4E\\Gui\\Intro\\gui4.py\nfrom tkinter import *\ndef greeting():\n    print('Hello stdout world!...')\nwin = Frame()\nwin.pack()\nLabel(win,  text='Hello container world').pack(side=TOP)\nButton(win, text='Hello', command=greeting).pack(side=LEFT)\nButton(win, text='Quit',  command=win.quit).pack(side=RIGHT)\nwin.mainloop()\nFigure 7-12. A multiple-widget window\nThis example makes a Frame widget (another tkinter class) and attaches three other\nwidget objects to it, a Label and two Buttons, by passing the Frame as their first argu-\nment. In tkinter terms, we say that the Frame becomes a parent to the other three\nwidgets. Both buttons on this display trigger callbacks:\n\u2022 Pressing the Hello button triggers the greeting function defined within this file,\nwhich prints to stdout again.\n\u2022 Pressing the Quit button calls the standard tkinter quit method, inherited by win\nfrom the Frame class (Frame.quit has the same effect as the Tk.quit we used earlier).\nHere is the stdout text that shows up on Hello button presses, wherever this script\u2019s\nstandard streams may be:\nC:\\...\\PP4E\\Gui\\Intro> python gui4.py\nHello stdout world!...\nHello stdout world!...\nAdding Multiple Widgets | 395Hello stdout world!...\nHello stdout world!...\nThe notion of attaching widgets to containers turns out to be at the core of layouts in\ntkinter. Before we go into more detail on that topic, though, let\u2019s get small.\nWidget Resizing Revisited: Clipping\nEarlier, we saw how to make widgets expand along with their parent window, by pass-\ning expand and fill options to the pack geometry manager. Now that we have a window\nwith more than one widget, I can let you in on one of the more useful secrets in the\npacker. As a rule, widgets packed first are clipped last when a window is shrunk. That\nis, the order in which you pack items determines which items will be cut out of the\ndisplay if it is made too small. Widgets packed later are cut out first. For example,\nFigure 7-13 shows what happens when the gui4 window is shrunk interactively.\nFigure 7-13. gui4 gets small\nTry reordering the label and button lines in the script and see what happens when the\nwindow shrinks; the first one packed is always the last to go away. For instance, if the\nlabel is packed last, Figure 7-14 shows that it is clipped first, even though it is attached\nto the top: side attachments and packing order both impact the overall layout, but only\npacking order matters when windows shrink. Here are the changed lines:\nButton(win, text='Hello', command=greeting).pack(side=LEFT)\nButton(win, text='Quit',  command=win.quit).pack(side=RIGHT)\nLabel(win,  text='Hello container world').pack(side=TOP)\nFigure 7-14. Label packed last, clipped first\ntkinter keeps track of the packing order internally to make this work. Scripts can plan\nahead for shrinkage by calling pack methods of more important widgets first. For in-\nstance, on the upcoming tkinter tour, we\u2019ll meet code that builds menus and toolbars\nat the top and bottom of the window; to make sure these are lost last as a window is\nshrunk, they are packed first, before the application components in the middle.\n396 | Chapter 7:\u2002Graphical User InterfacesSimilarly, displays that include scroll bars normally pack them before the items they\nscroll (e.g., text, lists) so that the scroll bars remain as the window shrinks.\nAttaching Widgets to Frames\nIn larger terms, the critical innovation in this example is its use of frames: Frame widgets\nare just containers for other widgets, and so give rise to the notion of GUIs as widget\nhierarchies, or trees. Here, win serves as an enclosing window for the other three\nwidgets. In general, though, by attaching widgets to frames, and frames to other frames,\nwe can build up arbitrary GUI layouts. Simply divide the user interface into a set of\nincreasingly smaller rectangles, implement each as a tkinter Frame, and attach basic\nwidgets to the frame in the desired screen position.\nIn this script, when you specify win in the first argument to the Label and Button con-\nstructors, tkinter attaches them to the Frame (they become children of the win parent).\nwin itself is attached to the default top-level window, since we didn\u2019t pass a parent to\nthe Frame constructor. When we ask win to run itself (by calling mainloop), tkinter draws\nall the widgets in the tree we\u2019ve built.\nThe three child widgets also provide pack options now: the side arguments tell which\npart of the containing frame (i.e., win) to attach the new widget to. The label hooks\nonto the top, and the buttons attach to the sides. TOP, LEFT, and RIGHT are all preassigned\nstring variables imported from tkinter. Arranging widgets is a bit subtler than simply\ngiving a side, though, but we need to take a quick detour into packer geometry man-\nagement details to see why.\nLayout: Packing Order and Side Attachments\nWhen a widget tree is displayed, child widgets appear inside their parents and are\narranged according to their order of packing and their packing options. Because of this,\nthe order in which widgets are packed not only gives their clipping order, but also\ndetermines how their side settings play out in the generated display.\nHere\u2019s how the packer\u2019s layout system works:\n1. The packer starts out with an available space cavity that includes the entire parent\ncontainer (e.g., the whole Frame or top-level window).\n2. As each widget is packed on a side, that widget is given the entire requested side\nin the remaining space cavity, and the space cavity is shrunk.\n3. Later pack requests are given an entire side of what is left, after earlier pack requests\nhave shrunk the cavity.\n4. After widgets are given cavity space, expand divides any space left, and fill and\nanchor stretch and position widgets within their assigned space.\nAdding Multiple Widgets | 397For instance, if you recode the gui4 child widget creation logic like this:\nButton(win, text='Hello', command=greeting).pack(side=LEFT)\nLabel(win,  text='Hello container world').pack(side=TOP)\nButton(win, text='Quit',  command=win.quit).pack(side=RIGHT)\nyou will wind up with the very different display shown in Figure 7-15, even though\nyou\u2019ve moved the label code only one line down in the source file (contrast with\nFigure 7-12).\nFigure 7-15. Packing the label second\nDespite its side setting, the label does not get the entire top of the window now, and\nyou have to think in terms of shrinking cavities to understand why. Because the Hello\nbutton is packed first, it is given the entire LEFT side of the Frame. Next, the label is given\nthe entire TOP side of what is left. Finally, the Quit button gets the RIGHT side of the\nremainder\u2014a rectangle to the right of the Hello button and under the label. When this\nwindow shrinks, widgets are clipped in reverse order of their packing: the Quit button\ndisappears first, followed by the label.\u2020\nIn the original version of this example (Figure 7-12), the label spans the entire top side\njust because it is the first one packed, not because of its side option. In fact, if you look\nat Figure 7-14 closely, you\u2019ll see that it illustrates the same point\u2014the label appeared\nbetween the buttons, because they had already carved off the entire left and right sides.\nThe Packer\u2019s Expand and Fill Revisited\nBeyond the effects of packing order, the fill option we met earlier can be used to stretch\nthe widget to occupy all the space in the cavity side it has been given, and any cavity\nspace left after all packing is evenly allocated among widgets with the expand=YES we\nsaw before. For example, coding this way creates the window in Figure 7-16 (compare\nthis to Figure 7-15):\nButton(win, text='Hello', command=greeting).pack(side=LEFT,fill=Y)\nLabel(win,  text='Hello container world').pack(side=TOP)\nButton(win, text='Quit', command=win.quit).pack(side=RIGHT, expand=YES, fill=X)\n\u2020 Technically, the packing steps are just rerun again after a window resize. But since this means that there won\u2019t\nbe enough space left for widgets packed last when the window shrinks, it is as if widgets packed first are\nclipped last.\n398 | Chapter 7:\u2002Graphical User InterfacesTo make all of these grow along with their window, though, we also need to make the\ncontainer frame expandable; widgets expand beyond their initial packer arrangement\nonly if all of their parents expand, too. Here are the changes in gui4.py:\nwin = Frame()\nwin.pack(side=TOP, expand=YES, fill=BOTH)\nButton(win, text='Hello', command=greeting).pack(side=LEFT, fill=Y)\nLabel(win,  text='Hello container world').pack(side=TOP)\nButton(win, text='Quit', command=win.quit).pack(side=RIGHT, expand=YES,fill=X)\nWhen this code runs, the Frame is assigned the entire top side of its parent as before\n(that is, the top parcel of the root window); but because it is now marked to expand\ninto unused space in its parent and to fill that space both ways, it and all of its attached\nchildren expand along with the window. Figure 7-17 shows how.\nFigure 7-17. gui4 gets big with an expandable frame\nUsing Anchor to Position Instead of Stretch\nAnd as if that isn\u2019t flexible enough, the packer also allows widgets to be positioned\nwithin their allocated space with an anchor option, instead of filling that space with a\nfill. The anchor option accepts tkinter constants identifying all eight points of the\ncompass (N, NE, NW, S, etc.) and CENTER as its value (e.g., anchor=NW). It instructs the packer\nto position the widget at the desired position within its allocated space, if the space\nallocated for the widget is larger than the space needed to display the widget.\nFigure 7-16. Packing with expand and fill options\nAdding Multiple Widgets | 399The default anchor is CENTER, so widgets show up in the middle of their space (the cavity\nside they were given) unless they are positioned with anchor or stretched with fill. To\ndemonstrate, change gui4 to use this sort of code:\nButton(win, text='Hello', command=greeting).pack(side=LEFT, anchor=N)\nLabel(win,  text='Hello container world').pack(side=TOP)\nButton(win, text='Quit',  command=win.quit).pack(side=RIGHT)\nThe only thing new here is that the Hello button is anchored to the north side of its\nspace allocation. Because this button was packed first, it got the entire left side of the\nparent frame. This is more space than is needed to show the button, so it shows up in\nthe middle of that side by default, as in Figure 7-15 (i.e., anchored to the center). Setting\nthe anchor to N moves it to the top of its side, as shown in Figure 7-18.\nFigure 7-18. Anchoring a button to the north\nKeep in mind that fill and anchor are applied after a widget has been allocated cavity\nside space by its side, packing order, and expand extra space request. By playing with\npacking orders, sides, fills, and anchors, you can generate lots of layout and clipping\neffects, and you should take a few moments to experiment with alternatives if you\nhaven\u2019t already. In the original version of this example, for instance, the label spans the\nentire top side just because it is the first packed.\nAs we\u2019ll see later, frames can be nested in other frames, too, in order to make more\ncomplex layouts. In fact, because each parent container is a distinct space cavity, this\nprovides a sort of escape mechanism for the packer cavity algorithm: to better control\nwhere a set of widgets show up, simply pack them within a nested subframe and attach\nthe frame as a package to a larger container. A row of push buttons, for example, might\nbe easier laid out in a frame of its own than if mixed with other widgets in the display\ndirectly.\nFinally, also keep in mind that the widget tree created by these examples is really an\nimplicit one; tkinter internally records the relationships implied by passed parent\nwidget arguments. In OOP terms, this is a composition relationship\u2014the Frame contains\na Label and Buttons. Let\u2019s look at inheritance relationships next.\nCustomizing Widgets with Classes\nYou don\u2019t have to use OOP in tkinter scripts, but it can definitely help. As we just saw,\ntkinter GUIs are built up as class-instance object trees. Here\u2019s another way Python\u2019s\n400 | Chapter 7:\u2002Graphical User InterfacesOOP features can be applied to GUI models: specializing widgets by inheritance.\nExample 7-18 builds the window in Figure 7-19.\nExample 7-18. PP4E\\Gui\\Intro\\gui5.py\nfrom tkinter import *\nclass HelloButton(Button):\n    def __init__(self, parent=None, **config):         # add callback method\n        Button.__init__(self, parent, **config)        # and pack myself\n        self.pack()                                    # could config style too\n        self.config(command=self.callback)\n    def callback(self):                                # default press action\n        print('Goodbye world...')                      # replace in subclasses\n        self.quit()\nif __name__ == '__main__':\n    HelloButton(text='Hello subclass world').mainloop()\nFigure 7-19. A button subclass in action\nThis example isn\u2019t anything special to look at: it just displays a single button that, when\npressed, prints a message and exits. But this time, it is a button widget we created on\nour own. The HelloButton class inherits everything from the tkinter Button class, but\nadds a callback method and constructor logic to set the command option to\nself.callback, a bound method of the instance. When the button is pressed this time,\nthe new widget class\u2019s callback method, not a simple function, is invoked.\nThe **config argument here is assigned unmatched keyword arguments in a dictionary,\nso they can be passed along to the Button constructor. The **config in the Button\nconstructor call unpacks the dictionary back into keyword arguments (it\u2019s actually\noptional here, because of the old-style dictionary widget call form we met earlier, but\ndoesn\u2019t hurt). We met the config widget method called in HelloButton\u2019s constructor\nearlier; it is just an alternative way to pass configuration options after the fact (instead\nof passing constructor arguments).\nStandardizing Behavior and Appearance\nSo what\u2019s the point of subclassing widgets like this? In short, it allows sets of widgets\nmade from the customized classes to look and act the same. When coded well, we get\nboth \u201cfor free\u201d from Python\u2019s OOP model. This can be a powerful technique in larger\nprograms.\nCustomizing Widgets with Classes | 401Common behavior\nExample 7-18 standardizes behavior\u2014it allows widgets to be configured by subclassing\ninstead of by passing in options. In fact, its HelloButton is a true button; we can pass\nin configuration options such as its text as usual when one is made. But we can also\nspecify callback handlers by overriding the callback method in subclasses, as shown\nin Example 7-19.\nExample 7-19. PP4E\\Gui\\Intro\\gui5b.py\nfrom gui5 import HelloButton\nclass MyButton(HelloButton):        # subclass HelloButton\n    def callback(self):             # redefine press-handler method\n        print(\"Ignoring press!...\")\nif __name__ == '__main__':\n    MyButton(None, text='Hello subclass world').mainloop()\nThis script makes the same window; but instead of exiting, this MyButton button, when\npressed, prints to stdout and stays up. Here is its standard output after being pressed\na few times:\nC:\\...\\PP4E\\Gui\\Intro> python gui5b.py\nIgnoring press!...\nIgnoring press!...\nIgnoring press!...\nIgnoring press!...\nWhether it\u2019s simpler to customize widgets by subclassing or passing in options is prob-\nably a matter of taste in this simple example. But the larger point to notice is that Tk\nbecomes truly object oriented in Python, just because Python is object oriented\u2014we\ncan specialize widget classes using normal class-based and object-oriented techniques.\nIn fact this applies to both widget behavior and appearance.\nCommon appearance\nFor example, although we won\u2019t study widget configuration options until the next\nchapter, a similar customized button class could provide a standard look-and-feel\ndifferent from tkinter\u2019s defaults for every instance created from it, and approach the\nnotions of \u201cstyles\u201d or \u201cthemes\u201d in some GUI toolkits:\nclass ThemedButton(Button):                             # config my style too\n    def __init__(self, parent=None, **configs):         # used for each instance\n        Button.__init__(self, parent, **configs)        # see chapter 8 for options\n        self.pack()\n        self.config(fg='red', bg='black', font=('courier', 12), relief=RAISED, bd=5)\nB1 = ThemedButton(text='spam', command=onSpam)  # normal button widget objects\nB2 = ThemedButton(text='eggs')                  # but same appearance by inheritance\nB2.pack(expand=YES, fill=BOTH)\n402 | Chapter 7:\u2002Graphical User InterfacesThis code is something of a preview; see file gui5b-themed.py in the examples package\nfor a complete version, and watch for more on its widget configuration options in\nChapter 8. But it illustrates the application of common appearance by subclassing\nwidgets directly\u2014every button created from its class looks the same, and will pick up\nany future changes in its configurations automatically.\nWidget subclasses are a programmer\u2019s tool, of course, but we can also make such con-\nfigurations accessible to a GUI\u2019s users. In larger programs later in the book (e.g., PyEdit,\nPyClock, and PyMailGUI), we\u2019ll sometimes achieve a similar effect by importing con-\nfigurations from modules and applying them to widgets as they are built. If such ex-\nternal settings are used by a customized widget subclass like our ThemedButton above,\nthey will again apply to all its instances and subclasses (for reference, the full version\nof the following code is in file gui5b-themed-user.py):\nfrom user_preferences import bcolor, bfont, bsize   # get user settings\nclass ThemedButton(Button):\n    def __init__(self, parent=None, **configs):\n        Button.__init__(self, parent, **configs)\n        self.pack()\n        self.config(bg=bcolor, font=(bfont, bsize))\nThemedButton(text='spam', command=onSpam)  # normal button widget objects\nThemedButton(text='eggs', command=onEggs)  # all inherit user preferences\nclass MyButton(ThemedButton):              # subclasses inherit prefs too\n    def __init__(self, parent=None, **configs):\n        ThemedButton.__init__(self, parent,  **configs)\n        self.config(text='subclass')\nMyButton(command=onSpam)\nAgain, more on widget configuration in the next chapter; the big picture to take away\nhere is that customizing widget classes with subclasses allows us to tailor both their\nbehavior and their appearance for an entire set of widgets. The next example provides\nyet another way to arrange for specialization\u2014as customizable and attachable widget\npackages, usually known as components.\nReusable GUI Components with Classes\nLarger GUI interfaces are often built up as subclasses of Frame, with callback handlers\nimplemented as methods. This structure gives us a natural place to store information\nbetween events: instance attributes record state. It also allows us to both specialize\nGUIs by overriding their methods in new subclasses and attach them to larger GUI\nstructures to reuse them as general components. For instance, a GUI text editor im-\nplemented as a Frame subclass can be attached to and configured by any number of\nother GUIs; if done well, we can plug such a text editor into any user interface that\nneeds text editing tools.\nReusable GUI Components with Classes | 403We\u2019ll meet such a text editor component in Chapter 11. For now, Example 7-20 illus-\ntrates the concept in a simple way. The script gui6.py produces the window in\nFigure 7-20.\nExample 7-20. PP4E\\Gui\\Intro\\gui6.py\nfrom tkinter import *\nclass Hello(Frame):                              # an extended Frame\n    def __init__(self, parent=None):\n        Frame.__init__(self, parent)             # do superclass init\n        self.pack()\n        self.data = 42\n        self.make_widgets()                      # attach widgets to self\n    def make_widgets(self):\n        widget = Button(self, text='Hello frame world!', command=self.message)\n        widget.pack(side=LEFT)\n    def message(self):\n        self.data += 1\n        print('Hello frame world %s!' % self.data)\nif __name__ == '__main__': Hello().mainloop()\nFigure 7-20. A custom Frame in action\nThis example pops up a single-button window. When pressed, the button triggers the\nself.message bound method to print to stdout again. Here is the output after pressing\nthis button four times; notice how self.data (a simple counter here) retains its state\nbetween presses:\nC:\\...\\PP4E\\Gui\\Intro> python gui6.py\nHello frame world 43!\nHello frame world 44!\nHello frame world 45!\nHello frame world 46!\nThis may seem like a roundabout way to show a Button (we did it in fewer lines in\nExamples 7-10, 7-11, and 7-12). But the Hello class provides an enclosing organiza-\ntional structure for building GUIs. In the examples prior to the last section, we made\nGUIs using a function-like approach: we called widget constructors as though they\nwere functions and hooked widgets together manually by passing in parents to widget\nconstruction calls. There was no notion of an enclosing context, apart from the global\n404 | Chapter 7:\u2002Graphical User Interfacesscope of the module file containing the widget calls. This works for simple GUIs but\ncan make for brittle code when building up larger GUI structures.\nBut by subclassing Frame as we\u2019ve done here, the class becomes an enclosing context\nfor the GUI:\n\u2022 Widgets are added by attaching objects to self, an instance of a Frame container\nsubclass (e.g., Button).\n\u2022 Callback handlers are registered as bound methods of self, and so are routed back\nto code in the class (e.g., self.message).\n\u2022 State information is retained between events by assigning to attributes of self,\nvisible to all callback methods in the class (e.g., self.data).\n\u2022 It\u2019s easy to make multiple copies of such a GUI component, even within the same\nprocess, because each class instance is a distinct namespace.\n\u2022 Classes naturally support customization by inheritance and by composition\nattachment.\nIn a sense, entire GUIs become specialized Frame objects with extensions for an appli-\ncation. Classes can also provide protocols for building widgets (e.g., the\nmake_widgets method here), handle standard configuration chores (like setting window\nmanager options), and so on. In short, Frame subclasses provide a simple way to or-\nganize collections of other widget-class objects.\nAttaching Class Components\nPerhaps more importantly, subclasses of Frame are true widgets: they can be further\nextended and customized by subclassing and can be attached to enclosing widgets. For\ninstance, to attach the entire package of widgets that a class builds to something else,\nsimply create an instance of the class with a real parent widget passed in. To illustrate,\nrunning the script in Example 7-21 creates the window shown in Figure 7-21.\nExample 7-21. PP4E\\Gui\\Intro\\gui6b.py\nfrom sys import exit\nfrom tkinter import *                    # get Tk widget classes\nfrom gui6 import Hello                   # get the subframe class\nparent = Frame(None)                     # make a container widget\nparent.pack()\nHello(parent).pack(side=RIGHT)           # attach Hello instead of running it\nButton(parent, text='Attach', command=exit).pack(side=LEFT)\nparent.mainloop()\nReusable GUI Components with Classes | 405Figure 7-21. An attached class component on the right\nThis script just adds Hello\u2019s button to the right side of parent\u2014a container Frame. In\nfact, the button on the right in this window represents an embedded component: its\nbutton really represents an attached Python class object. Pressing the embedded class\u2019s\nbutton on the right prints a message as before; pressing the new button exits the GUI\nby a sys.exit call:\nC:\\...\\PP4E\\Gui\\Intro> python gui6b.py\nHello frame world 43!\nHello frame world 44!\nHello frame world 45!\nHello frame world 46!\nIn more complex GUIs, we might instead attach large Frame subclasses to other con-\ntainer components and develop each independently. For instance, Example 7-22 is yet\nanother specialized Frame itself, but it attaches an instance of the original Hello class in\na more object-oriented fashion. When run as a top-level program, it creates a window\nidentical to the one shown in Figure 7-21.\nExample 7-22. PP4E\\Gui\\Intro\\gui6c.py\nfrom tkinter import *                    # get Tk widget classes\nfrom gui6 import Hello                   # get the subframe class\nclass HelloContainer(Frame):\n    def __init__(self, parent=None):\n        Frame.__init__(self, parent)\n        self.pack()\n        self.makeWidgets()\n    def makeWidgets(self):\n        Hello(self).pack(side=RIGHT)     # attach a Hello to me\n        Button(self, text='Attach', command=self.quit).pack(side=LEFT)\nif __name__ == '__main__': HelloContainer().mainloop()\nThis looks and works exactly like gui6b but registers the added button\u2019s callback han-\ndler as self.quit, which is just the standard quit widget method this class inherits from\nFrame. The window this time represents two Python classes at work\u2014the embedded\ncomponent\u2019s widgets on the right (the original Hello button) and the container\u2019s\nwidgets on the left.\nNaturally, this is a simple example (we attached only a single button here, after all).\nBut in more practical user interfaces, the set of widget class objects attached in this way\n406 | Chapter 7:\u2002Graphical User Interfacescan be much larger. If you imagine replacing the Hello call in this script with a call to\nattach an already coded and fully debugged calculator object, you\u2019ll begin to better\nunderstand the power of this paradigm. If we code all of our GUI components as classes,\nthey automatically become a library of reusable widgets, which we can combine in other\napplications as often as we like.\nExtending Class Components\nWhen GUIs are built with classes, there are a variety of ways to reuse their code in other\ndisplays. To extend Hello instead of attaching it, we just override some of its methods\nin a new subclass (which itself becomes a specialized Frame widget). This technique is\nshown in Example 7-23.\nExample 7-23. PP4E\\Gui\\Intro\\gui6d.py\nfrom tkinter import *\nfrom gui6 import Hello\nclass HelloExtender(Hello):\n    def make_widgets(self):                       # extend method here\n        Hello.make_widgets(self)\n        Button(self, text='Extend', command=self.quit).pack(side=RIGHT)\n    def message(self):\n        print('hello', self.data)                 # redefine method here\nif __name__ == '__main__': HelloExtender().mainloop()\nThis subclass\u2019s make_widgets method here first builds the superclass\u2019s widgets and then\nadds a second Extend button on the right, as shown in Figure 7-22.\nFigure 7-22. A customized class\u2019s widgets, on the left\nBecause it redefines the message method, pressing the original superclass\u2019s button on\nthe left now prints a different string to stdout (when searching up from self, the\nmessage attribute is found first in this subclass, not in the superclass):\nC:\\...\\PP4E\\Gui\\Intro> python gui6d.py\nhello 42\nhello 42\nhello 42\nhello 42\nBut pressing the new Extend button on the right, which is added by this subclass, exits\nimmediately, since the quit method (inherited from Hello, which inherits it from\nReusable GUI Components with Classes | 407Frame) is the added button\u2019s callback handler. The net effect is that this class customizes \nthe original to add a new button and change message\u2019s behavior.\nAlthough this example is simple, it demonstrates a technique that can be powerful in \npractice: to change a GUI\u2019s behavior, we can write a new class that customizes its parts \nrather than changing the existing GUI code in place. The main code need be debugged \nonly once and can be customized with subclasses as unique needs arise.\nThe moral of this story is that tkinter GUIs can be coded without ever writing a single \nnew class, but using classes to structure your GUI code makes it much more reusable \nin the long run. If done well, you can both attach already debugged components to new \ninterfaces and specialize their behavior in new external subclasses as needed for custom \nrequirements. Either way, the initial upfront investment to use classes is bound to save \ncoding time in the end.\nStandalone Container Classes\nBefore we move on, I want to point out that it\u2019s possible to reap most of the class-based \ncomponent benefits previously mentioned by creating standalone classes not derived \nfrom tkinter Frames or other widgets. For instance, the class in Example 7-24 generates \nthe window shown in Figure 7-23.\nExample 7-24. PP4E\\Gui\\Intro\\gui7.py\nfrom tkinter import *\nclass HelloPackage:                            # not a widget subbclass\n    def __init__(self, parent=None):\n        self.top = Frame(parent)               # embed a Frame\n        self.top.pack()\n        self.data = 0\n        self.make_widgets()                    # attach widgets to self.top\n    def make_widgets(self):\n        Button(self.top, text='Bye', command=self.top.quit).pack(side=LEFT)\n        Button(self.top, text='Hye', command=self.message).pack(side=RIGHT)\n    def message(self):\n        self.data += 1\n        print('Hello number', self.data)\nif __name__ == '__main__': HelloPackage().top.mainloop()\nFigure 7-23. A standalone class package in action\n408 | Chapter 7:\u2002Graphical User InterfacesWhen run, the Hye button here prints to stdout and the Bye button closes and exits\nthe GUI, much as before:\nC:\\...\\PP4E\\Gui\\Intro> python gui7.py\nHello number 1\nHello number 2\nHello number 3\nHello number 4\nAlso as before, self.data retains state between events, and callbacks are routed to the\nself.message method within this class. Unlike before, the HelloPackage class is not itself\na kind of Frame widget. In fact, it\u2019s not a kind of anything\u2014it serves only as a generator\nof namespaces for storing away real widget objects and state. Because of that, widgets\nare attached to a self.top (an embedded Frame), not to self. Moreover, all references\nto the object as a widget must descend to the embedded frame, as in the top.main\nloop call to start the GUI at the end of the script.\nThis makes for a bit more coding within the class, but it avoids potential name clashes\nwith both attributes added to self by the tkinter framework and existing tkinter widget\nmethods. For instance, if you define a config method in your class, it will hide the\nconfig call exported by tkinter. With the standalone class package in this example, you\nget only the methods and instance attributes that your class defines.\nIn practice, tkinter doesn\u2019t use very many names, so this is not generally a big con-\ncern.\u2021 It can happen, of course; but frankly, I\u2019ve never seen a real tkinter name clash in\nwidget subclasses in some 18 years of Python coding. Moreover, using standalone\nclasses is not without other downsides. Although they can generally be attached and\nsubclassed as before, they are not quite plug-and-play compatible with real widget\nobjects. For instance, the configuration calls made in Example 7-21 for the Frame sub-\nclass fail in Example 7-25.\nExample 7-25. PP4E\\Gui\\Intro\\gui7b.py\nfrom tkinter import *\nfrom gui7 import HelloPackage      # or get from gui7c--__getattr__ added\nfrm = Frame()\nfrm.pack()\nLabel(frm, text='hello').pack()\npart = HelloPackage(frm)\n\u2021 If you study the tkinter module\u2019s source code (today, mostly in file __init__.py in Lib\\tkinter), you\u2019ll notice\nthat many of the attribute names it creates start with a single underscore to make them unique from yours;\nothers do not because they are potentially useful outside of the tkinter implementation (e.g., self.master,\nself.children). Curiously, at this writing most of tkinter still does not use the Python \u201cpseudoprivate\nattributes\u201d trick of prefixing attribute names with two leading underscores to automatically add the enclosing\nclass\u2019s name and thus localize them to the creating class. If tkinter is ever rewritten to employ this feature,\nname clashes will be much less likely in widget subclasses. Most of the attributes of widget classes, though,\nare methods intended for use in client scripts; the single underscore names are accessible too, but are less\nlikely to clash with most names of your own.\nReusable GUI Components with Classes | 409part.pack(side=RIGHT)              # FAILS!--need part.top.pack(side=RIGHT)\nfrm.mainloop()\nThis won\u2019t quite work, because part isn\u2019t really a widget. To treat it as such, you must\ndescend to part.top before making GUI configurations and hope that the name top is\nnever changed by the class\u2019s developer. In other words, it exposes some of the class\u2019s\ninternals. The class could make this better by defining a method that always routes\nunknown attribute fetches to the embedded Frame, as in Example 7-26.\nExample 7-26. PP4E\\Gui\\Intro\\gui7c.py\nimport gui7\nfrom tkinter import *\nclass HelloPackage(gui7.HelloPackage):\n    def __getattr__(self, name):\n        return getattr(self.top, name)                  # pass off to a real widget\nif __name__ == '__main__': HelloPackage().mainloop()    # invokes __getattr__!\nAs is, this script simply creates Figure 7-23 again; changing Example 7-25 to import\nthis extended HelloPackage from gui7c, though, produces the correctly-working win-\ndow in Figure 7-24.\nFigure 7-24. A standalone class package in action\nRouting attribute fetches to nested widgets works this way, but that then requires even\nmore extra coding in standalone package classes. As usual, though, the significance of\nall these trade-offs varies per application.\nThe End of the Tutorial\nIn this chapter, we learned the core concepts of Python/tkinter programming and met\na handful of simple widget objects along the way\u2014e.g., labels, buttons, frames, and\nthe packer geometry manager. We\u2019ve seen enough to construct simple interfaces, but\nwe have really only scratched the surface of the tkinter widget set.\nIn the next two chapters, we will apply what we\u2019ve learned here to study the rest of the\ntkinter library, and we\u2019ll learn how to use it to generate the kinds of interfaces you\nexpect to see in realistic GUI programs. As a preview and roadmap, Table 7-1 lists the\nkinds of widgets we\u2019ll meet there in roughly their order of appearance. Note that this\n410 | Chapter 7:\u2002Graphical User Interfacestable lists only widget classes; along the way, we will also meet a few additional widget-\nrelated topics that don\u2019t appear in this table.\nTable 7-1. tkinter widget classes\nWidget class\nDescription\nLabel\nA simple message area\nButton\nA simple labeled push-button widget\nFrame\nA container for attaching and arranging other widget objects\nToplevel, Tk\nA new window managed by the window manager\nMessage\nA multiline label\nEntry\nA simple single-line text-entry field\nCheckbutton\nA two-state button widget, typically used for multiple-choice selections\nRadiobutton\nA two-state button widget, typically used for single-choice selections\nScale\nA slider widget with scalable positions\nPhotoImage\nAn image object used for displaying full-color images on other widgets\nBitmapImage\nAn image object used for displaying bitmap images on other widgets\nMenu\nA set of options associated with a Menubutton or top-level window\nMenubutton\nA button that opens a Menu of selectable options and submenus\nScrollbar\nA control for scrolling other widgets (e.g., listbox, canvas, text)\nListbox\nA list of selection names\nText\nA multiline text browse/edit widget, with support for fonts, and so on\nCanvas\nA graphic drawing area, which supports lines, circles, photos, text, and so on\nWe\u2019ve already met Label, Button, and Frame in this chapter\u2019s tutorial. To make the\nremaining topics easier to absorb, they are split over the next two chapters: Chap-\nter 8 covers the first widgets in this table up to but not including Menu, and Chapter 9\npresents widgets that are lower in this table.\nBesides the widget classes in this table, there are additional classes and tools in the\ntkinter library, many of which we\u2019ll explore in the following two chapters as well:\nGeometry management\npack, grid, place\ntkinter linked variables\nStringVar, IntVar, DoubleVar, BooleanVar\nAdvanced Tk widgets\nSpinbox, LabelFrame, PanedWindow\nComposite widgets\nDialog, ScrolledText, OptionMenu\nThe End of the Tutorial | 411Scheduled callbacks\nWidget after, wait, and update methods\nOther tools\nStandard dialogs, clipboard, bind and Event, widget configuration options, custom\nand modal dialogs, animation techniques\nMost tkinter widgets are familiar user interface devices. Some are remarkably rich in\nfunctionality. For instance, the Text class implements a sophisticated multiline text\nwidget that supports fonts, colors, and special effects and is powerful enough to im-\nplement a web browser\u2019s page display. The similarly feature-rich Canvas class provides\nextensive drawing tools powerful enough for visualization and other image-processing\napplications. Beyond this, tkinter extensions such as the Pmw, Tix, and ttk packages\ndescribed at the start of this chapter add even richer widgets to a GUI programmer\u2019s\ntoolbox.\nPython/tkinter for Tcl/Tk Converts\nAt the start of this chapter, I mentioned that tkinter is Python\u2019s interface to the Tk GUI\nlibrary, originally written for the Tcl language. To help readers migrating from Tcl to\nPython and to summarize some of the main topics we met in this chapter, this section\ncontrasts Python\u2019s Tk interface with Tcl\u2019s. This mapping also helps make Tk references\nwritten for other languages more useful to Python developers.\nIn general terms, Tcl\u2019s command-string view of the world differs widely from Python\u2019s\nobject-based approach to programming. In terms of Tk programming, though, the\nsyntactic differences are fairly small. Here are some of the main distinctions in Python\u2019s\ntkinter interface:\nCreation\nWidgets are created as class instance objects by calling a widget class.\nMasters (parents)\nParents are previously created objects that are passed to widget-class constructors.\nWidget options\nOptions are constructor or config keyword arguments or indexed keys.\nOperations\nWidget operations (actions) become tkinter widget class object methods.\nCallbacks\nCallback handlers are any callable objects: function, method, lambda, and so on.\nExtension\nWidgets are extended using Python class inheritance mechanisms.\nComposition\nInterfaces are constructed by attaching objects, not by concatenating names.\n412 | Chapter 7:\u2002Graphical User InterfacesLinked variables (next chapter)\nVariables associated with widgets are tkinter class objects with methods.\nIn Python, widget creation commands (e.g., button) are Python class names that start\nwith an uppercase letter (e.g., Button), two-word widget operations (e.g., add command)\nbecome a single method name with an underscore (e.g., add_command), and the \u201ccon-\nfigure\u201d method can be abbreviated as \u201cconfig,\u201d as in Tcl. In Chapter 8, we will also see\nthat tkinter \u201cvariables\u201d associated with widgets take the form of class instance objects\n(e.g., StringVar, IntVar) with get and set methods, not simple Python or Tcl variable\nnames. Table 7-2 shows some of the primary language mappings in more concrete\nterms.\nTable 7-2. Tk-to-tkinter mappings\nOperation\nTcl/Tk\nPython/tkinter\nCreation\nFrame .panel\npanel = Frame()\nMasters\nbutton .panel.quit\nquit = Button(panel)\nOptions\nbutton .panel.go -fg black\ngo = Button(panel, fg='black')\nConfigure\n.panel.go config -bg red\ngo.config(bg='red') go['bg'] = \u2018red\u2019\nActions\n.popup invoke\npopup.invoke()\nPacking\npack .panel -side left -fill x\npanel.pack(side=LEFT, fill=X)\nSome of these differences are more than just syntactic, of course. For instance, Python\nbuilds an internal widget object tree based on parent arguments passed to widget con-\nstructors, without ever requiring concatenated widget pathname strings. Once you\u2019ve\nmade a widget object, you can use it directly by object reference. Tcl coders can hide\nsome dotted pathnames by manually storing them in variables, but that\u2019s not quite the\nsame as Python\u2019s purely object-based model.\nOnce you\u2019ve written a few Python/tkinter scripts, though, the coding distinctions in\nthe Python object world will probably seem trivial. At the same time, Python\u2019s support\nfor object-oriented techniques adds an entirely new component to Tk development;\nyou get the same widgets, plus Python\u2019s support for code structure and reuse.\nPython/tkinter for Tcl/Tk Converts | 413", "8": "CHAPTER 8\nA tkinter Tour, Part 1\n\u201cWidgets and Gadgets and GUIs, Oh My!\u201d\nThis chapter is a continuation of our look at GUI programming in Python. The previous \nchapter used simple widgets\u2014buttons, labels, and the like\u2014to demonstrate the fun-\ndamentals of Python/tkinter coding. That was simple by design: it\u2019s easier to grasp the \nbig GUI picture if widget interface details don\u2019t get in the way. But now that we\u2019ve seen \nthe basics, this chapter and the next move on to present a tour of more advanced widget \nobjects and tools available in the tkinter library.\nAs we\u2019ll find, this is where GUI scripting starts getting both practical and fun. In these \ntwo chapters, we\u2019ll meet classes that build the interface devices you expect to see in \nreal programs\u2014e.g., sliders, check buttons, menus, scrolled lists, dialogs, graphics, and \nso on. After these chapters, the last GUI chapter moves on to present larger GUIs that \nutilize the coding techniques and the interfaces shown in all prior GUI chapters. In \nthese two chapters, though, examples are small and self-contained so that we can focus \non widget details.\nThis Chapter\u2019s Topics\nTechnically, we\u2019ve already used a handful of simple widgets in Chapter 7. So far we\u2019ve \nmet Label, Button, Frame, and Tk, and studied pack geometry management concepts \nalong the way. Although all of these are basic, they represent tkinter interfaces in general \nand can be workhorses in typical GUIs. Frame containers, for instance, are the basis of \nhierarchical display layout.\nIn this and the following chapter, we\u2019ll explore additional options for widgets we\u2019ve \nalready seen and move beyond the basics to cover the rest of the tkinter widget set. \nHere are some of the widgets and topics we\u2019ll explore in this chapter:\n\u2022 Toplevel and Tk widgets\n\u2022 Message and Entry widgets\n\u2022 Checkbutton, Radiobutton, and Scale widgets\n415\u2022 Images: PhotoImage and BitmapImage objects\n\u2022 Widget and window configuration options\n\u2022 Dialogs, both standard and custom\n\u2022 Low-level event binding\n\u2022 tkinter linked variable objects\n\u2022 Using the Python Imaging Library (PIL) extension for other image types and\noperations\nAfter this chapter, Chapter 9 concludes the two-part tour by presenting the remainder\nof the tkinter library\u2019s tool set: menus, text, canvases, animation, and more.\nTo make this tour interesting, I\u2019ll also introduce a few notions of component reuse\nalong the way. For instance, some later examples will be built using components written\nfor prior examples. Although these two tour chapters introduce widget interfaces, this\nbook is also about Python programming in general; as we\u2019ll see, tkinter programming\nin Python can be much more than simply drawing circles and arrows.\nConfiguring Widget Appearance\nSo far, all the buttons and labels in examples have been rendered with a default look-\nand-feel that is standard for the underlying platform. With my machine\u2019s color scheme,\nthat usually means that they\u2019re gray on Windows. tkinter widgets can be made to look\narbitrarily different, though, using a handful of widget and packer options.\nBecause I generally can\u2019t resist the temptation to customize widgets in examples, I want\nto cover this topic early on the tour. Example 8-1 introduces some of the configuration\noptions available in tkinter.\nExample 8-1. PP4E\\Gui\\Tour\\config-label.py\nfrom tkinter import *\nroot = Tk()\nlabelfont = ('times', 20, 'bold')                  # family, size, style\nwidget = Label(root, text='Hello config world')\nwidget.config(bg='black', fg='yellow')             # yellow text on black label\nwidget.config(font=labelfont)                      # use a larger font\nwidget.config(height=3, width=20)                  # initial size: lines,chars\nwidget.pack(expand=YES, fill=BOTH)\nroot.mainloop()\nRemember, we can call a widget\u2019s config method to reset its options at any time, instead\nof passing all of them to the object\u2019s constructor. Here, we use it to set options that\nproduce the window in Figure 8-1.\nThis may not be completely obvious unless you run this script on a real computer (alas,\nI can\u2019t show it in color here), but the label\u2019s text shows up in yellow on a black\n416 | Chapter 8:\u2002A tkinter Tour, Part 1background, and with a font that\u2019s very different from what we\u2019ve seen so far. In fact,\nthis script customizes the label in a number of ways:\nColor\nBy setting the bg option of the label widget here, its background is displayed in\nblack; the fg option similarly changes the foreground (text) color of the widget to\nyellow. These color options work on most tkinter widgets and accept either a sim-\nple color name (e.g., 'blue') or a hexadecimal string. Most of the color names you\nare familiar with are supported (unless you happen to work for Crayola). You can\nalso pass a hexadecimal color identifier string to these options to be more specific;\nthey start with a # and name a color by its red, green, and blue saturations, with\nan equal number of bits in the string for each. For instance, '#ff0000' specifies\neight bits per color and defines pure red; \u201cf\u201d means four \u201c1\u201d bits in hexadecimal.\nWe\u2019ll come back to this hex form when we meet the color selection dialog later in\nthis chapter.\nSize\nThe label is given a preset size in lines high and characters wide by setting its\nheight and width attributes. You can use this setting to make the widget larger than\nthe tkinter geometry manager would by default.\nFont\nThis script specifies a custom font for the label\u2019s text by setting the label\u2019s font\nattribute to a three-item tuple giving the font family, size, and style (here: Times,\n20-point, and bold). Font style can be normal, bold, roman, italic, underline, over\nstrike, or combinations of these (e.g., \u201cbold italic\u201d). tkinter guarantees that Times,\nCourier, and Helvetica font family names exist on all platforms, but others may\nwork, too (e.g., system gives the system font on Windows). Font settings like this\nwork on all widgets with text, such as labels, buttons, entry fields, listboxes, and\nText (the latter of which can even display more than one font at once with \u201ctags\u201d).\nThe font option still accepts older X-Windows-style font indicators\u2014long strings\nwith dashes and stars\u2014but the newer tuple font indicator form is more platform\nindependent.\nFigure 8-1. A custom label appearance\nConfiguring Widget Appearance | 417Layout and expansion\nFinally, the label is made generally expandable and stretched by setting the pack\nexpand and fill options we met in the last chapter; the label grows as the window\ndoes. If you maximize this window, its black background fills the whole screen and\nthe yellow message is centered in the middle; try it.\nIn this script, the net effect of all these settings is that this label looks radically different\nfrom the ones we\u2019ve been making so far. It no longer follows the Windows standard\nlook-and-feel, but such conformance isn\u2019t always important. For reference, tkinter\nprovides additional ways to customize appearance that are not used by this script, but\nwhich may appear in others:\nBorder and relief\nA bd= N widget option can be used to set border width, and a relief= S option can\nspecify a border style; S can be FLAT, SUNKEN, RAISED, GROOVE, SOLID, or RIDGE\u2014all\nconstants exported by the tkinter module.\nCursor\nA cursor option can be given to change the appearance of the mouse pointer when\nit moves over the widget. For instance, cursor='gumby' changes the pointer to a\nGumby figure (the green kind). Other common cursor names used in this book\ninclude watch, pencil, cross, and hand2.\nState\nSome widgets also support the notion of a state, which impacts their appearance.\nFor example, a state=DISABLED option will generally stipple (gray out) a widget on\nscreen and make it unresponsive; NORMAL does not. Some widgets support a\nREADONLY state as well, which displays normally but is unresponsive to changes.\nPadding\nExtra space can be added around many widgets (e.g., buttons, labels, and text)\nwith the padx= N and pady= N options. Interestingly, you can set these options both\nin pack calls (where it adds empty space around the widget in general) and in a\nwidget object itself (where it makes the widget larger).\nTo illustrate some of these extra settings, Example 8-2 configures the custom button\ncaptured in Figure 8-2 and changes the mouse pointer when it is positioned above it.\nExample 8-2. PP4E\\Gui\\Tour\\config-button.py\nfrom tkinter import *\nwidget = Button(text='Spam', padx=10, pady=10)\nwidget.pack(padx=20, pady=20)\nwidget.config(cursor='gumby')\nwidget.config(bd=8, relief=RAISED)\nwidget.config(bg='dark green', fg='white')\nwidget.config(font=('helvetica', 20, 'underline italic'))\nmainloop()\n418 | Chapter 8:\u2002A tkinter Tour, Part 1To see the effects generated by these two scripts\u2019 settings, try out a few changes on your\ncomputer. Most widgets can be given a custom appearance in the same way, and we\u2019ll\nsee such options used repeatedly in this text. We\u2019ll also meet operational configura-\ntions, such as focus (for focusing input) and others. In fact, widgets can have dozens\nof options; most have reasonable defaults that produce a native look-and-feel on each\nwindowing platform, and this is one reason for tkinter\u2019s simplicity. But tkinter lets you\nbuild more custom displays when you want to.\nFor more on ways to apply configuration options to provide common\nlook-and-feel for your widgets, refer back to \u201cCustomizing Widgets\nwith Classes\u201d on page 400, especially its ThemedButton examples. Now\nthat you know more about configuration, its examples\u2019 source code\nshould more readily show how configurations applied in widget sub-\nclasses are automatically inherited by all instances and subclasses. The\nnew ttk extension described in Chapter 7 also provides additional ways\nto configure widgets with its notion of themes; see the preceding chapter\nfor more details and resources on ttk.\nTop-Level Windows\ntkinter GUIs always have an application root window, whether you get it by default or\ncreate it explicitly by calling the Tk object constructor. This main root window is the\none that opens when your program runs, and it is where you generally pack your most\nimportant and long-lived widgets. In addition, tkinter scripts can create any number\nof independent windows, generated and popped up on demand, by creating Toplevel\nwidget objects.\nEach Toplevel object created produces a new window on the display and automatically\nadds it to the program\u2019s GUI event-loop processing stream (you don\u2019t need to call the\nmainloop method of new windows to activate them). Example 8-3 builds a root and two\npop-up windows.\nFigure 8-2. Config button at work\nTop-Level Windows | 419Example 8-3. PP4E\\Gui\\Tour\\toplevel0.py\nimport sys\nfrom tkinter import Toplevel, Button, Label\nwin1 = Toplevel()                  # two independent windows\nwin2 = Toplevel()                  # but part of same process\nButton(win1, text='Spam', command=sys.exit).pack()\nButton(win2, text='SPAM', command=sys.exit).pack()\nLabel(text='Popups').pack()        # on default Tk() root window\nwin1.mainloop()\nThe toplevel0 script gets a root window by default (that\u2019s what the Label is attached to,\nsince it doesn\u2019t specify a real parent), but it also creates two standalone Toplevel win-\ndows that appear and function independently of the root window, as seen in\nFigure 8-3.\nFigure 8-3. Two Toplevel windows and a root window\nThe two Toplevel windows on the right are full-fledged windows; they can be inde-\npendently iconified, maximized, and so on. Toplevels are typically used to implement\nmultiple-window displays and pop-up modal and nonmodal dialogs (more on dialogs\nin the next section). They stay up until they are explicitly destroyed or until the appli-\ncation that created them exits.\nIn fact, as coded here, pressing the X in the upper right corner of either of the\nToplevel windows kills that window only. On the other hand, the entire program and\nall it remaining windows are closed if you press either of the created buttons or the\nmain window\u2019s X (more on shutdown protocols in a moment).\nIt\u2019s important to know that although Toplevels are independently active windows, they\nare not separate processes; if your program exits, all of its windows are erased, including\nall Toplevel windows it may have created. We\u2019ll learn how to work around this rule\nlater by launching independent GUI programs.\n420 | Chapter 8:\u2002A tkinter Tour, Part 1Toplevel and Tk Widgets\nA Toplevel is roughly like a Frame that is split off into its own window and has additional\nmethods that allow you to deal with top-level window properties. The Tk widget is\nroughly like a Toplevel, but it is used to represent the application root window.\nToplevel windows have parents, but Tk windows do not\u2014they are the true roots of the\nwidget hierarchies we build when making tkinter GUIs.\nWe got a Tk root for free in Example 8-3 because the Label had a default parent, des-\nignated by not having a widget in the first argument of its constructor call:\nLabel(text='Popups').pack()              # on default Tk() root window\nPassing None to a widget constructor\u2019s first argument (or to its master keyword argu-\nment) has the same default-parent effect. In other scripts, we\u2019ve made the Tk root more\nexplicit by creating it directly, like this:\nroot = Tk()\nLabel(root, text='Popups').pack()        # on explicit Tk() root window\nroot.mainloop()\nIn fact, because tkinter GUIs are a hierarchy, by default you always get at least one Tk\nroot window, whether it is named explicitly, as here, or not. Though not typical, there\nmay be more than one Tk root if you make them manually, and a program ends if all\nits Tk windows are closed. The first Tk top-level window created\u2014whether explicitly\nby your code, or automatically by Python when needed\u2014is used as the default parent\nwindow of widgets and other windows if no parent is provided.\nYou should generally use the Tk root window to display top-level information of some\nsort. If you don\u2019t attach widgets to the root, it may show up as an odd empty window\nwhen you run your script (often because you used the default parent unintentionally\nin your code by omitting a widget\u2019s parent and didn\u2019t pack widgets attached to it).\nTechnically, you can suppress the default root creation logic and make multiple root\nwindows with the Tk widget, as in Example 8-4.\nExample 8-4. PP4E\\Gui\\Tour\\toplevel1.py\nimport tkinter\nfrom tkinter import Tk, Button\ntkinter.NoDefaultRoot()\nwin1 = Tk()         # two independent root windows\nwin2 = Tk()\nButton(win1, text='Spam', command=win1.destroy).pack()\nButton(win2, text='SPAM', command=win2.destroy).pack()\nwin1.mainloop()\nWhen run, this script displays the two pop-up windows of the screenshot in Fig-\nure 8-3 only (there is no third root window). But it\u2019s more common to use the Tk root\nas a main window and create Toplevel widgets for an application\u2019s pop-up windows.\nTop-Level Windows | 421Notice how this GUI\u2019s windows use a window\u2019s destroy method to close just one\nwindow, instead of sys.exit to shut down the entire program; to see how this method\nreally does its work, let\u2019s move on to window protocols.\nTop-Level Window Protocols\nBoth Tk and Toplevel widgets export extra methods and features tailored for their top-\nlevel role, as illustrated in Example 8-5.\nExample 8-5. PP4E\\Gui\\Tour\\toplevel2.py\n\"\"\"\npop up three new windows, with style\ndestroy() kills one window, quit() kills all windows and app (ends mainloop);\ntop-level windows have title, icon, iconify/deiconify and protocol for wm events;\nthere always is an application root window, whether by default or created as an\nexplicit Tk() object; all top-level windows are containers, but they are never\npacked/gridded; Toplevel is like Frame, but a new window, and can have a menu;\n\"\"\"\nfrom tkinter import *\nroot = Tk()                                                     # explicit root\ntrees = [('The Larch!',         'light blue'),\n         ('The Pine!',          'light green'),\n         ('The Giant Redwood!', 'red')]\nfor (tree, color) in trees:\n    win = Toplevel(root)                                        # new window\n    win.title('Sing...')                                        # set border\n    win.protocol('WM_DELETE_WINDOW', lambda:None)               # ignore close\n    win.iconbitmap('py-blue-trans-out.ico')                     # not red Tk\n    msg = Button(win, text=tree, command=win.destroy)           # kills one win\n    msg.pack(expand=YES, fill=BOTH)\n    msg.config(padx=10, pady=10, bd=10, relief=RAISED)\n    msg.config(bg='black', fg=color, font=('times', 30, 'bold italic'))\nroot.title('Lumberjack demo')\nLabel(root, text='Main window', width=30).pack()\nButton(root, text='Quit All', command=root.quit).pack()         # kills all app\nroot.mainloop()\nThis program adds widgets to the Tk root window, immediately pops up three\nToplevel windows with attached buttons, and uses special top-level protocols. When\nrun, it generates the scene captured in living black-and-white in Figure 8-4 (the buttons\u2019\ntext shows up blue, green, and red on a color display).\n422 | Chapter 8:\u2002A tkinter Tour, Part 1Figure 8-4. Three Toplevel windows with configurations\nThere are a few operational details worth noticing here, all of which are more obvious\nif you run this script on your machine:\nIntercepting closes: protocol\nBecause the window manager close event has been intercepted by this script using\nthe top-level widget protocol method, pressing the X in the top-right corner doesn\u2019t\ndo anything in the three Toplevel pop ups. The name string WM_DELETE_WINDOW\nidentifies the close operation. You can use this interface to disallow closes apart\nfrom the widgets your script creates. The function created by this script\u2019s\nlambda:None does nothing but return None.\nKilling one window (and its children): destroy\nPressing the big black buttons in any one of the three pop ups kills that pop up\nonly, because the pop up runs the widget destroy method. The other windows live\non, much as you would expect of a pop-up dialog window. Technically, this call\ndestroys the subject widget and any other widgets for which it is a parent. For\nwindows, this includes all their content. For simpler widgets, the widget is erased.\nBecause Toplevel windows have parents, too, their relationships might matter on\na destroy\u2014destroying a window, even the automatic or first-made Tk root which\nis used as the default parent, also destroys all its child windows. Since Tk root\nwindows have no parents, they are unaffected by destroys of other windows.\nMoreover, destroying the last Tk root window remaining (or the only Tk root cre-\nated) effectively ends the program. Toplevel windows, however, are always de-\nstroyed with their parents, and their destruction doesn\u2019t impact other windows to\nwhich they are not ancestors. This makes them ideal for pop-up dialogs. Techni-\ncally, a Toplevel can be a child of any type of widget and will be destroyed with it,\nthough they are usually children of an automatic or explicit Tk.\nTop-Level Windows | 423Killing all windows: quit\nTo kill all the windows at once and end the GUI application (really, its active\nmainloop call), the root window\u2019s button runs the quit method instead. That is,\npressing the root window\u2019s button ends the program. In general, the quit method\nimmediately ends the entire application and closes all its windows. It can be called\nthrough any tkinter widget, not just through the top-level window; it\u2019s also avail-\nable on frames, buttons, and so on. See the discussion of the bind method and its\n<Destroy> events later in this chapter for more on quit and destroy.\nWindow titles: title\nAs introduced in Chapter 7, top-level window widgets (Tk and Toplevel) have a\ntitle method that lets you change the text displayed on the top border. Here, the\nwindow title text is set to the string 'Sing...' in the pop-ups to override the default\n'tk'.\nWindow icons: iconbitmap\nThe iconbitmap method changes a top-level window\u2019s icon. It accepts an icon or\nbitmap file and uses it for the window\u2019s icon graphic when it is both minimized\nand open. On Windows, pass in the name of a .ico file (this example uses one in\nthe current directory); it will replace the default red \u201cTk\u201d icon that normally ap-\npears in the upper-lefthand corner of the window as well as in the Windows task-\nbar. On other platforms, you may need to use other icon file conventions if the\nicon calls in this book won\u2019t work for you (or simply comment-out the calls alto-\ngether if they cause scripts to fail); icons tend to be a platform-specific feature that\nis dependent upon the underlying window manager.\nGeometry management\nTop-level windows are containers for other widgets, much like a standalone\nFrame. Unlike frames, though, top-level window widgets are never themselves\npacked (or gridded, or placed). To embed widgets, this script passes its windows\nas parent arguments to label and button constructors.\nIt is also possible to fetch the maximum window size (the physical screen display\nsize, as a [width, height] tuple) with the maxsize() method, as well as set the initial\nsize of a window with the top-level geometry(\" width x height + x + y \") method. It\nis generally easier and more user-friendly to let tkinter (or your users) work out\nwindow size for you, but display size may be used for tasks such as scaling images\n(see the discussion on PyPhoto in Chapter 11 for an example).\nIn addition, top-level window widgets support other kinds of protocols that we will\nutilize later on in this tour:\nState\nThe iconify and withdraw top-level window object methods allow scripts to hide\nand erase a window on the fly; deiconify redraws a hidden or erased window. The\nstate method queries or changes a window\u2019s state; valid states passed in or re-\nturned include iconic, withdrawn, zoomed (full screen on Windows: use geometry\n424 | Chapter 8:\u2002A tkinter Tour, Part 1elsewhere), and normal (large enough for window content). The methods lift and\nlower raise and lower a window with respect to its siblings (lift is the Tk raise\ncommand, but avoids a Python reserved word). See the alarm scripts near the end\nof Chapter 9 for usage.\nMenus\nEach top-level window can have its own window menus too; both the Tk and the\nToplevel widgets have a menu option used to associate a horizontal menu bar of\npull-down option lists. This menu bar looks as it should on each platform on which\nyour scripts are run. We\u2019ll explore menus early in Chapter 9.\nMost top-level window-manager-related methods can also be named with a \u201cwm_\u201d at\nthe front; for instance, state and protocol can also be called wm_state and wm_protocol.\nNotice that the script in Example 8-3 passes its Toplevel constructor calls an explicit\nparent widget\u2014the Tk root window (that is, Toplevel(root)). Toplevels can be asso-\nciated with a parent just as other widgets can, even though they are not visually em-\nbedded in their parents. I coded the script this way to avoid what seems like an odd\nfeature; if coded instead like this:\nwin = Toplevel()                                    # new window\nand if no Tk root yet exists, this call actually generates a default Tk root window to serve\nas the Toplevel\u2019s parent, just like any other widget call without a parent argument. The\nproblem is that this makes the position of the following line crucial:\nroot = Tk()                                         # explicit root\nIf this line shows up above the Toplevel calls, it creates the single root window as\nexpected. But if you move this line below the Toplevel calls, tkinter creates a default\nTk root window that is different from the one created by the script\u2019s explicit Tk call. You\nwind up with two Tk roots just as in Example 8-4. Move the Tk call below the\nToplevel calls and rerun it to see what I mean. You\u2019ll get a fourth window that is com-\npletely empty! As a rule of thumb, to avoid such oddities, make your Tk root windows\nearly on and make them explicit.\nAll of the top-level protocol interfaces are available only on top-level window widgets,\nbut you can often access them by going through other widgets\u2019 master attributes\u2014links\nto the widget parents. For example, to set the title of a window in which a frame is\ncontained, say something like this:\ntheframe.master.title('Spam demo')    # master is the container window\nNaturally, you should do so only if you\u2019re sure that the frame will be used in only one\nkind of window. General-purpose attachable components coded as classes, for in-\nstance, should leave window property settings to their client applications.\nTop-level widgets have additional tools, some of which we may not meet in this book.\nFor instance, under Unix window managers, you can also set the name used on the\nwindow\u2019s icon (iconname). Because some icon options may be useful when scripts run\nTop-Level Windows | 425on Unix only, see other Tk and tkinter resources for more details on this topic. For\nnow, the next scheduled stop on this tour explores one of the more common uses of\ntop-level windows.\nDialogs\nDialogs are windows popped up by a script to provide or request additional informa-\ntion. They come in two flavors, modal and nonmodal:\nModal\nThese dialogs block the rest of the interface until the dialog window is dismissed;\nusers must reply to the dialog before the program continues.\nNonmodal\nThese dialogs can remain on-screen indefinitely without interfering with other\nwindows in the interface; they can usually accept inputs at any time.\nRegardless of their modality, dialogs are generally implemented with the Toplevel win-\ndow object we met in the prior section, whether you make the Toplevel or not. There\nare essentially three ways to present pop-up dialogs to users with tkinter\u2014by using\ncommon dialog calls, by using the now-dated Dialog object, and by creating custom\ndialog windows with Toplevels and other kinds of widgets. Let\u2019s explore the basics of\nall three schemes.\nStandard (Common) Dialogs\nBecause standard dialog calls are simpler, let\u2019s start here first. tkinter comes with a\ncollection of precoded dialog windows that implement many of the most common pop\nups programs generate\u2014file selection dialogs, error and warning pop ups, and question\nand answer prompts. They are called standard dialogs (and sometimes common dia-\nlogs) because they are part of the tkinter library, and they use platform-specific library\ncalls to look like they should on each platform. A tkinter file open dialog, for instance,\nlooks like any other on Windows.\nAll standard dialog calls are modal (they don\u2019t return until the dialog box is dismissed\nby the user), and they block the program\u2019s main window while they are displayed.\nScripts can customize these dialogs\u2019 windows by passing message text, titles, and the\nlike. Since they are so simple to use, let\u2019s jump right into Example 8-6 (coded as\na .pyw file here to avoid a shell pop up when clicked in Windows).\nExample 8-6. PP4E\\Gui\\Tour\\dlg1.pyw\nfrom tkinter import *\nfrom tkinter.messagebox import *\ndef callback():\n    if askyesno('Verify', 'Do you really want to quit?'):\n        showwarning('Yes', 'Quit not yet implemented')\n426 | Chapter 8:\u2002A tkinter Tour, Part 1else:\n        showinfo('No', 'Quit has been cancelled')\nerrmsg = 'Sorry, no Spam allowed!'\nButton(text='Quit', command=callback).pack(fill=X)\nButton(text='Spam', command=(lambda: showerror('Spam', errmsg))).pack(fill=X)\nmainloop()\nA lambda anonymous function is used here to wrap the call to showerror so that it is\npassed two hardcoded arguments (remember, button-press callbacks get no arguments\nfrom tkinter itself). When run, this script creates the main window in Figure 8-5.\nFigure 8-5. dlg1 main window: buttons to trigger pop ups\nWhen you press this window\u2019s Quit button, the dialog in Figure 8-6 is popped up by\ncalling the standard askyesno function in the tkinter package\u2019s messagebox module. This\nlooks different on Unix and Macintosh systems, but it looks like you\u2019d expect when\nrun on Windows (and in fact varies its appearance even across different versions and\nconfigurations of Windows\u2014using my default Window 7 setup, it looks slightly dif-\nferent than it did on Windows XP in the prior edition).\nThe dialog in Figure 8-6 blocks the program until the user clicks one of its buttons; if\nthe dialog\u2019s Yes button is clicked (or the Enter key is pressed), the dialog call returns\nwith a true value and the script pops up the standard dialog in Figure 8-7 by calling\nshowwarning.\nFigure 8-6. dlg1 askyesno dialog (Windows 7)\nDialogs | 427There is nothing the user can do with Figure 8-7\u2019s dialog but press OK. If No is clicked\nin Figure 8-6\u2019s quit verification dialog, a showinfo call creates the pop up in Fig-\nure 8-8 instead. Finally, if the Spam button is clicked in the main window, the standard\ndialog captured in Figure 8-9 is generated with the standard showerror call.\nFigure 8-8. dlg1 showinfo dialog\nFigure 8-9. dlg1 showerror dialog\nAll of this makes for a lot of window pop ups, of course, and you need to be careful not\nto rely on these dialogs too much (it\u2019s generally better to use input fields in long-lived\nFigure 8-7. dlg1 showwarning dialog\n428 | Chapter 8:\u2002A tkinter Tour, Part 1windows than to distract the user with pop ups). But where appropriate, such pop ups\nsave coding time and provide a nice native look-and-feel.\nA \u201csmart\u201d and reusable Quit button\nLet\u2019s put some of these canned dialogs to better use. Example 8-7 implements an at-\ntachable Quit button that uses standard dialogs to verify the quit request. Because it\u2019s\na class, it can be attached and reused in any application that needs a verifying Quit\nbutton. Because it uses standard dialogs, it looks as it should on each GUI platform.\nExample 8-7. PP4E\\Gui\\Tour\\quitter.py\n\"\"\"\na Quit button that verifies exit requests;\nto reuse, attach an instance to other GUIs, and re-pack as desired\n\"\"\"\nfrom tkinter import *                          # get widget classes\nfrom tkinter.messagebox import askokcancel     # get canned std dialog\nclass Quitter(Frame):                          # subclass our GUI\n    def __init__(self, parent=None):           # constructor method\n        Frame.__init__(self, parent)\n        self.pack()\n        widget = Button(self, text='Quit', command=self.quit)\n        widget.pack(side=LEFT, expand=YES, fill=BOTH)\n    def quit(self):\n        ans = askokcancel('Verify exit', \"Really quit?\")\n        if ans: Frame.quit(self)\nif __name__ == '__main__':  Quitter().mainloop()\nThis module is mostly meant to be used elsewhere, but it puts up the button it imple-\nments when run standalone. Figure 8-10 shows the Quit button itself in the upper left,\nand the askokcancel verification dialog that pops up when Quit is pressed.\nFigure 8-10. Quitter, with askokcancel dialog\nDialogs | 429If you press OK here, Quitter runs the Frame quit method to end the GUI to which this\nbutton is attached (really, the mainloop call). But to really understand how such a spring-\nloaded button can be useful, we need to move on and study a client GUI in the next\nsection.\nA dialog demo launcher bar\nSo far, we\u2019ve seen a handful of standard dialogs, but there are quite a few more. Instead\nof just throwing these up in dull screenshots, though, let\u2019s write a Python demo script\nto generate them on demand. Here\u2019s one way to do it. First of all, in Example 8-8 we\nwrite a module to define a table that maps a demo name to a standard dialog call (and\nwe use lambda to wrap the call if we need to pass extra arguments to the dialog\nfunction).\nExample 8-8. PP4E\\Gui\\Tour\\dialogTable.py\n# define a name:callback demos table\nfrom tkinter.filedialog   import askopenfilename        # get standard dialogs\nfrom tkinter.colorchooser import askcolor               # they live in Lib\\tkinter\nfrom tkinter.messagebox   import askquestion, showerror\nfrom tkinter.simpledialog import askfloat\ndemos = {\n    'Open':  askopenfilename,\n    'Color': askcolor,\n    'Query': lambda: askquestion('Warning', 'You typed \"rm *\"\\nConfirm?'),\n    'Error': lambda: showerror('Error!', \"He's dead, Jim\"),\n    'Input': lambda: askfloat('Entry', 'Enter credit card number')\n}\nI put this table in a module so that it might be reused as the basis of other demo scripts\nlater (dialogs are more fun than printing to stdout). Next, we\u2019ll write a Python script,\nshown in Example 8-9, which simply generates buttons for all of this table\u2019s entries\u2014\nuse its keys as button labels and its values as button callback handlers.\nExample 8-9. PP4E\\Gui\\Tour\\demoDlg.py\n\"create a bar of simple buttons that launch dialog demos\"\nfrom tkinter import *              # get base widget set\nfrom dialogTable import demos      # button callback handlers\nfrom quitter import Quitter        # attach a quit object to me\nclass Demo(Frame):\n    def __init__(self, parent=None, **options):\n        Frame.__init__(self, parent, **options)\n        self.pack()\n        Label(self, text=\"Basic demos\").pack()\n        for (key, value) in demos.items():\n            Button(self, text=key, command=value).pack(side=TOP, fill=BOTH)\n        Quitter(self).pack(side=TOP, fill=BOTH)\n430 | Chapter 8:\u2002A tkinter Tour, Part 1if __name__ == '__main__': Demo().mainloop()\nThis script creates the window shown in Figure 8-11 when run as a standalone program;\nit\u2019s a bar of demo buttons that simply route control back to the values of the table in\nthe module dialogTable when pressed.\nFigure 8-11. demoDlg main window\nNotice that because this script is driven by the contents of the dialogTable module\u2019s\ndictionary, we can change the set of demo buttons displayed by changing just\ndialogTable (we don\u2019t need to change any executable code in demoDlg). Also note that\nthe Quit button here is an attached instance of the Quitter class of the prior section\nwhose frame is repacked to stretch like the other buttons as needed here\u2014it\u2019s at least\none bit of code that you never have to write again.\nThis script\u2019s class also takes care to pass any **options constructor configuration key-\nword arguments on to its Frame superclass. Though not used here, this allows callers\nto pass in configuration options at creation time (Demo(o=v)), instead of configuring\nafter the fact (d.config(o=v)). This isn\u2019t strictly required, but it makes the demo class\nwork just like a normal tkinter frame widget (which is what subclassing makes it, after\nall). We\u2019ll see how this can be used to good effect later.\nWe\u2019ve already seen some of the dialogs triggered by this demo bar window\u2019s other\nbuttons, so I\u2019ll just step through the new ones here. Pressing the main window\u2019s Query\nbutton, for example, generates the standard pop up in Figure 8-12.\nThis askquestion dialog looks like the askyesno we saw earlier, but actually it returns\neither string \"yes\" or \"no\" (askyesno and askokcancel return True or False instead\u2014\ntrivial but true). Pressing the demo bar\u2019s Input button generates the standard ask\nfloat dialog box shown in Figure 8-13.\nDialogs | 431This dialog automatically checks the input for valid floating-point syntax before it re-\nturns, and it is representative of a collection of single-value input dialogs (askinteger\nand askstring prompt for integer and string inputs, too). It returns the input as a\nfloating-point number object (not as a string) when the OK button or Enter key is\npressed, or the Python None object if the user clicks Cancel. Its two relatives return the\ninput as integer and string objects instead.\nWhen the demo bar\u2019s Open button is pressed, we get the standard file open dialog\nmade by calling askopenfilename and captured in Figure 8-14. This is Windows 7\u2019s\nlook-and-feel; it can look radically different on Macs, Linux, and older versions of\nWindows, but appropriately so.\nA similar dialog for selecting a save-as filename is produced by calling asksaveasfile\nname (see the Text widget section in Chapter 9 for a first example). Both file dialogs let\nthe user navigate through the filesystem to select a subject filename, which is returned\nwith its full directory pathname when Open is pressed; an empty string comes back if\nCancel is pressed instead. Both also have additional protocols not demonstrated by this\nexample:\n\u2022 They can be passed a filetypes keyword argument\u2014a set of name patterns used\nto select files, which appear in the pull-down list near the bottom of the dialog.\nFigure 8-12. demoDlg query, askquestion dialog\nFigure 8-13. demoDlg input, askfloat dialog\n432 | Chapter 8:\u2002A tkinter Tour, Part 1\u2022 They can be passed an initialdir (start directory), initialfile (for \u201cFile name\u201d),\ntitle (for the dialog window), defaultextension (appended if the selection has\nnone), and parent (to appear as an embedded child instead of a pop-up dialog).\n\u2022 They can be made to remember the last directory selected by using exported objects\ninstead of these function calls\u2014a hook we\u2019ll make use of in later longer-lived\nexamples.\nAnother common dialog call in the tkinter filedialog module, askdirectory, can be\nused to pop up a dialog that allows users to choose a directory rather than a file. It\npresents a tree view that users can navigate to pick the desired directory, and it accepts\nkeyword arguments including initialdir and title. The corresponding Directory ob-\nject remembers the last directory selected and starts there the next time the dialog is\nshown.\nWe\u2019ll use most of these interfaces later in the book, especially for the file dialogs in the\nPyEdit example in Chapter 11, but feel free to flip ahead for more details now. The\ndirectory selection dialog will show up in the PyPhoto example in Chapter 11 and the\nPyMailGUI example in Chapter 14; again, skip ahead for code and screenshots.\nFinally, the demo bar\u2019s Color button triggers a standard askcolor call, which generates\nthe standard color selection dialog shown in Figure 8-15.\nFigure 8-14. demoDlg open, askopenfilename dialog\nDialogs | 433Figure 8-15. demoDlg color, askcolor dialog\nIf you press its OK button, it returns a data structure that identifies the selected color,\nwhich can be used in all color contexts in tkinter. It includes RGB values and a hexa-\ndecimal color string (e.g., ((160, 160, 160), '#a0a0a0')). More on how this tuple can\nbe useful in a moment. If you press Cancel, the script gets back a tuple containing two\nnones (Nones of the Python variety, that is).\nPrinting dialog results and passing callback data with lambdas\nThe dialog demo launcher bar displays standard dialogs and can be made to display\nothers by simply changing the dialogTable module it imports. As coded, though, it\nreally shows only dialogs; it would also be nice to see their return values so that we\nknow how to use them in scripts. Example 8-10 adds printing of standard dialog results\nto the stdout standard output stream.\nExample 8-10. PP4E\\Gui\\Tour\\demoDlg-print.py\n\"\"\"\nsimilar, but show return values of dialog calls;  the lambda saves data from\nthe local scope to be passed to the handler (button press handlers normally\nget no arguments, and enclosing scope references don't work for loop variables)\nand works just like a nested def statement: def func(key=key): self.printit(key)\n\"\"\"\n434 | Chapter 8:\u2002A tkinter Tour, Part 1from tkinter import *              # get base widget set\nfrom dialogTable import demos      # button callback handlers\nfrom quitter import Quitter        # attach a quit object to me\nclass Demo(Frame):\n    def __init__(self, parent=None):\n        Frame.__init__(self, parent)\n        self.pack()\n        Label(self, text=\"Basic demos\").pack()\n        for key in demos:\n            func = (lambda key=key: self.printit(key))\n            Button(self, text=key, command=func).pack(side=TOP, fill=BOTH)\n        Quitter(self).pack(side=TOP, fill=BOTH)\n    def printit(self, name):\n        print(name, 'returns =>', demos[name]())     # fetch, call, print\nif __name__ == '__main__': Demo().mainloop()\nThis script builds the same main button-bar window, but notice that the callback han-\ndler is an anonymous function made with a lambda now, not a direct reference to dialog\ncalls in the imported dialogTable dictionary:\n# use enclosing scope lookup\nfunc = (lambda key=key: self.printit(key))\nWe talked about this in the prior chapter\u2019s tutorial, but this is the first time we\u2019ve\nactually used lambda like this, so let\u2019s get the facts straight. Because button-press call-\nbacks are run with no arguments, if we need to pass extra data to the handler, it must\nbe wrapped in an object that remembers that extra data and passes it along, by deferring\nthe call to the actual handler. Here, a button press runs the function generated by the\nlambda, an indirect call layer that retains information from the enclosing scope. The\nnet effect is that the real handler, printit, receives an extra required name argument\ngiving the demo associated with the button pressed, even though this argument wasn\u2019t\npassed back from tkinter itself. In effect, the lambda remembers and passes on state\ninformation.\nNotice, though, that this lambda function\u2019s body references both self and key in the\nenclosing method\u2019s local scope. In all recent Pythons, the reference to self just works\nbecause of the enclosing function scope lookup rules, but we need to pass key in ex-\nplicitly with a default argument or else it will be the same in all the generated lambda\nfunctions\u2014the value it has after the last loop iteration. As we learned in Chapter 7,\nenclosing scope references are resolved when the nested function is called, but defaults\nare resolved when the nested function is created. Because self won\u2019t change after the\nfunction is made, we can rely on the scope lookup rules for that name, but not for loop\nvariables like key.\nDialogs | 435In earlier Pythons, default arguments were required to pass all values in from enclosing\nscopes explicitly, using either of these two techniques:\n# use simple defaults\nfunc = (lambda self=self, name=key: self.printit(name))\n# use a bound method default\nfunc = (lambda handler=self.printit, name=key: handler(name))\nToday, we can get away with the simpler enclosing -scope reference technique for\nself, though we still need a default for the key loop variable (and you may still see the\ndefault forms in older Python code).\nNote that the parentheses around the lambdas are not required here; I add them as a\npersonal style preference just to set the lambda off from its surrounding code (your\nmileage may vary). Also notice that the lambda does the same work as a nested def\nstatement here; in practice, though, the lambda could appear within the call to\nButton itself because it is an expression and it need not be assigned to a name. The\nfollowing two forms are equivalent:\nfor (key, value) in demos.items():\n    func = (lambda key=key: self.printit(key))          # can be nested i Button()\nfor (key, value) in demos.items():\n    def func(key=key): self.printit(key)                # but def statement cannot\nYou can also use a callable class object here that retains state as instance attributes (see\nthe tutorial\u2019s __call__ example in Chapter 7 for hints). But as a rule of thumb, if you\nwant a lambda\u2019s result to use any names from the enclosing scope when later called,\neither simply name them and let Python save their values for future use, or pass them\nin with defaults to save the values they have at lambda function creation time. The latter\nscheme is required only if the variable used may change before the callback occurs.\nWhen run, this script creates the same window (Figure 8-11) but also prints dialog\nreturn values to standard output; here is the output after clicking all the demo buttons\nin the main window and picking both Cancel/No and then OK/Yes buttons in each\ndialog:\nC:\\...\\PP4E\\Gui\\Tour> python demoDlg-print.py\nColor returns => (None, None)\nColor returns => ((128.5, 128.5, 255.99609375), '#8080ff')\nQuery returns => no\nQuery returns => yes\nInput returns => None\nInput returns => 3.14159\nOpen returns =>\nOpen returns => C:/Users/mark/Stuff/Books/4E/PP4E/dev/Examples/PP4E/Launcher.py\nError returns => ok\nNow that I\u2019ve shown you these dialog results, I want to next show you how one of them\ncan actually be useful.\n436 | Chapter 8:\u2002A tkinter Tour, Part 1Letting users select colors on the fly\nThe standard color selection dialog isn\u2019t just another pretty face\u2014scripts can pass the\nhexadecimal color string it returns to the bg and fg widget color configuration options\nwe met earlier. That is, bg and fg accept both a color name (e.g., blue) and an ask\ncolor hex RGB result string that starts with a # (e.g., the #8080ff in the last output line\nof the prior section).\nThis adds another dimension of customization to tkinter GUIs: instead of hardcoding\ncolors in your GUI products, you can provide a button that pops up color selectors that\nlet users choose color preferences on the fly. Simply pass the color string to widget\nconfig methods in callback handlers, as in Example 8-11.\nExample 8-11. PP4E\\Gui\\Tour\\setcolor.py\nfrom tkinter import *\nfrom tkinter.colorchooser import askcolor\ndef setBgColor():\n    (triple, hexstr) = askcolor()\n    if hexstr:\n        print(hexstr)\n        push.config(bg=hexstr)\nroot = Tk()\npush = Button(root, text='Set Background Color', command=setBgColor)\npush.config(height=3, font=('times', 20, 'bold'))\npush.pack(expand=YES, fill=BOTH)\nroot.mainloop()\nThis script creates the window in Figure 8-16 when launched (its button\u2019s background\nis a sort of green, but you\u2019ll have to trust me on this). Pressing the button pops up the\ncolor selection dialog shown earlier; the color you pick in that dialog becomes the\nbackground color of this button after you press OK.\nFigure 8-16. setcolor main window\nDialogs | 437Color strings are also printed to the stdout stream (the console window); run this on\nyour computer to experiment with available color settings:\nC:\\...\\PP4E\\Gui\\Tour> python setcolor.py\n#0080c0\n#408080\n#77d5df\nOther standard dialog calls\nWe\u2019ve seen most of the standard dialogs and we\u2019ll use these pop ups in examples\nthroughout the rest of this book. But for more details on other calls and options avail-\nable, either consult other tkinter documentation or browse the source code of the\nmodules used at the top of the dialogTable module in Example 8-8; all are simple\nPython files installed in the tkinter subdirectory of the Python source library on your\nmachine (e.g., in C:\\Python31\\Lib on Windows). And keep this demo bar example filed\naway for future reference; we\u2019ll reuse it later in the tour for callback actions when we\nmeet other button-like widgets.\nThe Old-Style Dialog Module\nIn older Python code, you may see dialogs occasionally coded with the standard tkinter\ndialog module. This is a bit dated now, and it uses an X Windows look-and-feel; but\njust in case you run across such code in your Python maintenance excursions, Exam-\nple 8-12 gives you a feel for the interface.\nExample 8-12. PP4E\\Gui\\Tour\\dlg-old.py\nfrom tkinter import *\nfrom tkinter.dialog import Dialog\nclass OldDialogDemo(Frame):\n    def __init__(self, master=None):\n        Frame.__init__(self, master)\n        Pack.config(self)  # same as self.pack()\n        Button(self, text='Pop1', command=self.dialog1).pack()\n        Button(self, text='Pop2', command=self.dialog2).pack()\n    def dialog1(self):\n        ans = Dialog(self,\n                     title   = 'Popup Fun!',\n                     text    = 'An example of a popup-dialog '\n                               'box, using older \"Dialog.py\".',\n                     bitmap  = 'questhead',\n                     default = 0, strings = ('Yes', 'No', 'Cancel'))\n        if ans.num == 0: self.dialog2()\n    def dialog2(self):\n        Dialog(self, title   = 'HAL-9000',\n                     text    = \"I'm afraid I can't let you do that, Dave...\",\n                     bitmap  = 'hourglass',\n438 | Chapter 8:\u2002A tkinter Tour, Part 1default = 0, strings = ('spam', 'SPAM'))\nif __name__ == '__main__': OldDialogDemo().mainloop()\nIf you supply Dialog a tuple of button labels and a message, you get back the index of\nthe button pressed (the leftmost is index zero). Dialog windows are modal: the rest of\nthe application\u2019s windows are disabled until the Dialog receives a response from the\nuser. When you press the Pop2 button in the main window created by this script, the\nsecond dialog pops up, as shown in Figure 8-17.\nFigure 8-17. Old-style dialog\nThis is running on Windows, and as you can see, it is nothing like what you would\nexpect on that platform for a question dialog. In fact, this dialog generates an X Win-\ndows look-and-feel, regardless of the underlying platform. Because of both Dialog\u2019s\nappearance and the extra complexity required to program it, you are probably better\noff using the standard dialog calls of the prior section instead.\nCustom Dialogs\nThe dialogs we\u2019ve seen so far have a standard appearance and interaction. They are fine\nfor many purposes, but often we need something a bit more custom. For example,\nforms that request multiple field inputs (e.g., name, age, shoe size) aren\u2019t directly ad-\ndressed by the common dialog library. We could pop up one single-input dialog in turn\nfor each requested field, but that isn\u2019t exactly user friendly.\nCustom dialogs support arbitrary interfaces, but they are also the most complicated to\nprogram. Even so, there\u2019s not much to it\u2014simply create a pop-up window as a\nToplevel with attached widgets, and arrange a callback handler to fetch user inputs\nentered in the dialog (if any) and to destroy the window. To make such a custom dialog\nmodal, we also need to wait for a reply by giving the window input focus, making other\nwindows inactive, and waiting for an event. Example 8-13 illustrates the basics.\nExample 8-13. PP4E\\Gui\\Tour\\dlg-custom.py\nimport sys\nfrom tkinter import *\nmakemodal = (len(sys.argv) > 1)\nDialogs | 439def dialog():\n    win = Toplevel()                                     # make a new window\n    Label(win,  text='Hard drive reformatted!').pack()   # add a few widgets\n    Button(win, text='OK', command=win.destroy).pack()   # set destroy callback\n    if makemodal:\n        win.focus_set()          # take over input focus,\n        win.grab_set()           # disable other windows while I'm open,\n        win.wait_window()        # and wait here until win destroyed\n    print('dialog exit')         # else returns right away\nroot = Tk()\nButton(root, text='popup', command=dialog).pack()\nroot.mainloop()\nThis script is set up to create a pop-up dialog window in either modal or nonmodal\nmode, depending on its makemodal global variable. If it is run with no command-line\narguments, it picks nonmodal style, captured in Figure 8-18.\nFigure 8-18. Nonmodal custom dialogs at work\nThe window in the upper right is the root window here; pressing its \u201cpopup\u201d button\ncreates a new pop-up dialog window. Because dialogs are nonmodal in this mode, the\nroot window remains active after a dialog is popped up. In fact, nonmodal dialogs never\nblock other windows, so you can keep pressing the root\u2019s button to generate as many\ncopies of the pop-up window as will fit on your screen. Any or all of the pop ups can\nbe killed by pressing their OK buttons, without killing other windows in this display.\nMaking custom dialogs modal\nNow, \nwhen \nthe \nscript \nis \nrun \nwith \na \ncommand-line \nargument \n(e.g.,\npython dlg-custom.py 1), it makes its pop ups modal instead. Because modal dialogs\ngrab all of the interface\u2019s attention, the main window becomes inactive in this mode\nuntil the pop up is killed; you can\u2019t even click on it to reactivate it while the dialog is\n440 | Chapter 8:\u2002A tkinter Tour, Part 1open. Because of that, you can never make more than one copy of the pop up on-screen\nat once, as shown in Figure 8-19.\nFigure 8-19. A modal custom dialog at work\nIn fact, the call to the dialog function in this script doesn\u2019t return until the dialog\nwindow on the left is dismissed by pressing its OK button. The net effect is that modal\ndialogs impose a function call\u2013like model on an otherwise event-driven programming\nmodel; user inputs can be processed right away, not in a callback handler triggered at\nsome arbitrary point in the future.\nForcing such a linear control flow on a GUI takes a bit of extra work, though. The secret\nto locking other windows and waiting for a reply boils down to three lines of code,\nwhich are a general pattern repeated in most custom modal dialogs.\nwin.focus_set()\nMakes the window take over the application\u2019s input focus, as if it had been clicked\nwith the mouse to make it the active window. This method is also known by the\nsynonym focus, and it\u2019s also common to set the focus on an input widget within\nthe dialog (e.g., an Entry) rather than on the entire window.\nwin.grab_set()\nDisables all other windows in the application until this one is destroyed. The user\ncannot interact with other windows in the program while a grab is set.\nwin.wait_window()\nPauses the caller until the win widget is destroyed, but keeps the main event-\nprocessing loop (mainloop) active during the pause. That means that the GUI at\nlarge remains active during the wait; its windows redraw themselves if covered and\nuncovered, for example. When the window is destroyed with the destroy method,\nit is erased from the screen, the application grab is automatically released, and this\nmethod call finally returns.\nBecause the script waits for a window destroy event, it must also arrange for a callback\nhandler to destroy the window in response to interaction with widgets in the dialog\nwindow (the only window active). This example\u2019s dialog is simply informational, so\nits OK button calls the window\u2019s destroy method. In user-input dialogs, we might\ninstead install an Enter key-press callback handler that fetches data typed into an\nEntry widget and then calls destroy (see later in this chapter).\nDialogs | 441Other ways to be modal\nModal dialogs are typically implemented by waiting for a newly created pop-up win-\ndow\u2019s destroy event, as in this example. But other schemes are viable too. For example,\nit\u2019s possible to create dialog windows ahead of time, and show and hide them as needed\nwith the top-level window\u2019s deiconify and withdraw methods (see the alarm scripts\nnear the end of Chapter 9 for details). Given that window creation speed is generally\nfast enough as to appear instantaneous today, this is much less common than making\nand destroying a window from scratch on each interaction.\nIt\u2019s also possible to implement a modal state by waiting for a tkinter variable to change\nits value, instead of waiting for a window to be destroyed. See this chapter\u2019s later dis-\ncussion of tkinter variables (which are class objects, not normal Python variables) and\nthe wait_variable method discussed near the end of Chapter 9 for more details. This\nscheme allows a long-lived dialog box\u2019s callback handler to signal a state change to a\nwaiting main program, without having to destroy the dialog box.\nFinally, if you call the mainloop method recursively, the call won\u2019t return until the widget\nquit method has been invoked. The quit method terminates a mainloop call, and so\nnormally ends a GUI program. But it will simply exit a recursive mainloop level if one\nis active. Because of this, modal dialogs can also be written without wait method calls\nif you are careful. For instance, Example 8-14 works the same way as the modal mode\nof dlg-custom.\nExample 8-14. PP4E\\Gui\\Tour\\dlg-recursive.py\nfrom tkinter import *\ndef dialog():\n    win = Toplevel()                                      # make a new window\n    Label(win,  text='Hard drive reformatted!').pack()    # add a few widgets\n    Button(win, text='OK', command=win.quit).pack()       # set quit callback\n    win.protocol('WM_DELETE_WINDOW', win.quit)            # quit on wm close too!\n    win.focus_set()          # take over input focus,\n    win.grab_set()           # disable other windows while I'm open,\n    win.mainloop()           # and start a nested event loop to wait\n    win.destroy()\n    print('dialog exit')\nroot = Tk()\nButton(root, text='popup', command=dialog).pack()\nroot.mainloop()\nIf you go this route, be sure to call quit rather than destroy in dialog callback handlers\n(destroy doesn\u2019t terminate the mainloop level), and be sure to use protocol to make the\nwindow border close button call quit too (or else it won\u2019t end the recursive mainloop\nlevel call and may generate odd error messages when your program finally exits). Be-\ncause of this extra complexity, you\u2019re probably better off using wait_window or\nwait_variable, not recursive mainloop calls.\n442 | Chapter 8:\u2002A tkinter Tour, Part 1We\u2019ll see how to build form-like dialogs with labels and input fields later in this chapter\nwhen we meet Entry, and again when we study the grid manager in Chapter 9. For\nmore custom dialog examples, see ShellGui (Chapter 10), PyMailGUI (Chapter 14),\nPyCalc (Chapter 19), and the nonmodal form.py (Chapter 12). Here, we\u2019re moving on\nto learn more about events that will prove to be useful currency at later tour\ndestinations.\nBinding Events\nWe met the bind widget method in the prior chapter, when we used it to catch button\npresses in the tutorial. Because bind is commonly used in conjunction with other widg-\nets (e.g., to catch return key presses for input boxes), we\u2019re going to make a stop early\nin the tour here as well. Example 8-15 illustrates more bind event protocols.\nExample 8-15. PP4E\\Gui\\Tour\\bind.py\nfrom tkinter import *\ndef showPosEvent(event):\n    print('Widget=%s X=%s Y=%s' % (event.widget, event.x, event.y))\ndef showAllEvent(event):\n    print(event)\n    for attr in dir(event):\n        if not attr.startswith('__'):\n            print(attr, '=>', getattr(event, attr))\ndef onKeyPress(event):\n    print('Got key press:', event.char)\ndef onArrowKey(event):\n    print('Got up arrow key press')\ndef onReturnKey(event):\n    print('Got return key press')\ndef onLeftClick(event):\n    print('Got left mouse button click:', end=' ')\n    showPosEvent(event)\ndef onRightClick(event):\n    print('Got right mouse button click:', end=' ')\n    showPosEvent(event)\ndef onMiddleClick(event):\n    print('Got middle mouse button click:', end=' ')\n    showPosEvent(event)\n    showAllEvent(event)\ndef onLeftDrag(event):\n    print('Got left mouse button drag:', end=' ')\n    showPosEvent(event)\nBinding Events | 443def onDoubleLeftClick(event):\n    print('Got double left mouse click', end=' ')\n    showPosEvent(event)\n    tkroot.quit()\ntkroot = Tk()\nlabelfont = ('courier', 20, 'bold')                # family, size, style\nwidget = Label(tkroot, text='Hello bind world')\nwidget.config(bg='red', font=labelfont)            # red background, large font\nwidget.config(height=5, width=20)                  # initial size: lines,chars\nwidget.pack(expand=YES, fill=BOTH)\nwidget.bind('<Button-1>',  onLeftClick)            # mouse button clicks\nwidget.bind('<Button-3>',  onRightClick)\nwidget.bind('<Button-2>',  onMiddleClick)          # middle=both on some mice\nwidget.bind('<Double-1>',  onDoubleLeftClick)      # click left twice\nwidget.bind('<B1-Motion>', onLeftDrag)             # click left and move\nwidget.bind('<KeyPress>',  onKeyPress)             # all keyboard presses\nwidget.bind('<Up>',        onArrowKey)             # arrow button pressed\nwidget.bind('<Return>',    onReturnKey)            # return/enter key pressed\nwidget.focus()                                     # or bind keypress to tkroot\ntkroot.title('Click Me')\ntkroot.mainloop()\nMost of this file consists of callback handler functions triggered when bound events\noccur. As we learned in Chapter 7, this type of callback receives an event object argu-\nment that gives details about the event that fired. Technically, this argument is an\ninstance of the tkinter Event class, and its details are attributes; most of the callbacks\nsimply trace events by displaying relevant event attributes.\nWhen run, this script makes the window shown in Figure 8-20; it\u2019s mostly intended\njust as a surface for clicking and pressing event triggers.\nFigure 8-20. A bind window for the clicking\nThe black-and-white medium of the book you\u2019re holding won\u2019t really do justice to this\nscript. When run live, it uses the configuration options shown earlier to make the\n444 | Chapter 8:\u2002A tkinter Tour, Part 1window show up as black on red, with a large Courier font. You\u2019ll have to take my\nword for it (or run this on your own).\nBut the main point of this example is to demonstrate other kinds of event binding\nprotocols at work. We saw a script that intercepted left and double-left mouse clicks\nwith the widget bind method in Chapter 7, using event names <Button-1> and\n<Double-1>; the script here demonstrates other kinds of events that are commonly\ncaught with bind:\n<KeyPress>\nTo catch the press of a single key on the keyboard, register a handler for the\n<KeyPress> event identifier; this is a lower-level way to input data in GUI programs\nthan the Entry widget covered in the next section. The key pressed is returned in\nASCII string form in the event object passed to the callback handler (event.char).\nOther attributes in the event structure identify the key pressed in lower-level detail.\nKey presses can be intercepted by the top-level root window widget or by a widget\nthat has been assigned keyboard focus with the focus method used by this script.\n<B1-Motion>\nThis script also catches mouse motion while a button is held down: the registered\n<B1-Motion> event handler is called every time the mouse is moved while the left\nbutton is pressed and receives the current X/Y coordinates of the mouse pointer in\nits event argument (event.x, event.y). Such information can be used to implement\nobject moves, drag-and-drop, pixel-level painting, and so on (e.g., see the PyDraw\nexamples in Chapter 11).\n<Button-3>, <Button-2>\nThis script also catches right and middle mouse button clicks (known as buttons\n3 and 2). To make the middle button 2 click work on a two-button mouse, try\nclicking both buttons at the same time; if that doesn\u2019t work, check your mouse\nsetting in your properties interface (the Control Panel on Windows).\n<Return>, <Up>\nTo catch more specific kinds of key presses, this script registers for the Return/\nEnter and up-arrow key press events; these events would otherwise be routed to\nthe general <KeyPress> handler and require event analysis.\nHere is what shows up in the stdout output stream after a left click, right click, left click\nand drag, a few key presses, a Return and up-arrow press, and a final double-left click\nto exit. When you press the left mouse button and drag it around on the display, you\u2019ll\nget lots of drag event messages; one is printed for every move during the drag (and one\nPython callback is run for each):\nC:\\...\\PP4E\\Gui\\Tour> python bind.py\nGot left mouse button click: Widget=.25763696 X=376 Y=53\nGot right mouse button click: Widget=.25763696 X=36 Y=60\nGot left mouse button click: Widget=.25763696 X=144 Y=43\nGot left mouse button drag: Widget=.25763696 X=144 Y=45\nGot left mouse button drag: Widget=.25763696 X=144 Y=47\nBinding Events | 445Got left mouse button drag: Widget=.25763696 X=145 Y=50\nGot left mouse button drag: Widget=.25763696 X=146 Y=51\nGot left mouse button drag: Widget=.25763696 X=149 Y=53\nGot key press: s\nGot key press: p\nGot key press: a\nGot key press: m\nGot key press: 1\nGot key press: -\nGot key press: 2\nGot key press: .\nGot return key press\nGot up arrow key press\nGot left mouse button click: Widget=.25763696 X=300 Y=68\nGot double left mouse click Widget=.25763696 X=300 Y=68\nFor mouse-related events, callbacks print the X and Y coordinates of the mouse pointer,\nin the event object passed in. Coordinates are usually measured in pixels from the\nupper-left corner (0,0), but are relative to the widget being clicked. Here\u2019s what is\nprinted for a left, middle, and double-left click. Notice that the middle-click callback\ndumps the entire argument\u2014all of the Event object\u2019s attributes (less internal names\nthat begin with \u201c__\u201d which includes the __doc__ string, and default operator overload-\ning methods inherited from the implied object superclass in Python 3.X). Different\nevent types set different event attributes; most key presses put something in char, for\ninstance:\nC:\\...\\PP4E\\Gui\\Tour> python bind.py\nGot left mouse button click: Widget=.25632624 X=6 Y=6\nGot middle mouse button click: Widget=.25632624 X=212 Y=95\n<tkinter.Event object at 0x018CA210>\nchar => ??\ndelta => 0\nheight => ??\nkeycode => ??\nkeysym => ??\nkeysym_num => ??\nnum => 2\nsend_event => False\nserial => 17\nstate => 0\ntime => 549707945\ntype => 4\nwidget => .25632624\nwidth => ??\nx => 212\nx_root => 311\ny => 95\ny_root => 221\nGot left mouse button click: Widget=.25632624 X=400 Y=183\nGot double left mouse click Widget=.25632624 X=400 Y=183\n446 | Chapter 8:\u2002A tkinter Tour, Part 1Other bind Events\nBesides those illustrated in this example, a tkinter script can register to catch additional\nkinds of bindable events. For example:\n\u2022 <ButtonRelease> fires when a button is released (<ButtonPress> is run when the\nbutton first goes down).\n\u2022 <Motion> is triggered when a mouse pointer is moved.\n\u2022 <Enter> and <Leave> handlers intercept mouse entry and exit in a window\u2019s display\narea (useful for automatically highlighting a widget).\n\u2022 <Configure> is invoked when the window is resized, repositioned, and so on (e.g.,\nthe event object\u2019s width and height give the new window size). We\u2019ll make use of\nthis to resize the display on window resizes in the PyClock example of Chapter 11.\n\u2022 <Destroy> is invoked when the window widget is destroyed (and differs from the\nprotocol mechanism for window manager close button presses). Since this inter-\nacts with widget quit and destroy methods, I\u2019ll say more about the event later in\nthis section.\n\u2022 <FocusIn> and <FocusOut> are run as the widget gains and loses focus.\n\u2022 <Map> and <Unmap> are run when a window is opened and iconified.\n\u2022 <Escape>, <BackSpace>, and <Tab> catch other special key presses.\n\u2022 <Down>, <Left>, and <Right> catch other arrow key presses.\nThis is not a complete list, and event names can be written with a somewhat sophisti-\ncated syntax of their own. For instance:\n\u2022 Modifiers can be added to event identifiers to make them even more specific; for\ninstance, <B1-Motion> means moving the mouse with the left button pressed, and\n<KeyPress-a> refers to pressing the \u201ca\u201d key only.\n\u2022 Synonyms can be used for some common event names; for instance, <Button\nPress-1>, <Button-1>, and <1> mean a left mouse button press, and <KeyPress-a>\nand <Key-a> mean the \u201ca\u201d key. All forms are case sensitive: use <Key-Escape>, not\n<KEY-ESCAPE>.\n\u2022 Virtual event identifiers can be defined within double bracket pairs (e.g., <<Paste\nText>>) to refer to a selection of one or more event sequences.\nIn the interest of space, though, we\u2019ll defer to other Tk and tkinter reference sources\nfor an exhaustive list of details on this front. Alternatively, changing some of the settings\nin the example script and rerunning can help clarify some event behavior, too; this is\nPython, after all.\nMore on <Destroy> events and the quit and destroy methods\nBefore we move on, one event merits a few extra words: the <Destroy> event (whose\nname is case significant) is run when a widget is being destroyed, as a result of both\nBinding Events | 447script method calls and window closures in general, including those at program exit.\nIf you bind this on a window, it will be triggered once for each widget in the window;\nthe callback\u2019s event argument widget attribute gives the widget being destroyed, and\nyou can check this to detect a particular widget\u2019s destruction. If you bind this on a\nspecific widget instead, it will be triggered once for that widget\u2019s destruction only.\nIt\u2019s important to know that a widget is in a \u201chalf dead\u201d state (Tk\u2019s terminology) when\nthis event is triggered\u2014it still exists, but most operations on it fail. Because of that, the\n<Destroy> event is not intended for GUI activity in general; for instance, checking a text\nwidget\u2019s changed state or fetching its content in a <Destroy> handler can both fail with\nexceptions. In addition, this event\u2019s handler cannot cancel the destruction in general\nand resume the GUI; if you wish to intercept and verify or suppress window closes\nwhen a user clicks on a window\u2019s X button, use WM_DELETE_WINDOW in top-level windows\u2019\nprotocol methods as described earlier in this chapter.\nYou should also know that running a tkinter widget\u2019s quit method does not trigger any\n<Destroy> events on exit, and even leads to a fatal Python error on program exit in 3.X\nif any <Destroy> event handlers are registered. Because of this, programs that bind this\nevent for non-GUI window exit actions should usually call destroy instead of quit to\nclose, and rely on the fact that a program exits when the last remaining or only Tk root\nwindow (default or explicit) is destroyed as described earlier. This precludes using\nquit for immediate shutdowns, though you can still run sys.exit for brute-force exits.\nA script can also perform program exit actions in code run after the mainloop call re-\nturns, but the GUI is gone completely at this point, and this code is not associated with\nany particular widget. Watch for more on this event when we study the PyEdit example\nprogram in Chapter 11; at the risk of spoiling the end of this story, we\u2019ll find it unusable\nfor verifying changed text saves.\nMessage and Entry\nThe Message and Entry widgets allow for display and input of simple text. Both are\nessentially functional subsets of the Text widget we\u2019ll meet later; Text can do everything\nMessage and Entry can, but not vice versa.\nMessage\nThe Message widget is simply a place to display text. Although the standard showinfo\ndialog we met earlier is perhaps a better way to display pop-up messages, Message splits\nup long strings automatically and flexibly and can be embedded inside container widg-\nets any time you need to add some read-only text to a display. Moreover, this widget\nsports more than a dozen configuration options that let you customize its appearance.\nExample 8-16 and Figure 8-21 illustrate Message basics, and demonstrates how\nMessage reacts to horizontal stretching with fill and expand; see Chapter 7 for more\non resizing and Tk or tkinter references for other options Message supports.\n448 | Chapter 8:\u2002A tkinter Tour, Part 1Example 8-16. PP4E\\Gui\\tour\\message.py\nfrom tkinter import *\nmsg = Message(text=\"Oh by the way, which one's Pink?\")\nmsg.config(bg='pink', font=('times', 16, 'italic'))\nmsg.pack(fill=X, expand=YES)\nmainloop()\nFigure 8-21. A Message widget at work\nEntry\nThe Entry widget is a simple, single-line text input field. It is typically used for input\nfields in form-like dialogs and anywhere else you need the user to type a value into a\nfield of a larger display. Entry also supports advanced concepts such as scrolling, key\nbindings for editing, and text selections, but it\u2019s simple to use in practice. Exam-\nple 8-17 builds the input window shown in Figure 8-22.\nExample 8-17. PP4E\\Gui\\tour\\entry1.py\nfrom tkinter import *\nfrom quitter import Quitter\ndef fetch():\n    print('Input => \"%s\"' % ent.get())             # get text\nroot = Tk()\nent = Entry(root)\nent.insert(0, 'Type words here')                   # set text\nent.pack(side=TOP, fill=X)                         # grow horiz\nent.focus()                                        # save a click\nent.bind('<Return>', (lambda event: fetch()))      # on enter key\nbtn = Button(root, text='Fetch', command=fetch)    # and on button\nbtn.pack(side=LEFT)\nQuitter(root).pack(side=RIGHT)\nroot.mainloop()\nMessage and Entry | 449Figure 8-22. entry1 caught in the act\nOn startup, the entry1 script fills the input field in this GUI with the text \u201cType words\nhere\u201d by calling the widget\u2019s insert method. Because both the Fetch button and the\nEnter key are set to trigger the script\u2019s fetch callback function, either user event gets\nand displays the current text in the input field, using the widget\u2019s get method:\nC:\\...\\PP4E\\Gui\\Tour> python entry1.py\nInput => \"Type words here\"\nInput => \"Have a cigar\"\nWe met the <Return> event earlier when we studied bind; unlike button presses, these\nlower-level callbacks get an event argument, so the script uses a lambda wrapper to\nignore it. This script also packs the entry field with fill=X to make it expand horizon-\ntally with the window (try it out), and it calls the widget focus method to give the entry\nfield input focus when the window first appears. Manually setting the focus like this\nsaves the user from having to click the input field before typing. Our smart Quit button\nwe wrote earlier is attached here again as well (it verifies exit).\nProgramming Entry widgets\nGenerally speaking, the values typed into and displayed by Entry widgets are set and\nfetched with either tied \u201cvariable\u201d objects (described later in this chapter) or Entry\nwidget method calls such as this one:\nent.insert(0, 'some text')          # set value\nvalue = ent.get()                   # fetch value (a string)\nThe first parameter to the insert method gives the position where the text is to be\ninserted. Here, \u201c0\u201d means the front because offsets start at zero, and integer 0 and string\n'0' mean the same thing (tkinter method arguments are always converted to strings if\nneeded). If the Entry widget might already contain text, you also generally need to delete\nits contents before setting it to a new value, or else new text will simply be added to\nthe text already present:\nent.delete(0, END)                  # first, delete from start to end\nent.insert(0, 'some text')          # then set value\nThe name END here is a preassigned tkinter constant denoting the end of the widget;\nwe\u2019ll revisit it in Chapter 9 when we meet the full-blown and multiple-line Text widget\n(Entry\u2019s more powerful cousin). Since the widget is empty after the deletion, this state-\nment sequence is equivalent to the prior one:\n450 | Chapter 8:\u2002A tkinter Tour, Part 1ent.delete('0', END)                # delete from start to end\nent.insert(END, 'some text')        # add at end of empty text\nEither way, if you don\u2019t delete the text first, new text that is inserted is simply added.\nIf you want to see how, try changing the fetch function in Example 8-17 to look like\nthis\u2014an \u201cx\u201d is added at the beginning and end of the input field on each button or key\npress:\ndef fetch():\n    print('Input => \"%s\"' % ent.get())        # get text\n    ent.insert(END, 'x')                      # to clear: ent.delete('0', END)\n    ent.insert(0, 'x')                        # new text simply added\nIn later examples, we\u2019ll also see the Entry widget\u2019s state='disabled' option, which\nmakes it read only, as well as its show='*' option, which makes it display each character\nas a * (useful for password-type inputs). Try this out on your own by changing and\nrunning this script for a quick look. Entry supports other options we\u2019ll skip here, too;\nsee later examples and other resources for additional details.\nLaying Out Input Forms\nAs mentioned, Entry widgets are often used to get field values in form-like displays.\nWe\u2019re going to create such displays often in this book, but to show you how this works\nin simpler terms, Example 8-18 combines labels, entries, and frames to achieve the\nmultiple-input display captured in Figure 8-23.\nExample 8-18. PP4E\\Gui\\Tour\\entry2.py\n\"\"\"\nuse Entry widgets directly\nlay out by rows with fixed-width labels: this and grid are best for forms\n\"\"\"\nfrom tkinter import *\nfrom quitter import Quitter\nfields = 'Name', 'Job', 'Pay'\ndef fetch(entries):\n    for entry in entries:\n        print('Input => \"%s\"' % entry.get())        # get text\ndef makeform(root, fields):\n    entries = []\n    for field in fields:\n        row = Frame(root)                           # make a new row\n        lab = Label(row, width=5, text=field)       # add label, entry\n        ent = Entry(row)\n        row.pack(side=TOP, fill=X)                  # pack row on top\n        lab.pack(side=LEFT)\n        ent.pack(side=RIGHT, expand=YES, fill=X)    # grow horizontal\n        entries.append(ent)\n    return entries\nMessage and Entry | 451if __name__ == '__main__':\n    root = Tk()\n    ents = makeform(root, fields)\n    root.bind('<Return>', (lambda event: fetch(ents)))\n    Button(root, text='Fetch',\n                 command= (lambda: fetch(ents))).pack(side=LEFT)\n    Quitter(root).pack(side=RIGHT)\n    root.mainloop()\nFigure 8-23. entry2 (and entry3) form displays\nThe input fields here are just simple Entry widgets. The script builds an explicit list of\nthese widgets to be used to fetch their values later. Every time you press this window\u2019s\nFetch button, it grabs the current values in all the input fields and prints them to the\nstandard output stream:\nC:\\...\\PP4E\\Gui\\Tour> python entry2.py\nInput => \"Bob\"\nInput => \"Technical Writer\"\nInput => \"Jack\"\nYou get the same field dump if you press the Enter key anytime this window has the\nfocus on your screen; this event has been bound to the whole root window this time,\nnot to a single input field.\nMost of the art in form layout has to do with arranging widgets in a hierarchy. This\nscript builds each label/entry row as a new Frame attached to the window\u2019s current\nTOP; fixed-width labels are attached to the LEFT of their row, and entries to the RIGHT.\nBecause each row is a distinct Frame, its contents are insulated from other packing going\non in this window. The script also arranges for just the entry fields to grow vertically\non a resize, as in Figure 8-24.\nGoing modal again\nLater on this tour, we\u2019ll see how to make similar form layouts with the grid geometry\nmanager, where we arrange by row and column numbers instead of frames. But now\nthat we have a handle on form layout, let\u2019s see how to apply the modal dialog techniques\nwe met earlier to a more complex input display.\n452 | Chapter 8:\u2002A tkinter Tour, Part 1Example 8-19 uses the prior example\u2019s makeform and fetch functions to generate a form\nand prints its contents, much as before. Here, though, the input fields are attached to\na new Toplevel pop-up window created on demand, and an OK button is added to the\nnew window to trigger a window destroy event that erases the pop up. As we learned\nearlier, the wait_window call pauses until the destroy happens.\nExample 8-19. PP4E\\Gui\\Tour\\entry2-modal.py\n# make form dialog modal; must fetch before destroy with entries\nfrom tkinter import *\nfrom entry2 import makeform, fetch, fields\ndef show(entries, popup):\n    fetch(entries)                  # must fetch before window destroyed!\n    popup.destroy()                 # fails with msgs if stmt order is reversed\ndef ask():\n    popup = Toplevel()              # show form in modal dialog window\n    ents = makeform(popup, fields)\n    Button(popup, text='OK', command=(lambda: show(ents, popup))).pack()\n    popup.grab_set()\n    popup.focus_set()\n    popup.wait_window()             # wait for destroy here\nroot = Tk()\nButton(root, text='Dialog', command=ask).pack()\nroot.mainloop()\nWhen you run this code, pressing the button in this program\u2019s main window creates\nthe blocking form input dialog in Figure 8-25, as expected.\nBut a subtle danger is lurking in this modal dialog code: because it fetches user inputs\nfrom Entry widgets embedded in the popped-up display, it must fetch those inputs\nbefore destroying the pop-up window in the OK press callback handler. It turns out\nthat a destroy call really does destroy all the child widgets of the window destroyed;\ntrying to fetch values from a destroyed Entry not only doesn\u2019t work, but also generates\na traceback with error messages in the console window. Try reversing the statement\norder in the show function to see for yourself.\nFigure 8-24. entry2 (and entry3) expansion at work\nMessage and Entry | 453To avoid this problem, we can either be careful to fetch before destroying, or use tkinter\nvariables, the subject of the next section.\ntkinter \u201cVariables\u201d and Form Layout Alternatives\nEntry widgets (among others) support the notion of an associated variable\u2014changing\nthe associated variable changes the text displayed in the Entry, and changing the text\nin the Entry changes the value of the variable. These aren\u2019t normal Python variable\nnames, though. Variables tied to widgets are instances of variable classes in the tkinter\nmodule library. These classes are named StringVar, IntVar, DoubleVar, and Boolean\nVar; you pick one based on the context in which it is to be used. For example, a String\nVar class instance can be associated with an Entry field, as demonstrated in\nExample 8-20.\nExample 8-20. PP4E\\Gui\\Tour\\entry3.py\n\"\"\"\nuse StringVar variables\nlay out by columns: this might not align horizontally everywhere (see entry2)\n\"\"\"\nfrom tkinter import *\nfrom quitter import Quitter\nfields = 'Name', 'Job', 'Pay'\ndef fetch(variables):\n    for variable in variables:\n        print('Input => \"%s\"' % variable.get())     # get from var\nFigure 8-25. entry2-modal (and entry3-modal) displays\n454 | Chapter 8:\u2002A tkinter Tour, Part 1def makeform(root, fields):\n    form = Frame(root)                              # make outer frame\n    left = Frame(form)                              # make two columns\n    rite = Frame(form)\n    form.pack(fill=X)\n    left.pack(side=LEFT)\n    rite.pack(side=RIGHT, expand=YES, fill=X)       # grow horizontal\n    variables = []\n    for field in fields:\n        lab = Label(left, width=5, text=field)      # add to columns\n        ent = Entry(rite)\n        lab.pack(side=TOP)\n        ent.pack(side=TOP, fill=X)                  # grow horizontal\n        var = StringVar()\n        ent.config(textvariable=var)                # link field to var\n        var.set('enter here')\n        variables.append(var)\n    return variables\nif __name__ == '__main__':\n    root = Tk()\n    vars = makeform(root, fields)\n    Button(root, text='Fetch', command=(lambda: fetch(vars))).pack(side=LEFT)\n    Quitter(root).pack(side=RIGHT)\n    root.bind('<Return>', (lambda event: fetch(vars)))\n    root.mainloop()\nExcept for the fact that this script initializes input fields with the string 'enter here',\nit makes a window virtually identical in appearance and function to that created by the\nscript entry2 (see Figures 8-23 and 8-24). For illustration purposes, the window is laid\nout differently\u2014as a Frame containing two nested subframes used to build the left and\nright columns of the form area\u2014but the end result is the same when it is displayed on\nscreen (for some GUIs on some platforms, at least: see the note at the end of this section\nfor a discussion of why layout by rows instead of columns is generally preferred).\nThe main thing to notice here, though, is the use of StringVar variables. Instead of using\na list of Entry widgets to fetch input values, this version keeps a list of StringVar objects\nthat have been associated with the Entry widgets, like this:\nent = Entry(rite)\nvar = StringVar()\nent.config(textvariable=var)                # link field to var\nOnce you\u2019ve tied variables in this way, changing and fetching the variable\u2019s value:\nvar.set('text here')\nvalue = var.get()\nMessage and Entry | 455will really change and fetch the corresponding display\u2019s input field value.* The variable\nobject get method returns as a string for StringVar, an integer for IntVar, and a floating-\npoint number for DoubleVar.\nOf course, we\u2019ve already seen that it\u2019s easy to set and fetch text in Entry fields directly,\nwithout adding extra code to use variables. So, why the bother about variable objects?\nFor one thing, it clears up that nasty fetch-after-destroy peril we met in the prior section.\nBecause StringVars live on after the Entry widgets they are tied to have been destroyed,\nit\u2019s OK to fetch input values from them long after a modal dialog has been dismissed,\nas shown in Example 8-21.\nExample 8-21. PP4E\\Gui\\Tour\\entry3-modal.py\n# can fetch values after destroy with stringvars\nfrom tkinter import *\nfrom entry3 import makeform, fetch, fields\ndef show(variables, popup):\n    popup.destroy()                 # order doesn't matter here\n    fetch(variables)                # variables live on after window destroyed\ndef ask():\n    popup = Toplevel()              # show form in modal dialog window\n    vars = makeform(popup, fields)\n    Button(popup, text='OK', command=(lambda: show(vars, popup))).pack()\n    popup.grab_set()\n    popup.focus_set()\n    popup.wait_window()             # wait for destroy here\nroot = Tk()\nButton(root, text='Dialog', command=ask).pack()\nroot.mainloop()\nThis version is the same as the original (shown in Example 8-19 and Figure 8-25), but\nshow now destroys the pop up before inputs are fetched through StringVars in the list\ncreated by makeform. In other words, variables are a bit more robust in some contexts\nbecause they are not part of a real display tree. For example, they are also commonly\nassociated with check buttons, radio boxes, and scales in order to provide access to\ncurrent settings and link multiple widgets together. Almost coincidentally, that\u2019s the\ntopic of the next section.\n* Historic anecdote: In a now-defunct tkinter release shipped with Python 1.3, you could also set and fetch\nvariable values by calling them like functions, with and without an argument (e.g., var(value) and var()).\nToday, you call variable set and get methods instead. For unknown reasons, the function call form stopped\nworking years ago, but you may still see it in older Python code (and in first editions of at least one O\u2019Reilly\nPython book). If a fix made in the name of aesthetics breaks working code, is it really a fix?\n456 | Chapter 8:\u2002A tkinter Tour, Part 1We laid out input forms two ways in this section: by row frames with\nfixed-width labels (entry2), and by column frames (entry3). In Chap-\nter 9 we\u2019ll see a third form technique: layouts using the grid geometry\nmanager. Of these, gridding, and the rows with fixed-width labels of\nentry2 tend to work best across all platforms.\nLaying out by column frames as in entry3 works only on platforms\nwhere the height of each label exactly matches the height of each entry\nfield. Because the two are not associated directly, they might not line up\nproperly on some platforms. When I tried running some forms that\nlooked fine on Windows XP on a Linux machine, labels and their cor-\nresponding entries did not line up horizontally.\nEven the simple window produced by entry3 looks slightly askew on\ncloser inspection. It only appears the same as entry2 on some platforms\nbecause of the small number of inputs and size defaults. On my Win-\ndows 7 netbook, the labels and entries start to become horizontally\nmismatched if you add 3 or 4 additional inputs to entry3\u2019s fields tuple.\nIf you care about portability, lay out your forms either with the packed\nrow frames and fixed/maximum-width labels of entry2, or by gridding\nwidgets by row and column numbers instead of packing them. We\u2019ll see\nmore on such forms in the next chapter. And in Chapter 12, we\u2019ll write\na form-construction tool that hides the layout details from its clients\naltogether (including its use case client in Chapter 13).\nCheckbutton, Radiobutton, and Scale\nThis section introduces three widget types: the Checkbutton (a multiple-choice input\nwidget), the Radiobutton (a single-choice device), and the Scale (sometimes known as\na \u201cslider\u201d). All are variations on a theme and are somewhat related to simple buttons,\nso we\u2019ll explore them as a group here. To make these widgets more fun to play with,\nwe\u2019ll reuse the dialogTable module shown in Example 8-8 to provide callbacks for\nwidget selections (callbacks pop up dialog boxes). Along the way, we\u2019ll also use the\ntkinter variables we just met to communicate with these widgets\u2019 state settings.\nCheckbuttons\nThe Checkbutton and Radiobutton widgets are designed to be associated with tkinter\nvariables: clicking the button changes the value of the variable, and setting the variable\nchanges the state of the button to which it is linked. In fact, tkinter variables are central\nto the operation of these widgets:\n\u2022 A collection of Checkbuttons implements a multiple-choice interface by assigning\neach button a variable of its own.\n\u2022 A collection of Radiobuttons imposes a mutually exclusive single-choice model by\ngiving each button a unique value and the same tkinter variable.\nCheckbutton, Radiobutton, and Scale | 457Both kinds of buttons provide both command and variable options. The command option \nlets you register a callback to be run immediately on button-press events, much like \nnormal Button widgets. But by associating a tkinter variable with the variable option, \nyou can also fetch or change widget state at any time by fetching or changing the value \nof the widget\u2019s associated variable.\nSince it\u2019s a bit simpler, let\u2019s start with the tkinter Checkbutton. Example 8-22 creates \nthe set of five captured in Figure 8-26. To make this more useful, it also adds a button \nthat dumps the current state of all Checkbuttons and attaches an instance of the verifying \nQuitter button we built earlier in the tour.\nFigure 8-26. demoCheck in action\nExample 8-22. PP4E\\Gui\\Tour\\demoCheck.py\n\"create a bar of check buttons that run dialog demos\"\nfrom tkinter import *             # get base widget set\nfrom dialogTable import demos     # get canned dialogs\nfrom quitter import Quitter       # attach a quitter object to \"me\"\nclass Demo(Frame):\n    def __init__(self, parent=None, **options):\n        Frame.__init__(self, parent, **options)\n        self.pack()\n        self.tools()\n        Label(self, text=\"Check demos\").pack()\n        self.vars = []\n        for key in demos:\n            var = IntVar()\n            Checkbutton(self,\n                        text=key,\n                        variable=var,\n                        command=demos[key]).pack(side=LEFT)\n            self.vars.append(var)\n    def report(self):\n        for var in self.vars:\n            print(var.get(), end=' ')   # current toggle settings: 1 or 0\n        print()\n    def tools(self):\n        frm = Frame(self)\n        frm.pack(side=RIGHT)\n458 | Chapter 8:\u2002A tkinter Tour, Part 1Button(frm, text='State', command=self.report).pack(fill=X)\n        Quitter(frm).pack(fill=X)\nif __name__ == '__main__': Demo().mainloop()\nIn terms of program code, check buttons resemble normal buttons; they are even\npacked within a container widget. Operationally, though, they are a bit different. As\nyou can probably tell from this figure (and can better tell by running this live), a check\nbutton works as a toggle\u2014pressing one changes its state from off to on (from deselected\nto selected); or from on to off again. When a check button is selected, it has a checked\ndisplay, and its associated IntVar variable has a value of 1; when deselected, its display\nis empty and its IntVar has a value of 0.\nTo simulate an enclosing application, the State button in this display triggers the script\u2019s\nreport method to display the current values of all five toggles on the stdout stream.\nHere is the output after a few clicks:\nC:\\...\\PP4E\\Gui\\Tour> python demoCheck.py\n0 0 0 0 0\n1 0 0 0 0\n1 0 1 0 0\n1 0 1 1 0\n1 0 0 1 0\n1 0 0 1 1\nReally, these are the values of the five tkinter variables associated with the\nCheckbuttons with variable options, but they give the buttons\u2019 values when queried.\nThis script associates IntVar variables with each Checkbutton in this display, since they\nare 0 or 1 binary indicators. StringVars will work here, too, although their get methods\nwould return strings '0' or '1' (not integers) and their initial state would be an empty\nstring (not the integer 0).\nThis widget\u2019s command option lets you register a callback to be run each time the button\nis pressed. To illustrate, this script registers a standard dialog demo call as a handler\nfor each of the Checkbuttons\u2014pressing a button changes the toggle\u2019s state but also pops\nup one of the dialog windows we visited earlier in this tour (regardless of its new state).\nInterestingly, you can sometimes run the report method interactively, too\u2014when\nworking as follows in a shell window, widgets pop up as lines are typed and are fully\nactive, even without calling mainloop (though this may not work in some interfaces like\nIDLE if you must call mainloop to display your GUI):\nC:\\...\\PP4E\\Gui\\Tour> python\n>>> from demoCheck import Demo\n>>> d = Demo()\n>>> d.report()\n0 0 0 0 0\n>>> d.report()\n1 0 0 0 0\n>>> d.report()\n1 0 0 1 1\nCheckbutton, Radiobutton, and Scale | 459Check buttons and variables\nWhen I first studied check buttons, my initial reaction was: why do we need tkinter\nvariables here at all when we can register button-press callbacks? Linked variables may\nseem superfluous at first glance, but they simplify some GUI chores. Instead of asking\nyou to accept this blindly, though, let me explain why.\nKeep in mind that a Checkbutton\u2019s command callback will be run on every press, whether\nthe press toggles the check button to a selected or a deselected state. Because of that,\nif you want to run an action immediately when a check button is pressed, you will\ngenerally want to check the button\u2019s current value in the callback handler. Because\nthere is no check button \u201cget\u201d method for fetching values, you usually need to inter-\nrogate an associated variable to see if the button is on or off.\nMoreover, some GUIs simply let users set check buttons without running command call-\nbacks at all and fetch button settings at some later point in the program. In such a\nscenario, variables serve to automatically keep track of button settings. The demo\nCheck script\u2019s report method represents this latter approach.\nOf course, you could manually keep track of each button\u2019s state in press callback\nhandlers, too. Example 8-23 keeps its own list of state toggles and updates it manually\non command press callbacks.\nExample 8-23. PP4E\\Gui\\Tour\\demo-check-manual.py\n# check buttons, the hard way (without variables)\nfrom tkinter import *\nstates = []                            # change object not name\ndef onPress(i):                        # keep track of states\n    states[i] = not states[i]          # changes False->True, True->False\nroot = Tk()\nfor i in range(10):\n    chk = Checkbutton(root, text=str(i), command=(lambda i=i: onPress(i)) )\n    chk.pack(side=LEFT)\n    states.append(False)\nroot.mainloop()\nprint(states)                          # show all states on exit\nThe lambda here passes along the pressed button\u2019s index in the states list. Otherwise,\nwe would need a separate callback function for each button. Here again, we need to\nuse a default argument to pass the loop variable into the lambda, or the loop variable\nwill be its value on the last loop iteration for all 10 of the generated functions (each\npress would update the tenth item in the list; see Chapter 7 for background details on\nthis). When run, this script makes the 10\u2013check button display in Figure 8-27.\n460 | Chapter 8:\u2002A tkinter Tour, Part 1Figure 8-27. Manual check button state window\nManually maintained state toggles are updated on every button press and are printed\nwhen the GUI exits (technically, when the mainloop call returns); it\u2019s a list of Boolean\nstate values, which could also be integers 1 or 0 if we cared to exactly imitate the\noriginal:\nC:\\...\\PP4E\\Gui\\Tour> python demo-check-manual.py\n[False, False, True, False, True, False, False, False, True, False]\nThis works, and it isn\u2019t too horribly difficult to manage manually. But linked tkinter\nvariables make this task noticeably easier, especially if you don\u2019t need to process check\nbutton states until some time in the future. This is illustrated in Example 8-24.\nExample 8-24. PP4E\\Gui\\Tour\\demo-check-auto.py\n# check buttons, the easy way\nfrom tkinter import *\nroot = Tk()\nstates = []\nfor i in range(10):\n    var = IntVar()\n    chk = Checkbutton(root, text=str(i), variable=var)\n    chk.pack(side=LEFT)\n    states.append(var)\nroot.mainloop()                               # let tkinter keep track\nprint([var.get() for var in states])          # show all states on exit (or map/lambda)\nThis looks and works the same way, but there is no command button-press callback\nhandler at all, because toggle state is tracked by tkinter automatically:\nC:\\...\\PP4E\\Gui\\Tour> python demo-check-auto.py\n[0, 0, 1, 1, 0, 0, 1, 0, 0, 1]\nThe point here is that you don\u2019t necessarily have to link variables with check buttons,\nbut your GUI life will be simpler if you do. The list comprehension at the very end of\nthis script, by the way, is equivalent to the following unbound method and lambda/\nbound-method map call forms:\nprint(list(map(IntVar.get, states)))\nprint(list(map(lambda var: var.get(), states)))\nThough comprehensions are common in Python today, the form that seems clearest to\nyou may very well depend upon your shoe size\u2026\nCheckbutton, Radiobutton, and Scale | 461Radio Buttons\nRadio buttons are toggles too, but they are generally used in groups: just like the me-\nchanical station selector pushbuttons on radios of times gone by, pressing one Radio\nbutton widget in a group automatically deselects the one pressed last. In other words,\nat most, only one can be selected at one time. In tkinter, associating all radio buttons\nin a group with unique values and the same variable guarantees that, at most, only one\ncan ever be selected at a given time.\nLike check buttons and normal buttons, radio buttons support a command option for\nregistering a callback to handle presses immediately. Like check buttons, radio buttons\nalso have a variable attribute for associating single-selection buttons in a group and\nfetching the current selection at arbitrary times.\nIn addition, radio buttons have a value attribute that lets you tell tkinter what value\nthe button\u2019s associated variable should have when the button is selected. Because more\nthan one radio button is associated with the same variable, you need to be explicit about\neach button\u2019s value (it\u2019s not just a 1 or 0 toggle scenario). Example 8-25 demonstrates\nradio button basics.\nExample 8-25. PP4E\\Gui\\Tour\\demoRadio.py\n\"create a group of radio buttons that launch dialog demos\"\nfrom tkinter import *                # get base widget set\nfrom dialogTable import demos        # button callback handlers\nfrom quitter import Quitter          # attach a quit object to \"me\"\nclass Demo(Frame):\n    def __init__(self, parent=None, **options):\n        Frame.__init__(self, parent, **options)\n        self.pack()\n        Label(self, text=\"Radio demos\").pack(side=TOP)\n        self.var = StringVar()\n        for key in demos:\n            Radiobutton(self, text=key,\n                              command=self.onPress,\n                              variable=self.var,\n                              value=key).pack(anchor=NW)\n        self.var.set(key) # select last to start\n        Button(self, text='State', command=self.report).pack(fill=X)\n        Quitter(self).pack(fill=X)\n    def onPress(self):\n        pick = self.var.get()\n        print('you pressed', pick)\n        print('result:', demos[pick]())\n    def report(self):\n        print(self.var.get())\nif __name__ == '__main__': Demo().mainloop()\n462 | Chapter 8:\u2002A tkinter Tour, Part 1Figure 8-28 shows what this script generates when run. Pressing any of this window\u2019s\nradio buttons triggers its command handler, pops up one of the standard dialog boxes we\nmet earlier, and automatically deselects the button previously pressed. Like check but-\ntons, radio buttons are packed; this script packs them to the top to arrange them ver-\ntically, and then anchors each on the northwest corner of its allocated space so that\nthey align well.\nFigure 8-28. demoRadio in action\nLike the check button demo script, this one also puts up a State button to run the class\u2019s\nreport method and to show the current radio state (the button selected). Unlike the\ncheck button demo, this script also prints the return values of dialog demo calls that\nare run as its buttons are pressed. Here is what the stdout stream looks like after a few\npresses and state dumps; states are shown in bold:\nC:\\...\\PP4E\\Gui\\Tour> python demoRadio.py\nyou pressed Input\nresult: 3.14\nInput\nyou pressed Open\nresult: C:/PP4thEd/Examples/PP4E/Gui/Tour/demoRadio.py\nOpen\nyou pressed Query\nresult: yes\nQuery\nRadio buttons and variables\nSo, why variables here? For one thing, radio buttons also have no \u201cget\u201d widget method\nto fetch the selection in the future. More importantly, in radio button groups, the\nvalue and variable settings turn out to be the whole basis of single-choice behavior. In\nCheckbutton, Radiobutton, and Scale | 463fact, to make radio buttons work normally at all, it\u2019s crucial that they are all associated\nwith the same tkinter variable and have distinct value settings. To truly understand\nwhy, though, you need to know a bit more about how radio buttons and variables do\ntheir stuff.\nWe\u2019ve already seen that changing a widget changes its associated tkinter variable, and\nvice versa. But it\u2019s also true that changing a variable in any way automatically changes\nevery widget it is associated with. In the world of radio buttons, pressing a button sets\na shared variable, which in turn impacts other buttons associated with that variable.\nAssuming that all radio buttons have distinct values, this works as you expect it to\nwork. When a button press changes the shared variable to the pressed button\u2019s value,\nall other buttons are deselected, simply because the variable has been changed to a\nvalue not their own.\nThis is true both when the user selects a button and changes the shared variable\u2019s value\nimplicitly, but also when the variable\u2019s value is set manually by a script. For instance,\nwhen Example 8-25 sets the shared variable to the last of the demo\u2019s names initially\n(with self.var.set), it selects that demo\u2019s button and deselects all the others in the\nprocess; this way, only one is selected at first. If the variable was instead set to a string\nthat is not any demo\u2019s name (e.g., ' '), all buttons would be deselected at startup.\nThis ripple effect is a bit subtle, but it might help to know that within a group of radio\nbuttons sharing the same variable, if you assign a set of buttons the same value, the\nentire set will be selected if any one of them is pressed. Consider Example 8-26, which\ncreates Figure 8-29, for instance. All buttons start out deselected this time (by initial-\nizing the shared variable to none of their values), but because radio buttons 0, 3, 6, and\n9 have value 0 (the remainder of division by 3), all are selected if any are selected.\nFigure 8-29. Radio buttons gone bad?\nExample 8-26. PP4E\\Gui\\Tour\\demo-radio-multi.py\n# see what happens when some buttons have same value\nfrom tkinter import *\nroot = Tk()\nvar = StringVar()\nfor i in range(10):\n    rad = Radiobutton(root, text=str(i), variable=var, value=str(i % 3))\n    rad.pack(side=LEFT)\nvar.set(' ') # deselect all initially\nroot.mainloop()\n464 | Chapter 8:\u2002A tkinter Tour, Part 1If you press 1, 4, or 7 now, all three of these are selected, and any existing selections\nare cleared (they don\u2019t have the value \u201c1\u201d). That\u2019s not normally what you want\u2014radio\nbuttons are usually a single-choice group (check buttons handle multiple-choice in-\nputs). If you want them to work as expected, be sure to give each radio button the same\nvariable but a unique value across the entire group. In the demoRadio script, for instance,\nthe name of the demo provides a naturally unique value for each button.\nRadio buttons without variables\nStrictly speaking, we could get by without tkinter variables here, too. Example 8-27,\nfor instance, implements a single-selection model without variables, by manually se-\nlecting and deselecting widgets in the group, in a callback handler of its own. On each\npress event, it issues deselect calls for every widget object in the group and select for\nthe one pressed.\nExample 8-27. PP4E\\Gui\\Tour\\demo-radio-manual.py\n\"\"\"\nradio buttons, the hard way (without variables)\nnote that deselect for radio buttons simply sets the button's\nassociated value to a null string, so we either need to still\ngive buttons unique values, or use checkbuttons here instead;\n\"\"\"\nfrom tkinter import *\nstate = ''\nbuttons = []\ndef onPress(i):\n    global state\n    state = i\n    for btn in buttons:\n        btn.deselect()\n    buttons[i].select()\nroot = Tk()\nfor i in range(10):\n    rad = Radiobutton(root, text=str(i),\n                            value=str(i), command=(lambda i=i: onPress(i)) )\n    rad.pack(side=LEFT)\n    buttons.append(rad)\nonPress(0)                   # select first initially\nroot.mainloop()\nprint(state)                 # show state on exit\nThis works. It creates a 10-radio button window that looks just like the one in Fig-\nure 8-29 but implements a single-choice radio-style interface, with current state avail-\nable in a global Python variable printed on script exit. By associating tkinter variables\nand unique values, though, you can let tkinter do all this work for you, as shown in\nExample 8-28.\nCheckbutton, Radiobutton, and Scale | 465Example 8-28. PP4E\\Gui\\Tour\\demo-radio-auto.py\n# radio buttons, the easy way\nfrom tkinter import *\nroot = Tk()                     # IntVars work too\nvar  = IntVar(0)                # select 0 to start\nfor i in range(10):\n    rad = Radiobutton(root, text=str(i), value=i, variable=var)\n    rad.pack(side=LEFT)\nroot.mainloop()\nprint(var.get())                # show state on exit\nThis works the same way, but it is a lot less to type and debug. Notice that this script\nassociates the buttons with an IntVar, the integer type sibling of StringVar, and initi-\nalizes it to zero (which is also its default); as long as button values are unique, integers\nwork fine for radio buttons too.\nHold onto your variables!\nOne minor word of caution: you should generally hold onto the tkinter variable object\nused to link radio buttons for as long as the radio buttons are displayed. Assign it to a\nmodule global variable, store it in a long-lived data structure, or save it as an attribute\nof a long-lived class instance object as done by demoRadio. Just make sure you retain a\nreference to it somehow. You normally will in order to fetch its state anyhow, so it\u2019s\nunlikely that you\u2019ll ever care about what I\u2019m about to tell you.\nBut in the current tkinter, variable classes have a __del__ destructor that automatically\nunsets a generated Tk variable when the Python object is reclaimed (i.e., garbage col-\nlected). The upshot is that all of your radio buttons may be deselected if the variable\nobject is collected, at least until the next press resets the Tk variable to a new value.\nExample 8-29 shows one way to trigger this.\nExample 8-29. PP4E\\Gui\\Tour\\demo-radio-clear.py\n# hold on to your radio variables (an obscure thing, indeed)\nfrom tkinter import *\nroot = Tk()\ndef radio1():                   # local vars are temporary\n    #global tmp                 # making it global fixes the problem\n    tmp = IntVar()\n    for i in range(10):\n        rad = Radiobutton(root, text=str(i), value=i, variable=tmp)\n        rad.pack(side=LEFT)\n    tmp.set(5)  # select 6th button\nradio1()\nroot.mainloop()\n466 | Chapter 8:\u2002A tkinter Tour, Part 1This should come up with button \u201c5\u201d selected initially, but it doesn\u2019t. The variable\nreferenced by local tmp is reclaimed on function exit, the Tk variable is unset, and the 5\nsetting is lost (all buttons come up unselected). These radio buttons work fine, though,\nonce you start pressing them, because that resets the internal Tk variable. Uncomment-\ning the global statement here makes 5 start out set, as expected.\nThis phenomenon seems to have grown even worse in Python 3.X: not only is \u201c5\u201d not\nselected initially, but moving the mouse cursor over the unselected buttons seems to\nselect many at random until one is pressed. (In 3.X we also need to initialize a String\nVar shared by radio buttons as we did in this section\u2019s earlier examples, or else its empty\nstring default selects all of them!)\nOf course, this is an atypical example\u2014as coded, there is no way to know which button\nis pressed, because the variable isn\u2019t saved (and command isn\u2019t set). It makes little sense\nto use a group of radio buttons at all if you cannot query its value later. In fact, this is\nso obscure that I\u2019ll just refer you to demo-radio-clear2.py in the book\u2019s examples dis-\ntribution for an example that works hard to trigger this oddity in other ways. You\nprobably won\u2019t care, but you can\u2019t say that I didn\u2019t warn you if you ever do.\nScales (Sliders)\nScales (sometimes called \u201csliders\u201d) are used to select among a range of numeric values.\nMoving the scale\u2019s position with mouse drags or clicks moves the widget\u2019s value among\na range of integers and triggers Python callbacks if registered.\nLike check buttons and radio buttons, scales have both a command option for registering\nan event-driven callback handler to be run right away when the scale is moved, and a\nvariable option for associating a tkinter variable that allows the scale\u2019s position to be\nfetched and set at arbitrary times. You can process scale settings when they are made,\nor let the user pick a setting for later use.\nIn addition, scales have a third processing option\u2014get and set methods that scripts\nmay call to access scale values directly without associating variables. Because scale\ncommand movement callbacks also get the current scale setting value as an argument, it\u2019s\noften enough just to provide a callback for this widget, without resorting to either linked\nvariables or get/set method calls.\nTo illustrate the basics, Example 8-30 makes two scales\u2014one horizontal and one ver-\ntical\u2014and links them with an associated variable to keep them in sync.\nExample 8-30. PP4E\\Gui\\Tour\\demoScale.py\n\"create two linked scales used to launch dialog demos\"\nfrom tkinter import *                # get base widget set\nfrom dialogTable import demos        # button callback handlers\nfrom quitter import Quitter          # attach a quit frame to me\nCheckbutton, Radiobutton, and Scale | 467class Demo(Frame):\n    def __init__(self, parent=None, **options):\n        Frame.__init__(self, parent, **options)\n        self.pack()\n        Label(self, text=\"Scale demos\").pack()\n        self.var = IntVar()\n        Scale(self, label='Pick demo number',\n                    command=self.onMove,                   # catch moves\n                    variable=self.var,                     # reflects position\n                    from_=0, to=len(demos)-1).pack()\n        Scale(self, label='Pick demo number',\n                    command=self.onMove,                   # catch moves\n                    variable=self.var,                     # reflects position\n                    from_=0, to=len(demos)-1,\n                    length=200, tickinterval=1,\n                    showvalue=YES, orient='horizontal').pack()\n        Quitter(self).pack(side=RIGHT)\n        Button(self, text=\"Run demo\", command=self.onRun).pack(side=LEFT)\n        Button(self, text=\"State\",    command=self.report).pack(side=RIGHT)\n    def onMove(self, value):\n        print('in onMove', value)\n    def onRun(self):\n        pos = self.var.get()\n        print('You picked', pos)\n        demo = list(demos.values())[pos]    # map from position to value (3.X view)\n        print(demo())                       # or demos[ list(demos.keys())[pos] ]()\n    def report(self):\n        print(self.var.get())\nif __name__ == '__main__':\n    print(list(demos.keys()))\n    Demo().mainloop()\nBesides value access and callback registration, scales have options tailored to the notion\nof a range of selectable values, most of which are demonstrated in this example\u2019s code:\n\u2022 The label option provides text that appears along with the scale, length specifies\nan initial size in pixels, and orient specifies an axis.\n\u2022 The from_ and to options set the scale range\u2019s minimum and maximum values (note\nthat from is a Python reserved word, but from_ is not).\n\u2022 The tickinterval option sets the number of units between marks drawn at regular\nintervals next to the scale (the default means no marks are drawn).\n\u2022 The resolution option provides the number of units that the scale\u2019s value jumps\non each drag or left mouse click event (defaults to 1).\n\u2022 The showvalue option can be used to show or hide the scale\u2019s current value next to\nits slider bar (the default showvalue=YES means it is drawn).\n468 | Chapter 8:\u2002A tkinter Tour, Part 1Note that scales are also packed in their container, just like other tkinter widgets. Let\u2019s\nsee how these ideas translate in practice; Figure 8-30 shows the window you get if you\nrun this script live on Windows 7 (you get a similar one on Unix and Mac machines).\nFigure 8-30. demoScale in action\nFor illustration purposes, this window\u2019s State button shows the scales\u2019 current values,\nand \u201cRun demo\u201d runs a standard dialog call as before, using the integer value of the\nscales to index the demos table. The script also registers a command handler that fires\nevery time either of the scales is moved and prints their new positions. Here is a set of\nmessages sent to stdout after a few moves, demo runs (italic), and state requests (bold):\nC:\\...\\PP4E\\Gui\\Tour> python demoScale.py\n['Color', 'Query', 'Input', 'Open', 'Error']\nin onMove 0\nin onMove 0\nin onMove 1\n1\nin onMove 2\nYou picked 2\n123.0\nin onMove 3\n3\nYou picked 3\nC:/Users/mark/Stuff/Books/4E/PP4E/dev/Examples/PP4E/Launcher.py\nScales and variables\nAs you can probably tell, scales offer a variety of ways to process their selections: im-\nmediately in move callbacks, or later by fetching current positions with variables or\nscale method calls. In fact, tkinter variables aren\u2019t needed to program scales at all\u2014\nCheckbutton, Radiobutton, and Scale | 469simply register movement callbacks or call the scale get method to fetch scale values\non demand, as in the simpler scale example in Example 8-31.\nExample 8-31. PP4E\\Gui\\Tour\\demo-scale-simple.py\nfrom tkinter import *\nroot = Tk()\nscl = Scale(root, from_=-100, to=100, tickinterval=50, resolution=10)\nscl.pack(expand=YES, fill=Y)\ndef report():\n    print(scl.get())\nButton(root, text='state', command=report).pack(side=RIGHT)\nroot.mainloop()\nFigure 8-31 shows two instances of this program running on Windows\u2014one stretched\nand one not (the scales are packed to grow vertically on resizes). Its scale displays a\nrange from \u2212100 to 100, uses the resolution option to adjust the current position up\nor down by 10 on every move, and sets the tickinterval option to show values next to\nthe scale in increments of 50. When you press the State button in this script\u2019s window,\nit calls the scale\u2019s get method to display the current setting, without variables or call-\nbacks of any kind:\nC:\\...\\PP4E\\Gui\\Tour> python demo-scale-simple.py\n0\n60\n-70\nFigure 8-31. A simple scale without variables\nFrankly, the only reason tkinter variables are used in the demoScale script at all is to\nsynchronize scales. To make the demo interesting, this script associates the same tkinter\n470 | Chapter 8:\u2002A tkinter Tour, Part 1variable object with both scales. As we learned in the last section, changing a widget\nchanges its variable, but changing a variable also changes all the widgets it is associated\nwith. In the world of sliders, moving the slide updates that variable, which in turn might\nupdate other widgets associated with the same variable. Because this script links one\nvariable with two scales, it keeps them automatically in sync: moving one scale moves\nthe other, too, because the shared variable is changed in the process and so updates the\nother scale as a side effect.\nLinking scales like this may or may not be typical of your applications (and borders on\ndeep magic), but it\u2019s a powerful tool once you get your mind around it. By linking\nmultiple widgets on a display with tkinter variables, you can keep them automatically\nin sync, without making manual adjustments in callback handlers. On the other hand,\nthe synchronization could be implemented without a shared variable at all by calling\none scale\u2019s set method from a move callback handler of the other. I\u2019ll leave such a\nmanual mutation as a suggested exercise, though. One person\u2019s deep magic might be\nanother\u2019s useful hack.\nRunning GUI Code Three Ways\nNow that we\u2019ve built a handful of similar demo launcher programs, let\u2019s write a few\ntop-level scripts to combine them. Because the demos were coded as both reusable\nclasses and scripts, they can be deployed as attached frame components, run in their\nown top-level windows, and launched as standalone programs. All three options illus-\ntrate code reuse in action.\nAttaching Frames\nTo illustrate hierarchical GUI composition on a grander scale than we\u2019ve seen so far,\nExample 8-32 arranges to show all four of the dialog launcher bar scripts of this chapter\nin a single container. It reuses Examples 8-9, 8-22, 8-25, and 8-30.\nExample 8-32. PP4E\\Gui\\Tour\\demoAll-frm.py\n\"\"\"\n4 demo class components (subframes) on one window;\nthere are 5 Quitter buttons on this one window too, and each kills entire gui;\nGUIs can be reused as frames in container, independent windows, or processes;\n\"\"\"\nfrom tkinter import *\nfrom quitter import Quitter\ndemoModules = ['demoDlg', 'demoCheck', 'demoRadio', 'demoScale']\nparts = []\ndef addComponents(root):\n    for demo in demoModules:\n        module = __import__(demo)                       # import by name string\n        part = module.Demo(root)                        # attach an instance\nRunning GUI Code Three Ways | 471part.config(bd=2, relief=GROOVE)                # or pass configs to Demo()\n        part.pack(side=LEFT, expand=YES, fill=BOTH)     # grow, stretch with window\n        parts.append(part)                              # change list in-place\ndef dumpState():\n    for part in parts:                                  # run demo report if any\n        print(part.__module__ + ':', end=' ')\n        if hasattr(part, 'report'):\n           part.report()\n        else:\n           print('none')\nroot = Tk()                                             # make explicit root first\nroot.title('Frames')\nLabel(root, text='Multiple Frame demo', bg='white').pack()\nButton(root, text='States', command=dumpState).pack(fill=X)\nQuitter(root).pack(fill=X)\naddComponents(root)\nroot.mainloop()\nBecause all four demo launcher bars are coded as frames which attach themselves to\nparent container widgets, this is easier than you might think: simply pass the same\nparent widget (here, the root window) to all four demo constructor calls, and repack\nand configure the demo objects as desired. Figure 8-32 shows this script\u2019s graphical\nresult\u2014a single window embedding instances of all four of the dialog demo launcher\ndemos we saw earlier. As coded, all four embedded demos grow and stretch with the\nwindow when resized (try taking out the expand=YES to keep their sizes more constant).\nFigure 8-32. demoAll_frm: nested subframes\nNaturally, this example is artificial, but it illustrates the power of composition when\napplied to building larger GUI displays. If you pretend that each of the four attached\n472 | Chapter 8:\u2002A tkinter Tour, Part 1demo objects was something more useful, like a text editor, calculator, or clock, you\u2019ll\nbetter appreciate the point of this example.\nBesides demo object frames, this composite window also contains no fewer than five\ninstances of the Quitter button we wrote earlier (all of which verify the request and any\none of which can end the GUI) and a States button to dump the current values of all\nthe embedded demo objects at once (it calls each object\u2019s report method, if it has one).\nHere is a sample of the sort of output that shows up in the stdout stream after interacting\nwith widgets on this display; States output is in bold:\nC:\\...\\PP4E\\Gui\\Tour> python demoAll_frm.py\nin onMove 0\nin onMove 0\ndemoDlg: none\ndemoCheck: 0 0 0 0 0\ndemoRadio: Error\ndemoScale: 0\nyou pressed Input\nresult: 1.234\nin onMove 1\ndemoDlg: none\ndemoCheck: 1 0 1 1 0\ndemoRadio: Input\ndemoScale: 1\nyou pressed Query\nresult: yes\nin onMove 2\nYou picked 2\nNone\nin onMove 3\nYou picked 3\nC:/Users/mark/Stuff/Books/4E/PP4E/dev/Examples/PP4E/Launcher.py\n3\nQuery\n1 1 1 1 0\ndemoDlg: none\ndemoCheck: 1 1 1 1 0\ndemoRadio: Query\ndemoScale: 3\nImporting by name string\nThe only substantially tricky part of this script is its use of Python\u2019s built-in\n__import__ function to import a module by a name string. Look at the following two\nlines from the script\u2019s addComponents function:\nmodule = __import__(demo)             # import module by name string\npart = module.Demo(root)              # attach an instance of its Demo\nThis is equivalent to saying something like this:\nimport 'demoDlg'\npart = 'demoDlg'.Demo(root)\nRunning GUI Code Three Ways | 473However, the preceding code is not legal Python syntax\u2014the module name in import\nstatements and dot expressions must be a Python variable, not a string; moreover, in\nan import the name is taken literally (not evaluated), and in dot syntax must evaluate\nto the object (not its string name). To be generic, addComponents steps through a list of\nname strings and relies on __import__ to import and return the module identified by\neach string. In fact, the for loop containing these statements works as though all of\nthese statements were run:\nimport demoDlg, demoRadio, demoCheck, demoScale\npart = demoDlg.Demo(root)\npart = demoRadio.Demo(root)\npart = demoCheck.Demo(root)\npart = demoScale.Demo(root)\nBut because the script uses a list of name strings, it\u2019s easier to change the set of demos\nembedded\u2014simply change the list, not the lines of executable code. Further, such data-\ndriven code tends to be more compact, less redundant, and easier to debug and main-\ntain. Incidentally, modules can also be imported from name strings by dynamically\nconstructing and running import statements, like this:\nfor demo in demoModules:\n    exec('from %s import Demo' % demo)       # make and run a from\n    part = eval('Demo')(root)                # fetch known import name by string\nThe exec statement compiles and runs a Python statement string (here, a from to load\na module\u2019s Demo class); it works here as if the statement string were pasted into the\nsource code where the exec statement appears. The following achieves the same effect\nby running an import statement instead:\nfor demo in demoModules:\n    exec('import %s' % demo)                 # make and run an import\n    part = eval(demo).Demo(root)             # fetch module variable by name too\nBecause it supports any sort of Python statement, these exec/eval techniques are more\ngeneral than the __import__ call, but can also be slower, since they must parse code\nstrings before running them.\u2020 However, that slowness may not matter in a GUI; users\ntend to be significantly slower than parsers.\nConfiguring at construction time\nOne other alternative worth mentioning: notice how Example 8-32 configures and\nrepacks each attached demo frame for its role in this GUI:\ndef addComponents(root):\n    for demo in demoModules:\n        module = __import__(demo)                       # import by name string\n        part = module.Demo(root)                        # attach an instance\n\u2020 As we\u2019ll see later in this book, exec can also be dangerous if it is running code strings fetched from users or\nnetwork connections. That\u2019s not an issue for the hardcoded strings used internally in this example.\n474 | Chapter 8:\u2002A tkinter Tour, Part 1part.config(bd=2, relief=GROOVE)                # or pass configs to Demo()\n        part.pack(side=LEFT, expand=YES, fill=BOTH)     # grow, stretch with window\nBecause the demo classes use their **options arguments to support constructor argu-\nments, though, we could configure at creation time, too. For example, if we change\nthis code as follows, it produces the slightly different composite window captured in\nFigure 8-33 (stretched a bit horizontally for illustration, too; you can run this as\ndemoAll-frm-ridge.py in the examples package):\ndef addComponents(root):\n    for demo in demoModules:\n        module = __import__(demo)                       # import by name string\n        part = module.Demo(root, bd=6, relief=RIDGE)    # attach, config instance\n        part.pack(side=LEFT, expand=YES, fill=BOTH)     # grow, stretch with window\nBecause the demo classes both subclass Frame and support the usual construction\nargument protocols, they become true widgets\u2014specialized tkinter frames that imple-\nment an attachable package of widgets and support flexible configuration techniques.\nFigure 8-33. demoAll_frm: configure when constructed\nAs we saw in Chapter 7, attaching nested frames like this is really just one way to reuse\nGUI code structured as classes. It\u2019s just as easy to customize such interfaces by sub-\nclassing rather than embedding. Here, though, we\u2019re more interested in deploying an\nexisting widget package than changing it, so attachment is the pattern we want. The\nnext two sections show two other ways to present such precoded widget packages to\nusers\u2014in pop-up windows and as autonomous programs.\nRunning GUI Code Three Ways | 475Independent Windows\nOnce you have a set of component classes coded as frames, any parent will work\u2014\nboth other frames and brand-new, top-level windows. Example 8-33 attaches instances\nof all four demo bar objects to their own independent Toplevel windows, instead of\nthe same container.\nExample 8-33. PP4E\\Gui\\Tour\\demoAll-win.py\n\"\"\"\n4 demo classes in independent top-level windows;\nnot processes: when one is quit all others go away, because all windows run in\nthe same process here; make Tk() first here, else we get blank default window\n\"\"\"\nfrom tkinter import *\ndemoModules = ['demoDlg', 'demoRadio', 'demoCheck', 'demoScale']\ndef makePopups(modnames):\n    demoObjects = []\n    for modname in modnames:\n        module = __import__(modname)          # import by name string\n        window = Toplevel()                   # make a new window\n        demo   = module.Demo(window)          # parent is the new window\n        window.title(module.__name__)\n        demoObjects.append(demo)\n    return demoObjects\ndef allstates(demoObjects):\n    for obj in demoObjects:\n        if hasattr(obj, 'report'):\n            print(obj.__module__, end=' ')\n            obj.report()\nroot = Tk()                                   # make explicit root first\nroot.title('Popups')\ndemos = makePopups(demoModules)\nLabel(root, text='Multiple Toplevel window demo', bg='white').pack()\nButton(root, text='States', command=lambda: allstates(demos)).pack(fill=X)\nroot.mainloop()\nWe met the Toplevel class earlier; every instance generates a new window on your\nscreen. The net result is captured in Figure 8-34. Each demo runs in an independent\nwindow of its own instead of being packed together in a single display.\n476 | Chapter 8:\u2002A tkinter Tour, Part 1Figure 8-34. demoAll_win: new Toplevel windows\nThe main root window of this program appears in the lower left of this screenshot; it\nprovides a States button that runs the report method of each demo object, producing\nthis sort of stdout text:\nC:\\...\\PP4E\\Gui\\Tour> python demoAll_win.py\nin onMove 0\nin onMove 0\nin onMove 1\nyou pressed Open\nresult: C:/Users/mark/Stuff/Books/4E/PP4E/dev/Examples/PP4E/Launcher.py\ndemoRadio Open\ndemoCheck 1 1 0 0 0\ndemoScale 1\nAs we learned earlier in this chapter, Toplevel windows function independently, but\nthey are not really independent programs. Destroying just one of the demo windows\nin Figure 8-34 by clicking the X button in its upper right corner closes just that window.\nBut quitting any of the windows shown in Figure 8-34\u2014by a demo window\u2019s Quit\nbuttons or the main window\u2019s X\u2014quits them all and ends the application, because all\nrun in the same program process. That\u2019s OK in some applications, but not all. To go\ntruly rogue we need to spawn processes, as the next section shows.\nRunning GUI Code Three Ways | 477Running Programs\nTo be more independent, Example 8-34 spawns each of the four demo launchers as\nindependent programs (processes), using the launchmodes module we wrote at the end\nof Chapter 5. This works only because the demos were written as both importable\nclasses and runnable scripts. Launching them here makes all their names __main__ when\nrun, because they are separate, stand-alone programs; this in turn kicks off the main\nloop call at the bottom of each of their files.\nExample 8-34. PP4E\\Gui\\Tour\\demoAll-prg.py\n\"\"\"\n4 demo classes run as independent program processes: command lines;\nif one window is quit now, the others will live on; there is no simple way to\nrun all report calls here (though sockets and pipes could be used for IPC), and\nsome launch schemes may drop child program stdout and disconnect parent/child;\n\"\"\"\nfrom tkinter import *\nfrom PP4E.launchmodes import PortableLauncher\ndemoModules = ['demoDlg', 'demoRadio', 'demoCheck', 'demoScale']\nfor demo in demoModules:                        # see Parallel System Tools\n    PortableLauncher(demo, demo + '.py')()      # start as top-level programs\nroot = Tk()\nroot.title('Processes')\nLabel(root, text='Multiple program demo: command lines', bg='white').pack()\nroot.mainloop()\nMake sure the PP4E directory\u2019s container is on your module search path (e.g.,\nPYTHONPATH) to run this; it imports an example module from a different directory.\nAs Figure 8-35 shows, the display generated by this script is similar to the prior one;\nall four demos come up in windows of their own.\nThis time, though, these are truly independent programs: if any one of the five windows\nhere is quit, the others live on. The demos even outlive their parent, if the main window\nis closed. On Windows, in fact, the shell window where this script is started becomes\nactive again when the main window is closed, even though the spawned demos con-\ntinue running. We\u2019re reusing the demo code as program, not module.\n478 | Chapter 8:\u2002A tkinter Tour, Part 1Figure 8-35. demoAll_prg: independent programs\nLaunching GUIs as programs other ways: multiprocessing\nIf you backtrack to Chapter 5 to study the portable launcher module used by Exam-\nple 8-34 to start programs, you\u2019ll see that it works by using os.spawnv on Windows and\nos.fork/exec on others. The net effect is that the GUI processes are effectively started\nby launching command lines. These techniques work well, but as we learned in Chap-\nter 5, they are members of a larger set of program launching tools that also includes\nos.popen, os.system, os.startfile, and the subprocess and multiprocessing modules;\nthese tools can vary subtly in how they handle shell window connections, parent\nprocess exits, and more.\nFor example, the multiprocessing module we studied in Chapter 5 provides a similarly\nportable way to run our GUIs as independent processes, as demonstrated in Exam-\nple 8-35. When run, it produces the exact same windows shown in Figure 8-35, except\nthat the label in the main window is different.\nExample 8-35. PP4E\\Gui\\Tour\\demoAll-prg-multi.py\n\"\"\"\n4 demo classes run as independent program processes: multiprocessing;\nmultiprocessing allows us to launch named functions with arguments,\nbut not lambdas, because they are not pickleable on Windows (Chapter 5);\nmultiprocessing also has its own IPC tools like pipes for communication;\n\"\"\"\nRunning GUI Code Three Ways | 479from tkinter import *\nfrom multiprocessing import Process\ndemoModules = ['demoDlg', 'demoRadio', 'demoCheck', 'demoScale']\ndef runDemo(modname):                     # run in a new process\n    module = __import__(modname)          # build gui from scratch\n    module.Demo().mainloop()\nif __name__ == '__main__':\n    for modname in demoModules:                               # in __main__ only!\n        Process(target=runDemo, args=(modname,)).start()\n    root = Tk()                                               # parent process GUI\n    root.title('Processes')\n    Label(root, text='Multiple program demo: multiprocessing', bg='white').pack()\n    root.mainloop()\nOperationally, this version differs on Windows only in that:\n\u2022 The child processes\u2019 standard output shows up in the window where the script was\nlaunched, including the outputs of both dialog demos themselves and all demo\nwindows\u2019 State buttons.\n\u2022 The script doesn\u2019t truly exit if any children are still running: the shell where it is\nlaunched is blocked if the main process\u2019s window is closed while children are still\nrunning, unless we set the child processes\u2019 daemon flag to True before they start as\nwe saw in Chapter 5\u2014in which case all child programs are automatically shut down\nwhen their parent is (but parents may still outlive their children).\nAlso observe how we start a simple named function in the new Process. As we learned\nin Chapter 5, the target must be pickleable on Windows (which essentially means im-\nportable), so we cannot use lambdas to pass extra data in the way we typically could\nin tkinter callbacks. The following coding alternatives both fail with errors on\nWindows:\nProcess(target=(lambda: runDemo(modname))).start()            # these both fail!\nProcess(target=(lambda: __import__(modname).Demo().mainloop())).start()\nWe won\u2019t recode our GUI program launcher script with any of the other techniques\navailable, but feel free to experiment on your own using Chapter 5 as a resource. Al-\nthough not universally applicable, the whole point of tools like the PortableLauncher\nclass is to hide such details so we can largely forget them.\nCross-program communication\nSpawning GUIs as programs is the ultimate in code independence, but it makes the\nlines of communication between components more complex. For instance, because the\ndemos run as programs here, there is no easy way to run all their report methods from\nthe launching script\u2019s window pictured in the upper right of Figure 8-35. In fact, the\n480 | Chapter 8:\u2002A tkinter Tour, Part 1States button is gone this time, and we only get PortableLauncher messages in stdout\nas the demos start up in Example 8-34:\nC:\\...\\PP4E\\Gui\\Tour> python demoAll_prg.py\ndemoDlg\ndemoRadio\ndemoCheck\ndemoScale\nOn some platforms, messages printed by the demo programs (including their own State\nbuttons) may show up in the original console window where this script is launched;\non Windows, the os.spawnv call used to start programs by launchmodes in Exam-\nple 8-34 completely disconnects the child program\u2019s stdout stream from its parent, but\nthe multiprocessing scheme of Example 8-35 does not. Regardless, there is no direct\nway to call all demos\u2019 report methods at once\u2014they are spawned programs in distinct\naddress spaces, not imported modules.\nOf course, we could trigger report methods in the spawned programs with some of the\nInter-Process Communication (IPC) mechanisms we met in Chapter 5. For instance:\n\u2022 The demos could be instrumented to catch a user signal, and could run their\nreport in response.\n\u2022 The demos could also watch for request strings sent by the launching program to\nshow up in pipes or fifos; the demoAll launching program would essentially act as\na client, and the demo GUIs as servers that respond to client requests.\n\u2022 Independent programs can also converse this same way over sockets, the general\nIPC tool introduced in Chapter 5, which we\u2019ll study in depth in Part IV. The main\nwindow might send a report request and receive its result on the same socket (and\nmight even contact demos running remotely).\n\u2022 If used, the multiprocessing module has IPC tools all its own, such as the object\npipes and queues we studied in Chapter 5, that could also be leveraged: demos\nmight listen on this type of pipe, too.\nGiven their event-driven nature, GUI-based programs like our demos also need to avoid\nbecoming stuck in wait states\u2014they cannot be blocked while waiting for requests on\nIPC devices like those above, or they won\u2019t be responsive to users (and might not even\nredraw themselves). Because of that, they may also have be augmented with threads,\ntimer-event callbacks, nonblocking input calls, or some combination of such techni-\nques to periodically check for incoming messages on pipes, fifos, or sockets. As we\u2019ll\nsee, the tkinter after method call described near the end of the next chapter is ideal for\nthis: it allows us to register a callback to run periodically to check for incoming requests\non such IPC tools.\nWe\u2019ll explore some of these options near the end of Chapter 10, after we\u2019ve looked at\nGUI threading topics. But since this is well beyond the scope of the current chapter\u2019s\nsimple demo programs, I\u2019ll leave such cross-program extensions up to more parallel-\nminded readers for now.\nRunning GUI Code Three Ways | 481Coding for reusability\nA postscript: I coded the demo launcher bars deployed by the last four examples to\ndemonstrate all the different ways that their widgets can be used. They were not de-\nveloped with general-purpose reusability in mind; in fact, they\u2019re not really useful out-\nside the context of introducing widgets in this book.\nThat was by design; most tkinter widgets are easy to use once you learn their interfaces,\nand tkinter already provides lots of configuration flexibility by itself. But if I had it in\nmind to code checkbutton and radiobutton classes to be reused as general library com-\nponents, they would have to be structured differently:\nExtra widgets\nThey would not display anything but radio buttons and check buttons. As is, the\ndemos each embed State and Quit buttons for illustration, but there really should\nbe just one Quit per top-level window.\nGeometry management\nThey would allow for different button arrangements and would not pack (or grid)\nthemselves at all. In a true general-purpose reuse scenario, it\u2019s often better to leave\na component\u2019s geometry management up to its caller.\nUsage mode limitations\nThey would either have to export complex interfaces to support all possible tkinter\nconfiguration options and modes, or make some limiting decisions that support\none common use only. For instance, these buttons can either run callbacks at press\ntime or provide their state later in the application.\nExample 8-36 shows one way to code check button and radio button bars as library\ncomponents. It encapsulates the notion of associating tkinter variables and imposes a\ncommon usage mode on callers\u2014state fetches rather than press callbacks\u2014to keep the\ninterface simple.\nExample 8-36. PP4E\\Gui\\Tour\\buttonbars.py\n\"\"\"\ncheck and radio button bar classes for apps that fetch state later;\npass a list of options, call state(), variable details automated\n\"\"\"\nfrom tkinter import *\nclass Checkbar(Frame):\n    def __init__(self, parent=None, picks=[], side=LEFT, anchor=W):\n        Frame.__init__(self, parent)\n        self.vars = []\n        for pick in picks:\n            var = IntVar()\n            chk = Checkbutton(self, text=pick, variable=var)\n            chk.pack(side=side, anchor=anchor, expand=YES)\n            self.vars.append(var)\n    def state(self):\n482 | Chapter 8:\u2002A tkinter Tour, Part 1return [var.get() for var in self.vars]\nclass Radiobar(Frame):\n    def __init__(self, parent=None, picks=[], side=LEFT, anchor=W):\n        Frame.__init__(self, parent)\n        self.var = StringVar()\n        self.var.set(picks[0])\n        for pick in picks:\n            rad = Radiobutton(self, text=pick, value=pick, variable=self.var)\n            rad.pack(side=side, anchor=anchor, expand=YES)\n    def state(self):\n        return self.var.get()\nif __name__ == '__main__':\n    root = Tk()\n    lng = Checkbar(root, ['Python', 'C#', 'Java', 'C++'])\n    gui = Radiobar(root, ['win', 'x11', 'mac'], side=TOP, anchor=NW)\n    tgl = Checkbar(root, ['All'])\n    gui.pack(side=LEFT, fill=Y)\n    lng.pack(side=TOP,  fill=X)\n    tgl.pack(side=LEFT)\n    lng.config(relief=GROOVE, bd=2)\n    gui.config(relief=RIDGE,  bd=2)\n    def allstates():\n        print(gui.state(), lng.state(), tgl.state())\n    from quitter import Quitter\n    Quitter(root).pack(side=RIGHT)\n    Button(root, text='Peek', command=allstates).pack(side=RIGHT)\n    root.mainloop()\nTo reuse these classes in your scripts, import and call them with a list of the options\nthat you want to appear in a bar of check buttons or radio buttons. This module\u2019s self-\ntest code at the bottom of the file gives further usage details. It generates Figure 8-36\u2014\na top-level window that embeds two Checkbars, one Radiobar, a Quitter button to exit,\nand a Peek button to show bar states\u2014when this file is run as a program instead of\nbeing imported.\nFigure 8-36. buttonbars self-test window\nRunning GUI Code Three Ways | 483Here\u2019s the stdout text you get after pressing Peek\u2014the results of these classes\u2019 state\nmethods:\nx11 [1, 0, 1, 1] [0]\nwin [1, 0, 0, 1] [1]\nThe two classes in this module demonstrate how easy it is to wrap tkinter interfaces to\nmake them easier to use; they completely abstract away many of the tricky parts of\nradio button and check button bars. For instance, you can forget about linked variable\ndetails completely if you use such higher-level classes instead\u2014simply make objects\nwith option lists and call their state methods later. If you follow this path to its logical\nconclusion, you might just wind up with a higher-level widget library on the order of\nthe Pmw package mentioned in Chapter 7.\nOn the other hand, these classes are still not universally applicable; if you need to run\nactions when these buttons are pressed, for instance, you\u2019ll need to use other high-level\ninterfaces. Luckily, Python/tkinter already provides plenty. Later in this book, we\u2019ll\nagain use the widget combination and reuse techniques introduced in this section to\nconstruct larger GUIs like text editors, email clients and calculators. For now, this first\nchapter in the widget tour is about to make one last stop\u2014the photo shop.\nImages\nIn tkinter, graphical images are displayed by creating independent PhotoImage or\nBitmapImage objects, and then attaching those image objects to other widgets via\nimage attribute settings. Buttons, labels, canvases, text, and menus can display images\nby associating prebuilt image objects in this way. To illustrate, Example 8-37 throws a\npicture up on a button.\nExample 8-37. PP4E\\Gui\\Tour\\imgButton.py\ngifdir = \"../gifs/\"\nfrom tkinter import *\nwin = Tk()\nigm = PhotoImage(file=gifdir + \"ora-pp.gif\")\nButton(win, image=igm).pack()\nwin.mainloop()\nI could try to come up with a simpler example, but it would be tough\u2014all this script\ndoes is make a tkinter PhotoImage object for a GIF file stored in another directory, and\nassociate it with a Button widget\u2019s image option. The result is captured in Figure 8-37.\n484 | Chapter 8:\u2002A tkinter Tour, Part 1Figure 8-37. imgButton in action\nPhotoImage and its cousin, BitmapImage, essentially load graphics files and allow those\ngraphics to be attached to other kinds of widgets. To open a picture file, pass its name\nto the file attribute of these image objects. Though simple, attaching images to buttons\nthis way has many uses; in Chapter 9, for instance, we\u2019ll use this basic idea to implement\ntoolbar buttons at the bottom of a window.\nCanvas widgets\u2014general drawing surfaces covered in more detail in the next chapter\u2014\ncan display pictures too. Though this is a bit of a preview for the upcoming chapter,\nbasic canvas usage is straightforward enough to demonstrate here; Example 8-38 ren-\nders Figure 8-38 (shrunk here for display):\nExample 8-38. PP4E\\Gui\\Tour\\imgCanvas.py\ngifdir = \"../gifs/\"\nfrom tkinter import *\nwin = Tk()\nimg = PhotoImage(file=gifdir + \"ora-lp4e.gif\")\ncan = Canvas(win)\ncan.pack(fill=BOTH)\ncan.create_image(2, 2, image=img, anchor=NW)           # x, y coordinates\nwin.mainloop()\nButtons are automatically sized to fit an associated photo, but canvases are not (because\nyou can add objects to a canvas later, as we\u2019ll see in Chapter 9). To make a canvas fit\nthe picture, size it according to the width and height methods of image objects, as in\nExample 8-39. This version will make the canvas smaller or larger than its default size\nas needed, lets you pass in a photo file\u2019s name on the command line, and can be used\nas a simple image viewer utility. The visual effect of this script is captured in Figure 8-39.\nImages | 485Example 8-39. PP4E\\Gui\\Tour\\imgCanvas2.py\ngifdir = \"../gifs/\"\nfrom sys import argv\nfrom tkinter import *\nfilename = argv[1] if len(argv) > 1 else 'ora-lp4e.gif'   # name on cmdline?\nwin = Tk()\nimg = PhotoImage(file=gifdir + filename)\ncan = Canvas(win)\ncan.pack(fill=BOTH)\ncan.config(width=img.width(), height=img.height())        # size to img size\ncan.create_image(2, 2, image=img, anchor=NW)\nwin.mainloop()\nFigure 8-38. An image on canvas\nFigure 8-39. Sizing the canvas to match the photo\n486 | Chapter 8:\u2002A tkinter Tour, Part 1Run this script with other filenames to view other images (try this on your own):\nC:\\...\\PP4E\\Gui\\Tour> imgCanvas2.py ora-ppr-german.gif\nAnd that\u2019s all there is to it. In Chapter 9, we\u2019ll see images show up again in the items\nof a Menu, in the buttons of a window\u2019s toolbar, in other Canvas examples, and in the\nimage-friendly Text widget. In later chapters, we\u2019ll find them in an image slideshow\n(PyView), in a paint program (PyDraw), on clocks (PyClock), in a generalized photo\nviewer (PyPhoto), and so on. It\u2019s easy to add graphics to GUIs in Python/tkinter.\nOnce you start using photos in earnest, though, you\u2019re likely to run into two tricky bits\nthat I want to warn you about here:\nSupported file types\nAt present, the standard tkinter PhotoImage widget supports only GIF, PPM, and\nPGM graphic file formats, and BitmapImage supports X Windows-style .xbm bitmap\nfiles. This may be expanded in future releases, and you can convert photos in other\nformats to these supported formats ahead of time, of course. But as we\u2019ll see later\nin this chapter, it\u2019s easy to support additional image types with the PIL open source\nextension toolkit and its PhotoImage replacement.\nHold on to your images!\nUnlike all other tkinter widgets, an image is utterly lost if the corresponding Python\nimage object is garbage collected. That means you must retain an explicit reference\nto image objects for as long as your program needs them (e.g., assign them to a\nlong-lived variable name, object attribute, or data structure component). Python\ndoes not automatically keep a reference to the image, even if it is linked to other\nGUI components for display. Moreover, image destructor methods erase the image\nfrom memory. We saw earlier that tkinter variables can behave oddly when re-\nclaimed, too (they may be unset), but the effect is much worse and more likely to\nhappen with images. This may change in future Python releases, though there are\ngood reasons for not retaining big image files in memory indefinitely; for now,\nthough, images are a \u201cuse it or lose it\u201d widget.\nFun with Buttons and Pictures\nI tried to come up with an image demo for this section that was both fun and useful. I\nsettled for the fun part. Example 8-40 displays a button that changes its image at ran-\ndom each time it is pressed.\nExample 8-40. PP4E\\Gui\\Tour\\buttonpics-func.py\nfrom tkinter import *                # get base widget set\nfrom glob import glob                # filename expansion list\nimport demoCheck                     # attach checkbutton demo to me\nimport random                        # pick a picture at random\ngifdir = '../gifs/'                  # where to look for GIF files\nImages | 487def draw():\n    name, photo = random.choice(images)\n    lbl.config(text=name)\n    pix.config(image=photo)\nroot=Tk()\nlbl = Label(root,  text=\"none\", bg='blue', fg='red')\npix = Button(root, text=\"Press me\", command=draw, bg='white')\nlbl.pack(fill=BOTH)\npix.pack(pady=10)\ndemoCheck.Demo(root, relief=SUNKEN, bd=2).pack(fill=BOTH)\nfiles = glob(gifdir + \"*.gif\")                              # GIFs for now\nimages = [(x, PhotoImage(file=x)) for x in files]           # load and hold\nprint(files)\nroot.mainloop()\nThis code uses a handful of built-in tools from the Python library:\n\u2022 The Python glob module we first met in Chapter 4 gives a list of all files ending\nin .gif in a directory; in other words, all GIF files stored there.\n\u2022 The Python random module is used to select a random GIF from files in the directory:\nrandom.choice picks and returns an item from a list at random.\n\u2022 To change the image displayed (and the GIF file\u2019s name in a label at the top of the\nwindow), the script simply calls the widget config method with new option set-\ntings; changing on the fly like this changes the widget\u2019s display dynamically.\nJust for fun, this script also attaches an instance of the demoCheck check button demo\nbar from Example 8-22, which in turn attaches an instance of the Quitter button we\nwrote earlier in Example 8-7. This is an artificial example, of course, but it again dem-\nonstrates the power of component class attachment at work.\nNotice how this script builds and holds on to all images in its images list. The list\ncomprehension here applies a PhotoImage constructor call to every .gif file in the photo\ndirectory, producing a list of (filename, imageobject) tuples that is saved in a global\nvariable (a map call using a one-argument lambda function could do the same). Remem-\nber, this guarantees that image objects won\u2019t be garbage collected as long as the pro-\ngram is running. Figure 8-40 shows this script in action on Windows.\nAlthough it may not be obvious in this grayscale book, the name of the GIF file being\ndisplayed is shown in red text in the blue label at the top of this window. This program\u2019s\nwindow grows and shrinks automatically when larger and smaller GIF files are dis-\nplayed; Figure 8-41 shows it randomly picking a taller photo globbed from the image\ndirectory.\n488 | Chapter 8:\u2002A tkinter Tour, Part 1Figure 8-40. buttonpics in action\nFigure 8-41. buttonpics showing a taller photo\nImages | 489And finally, Figure 8-42 captures this script\u2019s GUI displaying one of the wider GIFs,\nselected completely at random from the photo file directory.\u2021\nFigure 8-42. buttonpics gets political\nWhile we\u2019re playing, let\u2019s recode this script as a class in case we ever want to attach or\ncustomize it later (it could happen, especially in more realistic programs). It\u2019s mostly\na matter of indenting and adding self before global variable names, as shown in\nExample 8-41.\nExample 8-41. PP4E\\Gui\\Tour\\buttonpics.py\nfrom tkinter import *                # get base widget set\nfrom glob import glob                # filename expansion list\nimport demoCheck                     # attach check button example to me\nimport random                        # pick a picture at random\ngifdir = '../gifs/'                  # default dir to load GIF files\nclass ButtonPicsDemo(Frame):\n    def __init__(self, gifdir=gifdir, parent=None):\n        Frame.__init__(self, parent)\n        self.pack()\n        self.lbl = Label(self,  text=\"none\", bg='blue', fg='red')\n        self.pix = Button(self, text=\"Press me\", command=self.draw, bg='white')\n        self.lbl.pack(fill=BOTH)\n        self.pix.pack(pady=10)\n        demoCheck.Demo(self, relief=SUNKEN, bd=2).pack(fill=BOTH)\n        files = glob(gifdir + \"*.gif\")\n        self.images = [(x, PhotoImage(file=x)) for x in files]\n        print(files)\n    def draw(self):\n        name, photo = random.choice(self.images)\n\u2021 This particular image is not my creation; it appeared as a banner ad on developer-related websites such as\nSlashdot when the book Learning Python was first published in 1999. It generated enough of a backlash from\nPerl zealots that O\u2019Reilly eventually pulled the ad altogether. Which may be why, of course, it later appeared\nin this book.\n490 | Chapter 8:\u2002A tkinter Tour, Part 1self.lbl.config(text=name)\n        self.pix.config(image=photo)\nif __name__ == '__main__': ButtonPicsDemo().mainloop()\nThis version works the same way as the original, but it can now be attached to any\nother GUI where you would like to include such an unreasonably silly button.\nViewing and Processing Images with PIL\nAs mentioned earlier, Python tkinter scripts show images by associating independently\ncreated image objects with real widget objects. At this writing, tkinter GUIs can display\nphoto image files in GIF, PPM, and PGM formats by creating a PhotoImage object, as\nwell as X11-style bitmap files (usually suffixed with an .xbm extension) by creating a\nBitmapImage object.\nThis set of supported file formats is limited by the underlying Tk library, not by tkinter\nitself, and may expand in the future (it has not in many years). But if you want to display\nfiles in other formats today (e.g., the popular JPEG format), you can either convert your\nfiles to one of the supported formats with an image-processing program or install the\nPIL Python extension package mentioned at the start of Chapter 7.\nPIL, the Python Imaging Library, is an open source system that supports nearly 30\ngraphics file formats (including GIF, JPEG, TIFF, PNG, and BMP). In addition to al-\nlowing your scripts to display a much wider variety of image types than standard tkinter,\nPIL also provides tools for image processing, including geometric transforms, thumb-\nnail creation, format conversions, and much more.\nPIL Basics\nTo use its tools, you must first fetch and install the PIL package: see http://www.py\nthonware.com (or search for \u201cPIL\u201d on the web). Then, simply use special PhotoImage\nand BitmapImage objects imported from the PIL ImageTk module to open files in other\ngraphic formats. These are compatible replacements for the standard tkinter classes of\nthe same name, and they may be used anywhere tkinter expects a PhotoImage or\nBitmapImage object (i.e., in label, button, canvas, text, and menu object configurations).\nThat is, replace standard tkinter code such as this:\nfrom tkinter import *\nimgobj = PhotoImage(file=imgdir + \"spam.gif\")\nButton(image=imgobj).pack()\nViewing and Processing Images with PIL | 491with code of this form:\nfrom tkinter import *\nfrom PIL import ImageTk\nphotoimg = ImageTk.PhotoImage(file=imgdir + \"spam.jpg\")\nButton(image=photoimg).pack()\nor with the more verbose equivalent, which comes in handy if you will perform image\nprocessing in addition to image display:\nfrom tkinter import *\nfrom PIL import Image, ImageTk\nimageobj = Image.open(imgdir + \"spam.jpeg\")\nphotoimg = ImageTk.PhotoImage(imageobj)\nButton(image=photoimg).pack()\nIn fact, to use PIL for image display, all you really need to do is install it and add a single\nfrom statement to your code to get its replacement PhotoImage object after loading the\noriginal from tkinter. The rest of your code remains unchanged but will be able to\ndisplay JPEG, PNG, and other image types:\nfrom tkinter import *\nfrom PIL.ImageTk import PhotoImage                 # <== add this line\nimgobj = PhotoImage(file=imgdir + \"spam.png\")\nButton(image=imgobj).pack()\nPIL installation details vary per platform; on Windows, it is just a matter of down-\nloading and running a self-installer. PIL code winds up in the Python install directory\u2019s\nLib\\site-packages; because this is automatically added to the module import search\npath, no path configuration is required to use PIL. Simply run the installer and import\nthe PIL package\u2019s modules. On other platforms, you might untar or unZIP a fetched\nsource code archive and add PIL directories to the front of your PYTHONPATH setting; see\nthe PIL system\u2019s website for more details. (In fact, I am using a pre-release version of\nPIL for Python 3.1 in this edition; it should be officially released by the time you read\nthese words.)\nThere is much more to PIL than we have space to cover here. For instance, it also\nprovides image conversion, resizing, and transformation tools, some of which can be\nrun as command-line programs that have nothing to do with GUIs directly. Especially\nfor tkinter-based programs that display or process images, PIL will likely become a\nstandard component in your software tool set.\nSee http://www.pythonware.com for more information, as well as online PIL and tkinter\ndocumentation sets. To help get you started, though, we\u2019ll close out this chapter with\na handful of real scripts that use PIL for image display and processing.\n492 | Chapter 8:\u2002A tkinter Tour, Part 1Displaying Other Image Types with PIL\nIn our earlier image examples, we attached widgets to buttons and canvases, but the\nstandard tkinter toolkit allows images to be added to a variety of widget types, including\nsimple labels, text, and menu entries. Example 8-42, for instance, uses unadorned\ntkinter to display a single image by attaching it to a label, in the main application win-\ndow. The example assumes that images are stored in an images subdirectory, and it\nallows the image filename to be passed in as a command-line argument (it defaults to\nspam.gif if no argument is passed). It also joins file and directory names more portably\nwith os.path.join, and it prints the image\u2019s height and width in pixels to the standard\noutput stream, just to give extra information.\nExample 8-42. PP4E\\Gui\\PIL\\viewer-tk.py\n\"\"\"\nshow one image with standard tkinter photo object;\nas is this handles GIF files, but not JPEG images; image filename listed in\ncommand line, or default; use a Canvas instead of Label for scrolling, etc.\n\"\"\"\nimport os, sys\nfrom tkinter import *                    # use standard tkinter photo object\n                                         # GIF works, but JPEG requires PIL\nimgdir  = 'images'\nimgfile = 'london-2010.gif'\nif len(sys.argv) > 1:                    # cmdline argument given?\n    imgfile = sys.argv[1]\nimgpath = os.path.join(imgdir, imgfile)\nwin = Tk()\nwin.title(imgfile)\nimgobj = PhotoImage(file=imgpath)        # display photo on a Label\nLabel(win, image=imgobj).pack()\nprint(imgobj.width(), imgobj.height())   # show size in pixels before destroyed\nwin.mainloop()\nFigure 8-43 captures this script\u2019s display on Windows 7, showing the default GIF image\nfile. Run this from the system console with a filename as a command-line argument to\nview other files in the images subdirectory (e.g., python viewer_tk.py filename.gif).\nViewing and Processing Images with PIL | 493Figure 8-43. tkinter GIF display\nExample 8-42 works, but only for image types supported by the base tkinter toolkit.\nTo display other image formats, such as JPEG, we need to install PIL and use its re-\nplacement PhotoImage object. In terms of code, it\u2019s simply a matter of adding one import\nstatement, as illustrated in Example 8-43.\nExample 8-43. PP4E\\Gui\\PIL\\viewer-pil.py\n\"\"\"\nshow one image with PIL photo replacement object\nhandles many more image types; install PIL first: placed in Lib\\site-packages\n\"\"\"\nimport os, sys\nfrom tkinter import *\nfrom PIL.ImageTk import PhotoImage       # <== use PIL replacement class\n                                         # rest of code unchanged\nimgdir  = 'images'\nimgfile = 'florida-2009-1.jpg'           # does gif, jpg, png, tiff, etc.\nif len(sys.argv) > 1:\n    imgfile = sys.argv[1]\nimgpath = os.path.join(imgdir, imgfile)\nwin = Tk()\nwin.title(imgfile)\nimgobj = PhotoImage(file=imgpath)        # now JPEGs work!\nLabel(win, image=imgobj).pack()\n494 | Chapter 8:\u2002A tkinter Tour, Part 1win.mainloop()\nprint(imgobj.width(), imgobj.height())   # show size in pixels on exit\nWith PIL, our script is now able to display many image types, including the default\nJPEG image defined in the script and captured in Figure 8-44. Again, run with a\ncommand-line argument to view other photos.\nFigure 8-44. tkinter+PIL JPEG display\nDisplaying all images in a directory\nWhile we\u2019re at it, it\u2019s not much extra work to allow viewing all images in a directory,\nusing some of the directory path tools we met in the first part of this book.\nExample 8-44, for instance, simply opens a new Toplevel pop-up window for each\nimage in a directory (given as a command-line argument or a default), taking care to\nskip nonimage files by catching exceptions\u2014error messages are both printed and dis-\nplayed in the bad file\u2019s pop-up window.\nExample 8-44. PP4E\\Gui\\PIL\\viewer-dir.py\n\"\"\"\ndisplay all images in a directory in pop-up windows\nGIFs work in basic tkinter, but JPEGs will be skipped without PIL\n\"\"\"\nViewing and Processing Images with PIL | 495import os, sys\nfrom tkinter import *\nfrom PIL.ImageTk import PhotoImage          # <== required for JPEGs and others\nimgdir = 'images'\nif len(sys.argv) > 1: imgdir = sys.argv[1]\nimgfiles = os.listdir(imgdir)               # does not include directory prefix\nmain = Tk()\nmain.title('Viewer')\nquit = Button(main, text='Quit all', command=main.quit, font=('courier', 25))\nquit.pack()\nsavephotos = []\nfor imgfile in imgfiles:\n    imgpath = os.path.join(imgdir, imgfile)\n    win = Toplevel()\n    win.title(imgfile)\n    try:\n        imgobj = PhotoImage(file=imgpath)\n        Label(win, image=imgobj).pack()\n        print(imgpath, imgobj.width(), imgobj.height())      # size in pixels\n        savephotos.append(imgobj)                            # keep a reference\n    except:\n        errmsg = 'skipping %s\\n%s' % (imgfile, sys.exc_info()[1])\n        Label(win, text=errmsg).pack()\nmain.mainloop()\nRun this code on your own to see the windows it generates. If you do, you\u2019ll get one\nmain window with a Quit button to kill all the windows at once, plus as many pop-up\nimage view windows as there are images in the directory. This is convenient for a quick\nlook, but not exactly the epitome of user friendliness for large directories! The sample\nimages directory used for testing, for instance, has 59 images, yielding 60 pop-up win-\ndows; those created by your digital camera may have many more. To do better, let\u2019s\nmove on to the next section.\nCreating Image Thumbnails with PIL\nAs mentioned, PIL does more than display images in a GUI; it also comes with tools\nfor resizing, converting, and more. One of the many useful tools it provides is the ability\nto generate small, \u201cthumbnail\u201d images from originals. Such thumbnails may be dis-\nplayed in a web page or selection GUI to allow the user to open full-size images on\ndemand.\nExample 8-45 is a concrete implementation of this idea\u2014it generates thumbnail images\nusing PIL and displays them on buttons which open the corresponding original image\nwhen clicked. The net effect is much like the file explorer GUIs that are now standard\non modern operating systems, but by coding this in Python, we\u2019re able to control its\nbehavior and to reuse and customize its code in our own applications. In fact, we\u2019ll\n496 | Chapter 8:\u2002A tkinter Tour, Part 1reuse the makeThumbs function here repeatedly in other examples. As usual, these are\nsome of the primary benefits inherent in open source software in general.\nExample 8-45. PP4E\\Gui\\PIL\\viewer_thumbs.py\n\"\"\"\ndisplay all images in a directory as thumbnail image buttons that display\nthe full image when clicked; requires PIL for JPEGs and thumbnail image\ncreation;  to do: add scrolling if too many thumbs for window!\n\"\"\"\nimport os, sys, math\nfrom tkinter import *\nfrom PIL import Image                   # <== required for thumbs\nfrom PIL.ImageTk import PhotoImage      # <== required for JPEG display\ndef makeThumbs(imgdir, size=(100, 100), subdir='thumbs'):\n    \"\"\"\n    get thumbnail images for all images in a directory; for each image, create\n    and save a new thumb, or load and return an existing thumb;  makes thumb\n    dir if needed;  returns a list of (image filename, thumb image object);\n    caller can also run listdir on thumb dir to load;  on bad file types may\n    raise IOError, or other;  caveat: could also check file timestamps;\n    \"\"\"\n    thumbdir = os.path.join(imgdir, subdir)\n    if not os.path.exists(thumbdir):\n        os.mkdir(thumbdir)\n    thumbs = []\n    for imgfile in os.listdir(imgdir):\n        thumbpath = os.path.join(thumbdir, imgfile)\n        if os.path.exists(thumbpath):\n            thumbobj = Image.open(thumbpath)            # use already created\n            thumbs.append((imgfile, thumbobj))\n        else:\n            print('making', thumbpath)\n            imgpath = os.path.join(imgdir, imgfile)\n            try:\n                imgobj = Image.open(imgpath)            # make new thumb\n                imgobj.thumbnail(size, Image.ANTIALIAS) # best downsize filter\n                imgobj.save(thumbpath)                  # type via ext or passed\n                thumbs.append((imgfile, imgobj))\n            except:                                     # not always IOError\n                print(\"Skipping: \", imgpath)\n    return thumbs\nclass ViewOne(Toplevel):\n    \"\"\"\n    open a single image in a pop-up window when created;  photoimage\n    object must be saved: images are erased if object is reclaimed;\n    \"\"\"\n    def __init__(self, imgdir, imgfile):\n        Toplevel.__init__(self)\n        self.title(imgfile)\n        imgpath = os.path.join(imgdir, imgfile)\nViewing and Processing Images with PIL | 497imgobj  = PhotoImage(file=imgpath)\n        Label(self, image=imgobj).pack()\n        print(imgpath, imgobj.width(), imgobj.height())   # size in pixels\n        self.savephoto = imgobj                           # keep reference on me\ndef viewer(imgdir, kind=Toplevel, cols=None):\n    \"\"\"\n    make thumb links window for an image directory: one thumb button per image;\n    use kind=Tk to show in main  app window, or Frame container (pack);  imgfile\n    differs per loop: must save with a default;  photoimage objs must be saved:\n    erased if reclaimed; packed row frames (versus grids, fixed-sizes, canvas);\n    \"\"\"\n    win = kind()\n    win.title('Viewer: ' + imgdir)\n    quit = Button(win, text='Quit', command=win.quit, bg='beige')   # pack first\n    quit.pack(fill=X, side=BOTTOM)                                  # so clip last\n    thumbs = makeThumbs(imgdir)\n    if not cols:\n        cols = int(math.ceil(math.sqrt(len(thumbs))))     # fixed or N x N\n    savephotos = []\n    while thumbs:\n        thumbsrow, thumbs = thumbs[:cols], thumbs[cols:]\n        row = Frame(win)\n        row.pack(fill=BOTH)\n        for (imgfile, imgobj) in thumbsrow:\n            photo   = PhotoImage(imgobj)\n            link    = Button(row, image=photo)\n            handler = lambda savefile=imgfile: ViewOne(imgdir, savefile)\n            link.config(command=handler)\n            link.pack(side=LEFT, expand=YES)\n            savephotos.append(photo)\n    return win, savephotos\nif __name__ == '__main__':\n    imgdir = (len(sys.argv) > 1 and sys.argv[1]) or 'images'\n    main, save = viewer(imgdir, kind=Tk)\n    main.mainloop()\nNotice how this code\u2019s viewer must pass in the imgfile to the generated callback han-\ndler with a default argument; because imgfile is a loop variable, all callbacks will have\nits final loop iteration value if its current value is not saved this way (all buttons would\nopen the same image!). Also notice we keep a list of references to the photo image\nobjects; photos are erased when their object is garbage collected, even if they are cur-\nrently being displayed. To avoid this, we generate references in a long-lived list.\nFigure 8-45 shows the main thumbnail selection window generated by Example 8-45\nwhen viewing the default images subdirectory in the examples source tree (resized here\nfor display). As in the previous examples, you can pass in an optional directory name\nto run the viewer on a directory of your own (for instance, one copied from your digital\ncamera). Clicking a thumbnail button in the main window opens a corresponding im-\nage in a pop-up window; Figure 8-46 captures one.\n498 | Chapter 8:\u2002A tkinter Tour, Part 1Figure 8-45. Simple thumbnail selection GUI, simple row frames\nFigure 8-46. Thumbnail viewer pop-up image window\nViewing and Processing Images with PIL | 499Much of Example 8-45\u2019s code should be straightforward by now. It lays out thumbnail\nbuttons in row frames, much like prior examples (see the input forms layout alternatives\nearlier in this chapter). Most of the PIL-specific code in this example is in the make\nThumbs function. It opens, creates, and saves the thumbnail image, unless one has al-\nready been saved (i.e., cached) to a local file. As coded, thumbnail images are saved in\nthe same image format as the original full-size photo.\nWe also use the PIL ANTIALIAS filter\u2014the best quality for down-sampling (shrinking);\nthis does a better job on low-resolution GIFs. Thumbnail generation is essentially just\nan in-place resize that preserves the original aspect ratio. Because there is more to this\nstory than we can cover here, though, I\u2019ll defer to PIL and its documentation for more\ndetails on that package\u2019s API.\nWe\u2019ll revisit thumbnail creation again briefly in the next chapter to create toolbar but-\ntons. Before we move on, though, three variations on the thumbnail viewer are worth\nquick consideration\u2014the first underscores performance concepts and the others have\nto do with improving on the arguably odd layout of Figure 8-45.\nPerformance: Saving thumbnail files\nAs is, the viewer saves the generated thumbnail image in a file, so it can be loaded\nquickly the next time the script is run. This isn\u2019t strictly required\u2014Example 8-46, for\ninstance, customizes the thumbnail generation function to generate the thumbnail im-\nages in memory, but never save them.\nThere is no noticeable speed difference for very small image collections. If you run these\nalternatives on larger image collections, though, you\u2019ll notice that the original version\nin Example 8-45 gains a big performance advantage by saving and loading the thumb-\nnails to files. On one test with many large image files on my machine (some 320 images\nfrom a digital camera memory stick and an admittedly underpowered laptop), the\noriginal version opens the GUI in roughly just 5 seconds after its initial run to cache\nthumbnails, compared to as much as 1 minute and 20 seconds for Example 8-46: a\nfactor of 16 slower. For thumbnails, loading from files is much quicker than \nrecalculation.\nExample 8-46. PP4E\\Gui\\PIL\\viewer-thumbs-nosave.py\n\"\"\"\nsame, but make thumb images in memory without saving to or loading from files:\nseems just as fast for small directories, but saving to files makes startup much\nquicker for large image collections; saving may be needed in some apps (web pages)\n\"\"\"\nimport os, sys\nfrom PIL import Image\nfrom tkinter import Tk\nimport viewer_thumbs\ndef makeThumbs(imgdir, size=(100, 100), subdir='thumbs'):\n500 | Chapter 8:\u2002A tkinter Tour, Part 1\"\"\"\n    create thumbs in memory but don't cache to files\n    \"\"\"\n    thumbs = []\n    for imgfile in os.listdir(imgdir):\n        imgpath = os.path.join(imgdir, imgfile)\n        try:\n            imgobj = Image.open(imgpath)          # make new thumb\n            imgobj.thumbnail(size)\n            thumbs.append((imgfile, imgobj))\n        except:\n            print(\"Skipping: \", imgpath)\n    return thumbs\nif __name__ == '__main__':\n    imgdir = (len(sys.argv) > 1 and sys.argv[1]) or 'images'\n    viewer_thumbs.makeThumbs = makeThumbs\n    main, save = viewer_thumbs.viewer(imgdir, kind=Tk)\n    main.mainloop()\nLayout options: Gridding\nThe next variations on our viewer are purely cosmetic, but they illustrate tkinter layout\nconcepts. If you look at Figure 8-45 long enough, you\u2019ll notice that its layout of thumb-\nnails is not as uniform as it could be. Individual rows are fairly coherent because the\nGUI is laid out by row frames, but columns can be misaligned badly due to differences\nin image shape. Different packing options don\u2019t seem to help (and can make matters\neven more askew\u2014try it), and arranging by column frames would just shift the problem\nto another dimension. For larger collections, it could become difficult to locate and\nopen specific images.\nWith just a little extra work, we can achieve a more uniform layout by either laying out\nthe thumbnails in a grid, or using uniform fixed-size buttons. Example 8-47 positions\nbuttons in a row/column grid by using the tkinter grid geometry manager\u2014a topic we\nwill explore in more detail in the next chapter, so like the canvas, you should consider\nsome of this code to be a preview and segue, too. In short, grid arranges its contents\nby row and column; we\u2019ll learn all about the stickiness of the Quit button here in\nChapter 9.\nExample 8-47. PP4E\\Gui\\PIL\\viewer-thumbs-grid.py\n\"\"\"\nsame as viewer_thumbs, but uses the grid geometry manager to try to achieve\na more uniform layout; can generally achieve the same with frames and pack\nif buttons are all fixed and uniform in size;\n\"\"\"\nimport sys, math\nfrom tkinter import *\nfrom PIL.ImageTk import PhotoImage\nfrom viewer_thumbs import makeThumbs, ViewOne\nViewing and Processing Images with PIL | 501def viewer(imgdir, kind=Toplevel, cols=None):\n    \"\"\"\n    custom version that uses gridding\n    \"\"\"\n    win = kind()\n    win.title('Viewer: ' + imgdir)\n    thumbs = makeThumbs(imgdir)\n    if not cols:\n        cols = int(math.ceil(math.sqrt(len(thumbs))))     # fixed or N x N\n    rownum = 0\n    savephotos = []\n    while thumbs:\n        thumbsrow, thumbs = thumbs[:cols], thumbs[cols:]\n        colnum = 0\n        for (imgfile, imgobj) in thumbsrow:\n            photo   = PhotoImage(imgobj)\n            link    = Button(win, image=photo)\n            handler = lambda savefile=imgfile: ViewOne(imgdir, savefile)\n            link.config(command=handler)\n            link.grid(row=rownum, column=colnum)\n            savephotos.append(photo)\n            colnum += 1\n        rownum += 1\n    Button(win, text='Quit', command=win.quit).grid(columnspan=cols, stick=EW)\n    return win, savephotos\nif __name__ == '__main__':\n    imgdir = (len(sys.argv) > 1 and sys.argv[1]) or 'images'\n    main, save = viewer(imgdir, kind=Tk)\n    main.mainloop()\nFigure 8-47 displays the effect of gridding\u2014our buttons line up in rows and columns\nin a more uniform fashion than in Figure 8-45, because they are positioned by both row\nand column, not just by rows. As we\u2019ll see in the next chapter, gridding can help any\ntime our displays are two-dimensional by nature.\nLayout options: Fixed-size buttons\nGridding helps\u2014rows and columns align regularly now\u2014but image shape still makes\nthis less than ideal. We can achieve a layout that is perhaps even more uniform than\ngridding by giving each thumbnail button a fixed size. Buttons are sized to their images\n(or text) by default, but we can always override this if needed. Example 8-48 does the\ntrick. It sets the height and width of each button to match the maximum dimension of\nthe thumbnail icon, so it is neither too thin nor too high. Assuming all thumbnails have\nthe same maximum dimension (something our thumb-maker ensures), this will achieve\nthe desired layout.\n502 | Chapter 8:\u2002A tkinter Tour, Part 1Example 8-48. PP4E\\Gui\\PIL\\viewer-thumbs-fixed.py\n\"\"\"\nuse fixed size for thumbnails, so align regularly; size taken from image\nobject, assume all same max; this is essentially what file selection GUIs do;\n\"\"\"\nimport sys, math\nfrom tkinter import *\nfrom PIL.ImageTk import PhotoImage\nfrom viewer_thumbs import makeThumbs, ViewOne\ndef viewer(imgdir, kind=Toplevel, cols=None):\n    \"\"\"\n    custom version that lays out with fixed-size buttons\n    \"\"\"\n    win = kind()\n    win.title('Viewer: ' + imgdir)\n    thumbs = makeThumbs(imgdir)\n    if not cols:\n        cols = int(math.ceil(math.sqrt(len(thumbs))))      # fixed or N x N\n    savephotos = []\n    while thumbs:\n        thumbsrow, thumbs = thumbs[:cols], thumbs[cols:]\n        row = Frame(win)\n        row.pack(fill=BOTH)\n        for (imgfile, imgobj) in thumbsrow:\n            size    = max(imgobj.size)                     # width, height\n            photo   = PhotoImage(imgobj)\n            link    = Button(row, image=photo)\nFigure 8-47. Gridded thumbnail selection GUI\nViewing and Processing Images with PIL | 503handler = lambda savefile=imgfile: ViewOne(imgdir, savefile)\n            link.config(command=handler, width=size, height=size)\n            link.pack(side=LEFT, expand=YES)\n            savephotos.append(photo)\n    Button(win, text='Quit', command=win.quit, bg='beige').pack(fill=X)\n    return win, savephotos\nif __name__ == '__main__':\n    imgdir = (len(sys.argv) > 1 and sys.argv[1]) or 'images'\n    main, save = viewer(imgdir, kind=Tk)\n    main.mainloop()\nFigure 8-48 shows the results of applying a fixed size to our buttons; all are the same\nsize now, using a size taken from the images themselves. The effect is to display all\nthumbnails as same-size tiles regardless of their shape, so they are easier to view. Nat-\nurally, other layout schemes are possible as well; experiment with some of the config-\nuration options in this code on your own to see their effect on the display.\nFigure 8-48. Fixed-size thumbnail selection GUI, row frames\nScrolling and canvases (ahead)\nThe thumbnail viewer scripts presented in this section work well for reasonably sized\nimage directories, and you can use smaller thumbnail size settings for larger image\ncollections. Perhaps the biggest limitation of these programs, though, is that the\nthumbnail windows they create will become too large to handle (or display at all) if the\nimage directory contains very many files.\n504 | Chapter 8:\u2002A tkinter Tour, Part 1Even with the sample images directory used for this book, we lost the Quit button at\nthe bottom of the display in the last two figures because there are too many thumbnail\nimages to show. To illustrate the difference, the original Example 8-45 packs the Quit\nbutton first for this very reason\u2014so it is clipped last, after all thumbnails, and thus\nremains visible when there are many photos. We could do a similar thing for the other\nversions, but we\u2019d still lose thumbnails if there were too many. A directory from your\ncamera with many images might similarly produce a window too large to fit on your\ncomputer\u2019s screen.\nTo do better, we could arrange the thumbnails on a widget that supports scrolling. The\nopen source Pmw package includes a handy scrolled frame that may help. Moreover,\nthe standard tkinter Canvas widget gives us more control over image displays (including\nplacement by absolute pixel coordinates) and supports horizontal and vertical scrolling\nof its content.\nIn fact, in the next chapter, we\u2019ll code one final extension to our script which does just\nthat\u2014it displays thumbnails in a scrolled canvas, and so it handles large collections\nmuch better. Its thumbnail buttons are fixed-size as in our last example here, but are\npositioned at computed coordinates. I\u2019ll defer further details here, though, because\nwe\u2019ll study that extension in conjunction with canvases in the next chapter. And in\nChapter 11, we\u2019ll apply this technique to an even more full-featured image program\ncalled PyPhoto.\nTo learn how these programs do their jobs, though, we need to move on to the next\nchapter, and the second half of our widget tour.\nViewing and Processing Images with PIL | 505", "9": "CHAPTER 9\nA tkinter Tour, Part 2\n\u201cOn Today\u2019s Menu: Spam, Spam, and Spam\u201d\nThis chapter is the second in a two-part tour of the tkinter library. It picks up where \nChapter 8 left off and covers some of the more advanced widgets and tools in the tkinter \narsenal. Among the topics presented in this chapter:\n\u2022 Menu, Menubutton, and OptionMenu widgets\n\u2022 The Scrollbar widget: for scrolling text, lists, and canvases\n\u2022 The Listbox widget: a list of multiple selections\n\u2022 The Text widget: a general text display and editing tool\n\u2022 The Canvas widget: a general graphical drawing tool\n\u2022 The grid table-based geometry manager\n\u2022 Time-based tools: after, update, wait, and threads\n\u2022 Basic tkinter animation techniques\n\u2022 Clipboards, erasing widgets and windows, and so on\nBy the time you\u2019ve finished this chapter, you will have seen the bulk of the tkinter \nlibrary, and you will have all the information you need to compose larger, portable user \ninterfaces of your own. You\u2019ll also be ready to tackle the larger GUI techniques and \nmore complete examples presented in Chapters 10 and 11. For now, let\u2019s resume the \nwidget show.\nMenus\nMenus are the pull-down lists you\u2019re accustomed to seeing at the top of a window (or \nthe entire display, if you\u2019re accustomed to seeing them that way on a Macintosh). Move \nthe mouse cursor to the menu bar at the top and click on a name (e.g., File), and a list \nof selectable options pops up under the name you clicked (e.g., Open, Save). The op-\ntions within a menu might trigger actions, much like clicking on a button; they may\n507also open other \u201ccascading\u201d submenus that list more options, pop up dialog windows, \nand so on. In tkinter, there are two kinds of menus you can add to your scripts: top-\nlevel window menus and frame-based menus. The former option is better suited to \nwhole windows, but the latter also works as a nested component.\nTop-Level Window Menus\nIn all recent Python releases (using Tk 8.0 and later), you can associate a horizontal \nmenu bar with a top-level window object (e.g., a Tk or Toplevel). On Windows and \nUnix (X Windows), this menu bar is displayed along the top of the window; on some \nMacintosh machines, this menu replaces the one shown at the top of the screen when \nthe window is selected. In other words, window menus look like you would expect on \nwhatever underlying platform your script runs upon.\nThis scheme is based on building trees of Menu widget objects. Simply associate one top-\nlevel Menu with the window, add other pull-down Menu objects as cascades of the top-\nlevel Menu, and add entries to each of the pull-down objects. Menus are cross-linked with \nthe next higher level, by using parent widget arguments and the Menu widget\u2019s \nadd_cascade method. It works like this:\n1. Create a topmost Menu as the child of the window widget and configure the win-\ndow\u2019s menu attribute to be the new Menu.\n2. For each pull-down object, make a new Menu as the child of the topmost Menu and \nadd the child as a cascade of the topmost Menu using add_cascade.\n3. Add menu selections to each pull-down Menu from step 2, using the command options \nof add_command to register selection callback handlers.\n4. Add a cascading submenu by making a new Menu as the child of the Menu the cascade \nextends and using add_cascade to link the parent to the child.\nThe end result is a tree of Menu widgets with associated command callback handlers. This \nis probably simpler in code than in words, though. Example 9-1 makes a main menu \nwith two pull downs, File and Edit; the Edit pull down in turn has a nested submenu \nof its own.\nExample 9-1. PP4E\\Gui\\Tour\\menu_win.py \n# Tk8.0 style top-level window menus\nfrom tkinter import *                              # get widget classes\nfrom tkinter.messagebox import *                   # get standard dialogs\ndef notdone():\n    showerror('Not implemented', 'Not yet available')\ndef makemenu(win):\n    top = Menu(win)                                # win=top-level window\n    win.config(menu=top)                           # set its menu option\n508 | Chapter 9:\u2002A tkinter Tour, Part 2file = Menu(top)\n    file.add_command(label='New...',  command=notdone,  underline=0)\n    file.add_command(label='Open...', command=notdone,  underline=0)\n    file.add_command(label='Quit',    command=win.quit, underline=0)\n    top.add_cascade(label='File',     menu=file,        underline=0)\n    edit = Menu(top, tearoff=False)\n    edit.add_command(label='Cut',     command=notdone,  underline=0)\n    edit.add_command(label='Paste',   command=notdone,  underline=0)\n    edit.add_separator()\n    top.add_cascade(label='Edit',     menu=edit,        underline=0)\n    submenu = Menu(edit, tearoff=True)\n    submenu.add_command(label='Spam', command=win.quit, underline=0)\n    submenu.add_command(label='Eggs', command=notdone,  underline=0)\n    edit.add_cascade(label='Stuff',   menu=submenu,     underline=0)\nif __name__ == '__main__':\n    root = Tk()                                        # or Toplevel()\n    root.title('menu_win')                             # set window-mgr info\n    makemenu(root)                                     # associate a menu bar\n    msg = Label(root, text='Window menu basics')       # add something below\n    msg.pack(expand=YES, fill=BOTH)\n    msg.config(relief=SUNKEN, width=40, height=7, bg='beige')\n    root.mainloop()\nA lot of code in this file is devoted to setting callbacks and such, so it might help to\nisolate the bits involved with the menu tree-building process. For the File menu, it\u2019s\ndone like this:\ntop = Menu(win)                            # attach Menu to window\nwin.config(menu=top)                       # cross-link window to menu\nfile = Menu(top)                           # attach a Menu to top Menu\ntop.add_cascade(label='File', menu=file)   # cross-link parent to child\nApart from building up the menu object tree, this script also demonstrates some of the\nmost common menu configuration options:\nSeparator lines\nThe script makes a separator in the Edit menu with add_separator; it\u2019s just a line\nused to set off groups of related entries.\nTear-offs\nThe script also disables menu tear-offs in the Edit pull down by passing a\ntearoff=False widget option to Menu. Tear-offs are dashed lines that appear by\ndefault at the top of tkinter menus and create a new window containing the menu\u2019s\ncontents when clicked. They can be a convenient shortcut device (you can click\nitems in the tear-off window right away, without having to navigate through menu\ntrees), but they are not widely used on all platforms.\nKeyboard shortcuts\nThe script uses the underline option to make a unique letter in a menu entry a\nkeyboard shortcut. It gives the offset of the shortcut letter in the entry\u2019s label string.\nMenus | 509On Windows, for example, the Quit option in this script\u2019s File menu can be se-\nlected with the mouse but also by pressing Alt, then \u201cf,\u201d and then \u201cq.\u201d You don\u2019t\nstrictly have to use underline\u2014on Windows, the first letter of a pull-down name\nis a shortcut automatically, and arrow and Enter keys can be used to select pull-\ndown items. But explicit keys can enhance usability in large menus; for instance,\nthe key sequence Alt-E-S-S runs the quit action in this script\u2019s nested submenu.\nLet\u2019s see what this translates to in the realm of the pixel. Figure 9-1 shows the window\nthat first appears when this script is run on Windows 7 with my system settings; it looks\ndifferent, but similar, on Unix, Macintosh, and other Windows configurations.\nFigure 9-1. menu_win: a top-level window menu bar\nFigure 9-2 shows the scene when the File pull down is selected. Notice that Menu widgets\nare linked, not packed (or gridded)\u2014the geometry manager doesn\u2019t really come into\nplay here. If you run this script, you\u2019ll also notice that all of its menu entries either quit\nthe program immediately or pop up a \u201cNot Implemented\u201d standard error dialog. This\nexample is about menus, after all, but menu selection callback handlers generally do\nmore useful work in practice.\nFigure 9-2. The File menu pull down\n510 | Chapter 9:\u2002A tkinter Tour, Part 2And finally, Figure 9-3 shows what happens after clicking the File menu\u2019s tear-off line\nand selecting the cascading submenu in the Edit pull down. Cascades can be nested as\ndeep as you like (though your users probably won\u2019t be happy if this gets silly).\nIn tkinter, every top-level window can have a menu bar, including pop ups you create\nwith the Toplevel widget. Example 9-2 makes three pop-up windows with the same\nmenu bar as the one we just met; when run, it constructs the scene in Figure 9-4.\nFigure 9-3. A File tear-off and Edit cascade\nFigure 9-4. Multiple Toplevels with menus\nExample 9-2. PP4E\\Gui\\Tour\\menu_win-multi.py\nfrom menu_win import makemenu       # reuse menu maker function\nfrom tkinter import *\nroot = Tk()\nfor i in range(3):                  # three pop-up windows with menus\n    win = Toplevel(root)\n    makemenu(win)\nMenus | 511Label(win, bg='black', height=5, width=25).pack(expand=YES, fill=BOTH)\nButton(root, text=\"Bye\", command=root.quit).pack()\nroot.mainloop()\nFrame- and Menubutton-Based Menus\nAlthough these are less commonly used for top-level windows, it\u2019s also possible to\ncreate a menu bar as a horizontal Frame. Before I show you how, though, let me explain\nwhy you should care. Because this frame-based scheme doesn\u2019t depend on top-level\nwindow protocols, it can also be used to add menus as nested components of larger\ndisplays. In other words, it\u2019s not just for top-level windows. For example, Chap-\nter 11\u2019s PyEdit text editor can be used both as a program and as an attachable compo-\nnent. We\u2019ll use window menus to implement PyEdit selections when PyEdit is run as\na standalone program, but we\u2019ll use frame-based menus when PyEdit is embedded in\nthe PyMailGUI and PyView displays. Both schemes are worth knowing.\nFrame-based menus require a few more lines of code, but they aren\u2019t much more com-\nplex than window menus. To make one, simply pack Menubutton widgets within a\nFrame container, associate Menu widgets with the Menubuttons, and associate the Frame\nwith the top of a container window. Example 9-3 creates the same menu as Exam-\nple 9-2, but using the frame-based approach.\nExample 9-3. PP4E\\Gui\\Tour\\menu_frm.py\n# Frame-based menus: for top-levels and components\nfrom tkinter import *                              # get widget classes\nfrom tkinter.messagebox import *                   # get standard dialogs\ndef notdone():\n    showerror('Not implemented', 'Not yet available')\ndef makemenu(parent):\n    menubar = Frame(parent)                        # relief=RAISED, bd=2...\n    menubar.pack(side=TOP, fill=X)\n    fbutton = Menubutton(menubar, text='File', underline=0)\n    fbutton.pack(side=LEFT)\n    file = Menu(fbutton)\n    file.add_command(label='New...',  command=notdone,     underline=0)\n    file.add_command(label='Open...', command=notdone,     underline=0)\n    file.add_command(label='Quit',    command=parent.quit, underline=0)\n    fbutton.config(menu=file)\n    ebutton = Menubutton(menubar, text='Edit', underline=0)\n    ebutton.pack(side=LEFT)\n    edit = Menu(ebutton, tearoff=False)\n    edit.add_command(label='Cut',     command=notdone,     underline=0)\n    edit.add_command(label='Paste',   command=notdone,     underline=0)\n    edit.add_separator()\n    ebutton.config(menu=edit)\n512 | Chapter 9:\u2002A tkinter Tour, Part 2submenu = Menu(edit, tearoff=True)\n    submenu.add_command(label='Spam', command=parent.quit, underline=0)\n    submenu.add_command(label='Eggs', command=notdone,     underline=0)\n    edit.add_cascade(label='Stuff',   menu=submenu,        underline=0)\n    return menubar\nif __name__ == '__main__':\n    root = Tk()                                        # or TopLevel or Frame\n    root.title('menu_frm')                             # set window-mgr info\n    makemenu(root)                                     # associate a menu bar\n    msg = Label(root, text='Frame menu basics')        # add something below\n    msg.pack(expand=YES, fill=BOTH)\n    msg.config(relief=SUNKEN, width=40, height=7, bg='beige')\n    root.mainloop()\nAgain, let\u2019s isolate the linkage logic here to avoid getting distracted by other details.\nFor the File menu case, here is what this boils down to:\nmenubar = Frame(parent)                     # make a Frame for the menubar\nfbutton = Menubutton(menubar, text='File')  # attach a Menubutton to Frame\nfile    = Menu(fbutton)                     # attach a Menu to Menubutton\nfbutton.config(menu=file)                   # crosslink button to menu\nThere is an extra Menubutton widget in this scheme, but it\u2019s not much more complex\nthan making top-level window menus. Figures 9-5 and 9-6 show this script in action\non Windows.\nFigure 9-5. menu_frm: Frame and Menubutton menu bar\nThe menu widgets in this script provide a default set of event bindings that automati-\ncally pop up menus when selected with a mouse. This doesn\u2019t look or behave exactly\nlike the top-level window menu scheme shown earlier, but it is close, can be configured\nin any way that frames can (i.e., with colors and borders), and will look similar on every\nplatform (though this may or may not be a feature in all contexts).\nThe biggest advantage of frame-based menu bars, though, is that they can also be at-\ntached as nested components in larger displays. Example 9-4 and its resulting interface\n(Figure 9-7) show how\u2014both menu bars are completely functional in the same single\nwindow.\nMenus | 513Example 9-4. PP4E\\Gui\\Tour\\menu_frm-multi.py\nfrom menu_frm import makemenu         # can't use menu_win here--one window\nfrom tkinter import *                 # but can attach frame menus to windows\nroot = Tk()\nfor i in range(2):                    # 2 menus nested in one window\n    mnu = makemenu(root)\n    mnu.config(bd=2, relief=RAISED)\n    Label(root, bg='black', height=5, width=25).pack(expand=YES, fill=BOTH)\nButton(root, text=\"Bye\", command=root.quit).pack()\nroot.mainloop()\nFigure 9-7. Multiple Frame menus on one window\nFigure 9-6. With the Edit menu selected\n514 | Chapter 9:\u2002A tkinter Tour, Part 2Because they are not tied to the enclosing window, frame-based menus can also be used\nas part of another attachable component\u2019s widget package. For example, the menu-\nembedding behavior in Example 9-5 works even if the menu\u2019s parent is another\nFrame container and not the top-level window; this script is similar to the prior, but\ncreates three fully functional menu bars attached to frames nested in a window.\nExample 9-5. PP4E\\Gui\\Tour\\menu_frm-multi2.py\nfrom menu_frm import makemenu         # can't use menu_win here--root=Frame\nfrom tkinter import *\nroot = Tk()\nfor i in range(3):                    # three menus nested in the containers\n    frm = Frame()\n    mnu = makemenu(frm)\n    mnu.config(bd=2, relief=RAISED)\n    frm.pack(expand=YES, fill=BOTH)\n    Label(frm, bg='black', height=5, width=25).pack(expand=YES, fill=BOTH)\nButton(root, text=\"Bye\", command=root.quit).pack()\nroot.mainloop()\nUsing Menubuttons and Optionmenus\nIn fact, menus based on Menubutton are even more general than Example 9-3 implies\u2014\nthey can actually show up anywhere on a display that normal buttons can, not just\nwithin a menu bar Frame. Example 9-6 makes a Menubutton pull-down list that simply\nshows up by itself, attached to the root window; Figure 9-8 shows the GUI it produces.\nExample 9-6. PP4E\\Gui\\Tour\\mbutton.py\nfrom tkinter import *\nroot    = Tk()\nmbutton = Menubutton(root, text='Food')     # the pull-down stands alone\npicks   = Menu(mbutton)\nmbutton.config(menu=picks)\npicks.add_command(label='spam',  command=root.quit)\npicks.add_command(label='eggs',  command=root.quit)\npicks.add_command(label='bacon', command=root.quit)\nmbutton.pack()\nmbutton.config(bg='white', bd=4, relief=RAISED)\nroot.mainloop()\nThe related tkinter Optionmenu widget displays an item selected from a pull-down menu.\nIt\u2019s roughly like a Menubutton plus a display label, and it displays a menu of choices\nwhen clicked, but you must link tkinter variables (described in Chapter 8) to fetch the\nchoice after the fact instead of registering callbacks, and menu entries are passed as\narguments in the widget constructor call after the variable.\nExample 9-7 illustrates typical Optionmenu usage and builds the interface captured in\nFigure 9-9. Clicking on either of the first two buttons opens a pull-down menu of\nMenus | 515options; clicking on the third \u201cstate\u201d button fetches and prints the current values dis-\nplayed in the first two.\nExample 9-7. PP4E\\Gui\\Tour\\optionmenu.py\nfrom tkinter import *\nroot = Tk()\nvar1 = StringVar()\nvar2 = StringVar()\nopt1 = OptionMenu(root, var1, 'spam', 'eggs',  'toast')     # like Menubutton\nopt2 = OptionMenu(root, var2, 'ham',  'bacon', 'sausage')   # but shows choice\nopt1.pack(fill=X)\nopt2.pack(fill=X)\nvar1.set('spam')\nvar2.set('ham')\ndef state(): print(var1.get(), var2.get())                  # linked variables\nButton(root, command=state, text='state').pack()\nroot.mainloop()\nFigure 9-9. An Optionmenu at work\nThere are other menu-related topics that we\u2019ll skip here in the interest of space. For\ninstance, scripts can add entries to system menus and can generate pop-up menus\n(posted in response to events, without an associated button). Refer to Tk and tkinter\nresources for more details on this front.\nFigure 9-8. A Menubutton all by itself\n516 | Chapter 9:\u2002A tkinter Tour, Part 2In addition to simple selections and cascades, menus can also contain disabled entries,\ncheck button and radio button selections, and bitmap and photo images. The next\nsection demonstrates how some of these special menu entries are programmed.\nWindows with Both Menus and Toolbars\nBesides showing a menu at the top, it is common for windows to display a row of\nbuttons at the bottom. This bottom button row is usually called a toolbar, and it often\ncontains shortcuts to items also available in the menus at the top. It\u2019s easy to add a\ntoolbar to windows in tkinter\u2014simply pack buttons (and other kinds of widgets) into\na frame, pack the frame on the bottom of the window, and set it to expand horizontally\nonly. This is really just hierarchical GUI layout at work again, but make sure to pack\ntoolbars (and frame-based menu bars) early so that other widgets in the middle of the\ndisplay are clipped first when the window shrinks; you usually want your tool and menu\nbars to outlive other widgets.\nExample 9-8 shows one way to go about adding a toolbar to a window. It also dem-\nonstrates how to add photo images in menu entries (set the image attribute to a Photo\nImage object) and how to disable entries and give them a grayed-out appearance (call\nthe menu entryconfig method with the index of the item to disable, starting from 1).\nNotice that PhotoImage objects are saved as a list; remember, unlike other widgets, these\ngo away if you don\u2019t hold on to them (see Chapter 8 if you need a refresher).\nExample 9-8. PP4E\\Gui\\Tour\\menuDemo.py\n#!/usr/local/bin/python\n\"\"\"\nTk8.0 style main window menus\nmenu/tool bars packed before middle, fill=X (pack first=clip last);\nadds photo menu entries; see also: add_checkbutton, add_radiobutton\n\"\"\"\nfrom tkinter import *                              # get widget classes\nfrom tkinter.messagebox import *                   # get standard dialogs\nclass NewMenuDemo(Frame):                          # an extended frame\n    def __init__(self, parent=None):               # attach to top-level?\n        Frame.__init__(self, parent)               # do superclass init\n        self.pack(expand=YES, fill=BOTH)\n        self.createWidgets()                       # attach frames/widgets\n        self.master.title(\"Toolbars and Menus\")    # set window-manager info\n        self.master.iconname(\"tkpython\")           # label when iconified\n    def createWidgets(self):\n        self.makeMenuBar()\n        self.makeToolBar()\n        L = Label(self, text='Menu and Toolbar Demo')\n        L.config(relief=SUNKEN, width=40, height=10, bg='white')\n        L.pack(expand=YES, fill=BOTH)\nMenus | 517def makeToolBar(self):\n        toolbar = Frame(self, cursor='hand2', relief=SUNKEN, bd=2)\n        toolbar.pack(side=BOTTOM, fill=X)\n        Button(toolbar, text='Quit',  command=self.quit    ).pack(side=RIGHT)\n        Button(toolbar, text='Hello', command=self.greeting).pack(side=LEFT)\n    def makeMenuBar(self):\n        self.menubar = Menu(self.master)\n        self.master.config(menu=self.menubar)    # master=top-level window\n        self.fileMenu()\n        self.editMenu()\n        self.imageMenu()\n    def fileMenu(self):\n        pulldown = Menu(self.menubar)\n        pulldown.add_command(label='Open...', command=self.notdone)\n        pulldown.add_command(label='Quit',    command=self.quit)\n        self.menubar.add_cascade(label='File', underline=0, menu=pulldown)\n    def editMenu(self):\n        pulldown = Menu(self.menubar)\n        pulldown.add_command(label='Paste',   command=self.notdone)\n        pulldown.add_command(label='Spam',    command=self.greeting)\n        pulldown.add_separator()\n        pulldown.add_command(label='Delete',  command=self.greeting)\n        pulldown.entryconfig(4, state=DISABLED)\n        self.menubar.add_cascade(label='Edit', underline=0, menu=pulldown)\n    def imageMenu(self):\n        photoFiles = ('ora-lp4e.gif', 'pythonPowered.gif', 'python_conf_ora.gif')\n        pulldown = Menu(self.menubar)\n        self.photoObjs = []\n        for file in photoFiles:\n            img = PhotoImage(file='../gifs/' + file)\n            pulldown.add_command(image=img, command=self.notdone)\n            self.photoObjs.append(img)   # keep a reference\n        self.menubar.add_cascade(label='Image', underline=0, menu=pulldown)\n    def greeting(self):\n        showinfo('greeting', 'Greetings')\n    def notdone(self):\n        showerror('Not implemented', 'Not yet available')\n    def quit(self):\n        if askyesno('Verify quit', 'Are you sure you want to quit?'):\n            Frame.quit(self)\nif __name__ == '__main__':  NewMenuDemo().mainloop()  # if I'm run as a script\nWhen run, this script generates the scene in Figure 9-10 at first. Figure 9-11 shows this\nwindow after being stretched a bit, with its Image menu torn off and its Edit menu\nselected. The toolbar at the bottom grows horizontally with the window but not ver-\ntically. For emphasis, this script also sets the cursor to change to a hand when moved\nover the toolbar at the bottom. Run this on your own to get a better feel for its behavior.\n518 | Chapter 9:\u2002A tkinter Tour, Part 2Figure 9-10. menuDemo: menus and toolbars\nFigure 9-11. Images and tear-offs on the job\nMenus | 519Using images in toolbars, too\nAs shown in Figure 9-11, it\u2019s easy to use images for menu items. Although not used in\nExample 9-8, toolbar items can be pictures too, just like the Image menu\u2019s items\u2014\nsimply associate small images with toolbar frame buttons, just as we did in the image\nbutton examples we wrote in the last part of Chapter 8. If you create toolbar images\nmanually ahead of time, it\u2019s simple to associate them with buttons as we\u2019ve learned. In\nfact, it\u2019s not much more work to build them dynamically\u2014the PIL-based thumbnail\nimage construction skills we developed in the prior chapter might come in handy in\nthis context as well.\nTo illustrate, make sure you\u2019ve installed the PIL extension, and replace the toolbar\nconstruction method of Example 9-8 with the following (I\u2019ve done this in file menu-\nDemo2.py in the examples distribution so you can run and experiment on your own):\n    # resize toolbar images on the fly with PIL\n    def makeToolBar(self, size=(40, 40)):\n        from PIL.ImageTk import PhotoImage, Image     # if jpegs or make new thumbs\n        imgdir = r'../PIL/images/'\n        toolbar = Frame(self, cursor='hand2', relief=SUNKEN, bd=2)\n        toolbar.pack(side=BOTTOM, fill=X)\n        photos = 'ora-lp4e-big.jpg', 'PythonPoweredAnim.gif', 'python_conf_ora.gif'\n        self.toolPhotoObjs = []\n        for file in photos:\n            imgobj = Image.open(imgdir + file)        # make new thumb\n            imgobj.thumbnail(size, Image.ANTIALIAS)   # best downsize filter\n            img = PhotoImage(imgobj)\n            btn = Button(toolbar, image=img, command=self.greeting)\n            btn.config(relief=RAISED, bd=2)\n            btn.config(width=size[0], height=size[1])\n            btn.pack(side=LEFT)\n            self.toolPhotoObjs.append((img, imgobj))  # keep a reference\n        Button(toolbar, text='Quit', command=self.quit).pack(side=RIGHT, fill=Y)\nWhen run, this alternative creates the window captured in Figure 9-12\u2014the three im-\nage options available in the Image menu at the top of the window are now also buttons\nin the toolbar at the bottom, along with a simple text button for quitting on the right.\nAs before, the cursor becomes a hand over the toolbar.\nYou don\u2019t need PIL at all if you\u2019re willing to use GIF or supported bitmap images that\nyou create by hand manually\u2014simply load by filename using the standard tkinter\nphoto object, as shown by the following alternative coding for the toolbar construction\nmethod (this is file menuDemo3.py in the examples distribution if you\u2019re keeping\nscope):\n    # use unresized gifs with standard tkinter\n    def makeToolBar(self, size=(30, 30)):\n        imgdir = r'../gifs/'\n        toolbar = Frame(self, cursor='hand2', relief=SUNKEN, bd=2)\n        toolbar.pack(side=BOTTOM, fill=X)\n520 | Chapter 9:\u2002A tkinter Tour, Part 2photos = 'ora-lp4e.gif', 'pythonPowered.gif', 'python_conf_ora.gif'\n        self.toolPhotoObjs = []\n        for file in photos:\n            img = PhotoImage(file=imgdir + file)\n            btn = Button(toolbar, image=img, command=self.greeting)\n            btn.config(bd=5, relief=RIDGE)\n            btn.config(width=size[0], height=size[1])\n            btn.pack(side=LEFT)\n            self.toolPhotoObjs.append(img)  # keep a reference\n        Button(toolbar, text='Quit', command=self.quit).pack(side=RIGHT, fill=Y)\nFigure 9-12. menuDemo2: images in the toolbar with PIL\nWhen run, this alternative uses GIF images, and renders the window grabbed in Fig-\nure 9-13. Depending on your user\u2019s preferences, you might want to resize the GIF\nimages used here for this role with other tools; we only get part of unresized photos in\nthe fixed-width buttons, which may or may not be enough.\nAs is, this is something of a first cut solution to toolbar image buttons. There are many\nways to configure such image buttons. Since we\u2019re going to see PIL in action again later\nin this chapter when we explore canvases, though, we\u2019ll leave further extensions in the\nsuggested exercise column.\nAutomating menu construction\nMenus are a powerful tkinter interface device. If you\u2019re like me, though, the examples\nin this section probably seem like a lot of work. Menu construction can be both code\nintensive and error prone if done by calling tkinter methods directly. A better approach\nmight automatically build and link up menus from a higher-level description of their\ncontents. In fact, in Chapter 10, we\u2019ll meet a tool called GuiMixin that automates the\nmenu construction process, given a data structure that contains all menus desired. As\nMenus | 521an added bonus, it supports both window and frame-style menus, so it can be used by\nboth standalone programs and nested components. Although it\u2019s important to know\nthe underlying calls used to make menus, you don\u2019t necessarily have to remember them\nfor long.\nListboxes and Scrollbars\nLet\u2019s rejoin our widget tour. Listbox widgets allow you to display a list of items for\nselection, and Scrollbars are designed for navigating through the contents of other\nwidgets. Because it is common to use these widgets together, we\u2019ll study them both at\nonce. Example 9-9 builds both a Listbox and a Scrollbar, as a packaged set.\nExample 9-9. PP4E\\Gui\\Tour\\scrolledlist.py\n\"a simple customizable scrolled listbox component\"\nfrom tkinter import *\nclass ScrolledList(Frame):\n    def __init__(self, options, parent=None):\n        Frame.__init__(self, parent)\n        self.pack(expand=YES, fill=BOTH)                   # make me expandable\n        self.makeWidgets(options)\n    def handleList(self, event):\n        index = self.listbox.curselection()                # on list double-click\n        label = self.listbox.get(index)                    # fetch selection text\n        self.runCommand(label)                             # and call action here\n                                                           # or get(ACTIVE)\n    def makeWidgets(self, options):\n        sbar = Scrollbar(self)\nFigure 9-13. menuDemo3: unresized GIF images in the toolbar\n522 | Chapter 9:\u2002A tkinter Tour, Part 2list = Listbox(self, relief=SUNKEN)\n        sbar.config(command=list.yview)                    # xlink sbar and list\n        list.config(yscrollcommand=sbar.set)               # move one moves other\n        sbar.pack(side=RIGHT, fill=Y)                      # pack first=clip last\n        list.pack(side=LEFT, expand=YES, fill=BOTH)        # list clipped first\n        pos = 0\n        for label in options:                              # add to listbox\n            list.insert(pos, label)                        # or insert(END,label)\n            pos += 1                                       # or enumerate(options)\n       #list.config(selectmode=SINGLE, setgrid=1)          # select,resize modes\n        list.bind('<Double-1>', self.handleList)           # set event handler\n        self.listbox = list\n    def runCommand(self, selection):                       # redefine me lower\n        print('You selected:', selection)\nif __name__ == '__main__':\n    options = (('Lumberjack-%s' % x) for  x in range(20))  # or map/lambda, [...]\n    ScrolledList(options).mainloop()\nThis module can be run standalone to experiment with these widgets, but it is also\ndesigned to be useful as a library object. By passing in different selection lists to the\noptions argument and redefining the runCommand method in a subclass, the Scrolled\nList component class defined here can be reused anytime you need to display a scrol-\nlable list. In fact, we\u2019ll be reusing it this way in Chapter 11\u2019s PyEdit program. With just\na little forethought, it\u2019s easy to extend the tkinter library with Python classes this way.\nWhen run standalone, this script generates the window in Figure 9-14, shown here\nwith Windows 7 look-and-feel. It\u2019s a Frame, with a Listbox on its left containing 20\ngenerated entries (the fifth has been clicked), along with an associated Scrollbar on its\nright for moving through the list. If you move the scroll, the list moves, and vice versa.\nFigure 9-14. scrolledlist at the top\nListboxes and Scrollbars | 523Programming Listboxes\nListboxes are straightforward to use, but they are populated and processed in somewhat\nunique ways compared to the widgets we\u2019ve seen so far. Many listbox calls accept a\npassed-in index to refer to an entry in the list. Indexes start at integer 0 and grow higher,\nbut tkinter also accepts special name strings in place of integer offsets: end to refer to\nthe end of the list, active to denote the line selected, and more. This generally yields\nmore than one way to code listbox calls.\nFor instance, this script adds items to the listbox in this window by calling its insert\nmethod, with successive offsets (starting at zero\u2014something the enumerate built-in\ncould automate for us):\nlist.insert(pos, label)\npos += 1\nBut you can also fill a list by simply adding items at the end without keeping a position\ncounter at all, with either of these statements:\nlist.insert('end', label)     # add at end: no need to count positions\nlist.insert(END, label)       # END is preset to 'end' inside tkinter\nThe listbox widget doesn\u2019t have anything like the command option we use to register\ncallback handlers for button presses, so you either need to fetch listbox selections while\nprocessing other widgets\u2019 events (e.g., a button press elsewhere in the GUI) or tap into\nother event protocols to process user selections. To fetch a selected value, this script\nbinds the <Double-1> left mouse button double-click event to a callback handler method\nwith bind (seen earlier on this tour).\nIn the double-click handler, this script grabs the selected item out of the listbox with\nthis pair of listbox method calls:\nindex = self.listbox.curselection()       # get selection index\nlabel = self.listbox.get(index)           # fetch text by its index\nHere, too, you can code this differently. Either of the following lines has the same effect;\nthey get the contents of the line at index 'active'\u2014the one selected:\nlabel = self.listbox.get('active')        # fetch from active index\nlabel = self.listbox.get(ACTIVE)          # ACTIVE='active' in tkinter\nFor illustration purposes, the class\u2019s default runCommand method prints the value selec-\nted each time you double-click an entry in the list\u2014as fetched by this script, it comes\nback as a string reflecting the text in the selected entry:\nC:\\...\\PP4E\\Gui\\Tour> python scrolledlist.py\nYou selected: Lumberjack-2\nYou selected: Lumberjack-19\nYou selected: Lumberjack-4\nYou selected: Lumberjack-12\nListboxes can also be useful input devices even without attached scroll bars; they accept\ncolor, font, and relief configuration options. They also support both single and multiple\n524 | Chapter 9:\u2002A tkinter Tour, Part 2selection modes. The default mode allows only a single item to be selected, but the\nselectmode argument supports four settings: SINGLE, BROWSE, MULTIPLE, and EXTENDED\n(the default is BROWSE). Of these, the first two are single selection modes, and the last\ntwo allow multiple items to be selected.\nThese modes vary in subtle ways. For instance, BROWSE is like SINGLE, but it also allows\nthe selection to be dragged. Clicking an item in MULTIPLE mode toggles its state without\naffecting other selected items. And the EXTENDED mode allows for multiple selections\nand works like the Windows file explorer GUI\u2014you select one item with a simple click,\nmultiple items with a Ctrl-click combination, and ranges of items with Shift-clicks.\nMultiple selections can be programmed with code of this sort:\nlistbox = Listbox(window, bg='white', font=('courier', fontsz))\nlistbox.config(selectmode=EXTENDED)\nlistbox.bind('<Double-1>', (lambda event: onDoubleClick()))\n# onDoubeClick: get messages selected in listbox\nselections = listbox.curselection()           # tuple of digit strs, 0..N-1\nselections = [int(x)+1 for x in selections]   # convert to ints, make 1..N\nWhen multiple selections are enabled, the curselection method returns a list of digit\nstrings giving the relative numbers of the items selected, or it returns an empty tuple if\nnone is selected. Really, this method always returns a tuple of digit strings, even in\nsingle selection mode (we don\u2019t care in Example 9-9, because the get method does the\nright thing for a one-item tuple, when fetching a value out of the listbox).\nYou can experiment with the selection alternatives on your own by uncommenting the\nselectmode setting in Example 9-9 and changing its value. You may get an error on\ndouble-clicks in multiple selection modes, though, because the get method will be\npassed a tuple of more than one selection index (print it out to see for yourself). We\u2019ll\nsee multiple selections in action in the PyMailGUI example later in this book (Chap-\nter 14), so I\u2019ll pass on further examples here.\nProgramming Scroll Bars\nPerhaps the deepest magic in the Example 9-9 script, though, boils down to two lines\nof code:\nsbar.config(command=list.yview)              # call list.yview when I move\nlist.config(yscrollcommand=sbar.set)         # call sbar.set when I move\nThe scroll bar and listbox are effectively cross-linked to each other through these con-\nfiguration options; their values simply refer to bound widget methods of the other. By\nlinking like this, tkinter automatically keeps the two widgets in sync with each other\nas they move. Here\u2019s how this works:\n\u2022 Moving a scroll bar invokes the callback handler registered with its command option.\nHere, list.yview refers to a built-in listbox method that adjusts the listbox display\nproportionally, based on arguments passed to the handler.\nListboxes and Scrollbars | 525\u2022 Moving a listbox vertically invokes the callback handler registered with its yscroll\ncommand option. In this script, the sbar.set built-in method adjusts a scroll bar\nproportionally.\nIn other words, moving one automatically moves the other. It turns out that every\nscrollable object in tkinter\u2014Listbox, Entry, Text, and Canvas\u2014has built-in yview and\nxview methods to process incoming vertical and horizontal scroll callbacks, as well as\nyscrollcommand and xscrollcommand options for specifying an associated scroll bar\u2019s\ncallback handler to invoke. All scroll bars have a command option, to name an associated\nwidget\u2019s handler to be called on moves. Internally, tkinter passes information to all of\nthese methods, and that information specifies their new position (e.g., \u201cgo 10 percent\ndown from the top\u201d), but your scripts usually need never deal with that level of detail.\nBecause the scroll bar and listbox have been cross-linked in their option settings, mov-\ning the scroll bar automatically moves the list, and moving the list automatically moves\nthe scroll bar. To move the scroll bar, either drag the solid part or click on its arrows\nor empty areas. To move the list, click on the list and either use your arrow keys or\nmove the mouse pointer above or below the listbox without releasing the mouse button.\nIn all cases, the list and scroll bar move in unison. Figure 9-15 shows the scene after\nexpanding the window and moving down a few entries in the list, one way or another.\nFigure 9-15. scrolledlist in the middle\nPacking Scroll Bars\nFinally, remember that widgets packed last are always clipped first when a window is\nshrunk. Because of that, it\u2019s important to pack scroll bars in a display as soon as possible\nso that they are the last to go when the window becomes too small for everything. You\ncan generally make do with less than complete listbox text, but the scroll bar is crucial\n526 | Chapter 9:\u2002A tkinter Tour, Part 2for navigating through the list. As Figure 9-16 shows, shrinking this script\u2019s window\ncuts out part of the list but retains the scroll bar.\nFigure 9-16. scrolledlist gets small\nAt the same time, you don\u2019t generally want a scroll bar to expand with a window, so\nbe sure to pack it with just a fill=Y (or fill=X for a horizontal scroll) and not an\nexpand=YES. Expanding this example\u2019s window in Figure 9-15, for instance, made the\nlistbox grow along with the window, but it kept the scroll bar attached to the right and\nkept it the same size.\nWe\u2019ll see both scroll bars and listboxes repeatedly in later examples in this and later\nchapters (flip ahead to examples for PyEdit, PyMailGUI, PyForm, PyTree, and ShellGui\nfor more). And although the example script in this section captures the fundamentals,\nI should point out that there is more to both scroll bars and listboxes than meets the\neye here.\nFor example, it\u2019s just as easy to add horizontal scroll bars to scrollable widgets. They\nare programmed almost exactly like the vertical one implemented here, but callback\nhandler names start with \u201cx,\u201d not \u201cy\u201d (e.g., \nxscrollcommand), and an\norient='horizontal' configuration option is set for the scroll bar object. To add both\nvertical and horizontal scrolls and to crosslink their motions, you would use the fol-\nlowing sort of code:\nwindow  = Frame(self)\nvscroll = Scrollbar(window)\nhscroll = Scrollbar(window, orient='horizontal')\nlistbox = Listbox(window)\n# move listbox when scroll moved\nvscroll.config(command=listbox.yview, relief=SUNKEN)\nhscroll.config(command=listbox.xview, relief=SUNKEN)\n# move scroll when listbox moved\nlistbox.config(yscrollcommand=vscroll.set, relief=SUNKEN)\nlistbox.config(xscrollcommand=hscroll.set)\nSee the image viewer canvas later in this chapter, as well as the PyEdit, PyTree, and\nPyMailGUI programs later in this book, for examples of horizontal scroll bars at work.\nScroll bars see more kinds of GUI action too\u2014they can be associated with other kinds\nof widgets in the tkinter library. For instance, it is common to attach one to the Text\nListboxes and Scrollbars | 527widget. Not entirely by coincidence, this brings us to the next point of interest on our\nwidget tour.\nText\nIt\u2019s been said that tkinter\u2019s strongest points may be its Text and Canvas widgets. Both\nprovide a remarkable amount of functionality. For instance, the tkinter Text widget\nwas powerful enough to implement the web pages of Grail, an experimental web\nbrowser coded in Python; Text supports complex font-style settings, embedded images,\nunlimited undo and redo, and much more. The tkinter Canvas widget, a general-purpose\ndrawing device, allows for efficient free-form graphics and has been the basis of so-\nphisticated image-processing and visualization applications.\nIn Chapter 11, we\u2019ll put these two widgets to use to implement text editors (PyEdit),\npaint programs (PyDraw), clock GUIs (PyClock), and image programs (PyPhoto and\nPyView). For the purposes of this tour chapter, though, let\u2019s start out using these\nwidgets in simpler ways. Example 9-10 implements a simple scrolled-text display,\nwhich knows how to fill its display with a text string or file.\nExample 9-10. PP4E\\Gui\\Tour\\scrolledtext.py\n\"a simple text or file viewer component\"\nprint('PP4E scrolledtext')\nfrom tkinter import *\nclass ScrolledText(Frame):\n    def __init__(self, parent=None, text='', file=None):\n        Frame.__init__(self, parent)\n        self.pack(expand=YES, fill=BOTH)                 # make me expandable\n        self.makewidgets()\n        self.settext(text, file)\n    def makewidgets(self):\n        sbar = Scrollbar(self)\n        text = Text(self, relief=SUNKEN)\n        sbar.config(command=text.yview)                  # xlink sbar and text\n        text.config(yscrollcommand=sbar.set)             # move one moves other\n        sbar.pack(side=RIGHT, fill=Y)                    # pack first=clip last\n        text.pack(side=LEFT, expand=YES, fill=BOTH)      # text clipped first\n        self.text = text\n    def settext(self, text='', file=None):\n        if file:\n            text = open(file, 'r').read()\n        self.text.delete('1.0', END)                     # delete current text\n        self.text.insert('1.0', text)                    # add at line 1, col 0\n        self.text.mark_set(INSERT, '1.0')                # set insert cursor\n        self.text.focus()                                # save user a click\n    def gettext(self):                                   # returns a string\n528 | Chapter 9:\u2002A tkinter Tour, Part 2return self.text.get('1.0', END+'-1c')           # first through last\nif __name__ == '__main__':\n    root = Tk()\n    if len(sys.argv) > 1:\n        st = ScrolledText(file=sys.argv[1])              # filename on cmdline\n    else:\n        st = ScrolledText(text='Words\\ngo here')         # or not: two lines\n    def show(event):\n        print(repr(st.gettext()))                        # show as raw string\n    root.bind('<Key-Escape>', show)                      # esc = dump text\n    root.mainloop()\nLike the ScrolledList in Example 9-9, the ScrolledText object in this file is designed\nto be a reusable component which we\u2019ll also put to work in later examples, but it can\nalso be run standalone to display text file contents. Also like the last section, this script\nis careful to pack the scroll bar first so that it is cut out of the display last as the window\nshrinks and arranges for the embedded Text object to expand in both directions as the\nwindow grows. When run with a filename argument, this script makes the window\nshown in Figure 9-17; it embeds a Text widget on the left and a cross-linked Scroll\nbar on the right.\nFigure 9-17. scrolledtext in action\nJust for fun, I populated the text file displayed in the window with the following code\nand command lines (and not just because I used to live near an infamous hotel in\nColorado):\nC:\\...\\PP4E\\Gui\\Tour> type makefile.py\nf = open('jack.txt', 'w')\nText | 529for i in range(250):\n    f.write('%03d)  All work and no play makes Jack a dull boy.\\n' % i)\nf.close()\nC:\\...\\PP4E\\Gui\\Tour> python makefile.py\nC:\\...\\PP4E\\Gui\\Tour> python scrolledtext.py jack.txt\nPP4E scrolledtext\nTo view a file, pass its name on the command line\u2014its text is automatically displayed\nin the new window. By default, it is shown in a font that may vary per platform (and\nmight not be fixed-width on some), but we\u2019ll pass a font option to the Text widget in\nthe next example to change that. Pressing the Escape key fetches and displays the full\ntext content of the widget as a single string (more on this in a moment).\nNotice the PP4E scrolledtext message printed when this script runs. Because there is\nalso a scrolledtext.py file in the standard Python distribution (in module\ntkinter.scrolledtext) with a very different implementation and interface, the one here\nidentifies itself when run or imported, so you can tell which one you\u2019ve got. If the\nstandard library\u2019s alternative ever goes away, import the class listed to get a simple text\nbrowser, and adjust any text widget configuration calls to include a .text qualifier level\n(e.g., x.text.config instead of x.config; the library version subclasses Text directly, \nnot Frame).\nProgramming the Text Widget\nTo understand how this script works at all, though, we have to detour into a few\nText widget details here. Earlier we met the Entry and Message widgets, which address\na subset of the Text widget\u2019s uses. The Text widget is much richer in both features and\ninterfaces\u2014it supports both input and display of multiple lines of text, editing opera-\ntions for both programs and interactive users, multiple fonts and colors, and much\nmore. Text objects are created, configured, and packed just like any other widget, but\nthey have properties all their own.\nText is a Python string\nAlthough the Text widget is a powerful tool, its interface seems to boil down to two\ncore concepts. First, the content of a Text widget is represented as a string in Python\nscripts, and multiple lines are separated with the normal \\n line terminator. The string\n'Words\\ngo here', for instance, represents two lines when stored in or fetched from a\nText widget; it would normally have a trailing \\n also, but it doesn\u2019t have to.\nTo help illustrate this point, this script binds the Escape key press to fetch and print\nthe entire contents of the Text widget it embeds:\nC:\\...\\PP4E\\Gui\\Tour> python scrolledtext.py\nPP4E scrolledtext\n'Words\\ngo here'\n'Always look\\non the bright\\nside of life\\n'\n530 | Chapter 9:\u2002A tkinter Tour, Part 2When run with arguments, the script stores a file\u2019s contents in the Text widget. When\nrun without arguments, the script stuffs a simple literal string into the widget, displayed\nby the first Escape press output here (recall that \\n is the escape sequence for the line-\nend character). The second output here happens after editing the window\u2019s text, when\npressing Escape in the shrunken window captured in Figure 9-18. By default, Text\nwidget text is fully editable using the usual edit operations for your platform.\nFigure 9-18. scrolledtext gets a positive outlook\nString positions\nThe second key to understanding Text code has to do with the ways you specify a\nposition in the text string. Like the listbox, Text widgets allow you to specify such a\nposition in a variety of ways. In Text, methods that expect a position to be passed in\nwill accept an index, a mark, or a tag reference. Moreover, some special operations are\ninvoked with predefined marks and tags\u2014the insert cursor is mark INSERT, and the\ncurrent selection is tag SEL. Since they are fundamental to Text and the source of much\nof its expressive power, let\u2019s take a closer look at these settings.\nBecause it is a multiple-line widget, Text indexes identify both a line and a\ncolumn. For instance, consider the interfaces of the basic insert, delete, and fetch text\noperations used by this script:\nself.text.insert('1.0', text)             # insert text at the start\nself.text.delete('1.0', END)              # delete all current text\nreturn self.text.get('1.0', END+'-1c')    # fetch first through last\nIn all of these, the first argument is an absolute index that refers to the start of the text\nstring: string '1.0' means row 1, column 0 (rows are numbered from 1 and columns\nfrom 0, though '0.0' is accepted as a reference to the start of the text, too). An index\n'2.1' refers to the second character in the second row.\nLike the listbox, text indexes can also be symbolic names: the END in the preceding\ndelete call refers to the position just past the last character in the text string (it\u2019s a\ntkinter variable preset to string 'end'). Similarly, the symbolic index INSERT (really,\nstring 'insert') refers to the position immediately after the insert cursor\u2014the place\nwhere characters would appear if typed at the keyboard. Symbolic names such as\nINSERT can also be called marks, described in a moment.\nText indexes.\nText | 531For added precision, you can add simple arithmetic extensions to index strings. The\nindex expression END+'-1c' in the get call in the previous example, for instance, is really\nthe string 'end-1c' and refers to one character back from END. Because END points to\njust beyond the last character in the text string, this expression refers to the last char-\nacter itself. The \u22121c extension effectively strips the trailing \\n that this widget adds to\nits contents (and which may add a blank line if saved in a file).\nSimilar index string extensions let you name characters ahead (+1c), name lines ahead\nand behind (+2l, \u22122l), and specify things such as line ends and word starts around an\nindex (lineend, wordstart). Indexes show up in most Text widget calls.\nBesides row/column identifier strings, you can also pass positions as names\nof marks\u2014symbolic names for a position between two characters. Unlike absolute row/\ncolumn positions, marks are virtual locations that move as new text is inserted or de-\nleted (by your script or your user). A mark always refers to its original location, even if\nthat location shifts to a different row and column over time.\nTo create a mark, call the Text object\u2019s mark_set method with a string name and an\nindex to give its logical location. For instance, this script sets the insert cursor at the\nstart of the text initially, with a call like the first one here:\nself.text.mark_set(INSERT, '1.0')             # set insert cursor to start\nself.text.mark_set('linetwo', '2.0')          # mark current line 2\nThe name INSERT is a predefined special mark that identifies the insert cursor position;\nsetting it changes the insert cursor\u2019s location. To make a mark of your own, simply\nprovide a unique name as in the second call here and use it anywhere you need to specify\na text position. The mark_unset call deletes marks by name.\nIn addition to absolute indexes and symbolic mark names, the Text widget\nsupports the notion of tags\u2014symbolic names associated with one or more substrings\nwithin the Text widget\u2019s string. Tags can be used for many things, but they also serve\nto represent a position anywhere you need one: tagged items are named by their be-\nginning and ending indexes, which can be later passed to position-based calls.\nFor example, tkinter provides a built-in tag name, SEL\u2014a tkinter name preassigned to\nstring 'sel'\u2014which automatically refers to currently selected text. To fetch the text\nselected (highlighted) with a mouse, run either of these calls:\ntext = self.text.get(SEL_FIRST, SEL_LAST)      # use tags for from/to indexes\ntext = self.text.get('sel.first', 'sel.last')  # strings and constants work\nThe names SEL_FIRST and SEL_LAST are just preassigned variables in the tkinter module\nthat refer to the strings used in the second line here. The text get method expects two\nindexes; to fetch text names by a tag, add .first and .last to the tag\u2019s name to get its\nstart and end indexes.\nTo tag a substring, call the Text widget\u2019s tag_add method with a tag name string and\nstart and stop positions (text can also be tagged as added in insert calls). To remove\na tag from all characters in a range of text, call tag_remove:\nText marks.\nText tags.\n532 | Chapter 9:\u2002A tkinter Tour, Part 2self.text.tag_add('alltext', '1.0', END)  # tag all text in the widget\nself.text.tag_add(SEL, index1, index2)    # select from index1 up to index2\nself.text.tag_remove(SEL, '1.0', END)     # remove selection from all text\nThe first line here creates a new tag that names all text in the widget\u2014from start through\nend positions. The second line adds a range of characters to the built-in SEL selection\ntag\u2014they are automatically highlighted, because this tag is predefined to configure its\nmembers that way. The third line removes all characters in the text string from the\nSEL tag (all selections are unselected). Note that the tag_remove call just untags text\nwithin the named range; to really delete a tag completely, call tag_delete instead. Also\nkeep in mind that these calls apply to tags themselves; to delete actual text use the\ndelete method shown earlier.\nYou can map indexes to tags dynamically, too. For example, the text search method\nreturns the row.column index of the first occurrence of a string between start and stop\npositions. To automatically select the text thus found, simply add its index to the built-\nin SEL tag:\nwhere = self.text.search(target, INSERT, END)  # search from insert cursor\npastit = where + ('+%dc' % len(target))        # index beyond string found\nself.text.tag_add(SEL, where, pastit)          # tag and select found string\nself.text.focus()                              # select text widget itself\nIf you want only one string to be selected, be sure to first run the tag_remove call listed\nearlier\u2014this code adds a selection in addition to any selections that already exist (it\nmay generate multiple selections in the display). In general, you can add any number\nof substrings to a tag to process them as a group.\nTo summarize: indexes, marks, and tag locations can be used anytime you need a text\nposition. For instance, the text see method scrolls the display to make a position visible;\nit accepts all three kinds of position specifiers:\nself.text.see('1.0')          # scroll display to top\nself.text.see(INSERT)         # scroll display to insert cursor mark\nself.text.see(SEL_FIRST)      # scroll display to selection tag\nText tags can also be used in broader ways for formatting and event bindings, but I\u2019ll\ndefer those details until the end of this section.\nAdding Text-Editing Operations\nExample 9-11 puts some of these concepts to work. It extends Example 9-10 to add\nsupport for four common text-editing operations\u2014file save, text cut and paste, and\nstring find searching\u2014by subclassing ScrolledText to provide additional buttons and\nmethods. The Text widget comes with a set of default keyboard bindings that perform\nsome common editing operations, too, but they might not be what is expected on every\nplatform; it\u2019s more common and user friendly to provide GUI interfaces to editing\noperations in a GUI text editor.\nText | 533Example 9-11. PP4E\\Gui\\Tour\\simpleedit.py\n\"\"\"\nadd common edit tools to ScrolledText by inheritance;\ncomposition (embedding) would work just as well here;\nthis is not robust!--see PyEdit for a feature superset;\n\"\"\"\nfrom tkinter import *\nfrom tkinter.simpledialog import askstring\nfrom tkinter.filedialog   import asksaveasfilename\nfrom quitter      import Quitter\nfrom scrolledtext import ScrolledText                     # here, not Python's\nclass SimpleEditor(ScrolledText):                         # see PyEdit for more\n    def __init__(self, parent=None, file=None):\n        frm = Frame(parent)\n        frm.pack(fill=X)\n        Button(frm, text='Save',  command=self.onSave).pack(side=LEFT)\n        Button(frm, text='Cut',   command=self.onCut).pack(side=LEFT)\n        Button(frm, text='Paste', command=self.onPaste).pack(side=LEFT)\n        Button(frm, text='Find',  command=self.onFind).pack(side=LEFT)\n        Quitter(frm).pack(side=LEFT)\n        ScrolledText.__init__(self, parent, file=file)\n        self.text.config(font=('courier', 9, 'normal'))\n    def onSave(self):\n        filename = asksaveasfilename()\n        if filename:\n            alltext = self.gettext()                      # first through last\n            open(filename, 'w').write(alltext)            # store text in file\n    def onCut(self):\n        text = self.text.get(SEL_FIRST, SEL_LAST)         # error if no select\n        self.text.delete(SEL_FIRST, SEL_LAST)             # should wrap in try\n        self.clipboard_clear()\n        self.clipboard_append(text)\n    def onPaste(self):                                    # add clipboard text\n        try:\n            text = self.selection_get(selection='CLIPBOARD')\n            self.text.insert(INSERT, text)\n        except TclError:\n            pass                                          # not to be pasted\n    def onFind(self):\n        target = askstring('SimpleEditor', 'Search String?')\n        if target:\n            where = self.text.search(target, INSERT, END)  # from insert cursor\n            if where:                                      # returns an index\n                print(where)\n                pastit = where + ('+%dc' % len(target))    # index past target\n               #self.text.tag_remove(SEL, '1.0', END)      # remove selection\n                self.text.tag_add(SEL, where, pastit)      # select found target\n                self.text.mark_set(INSERT, pastit)         # set insert mark\n                self.text.see(INSERT)                      # scroll display\n534 | Chapter 9:\u2002A tkinter Tour, Part 2self.text.focus()                          # select text widget\nif __name__ == '__main__':\n    if len(sys.argv) > 1:\n        SimpleEditor(file=sys.argv[1]).mainloop()    # filename on command line\n    else:\n        SimpleEditor().mainloop()                    # or not: start empty\nThis, too, was written with one eye toward reuse\u2014the SimpleEditor class it defines\ncould be attached or subclassed by other GUI code. As I\u2019ll explain at the end of this\nsection, though, it\u2019s not yet as robust as a general-purpose library tool should be. Still,\nit implements a functional text editor in a small amount of portable code. When run\nstandalone, it brings up the window in Figure 9-19 (shown editing itself and running\non Windows); index positions are printed on stdout after each successful find\noperation\u2014here, for two \u201cdef\u201d finds, with prior selection removal logic commented-\nout in the script (uncomment this line in the script to get single-selection behavior for\nfinds):\nC:\\...\\PP4E\\Gui\\Tour> python simpleedit.py simpleedit.py\nPP4E scrolledtext\n14.4\n25.4\nFigure 9-19. simpleedit in action\nThe save operation pops up the common save dialog that is available in tkinter and is\ntailored to look native on each platform. Figure 9-20 shows this dialog in action on\nWindows 7. Find operations also pop up a standard dialog box to input a search string\nText | 535(Figure 9-21); in a full-blown editor, you might want to save this string away to repeat\nthe find again (we will, in Chapter 11\u2019s more full-featured PyEdit example). Quit op-\nerations reuse the verifying Quit button component we coded in Chapter 8 yet again;\ncode reuse means never having to say you\u2019re quitting without warning\u2026\nFigure 9-20. Save pop-up dialog on Windows\nFigure 9-21. Find pop-up dialog\nUsing the clipboard\nBesides Text widget operations, Example 9-11 applies the tkinter clipboard interfaces\nin its cut-and-paste functions. Together, these operations allow you to move text within\na file (cut in one place, paste in another). The clipboard they use is just a place to store\ndata temporarily\u2014deleted text is placed on the clipboard on a cut, and text is inserted\nfrom the clipboard on a paste. If we restrict our focus to this program alone, there really\n536 | Chapter 9:\u2002A tkinter Tour, Part 2is no reason that the text string cut couldn\u2019t simply be stored in a Python instance\nvariable. But the clipboard is actually a much larger concept.\nThe clipboard used by this script is an interface to a system-wide storage space, shared\nby all programs on your computer. Because of that, it can be used to transfer data\nbetween applications, even ones that know nothing of tkinter. For instance, text cut or\ncopied in a Microsoft Word session can be pasted in a SimpleEditor window, and text\ncut in SimpleEditor can be pasted in a Microsoft Notepad window (try it). By using the\nclipboard for cut and paste, SimpleEditor automatically integrates with the window\nsystem at large. Moreover, the clipboard is not just for the Text widget\u2014it can also be\nused to cut and paste graphical objects in the Canvas widget (discussed next).\nAs used in the script of Example 9-11, the basic tkinter clipboard interface looks like\nthis:\nself.clipboard_clear()                            # clear the clipboard\nself.clipboard_append(text)                       # store a text string on it\ntext = self.selection_get(selection='CLIPBOARD')  # fetch contents, if any\nAll of these calls are available as methods inherited by all tkinter widget objects because\nthey are global in nature. The CLIPBOARD selection used by this script is available on all\nplatforms (a PRIMARY selection is also available, but it is only generally useful on X\nWindows, so we\u2019ll ignore it here). Notice that the clipboard selection_get call throws\na TclError exception if it fails; this script simply ignores it and abandons a paste request,\nbut we\u2019ll do better later.\nComposition versus inheritance\nAs coded, SimpleEditor uses inheritance to extend ScrolledText with extra buttons and\ncallback methods. As we\u2019ve seen, it\u2019s also reasonable to attach (embed) GUI objects\ncoded as components, such as ScrolledText. The attachment model is usually called\ncomposition; some people find it simpler to understand and less prone to name clashes\nthan extension by inheritance.\nTo give you an idea of the differences between these two approaches, the following\nsketches the sort of code you would write to attach ScrolledText to SimpleEditor with\nchanged lines in bold font (see the file simpleedit2.py in the book\u2019s examples distribu-\ntion for a complete composition implementation). It\u2019s mostly a matter of passing in the\nright parents and adding an extra st attribute name anytime you need to get to the\nText widget\u2019s methods:\nclass SimpleEditor(Frame):\n    def __init__(self, parent=None, file=None):\n        Frame.__init__(self, parent)\n        self.pack()\n        frm = Frame(self)\n        frm.pack(fill=X)\n        Button(frm, text='Save',  command=self.onSave).pack(side=LEFT)\n        ...more...\nText | 537Quitter(frm).pack(side=LEFT)\n        self.st = ScrolledText(self, file=file)           # attach, not subclass\n        self.st.text.config(font=('courier', 9, 'normal'))\n    def onSave(self):\n        filename = asksaveasfilename()\n        if filename:\n            alltext = self.st.gettext()                   # go through attribute\n            open(filename, 'w').write(alltext)\n    def onCut(self):\n        text = self.st.text.get(SEL_FIRST, SEL_LAST)\n        self.st.text.delete(SEL_FIRST, SEL_LAST)\n        ...more...\nThis code doesn\u2019t need to subclass Frame necessarily (it could add widgets to the passed-\nin parent directly), but being a frame allows the full package here to be embedded and\nconfigured as well. The window looks identical when such code is run. I\u2019ll let you be\nthe judge of whether composition or inheritance is better here. If you code your Python\nGUI classes right, they will work under either regime.\nIt\u2019s called \u201cSimple\u201d for a reason: PyEdit (ahead)\nFinally, before you change your system registry to make SimpleEditor your default text\nfile viewer, I should mention that although it shows the basics, it\u2019s something of a\nstripped-down version (really, a prototype) of the PyEdit example we\u2019ll meet in Chap-\nter 11. In fact, you may wish to study that example now if you\u2019re looking for more\ncomplete tkinter text-processing code in general. There, we\u2019ll also use more advanced\ntext operations, such as the undo/redo interface, case-insensitive searches, external files\nsearch, and more. Because the Text widget is so powerful, it\u2019s difficult to demonstrate\nmore of its features without the volume of code that is already listed in the PyEdit\nprogram.\nI should also point out that SimpleEditor not only is limited in function, but also is just\nplain careless\u2014many boundary cases go unchecked and trigger uncaught exceptions\nthat don\u2019t kill the GUI, but are not handled or reported well. Even errors that are caught\nare not reported to the user (e.g., a paste with nothing to be pasted). Be sure to see the\nPyEdit example for a more robust and complete implementation of the operations \nintroduced in SimpleEditor.\nUnicode and the Text Widget\nI told you earlier that text content in the Text widget is always a string. Technically,\nthough, there are two string types in Python 3.X: str for Unicode text, and bytes for\nbyte strings. Moreover, text can be represented in a variety of Unicode encodings when\nstored on files. It turns out that both these factors can impact programs that wish to\nuse Text well in Python 3.X.\n538 | Chapter 9:\u2002A tkinter Tour, Part 2In short, tkinter\u2019s Text and other text-related widgets such as Entry support display of\nInternational character sets for both str and bytes, but we must pass decoded Unicode\nstr to support the broadest range of character types. In this section, we decompose the\ntext story in tkinter in general to show why.\nString types in the Text widget\nYou may or may not have noticed, but all our examples so far have been representing\ncontent as str strings\u2014either hardcoded in scripts, or fetched and saved using simple\ntext-mode files which assume the platform default encoding. Technically, though, the\nText widget allows us to insert both str and bytes:\n>>> from tkinter import Text\n>>> T = Text()\n>>> T.insert('1.0', 'spam')          # insert a str\n>>> T.insert('end', b'eggs')         # insert a bytes\n>>> T.pack()                         # \"spameggs\" appears in text widget now\n>>> T.get('1.0', 'end')              # fetch content\n'spameggs\\n'\nInserting text as bytes might be useful for viewing arbitrary kinds of Unicode text,\nespecially if the encoding name is unknown. For example, text fetched over the Internet\n(e.g., attached to an email or fetched by FTP) could be in any Unicode encoding; storing\nit in binary-mode files and displaying it as bytes in a Text widget may at least seem to\nside-step the encoding in our scripts.\nUnfortunately, though, the Text widget returns its content as str strings, regardless of\nwhether it was inserted as str or bytes\u2014we get back already-decoded Unicode text\nstrings either way:\n>>> T = Text()\n>>> T.insert('1.0', 'Textfileline1\\n')\n>>> T.insert('end', 'Textfileline2\\n')            # content is str for str\n>>> T.get('1.0', 'end')                           # pack() is irrelevent to get()\n'Textfileline1\\nTextfileline2\\n\\n'\n>>> T = Text()\n>>> T.insert('1.0', b'Bytesfileline1\\r\\n')        # content is str for bytes too!\n>>> T.insert('end', b'Bytesfileline2\\r\\n')        # and \\r displays as a space\n>>> T.get('1.0', 'end')\n'Bytesfileline1\\r\\nBytesfileline2\\r\\n\\n'\nIn fact, we get back str for content even if we insert both str and bytes, with a single\n\\n added at the end for good measure, as the first example in this section shows; here\u2019s\na more comprehensive illustration:\n>>> T = Text()\n>>> T.insert('1.0', 'Textfileline1\\n')\n>>> T.insert('end', 'Textfileline2\\n')            # content is str for both\n>>> T.insert('1.0', b'Bytesfileline1\\r\\n')        # one \\n added for either type\n>>> T.insert('end', b'Bytesfileline2\\r\\n')        # pack() displays as 4 lines\n>>> T.get('1.0', 'end')\n'Bytesfileline1\\r\\nTextfileline1\\nTextfileline2\\nBytesfileline2\\r\\n\\n'\nText | 539>>>\n>>> print(T.get('1.0', 'end'))\nBytesfileline1\nTextfileline1\nTextfileline2\nBytesfileline2\nThis makes it easy to perform text processing on content after it is fetched: we may\nconduct it in terms of str, regardless of which type of string was inserted. However,\nthis also makes it difficult to treat text data generically from a Unicode perspective: we\ncannot save the returned str content to a binary mode file as is, because binary mode\nfiles expect bytes. We must either encode to bytes manually first or open the file in text\nmode and rely on it to encode the str. In either case we must know the Unicode en-\ncoding name to apply, assume the platform default suffices, fall back on guesses and\nhope one works, or ask the user.\nIn other words, although tkinter allows us to insert and view some text of unknown\nencoding as bytes, the fact that it\u2019s returned as str strings means we generally need to\nknow how to encode it anyhow on saves, to satisfy Python 3.X file interfaces. Moreover,\nbecause bytes inserted into Text widgets must also be decodable according to the limi-\nted Unicode policies of the underlying Tk library, we\u2019re generally better off decoding\ntext to str ourselves if we wish to support Unicode broadly. To truly understand why\nthat\u2019s true, we need to take a brief excursion through the Land of Unicode.\nUnicode text in strings\nThe reason for all this extra complexity, of course, is that in a world with Unicode, we\ncannot really think of \u201ctext\u201d anymore without also asking \u201cwhich kind.\u201d Text in general\ncan be encoded in a wide variety of Unicode encoding schemes. In Python, this is always\na factor for str and pertains to bytes when it contains encoded text. Python\u2019s str Uni-\ncode strings are simply strings once they are created, but you have to take encodings\ninto consideration when transferring them to and from files and when passing them to\nlibraries that impose constraints on text encodings.\nWe won\u2019t cover Unicode encodings it in depth here (see Learning Python for back-\nground details, as well as the brief look at implications for files in Chapter 4), but a\nquick review is in order to illustrate how this relates to Text widgets. First of all, keep\nin mind that ASCII text data normally just works in most contexts, because it is a subset\nof most Unicode encoding schemes. Data outside the ASCII 7-bit range, though, may\nbe represented differently as bytes in different encoding schemes.\nFor instance, the following must decode a Latin-1 bytes string using the Latin-1 en-\ncoding\u2014using the platform default or an explicitly named encoding that doesn\u2019t match\nthe bytes will fail:\n>>> b = b'A\\xc4B\\xe4C'              # these bytes are latin-1 format text\n>>> b\nb'A\\xc4B\\xe4C'\n540 | Chapter 9:\u2002A tkinter Tour, Part 2>>> s = b.decode('utf8')\nUnicodeDecodeError: 'utf8' codec can't decode bytes in position 1-2: invalid dat...\n>>> s = b.decode()\nUnicodeDecodeError: 'utf8' codec can't decode bytes in position 1-2: invalid dat...\n>>> s = b.decode('latin1')\n>>> s\n'A\u00c4B\u00e4C'\nOnce you\u2019ve decoded to a Unicode string, you can \u201cconvert\u201d it to a variety of different\nencoding schemes. Really, this simply translates to alternative binary encoding formats,\nfrom which we can decode again later; a Unicode string has no Unicode type per se,\nonly encoded binary data does:\n>>> s.encode('latin-1')\nb'A\\xc4B\\xe4C'\n>>> s.encode('utf-8')\nb'A\\xc3\\x84B\\xc3\\xa4C'\n>>> s.encode('utf-16')\nb'\\xff\\xfeA\\x00\\xc4\\x00B\\x00\\xe4\\x00C\\x00'\n>>> s.encode('ascii')\nUnicodeEncodeError: 'ascii' codec can't encode character '\\xc4' in position 1: o...\nNotice the last test here: the string you encode to must be compatible with the scheme\nyou choose, or you\u2019ll get an exception; here, ASCII is too narrow to represent characters\ndecoded from Latin-1 bytes. Even though you can convert to different (compatible)\nrepresentations\u2019 bytes, you must generally know what the encoded format is in order\nto decode back to a string:\n>>> s.encode('utf-16').decode('utf-16')\n'A\u00c4B\u00e4C'\n>>> s.encode('latin-1').decode('latin-1')\n'A\u00c4B\u00e4C'\n>>> s.encode('latin-1').decode('utf-8')\nUnicodeDecodeError: 'utf8' codec can't decode bytes in position 1-2: invalid dat...\n>>> s.encode('utf-8').decode('latin-1')\nUnicodeEncodeError: 'charmap' codec can't encode character '\\xc3' in position 2:...\nNote the last test here again. Technically, encoding Unicode code points (characters)\nto UTF-8 bytes and then decoding back again per the Latin-1 format does not raise an\nerror, but trying to print the result does: it\u2019s scrambled garbage. To maintain fidelity,\nyou must generally know what format encoded bytes are in:\n>>> s\n'A\u00c4B\u00e4C'\n>>> x = s.encode('utf-8').decode('utf-8')        # OK if encoding matches data\n>>> x\n'A\u00c4B\u00e4C'\n>>> x = s.encode('latin-1').decode('latin-1')    # any compatible encoding works\nText | 541>>> x\n'A\u00c4B\u00e4C'\n>>> x = s.encode('utf-8').decode('latin-1')      # decoding works, result is garbage\n>>> x\nUnicodeEncodeError: 'charmap' codec can't encode character '\\xc3' in position 2:...\n>>> len(s), len(x)                               # no longer the same string\n(5, 7)\n>>> s.encode('utf-8')                            # no longer same code points\nb'A\\xc3\\x84B\\xc3\\xa4C'\n>>> x.encode('utf-8')\nb'A\\xc3\\x83\\xc2\\x84B\\xc3\\x83\\xc2\\xa4C'\n>>> s.encode('latin-1')\nb'A\\xc4B\\xe4C'\n>>> x.encode('latin-1')\nb'A\\xc3\\x84B\\xc3\\xa4C'\nCuriously, the original string may still be there after a mismatch like this\u2014if we encode\nthe scrambled bytes back to Latin-1 again (as 8-bit characters) and then decode prop-\nerly, we might restore the original (in some contexts this can constitute a sort of second\nchance if data is decoded wrong initially):\n>>> s\n'A\u00c4B\u00e4C'\n>>> s.encode('utf-8').decode('latin-1')\nUnicodeEncodeError: 'charmap' codec can't encode character '\\xc3' in position 2:...\n>>> s.encode('utf-8').decode('latin-1').encode('latin-1')\nb'A\\xc3\\x84B\\xc3\\xa4C'\n>>> s.encode('utf-8').decode('latin-1').encode('latin-1').decode('utf-8')\n'A\u00c4B\u00e4C'\n>>> s.encode('utf-8').decode('latin-1').encode('latin-1').decode('utf-8') == s\nTrue\nOn the other hand, we can use a different encoding name to decode, as long as it\u2019s\ncompatible with the format of the data; ASCII, UTF-8, and Latin-1, for instance, all\nformat ASCII text the same way:\n>>> 'spam'.encode('utf8').decode('latin1')\n'spam'\n>>> 'spam'.encode('latin1').decode('ascii')\n'spam'\nIt\u2019s important to remember that a string\u2019s decoded value doesn\u2019t depend on the en-\ncoding it came from\u2014once decoded, a string has no notion of encoding and is simply\na sequence of Unicode characters (\u201ccode points\u201d). Hence, we really only need to care\nabout encodings at the point of transfer to and from files:\n>>> s\n'A\u00c4B\u00e4C'\n>>> s.encode('utf-16').decode('utf-16') == s.encode('latin-1').decode('latin-1')\nTrue\n542 | Chapter 9:\u2002A tkinter Tour, Part 2Unicode text in files\nNow, the same rules apply to text files, because Unicode strings are stored in files as\nencoded bytes. When writing, we can encode in any format that accommodates the\nstring\u2019s characters. When reading, though, we generally must know what that encoding\nis or provide one that formats characters the same way:\n>>> open('ldata', 'w', encoding='latin-1').write(s)   # store in latin-1 format\n5\n>>> open('udata', 'w', encoding='utf-8').write(s)     # store in utf-8 format\n5\n>>> open('ldata', 'r', encoding='latin-1').read()     # OK if correct name given\n'A\u00c4B\u00e4C'\n>>> open('udata', 'r', encoding='utf-8').read()\n'A\u00c4B\u00e4C'\n>>> open('ldata', 'r').read()                         # else, may not work\n'A\u00c4B\u00e4C'\n>>> open('udata', 'r').read()\nUnicodeEncodeError: 'charmap' codec can't encode characters in position 2-3: cha...\n>>> open('ldata', 'r', encoding='utf-8').read()\nUnicodeDecodeError: 'utf8' codec can't decode bytes in position 1-2: invalid dat...\n>>> open('udata', 'r', encoding='latin-1').read()\nUnicodeEncodeError: 'charmap' codec can't encode character '\\xc3' in position 2:...\nBy contrast, binary mode files don\u2019t attempt to decode into a Unicode string; they\nhappily read whatever is present, whether the data was written to the file in text mode\nwith automatically encoded str strings (as in the preceding interaction) or in binary\nmode with manually encoded bytes strings:\n>>> open('ldata', 'rb').read()\nb'A\\xc4B\\xe4C'\n>>> open('udata', 'rb').read()\nb'A\\xc3\\x84B\\xc3\\xa4C'\n>>> open('sdata', 'wb').write( s.encode('utf-16') )   # return value: 12\n>>> open('sdata', 'rb').read()\nb'\\xff\\xfeA\\x00\\xc4\\x00B\\x00\\xe4\\x00C\\x00'\nUnicode and the Text widget\nThe application of all this to tkinter Text displays is straightforward: if we open in binary\nmode to read bytes, we don\u2019t need to be concerned about encodings in our own code\u2014\ntkinter interprets the data as expected, at least for these two encodings:\n>>> from tkinter import Text\n>>> t = Text()\n>>> t.insert('1.0', open('ldata', 'rb').read())\n>>> t.pack()                                          # string appears in GUI OK\n>>> t.get('1.0', 'end')\n'A\u00c4B\u00e4C\\n'\n>>>\nText | 543>>> t = Text()\n>>> t.insert('1.0', open('udata', 'rb').read())\n>>> t.pack()                                          # string appears in GUI OK\n>>> t.get('1.0', 'end')\n'A\u00c4B\u00e4C\\n'\nIt works the same if we pass a str fetched in text mode, but we then need to know the\nencoding type on the Python side of the fence\u2014reads will fail if the encoding type\ndoesn\u2019t match the stored data:\n>>> t = Text()\n>>> t.insert('1.0', open('ldata', 'r', encoding='latin-1').read())\n>>> t.pack()\n>>> t.get('1.0', 'end')\n'A\u00c4B\u00e4C\\n'\n>>>\n>>> t = Text()\n>>> t.insert('1.0', open('udata', 'r', encoding='utf-8').read())\n>>> t.pack()\n>>> t.get('1.0', 'end')\n'A\u00c4B\u00e4C\\n'\nEither way, though, the fetched content is always a Unicode str, so binary mode really\nonly addresses loads: we still need to know an encoding to store, whether we write in\ntext mode directly or write in binary mode after manual encoding:\n>>> c = t.get('1.0', 'end')\n>>> c                                                   # content is str\n'A\u00c4B\u00e4C\\n'\n>>> open('cdata', 'wb').write(c)                        # binary mode needs bytes\nTypeError: must be bytes or buffer, not str\n>>> open('cdata', 'w', encoding='latin-1').write(c)     # each write returns 6\n>>> open('cdata', 'rb').read()\nb'A\\xc4B\\xe4C\\r\\n'\n>>> open('cdata', 'w', encoding='utf-8').write(c)       # different bytes on files\n>>> open('cdata', 'rb').read()\nb'A\\xc3\\x84B\\xc3\\xa4C\\r\\n'\n>>> open('cdata', 'w', encoding='utf-16').write(c)\n>>> open('cdata', 'rb').read()\nb'\\xff\\xfeA\\x00\\xc4\\x00B\\x00\\xe4\\x00C\\x00\\r\\x00\\n\\x00'\n>>> open('cdata', 'wb').write( c.encode('latin-1') )    # manual encoding first\n>>> open('cdata', 'rb').read()                          # same but no \\r on Win\nb'A\\xc4B\\xe4C\\n'\n>>> open('cdata', 'w', encoding='ascii').write(c)       # still must be compatible\nUnicodeEncodeError: 'ascii' codec can't encode character '\\xc4' in position 1: o\nNotice the last test here: like manual encoding, file writes can still fail if the data cannot\nbe encoded in the target scheme. Because of that, programs may need to recover from\n544 | Chapter 9:\u2002A tkinter Tour, Part 2exceptions or try alternative schemes; this is especially true on platforms where ASCII\nmay be the default platform encoding.\nThe problem with treating text as bytes\nThe prior sections\u2019 rules may seem complex, but they boil down to the following:\n\u2022 Unless strings always use the platform default, we need to know encoding types\nto read or write in text mode and to manually decode or encode for binary mode.\n\u2022 We can use almost any encoding to write new files as long as it can handle the\nstring\u2019s characters, but must provide one that is compatible with the existing data\u2019s\nbinary format on reads.\n\u2022 We don\u2019t need to know the encoding mode to read text as bytes in binary mode\nfor display, but the str content returned by the Text widget still requires us to\nencode to write on saves.\nSo why not always load text files in binary mode to display them in a tkinter Text widget?\nWhile binary mode input files seem to side-step encoding issues for display, passing\ntext to tkinter as bytes instead of str really just delegates the encoding issue to the Tk\nlibrary, which imposes constraints of its own.\nMore specifically, opening input files in binary mode to read bytes may seem to support\nviewing arbitrary types of text, but it has two potential downsides:\n\u2022 It shifts the burden of deciding encoding type from our script to the Tk GUI library.\nThe library must still determine how to render those bytes and may not support\nall encodings possible.\n\u2022 It allows opening and viewing data that is not text in nature, thereby defeating\nsome of the purpose of the validity checks performed by text decoding.\nThe first point is probably the most crucial here. In experiments I\u2019ve run on Windows,\nTk seems to correctly handle raw bytes strings encoded in ASCII, UTF-8 and Latin-1\nformat, but not UTF-16 or others such as CP500. By contrast, these all render correctly\nif decoded in Python to str before being passed on to Tk. In programs intended for the\nworld at large, this wider support is crucial today. If you\u2019re able to know or ask for\nencodings, you\u2019re better off using str both for display and saves.\nTo some degree, regardless of whether you pass in str or bytes, tkinter GUIs are subject\nto the constraints imposed by the underlying Tk library and the Tcl language it uses\ninternally, as well as any imposed by the techniques Python\u2019s tkinter uses to interface\nwith Tk. For example:\n\u2022 Tcl, the internal implementation language of the Tk library, stores strings internally\nin UTF-8 format, and decrees that strings passed in to and returned from its C API\nbe in this format.\nText | 545\u2022 Tcl attempts to convert byte strings to its internal UTF-8 format, and generally\nsupports translation using the platform and locale encodings in the local operating\nsystem with Latin-1 as a fallback.\n\u2022 Python\u2019s tkinter passes bytes strings to Tcl directly, but copies Python str Unicode\nstrings to and from Tcl Unicode string objects.\n\u2022 Tk inherits all of Tcl\u2019s Unicode policies, but adds additional font selection policies\nfor display.\nIn other words, GUIs that display text in tkinter are somewhat at the mercy of multiple\nlayers of software, above and beyond the Python language itself. In general, though,\nUnicode is broadly supported by Tk\u2019s Text widget for Python str, but not for Python\nbytes. As you can probably tell, though, this story quickly becomes very low-level and\ndetailed, so we won\u2019t explore it further in this book; see the Web and other resources\nfor more on tkinter, Tk, and Tcl, and the interfaces between them.\nOther binary mode considerations\nEven in contexts where it\u2019s sufficient, using binary mode files to finesse encodings for\ndisplay is more complicated than you might think. We always need to be careful to\nwrite output in binary mode, too, so what we read is what we later write\u2014if we read\nin binary mode, content end-lines will be \\r\\n on Windows, and we don\u2019t want text-\nmode files to expand this to \\r\\r\\n. Moreover, there\u2019s another difference in tkinter for\nstr and bytes. A str read from a text-mode file appears in the GUI as you expect, and\nend-lines are mapped on Windows as usual:\nC:\\...\\PP4E\\Gui\\Tour> python\n>>> from tkinter import *\n>>> T = Text()                                      # str from text-mode file\n>>> T.insert('1.0', open('jack.txt').read())        # platform default encoding\n>>> T.pack()                                        # appears in GUI normally\n>>> T.get('1.0', 'end')[:75]\n'000)  All work and no play makes Jack a dull boy.\\n001)  All work and no pla'\nIf you pass in a bytes obtained from a binary-mode file, however, it\u2019s odd in the GUI\non Windows\u2014there\u2019s an extra space at the end of each line, which reflects the \\r that\nis not stripped by binary mode files:\nC:\\...\\PP4E\\Gui\\Tour> python\n>>> from tkinter import *\n>>> T = Text()                                       # bytes from binary-mode\n>>> T.insert('1.0', open('jack.txt', 'rb').read())   # no decoding occurs\n>>> T.pack()                                         # lines have space at end!\n>>> T.get('1.0', 'end')[:75]\n'000)  All work and no play makes Jack a dull boy.\\r\\n001)  All work and no pl'\nTo use bytes to allow for arbitrary text but make the text appear as expected by users,\nwe also have to strip the \\r characters at line end manually. This assumes that a \\r\\n\ncombination doesn\u2019t mean something special in the text\u2019s encoding scheme, though\ndata in which this sequence does not mean end-of-line will likely have other issues when\n546 | Chapter 9:\u2002A tkinter Tour, Part 2displayed. The following avoids the extra end-of-line spaces\u2014we open for input in\nbinary mode for undecoded bytes, but drop \\r:\nC:\\...\\PP4E\\Gui\\Tour> python\n>>> from tkinter import *                        # use bytes, strip \\r if any\n>>> T = Text()\n>>> data = open('jack.txt', 'rb').read()\n>>> data = data.replace(b'\\r\\n', b'\\n')\n>>> T.insert('1.0', data)\n>>> T.pack()\n>>> T.get('1.0', 'end')[:75]\n'000)  All work and no play makes Jack a dull boy.\\n001)  All work and no pla'\nTo save content later, we can either add the \\r characters back on Windows only,\nmanually encode to bytes, and save in binary mode; or we can open in text mode to\nmake the file object restore the \\r if needed and encode for us, and write the str content\nstring directly. The second of these is probably simpler, as we don\u2019t need to care about\nplatform differences.\nEither way, though, we still face an encoding step\u2014we can either rely on the platform\ndefault encoding or obtain an encoding name from user interfaces. In the following,\nfor example, the text-mode file converts end-lines and encodes to bytes internally using\nthe platform default. If we care about supporting arbitrary Unicode types or run on a\nplatform whose default does not accommodate characters displayed, we would need\nto pass in an explicit encoding argument (the Python slice operation here has the same\neffect as fetching through Tk\u2019s \u201cend-1c\u201d position specification):\n...continuing prior listing...\n>>> content = T.get('1.0', 'end')[:-1]                # drop added \\n at end\n>>> open('copyjack.txt', 'w').write(content)          # use platform default\n12500                                                 # text mode adds \\n on Win\n>>> ^Z\nC:\\...\\PP4E\\Gui\\Tour> fc jack.txt copyjack.txt\nComparing files jack.txt and COPYJACK.TXT\nFC: no differences encountered\nSupporting Unicode in PyEdit (ahead)\nWe\u2019ll see a use case of accommodating the Text widget\u2019s Unicode behavior in the larger\nPyEdit example of Chapter 11. Really, supporting Unicode just means supporting\narbitrary Unicode encodings in text files on opens and saves; once in memory, text\nprocessing can always be performed in terms of str, since that\u2019s how tkinter returns\ncontent. To support Unicode, PyEdit will open both input and output files in text mode\nwith explicit encodings whenever possible, and fall back on opening input files in binary\nmode only as a last resort. This avoids relying on the limited Unicode support Tk\nprovides for display of raw byte strings.\nTo make this policy work, PyEdit will accept encoding names from a wide variety of\nsources and allow the user to configure which to attempt. Encodings may be obtained\nfrom user dialog inputs, configuration file settings, the platform default, the prior\nText | 547open\u2019s encoding on saves, and even internal program values (parsed from email head-\ners, for instance). These sources are attempted until the first that succeeds, though it\nmay also be desirable to limit encoding attempts to just one such source in some\ncontexts.\nWatch for this code in Chapter 14. Frankly, PyEdit in this edition originally read and\nwrote files in text mode with platform default encodings. I didn\u2019t consider the impli-\ncations of Unicode on PyEdit until the PyMailGUI example\u2019s Internet world raised the\nspecter of arbitrary text encodings. If it seems that strings are a lot more complicated\nthan they used to be, it\u2019s probably only because your scope has been too narrow.\nAdvanced Text and Tag Operations\nBut enough about the idiosyncrasies of Unicode text\u2014let\u2019s get back to coding GUIs.\nBesides the position specification roles we\u2019ve seen so far, the Text widget\u2019s text tags can\nalso be used to apply formatting and behavior to all characters in a substring and all\nsubstrings added to a tag. In fact, this is where much of the power of the Text widget lies:\n\u2022 Tags have formatting attributes for setting color, font, tabs, and line spacing and\njustification; to apply these to many parts of the text at once, associate them with\na tag and apply formatting to the tag with the tag_config method, much like the\ngeneral config widget we\u2019ve been using.\n\u2022 Tags can also have associated event bindings, which let you implement things such\nas hyperlinks in a Text widget: clicking the text triggers its tag\u2019s event handler. Tag\nbindings are set with a tag_bind method, much like the general widget bind method\nwe\u2019ve already met.\nWith tags, it\u2019s possible to display multiple configurations within the same Text widget;\nfor instance, you can apply one font to the Text widget at large and other fonts to tagged\ntext. In addition, the Text widget allows you to embed other widgets at an index (they\nare treated like a single character), as well as images.\nExample 9-12 illustrates the basics of all these advanced tools at once and draws the\ninterface captured in Figure 9-22. This script applies formatting and event bindings to\nthree tagged substrings, displays text in two different font and color schemes, and em-\nbeds an image and a button. Double-clicking any of the tagged substrings (or the em-\nbedded button) with a mouse triggers an event that prints a \u201cGot tag event\u201d message\nto stdout.\nExample 9-12. PP4E\\Gui\\Tour\\texttags.py\n\"demo advanced tag and text interfaces\"\nfrom tkinter import *\nroot = Tk()\ndef hello(event): print('Got tag event')\n# make and config a Text\n548 | Chapter 9:\u2002A tkinter Tour, Part 2text = Text()\ntext.config(font=('courier', 15, 'normal'))                  # set font for all\ntext.config(width=20, height=12)\ntext.pack(expand=YES, fill=BOTH)\ntext.insert(END, 'This is\\n\\nthe meaning\\n\\nof life.\\n\\n')   # insert six lines\n# embed windows and photos\nbtn = Button(text, text='Spam', command=lambda: hello(0))    # embed a button\nbtn.pack()\ntext.window_create(END, window=btn)                          # embed a photo\ntext.insert(END, '\\n\\n')\nimg = PhotoImage(file='../gifs/PythonPowered.gif')\ntext.image_create(END, image=img)\n# apply tags to substrings\ntext.tag_add('demo', '1.5', '1.7')                       # tag 'is'\ntext.tag_add('demo', '3.0', '3.3')                       # tag 'the'\ntext.tag_add('demo', '5.3', '5.7')                       # tag 'life'\ntext.tag_config('demo', background='purple')             # change colors in tag\ntext.tag_config('demo', foreground='white')              # not called bg/fg here\ntext.tag_config('demo', font=('times', 16, 'underline')) # change font in tag\ntext.tag_bind('demo', '<Double-1>', hello)               # bind events in tag\nroot.mainloop()\nFigure 9-22. Text tags in action\nSuch embedding and tag tools could ultimately be used to render a web page. In fact,\nPython\u2019s standard html.parser HTML parser module can help automate web page GUI\nText | 549construction. As you can probably tell, though, the Text widget offers more GUI pro-\ngramming options than we have space to list here. For more details on tag and text\noptions, consult other Tk and tkinter references. Right now, art class is about to begin.\nCanvas\nWhen it comes to graphics, the tkinter Canvas widget is the most free-form device in\nthe library. It\u2019s a place to draw shapes, move objects dynamically, and place other kinds\nof widgets. The canvas is based on a structured graphic object model: everything drawn\non a canvas can be processed as an object. You can get down to the pixel-by-pixel level\nin a canvas, but you can also deal in terms of larger objects such as shapes, photos, and\nembedded widgets. The net result makes the canvas powerful enough to support\neverything from simple paint programs to full-scale visualization and animation.\nBasic Canvas Operations\nCanvases are ubiquitous in much nontrivial GUI work, and we\u2019ll see larger canvas\nexamples show up later in this book under the names PyDraw, PyPhoto, PyView,\nPyClock, and PyTree. For now, let\u2019s jump right into an example that illustrates the\nbasics. Example 9-13 runs most of the major canvas drawing methods.\nExample 9-13. PP4E\\Gui\\Tour\\canvas1.py\n\"demo all basic canvas interfaces\"\nfrom tkinter import *\ncanvas = Canvas(width=525, height=300, bg='white')   # 0,0 is top left corner\ncanvas.pack(expand=YES, fill=BOTH)                   # increases down, right\ncanvas.create_line(100, 100, 200, 200)               # fromX, fromY, toX, toY\ncanvas.create_line(100, 200, 200, 300)               # draw shapes\nfor i in range(1, 20, 2):\n    canvas.create_line(0, i, 50, i)\ncanvas.create_oval(10, 10, 200, 200, width=2, fill='blue')\ncanvas.create_arc(200, 200, 300, 100)\ncanvas.create_rectangle(200, 200, 300, 300, width=5, fill='red')\ncanvas.create_line(0, 300, 150, 150, width=10, fill='green')\nphoto=PhotoImage(file='../gifs/ora-lp4e.gif')\ncanvas.create_image(325, 25, image=photo, anchor=NW)  # embed a photo\nwidget = Label(canvas, text='Spam', fg='white', bg='black')\nwidget.pack()\ncanvas.create_window(100, 100, window=widget)        # embed a widget\ncanvas.create_text(100, 280, text='Ham')             # draw some text\nmainloop()\n550 | Chapter 9:\u2002A tkinter Tour, Part 2When run, this script draws the window captured in Figure 9-23. We saw how to place\na photo on canvas and size a canvas for a photo earlier on this tour (see \u201cIm-\nages\u201d on page 484). This script also draws shapes, text, and even an embedded Label\nwidget. Its window gets by on looks alone; in a moment, we\u2019ll learn how to add event\ncallbacks that let users interact with drawn items.\nFigure 9-23. canvas1 hardcoded object sketches\nProgramming the Canvas Widget\nCanvases are easy to use, but they rely on a coordinate system, define unique drawing\nmethods, and name objects by identifier or tag. This section introduces these core\ncanvas concepts.\nCoordinates\nAll items drawn on a canvas are distinct objects, but they are not really widgets. If you\nstudy the canvas1 script closely, you\u2019ll notice that canvases are created and packed (or\ngridded or placed) within their parent container just like any other widget in tkinter.\nBut the items drawn on a canvas are not. Shapes, images, and so on, are positioned and\nmoved on the canvas by coordinates, identifiers, and tags. Of these, coordinates are\nthe most fundamental part of the canvas model.\nCanvases define an (X,Y) coordinate system for their drawing area; x means the hori-\nzontal scale, y means vertical. By default, coordinates are measured in screen pixels\n(dots), the upper-left corner of the canvas has coordinates (0,0), and x and y coordinates\nCanvas | 551increase to the right and down, respectively. To draw and embed objects within a can-\nvas, you supply one or more (X,Y) coordinate pairs to give absolute canvas locations.\nThis is different from the constraints we\u2019ve used to pack widgets thus far, but it allows\nvery fine-grained control over graphical layouts, and it supports more free-form inter-\nface techniques such as animation.*\nObject construction\nThe canvas allows you to draw and display common shapes such as lines, ovals, rec-\ntangles, arcs, and polygons. In addition, you can embed text, images, and other kinds\nof tkinter widgets such as labels and buttons. The canvas1 script demonstrates all the\nbasic graphic object constructor calls; to each, you pass one or more sets of (X,Y) co-\nordinates to give the new object\u2019s location, start point and endpoint, or diagonally\nopposite corners of a bounding box that encloses the shape:\nid = canvas.create_line(fromX, fromY, toX, toY)       # line start, stop\nid = canvas.create_oval(fromX, fromY, toX, toY)       # two opposite box corners\nid = canvas.create_arc( fromX, fromY, toX, toY)       # two opposite oval corners\nid = canvas.create_rectangle(fromX, fromY, toX, toY)  # two opposite corners\nOther drawing calls specify just one (X,Y) pair, to give the location of the object\u2019s upper-\nleft corner:\nid = canvas.create_image(250, 0, image=photo, anchor=NW)  # embed a photo\nid = canvas.create_window(100, 100, window=widget)        # embed a widget\nid = canvas.create_text(100, 280, text='Ham')             # draw some text\nThe canvas also provides a create_polygon method that accepts an arbitrary set of\ncoordinate arguments defining the endpoints of connected lines; it\u2019s useful for drawing\nmore arbitrary kinds of shapes composed of straight lines.\nIn addition to coordinates, most of these drawing calls let you specify common con-\nfiguration options, such as outline width, fill color, outline color, and so on. Indi-\nvidual object types have unique configuration options all their own, too; for instance,\nlines may specify the shape of an optional arrow, and text, widgets, and images may\nbe anchored to a point of the compass (this looks like the packer\u2019s anchor, but really it\ngives a point on the object that is positioned at the [X,Y] coordinates given in the\ncreate call; NW puts the upper-left corner at [X,Y]).\nPerhaps the most important thing to notice here, though, is that tkinter does most of\nthe \u201cgrunt\u201d work for you\u2014when drawing graphics, you provide coordinates, and\nshapes are automatically plotted and rendered in the pixel world. If you\u2019ve ever done\nany lower-level graphics work, you\u2019ll appreciate the difference.\n* Animation techniques are covered at the end of this tour. As a use case example, because you can embed\nother widgets in a canvas\u2019s drawing area, their coordinate system also makes them ideal for implementing\nGUIs that let users design other GUIs by dragging embedded widgets around on the canvas\u2014a useful canvas\napplication we would explore in this book if I had a few hundred pages to spare.\n552 | Chapter 9:\u2002A tkinter Tour, Part 2Object identifiers and operations\nAlthough not used by the canvas1 script, every object you put on a canvas has an iden-\ntifier, returned by the create_ method that draws or embeds the object (what was coded\nas id in the last section\u2019s examples). This identifier can later be passed to other methods\nthat move the object to new coordinates, set its configuration options, delete it from\nthe canvas, raise or lower it among other overlapping objects, and so on.\nFor instance, the canvas move method accepts both an object identifier and X and Y\noffsets (not coordinates), and it moves the named object by the offsets given:\ncanvas.move(objectIdOrTag, offsetX, offsetY)    # move object(s) by offset\nIf this happens to move the object off-screen, it is simply clipped (not shown). Other\ncommon canvas operations process objects, too:\ncanvas.delete(objectIdOrTag)                   # delete object(s) from canvas\ncanvas.tkraise(objectIdOrTag)                  # raise object(s) to front\ncanvas.lower(objectIdOrTag)                    # lower object(s) below others\ncanvas.itemconfig(objectIdOrTag, fill='red')   # fill object(s) with red color\nNotice the tkraise name\u2014raise by itself is a reserved word in Python. Also note that\nthe itemconfig method is used to configure objects drawn on a canvas after they have\nbeen created; use config to set configuration options for the canvas itself. Probably the\nbest thing to notice here, though, is that because tkinter is based on structured objects,\nyou can process a graphic object all at once; there is no need to erase and redraw each\npixel manually to implement a move or a raise.\nCanvas object tags\nBut canvases offer even more power than suggested so far. In addition to object iden-\ntifiers, you can also perform canvas operations on entire sets of objects at once, by\nassociating them all with a tag, a name that you make up and apply to objects on the\ndisplay. Tagging objects in a Canvas is at least similar in spirit to tagging substrings in\nthe Text widget we studied in the prior section. In general terms, canvas operation\nmethods accept either a single object\u2019s identifier or a tag name.\nFor example, you can move an entire set of drawn objects by associating all with the\nsame tag and passing the tag name to the canvas move method. In fact, this is why\nmove takes offsets, not coordinates\u2014when given a tag, each object associated with the\ntag is moved by the same (X,Y) offsets; absolute coordinates would make all the tagged\nobjects appear on top of each other instead.\nTo associate an object with a tag, either specify the tag name in the object drawing call\u2019s\ntag option or call the addtag_withtag(tag, objectIdOrTag) canvas method (or its rel-\natives). For instance:\ncanvas.create_oval(x1, y1, x2, y2, fill='red', tag='bubbles')\ncanvas.create_oval(x3, y3, x4, y4, fill='red', tag='bubbles')\nobjectId = canvas.create_oval(x5, y5, x6, y6, fill='red')\nCanvas | 553canvas.addtag_withtag('bubbles', objectId)\ncanvas.move('bubbles', diffx, diffy)\nThis makes three ovals and moves them at the same time by associating them all with\nthe same tag name. Many objects can have the same tag, many tags can refer to the\nsame object, and each tag can be individually configured and processed.\nAs in Text, Canvas widgets have predefined tag names too: the tag all refers to all objects\non the canvas, and current refers to whatever object is under the mouse cursor. Besides\nasking for an object under the mouse, you can also search for objects with the find_\ncanvas methods: canvas.find_closest(X,Y), for instance, returns a tuple whose first\nitem is the identifier of the closest object to the supplied coordinates\u2014handy after\nyou\u2019ve received coordinates in a general mouse-click event callback.\nWe\u2019ll revisit the notion of canvas tags by example later in this chapter (see the animation\nscripts near the end if you need more details right away). As usual, canvases support\nadditional operations and options that we don\u2019t have space to cover in a finite text like\nthis (e.g., the canvas postscript method lets you save the canvas in a PostScript file).\nSee later examples in this book, such as PyDraw, for more details, and consult other\nTk or tkinter references for an exhaustive list of canvas object options.\nScrolling Canvases\nOne canvas-related operation is so common, though, that it does merit a look here. As\ndemonstrated in Example 9-14, scroll bars can be cross-linked with a canvas using the\nsame protocols we used to add them to listboxes and text earlier, but with a few unique\nrequirements.\nExample 9-14. PP4E\\Gui\\Tour\\scrolledcanvas.py\n\"a simple vertically-scrollable canvas component and demo\"\nfrom tkinter import *\nclass ScrolledCanvas(Frame):\n    def __init__(self, parent=None, color='brown'):\n        Frame.__init__(self, parent)\n        self.pack(expand=YES, fill=BOTH)                  # make me expandable\n        canv = Canvas(self, bg=color, relief=SUNKEN)\n        canv.config(width=300, height=200)                # display area size\n        canv.config(scrollregion=(0, 0, 300, 1000))       # canvas size corners\n        canv.config(highlightthickness=0)                 # no pixels to border\n        sbar = Scrollbar(self)\n        sbar.config(command=canv.yview)                   # xlink sbar and canv\n        canv.config(yscrollcommand=sbar.set)              # move one moves other\n        sbar.pack(side=RIGHT, fill=Y)                     # pack first=clip last\n        canv.pack(side=LEFT, expand=YES, fill=BOTH)       # canv clipped first\n        self.fillContent(canv)\n        canv.bind('<Double-1>', self.onDoubleClick)       # set event handler\n554 | Chapter 9:\u2002A tkinter Tour, Part 2self.canvas = canv\n    def fillContent(self, canv):                           # override me below\n        for i in range(10):\n            canv.create_text(150, 50+(i*100), text='spam'+str(i), fill='beige')\n    def onDoubleClick(self, event):                       # override me below\n        print(event.x, event.y)\n        print(self.canvas.canvasx(event.x), self.canvas.canvasy(event.y))\nif __name__ == '__main__': ScrolledCanvas().mainloop()\nThis script makes the window in Figure 9-24. It is similar to prior scroll examples, but\nscrolled canvases introduce two new kinks in the scrolling model:\nScrollable versus viewable sizes\nYou can specify the size of the displayed view window, but you must specify the\nsize of the scrollable canvas at large. The size of the view window is what is dis-\nplayed, and it can be changed by the user by resizing. The size of the scrollable\ncanvas will generally be larger\u2014it includes the entire content, of which only part\nis displayed in the view window. Scrolling moves the view window over the scrol-\nlable size canvas.\nViewable to absolute coordinate mapping\nIn addition, you may need to map between event view area coordinates and overall\ncanvas coordinates if the canvas is larger than its view area. In a scrolling scenario,\nthe canvas will almost always be larger than the part displayed, so mapping is often\nneeded when canvases are scrolled. In some applications, this mapping is not re-\nquired, because widgets embedded in the canvas respond to users directly (e.g.,\nbuttons in the PyPhoto example in Chapter 11). If the user interacts with the canvas\ndirectly, though (e.g., in a drawing program), mapping from view coordinates to\nscrollable size coordinates may be necessary.\nFigure 9-24. scrolledcanvas live\nCanvas | 555Sizes are given as configuration options. To specify a view area size, use canvas width\nand height options. To specify an overall canvas size, give the (X,Y) coordinates of the\nupper-left and lower-right corners of the canvas in a four-item tuple passed to the\nscrollregion option. If no view area size is given, a default size is used. If no\nscrollregion is given, it defaults to the view area size; this makes the scroll bar useless,\nsince the view is assumed to hold the entire canvas.\nMapping coordinates is a bit subtler. If the scrollable view area associated with a canvas\nis smaller than the canvas at large, the (X,Y) coordinates returned in event objects are\nview area coordinates, not overall canvas coordinates. You\u2019ll generally want to scale\nthe event coordinates to canvas coordinates, by passing them to the canvasx and\ncanvasy canvas methods before using them to process objects.\nFor example, if you run the scrolled canvas script and watch the messages printed on\nmouse double-clicks, you\u2019ll notice that the event coordinates are always relative to the\ndisplayed view window, not to the overall canvas:\nC:\\...\\PP4E\\Gui\\Tour> python scrolledcanvas.py\n2 0                       event x,y when scrolled to top of canvas\n2.0 0.0                   canvas x,y -same, as long as no border pixels\n150 106\n150.0 106.0\n299 197\n299.0 197.0\n3 2                       event x,y when scrolled to bottom of canvas\n3.0 802.0                 canvas x,y -y differs radically\n296 192\n296.0 992.0\n152 97                    when scrolled to a midpoint in the canvas\n152.0 599.0\n16 187\n16.0 689.0\nHere, the mapped canvas X is always the same as the canvas X because the display area\nand canvas are both set at 300 pixels wide (it would be off by 2 pixels due to automatic\nborders if not for the script\u2019s highlightthickness setting). But notice that the mapped\nY is wildly different from the event Y if you click after a vertical scroll. Without scaling,\nthe event\u2019s Y incorrectly points to a spot much higher in the canvas.\nMany of this book\u2019s canvas examples need no such scaling\u2014(0,0) always maps to the\nupper-left corner of the canvas display in which a mouse click occurs\u2014but just because\ncanvases are not scrolled. See the next section for a canvas with both horizontal and\nvertical scrolls; the PyTree program later in this book is similar, but it also uses dy-\nnamically changed scrollable region sizes when new trees are viewed.\nAs a rule of thumb, if your canvases scroll, be sure to scale event coordinates to true\ncanvas coordinates in callback handlers that care about positions. Some handlers might\nnot care whether events are bound to individual drawn objects or embedded widgets\ninstead of the canvas at large, but we need to move on to the next two sections to see \nhow.\n556 | Chapter 9:\u2002A tkinter Tour, Part 2Scrollable Canvases and Image Thumbnails\nAt the end of Chapter 8, we looked at a collection of scripts that display thumbnail\nimage links for all photos in a directory. There, we noted that scrolling is a major\nrequirement for large photo collections. Now that we know about canvases and scroll-\nbars, we can finally put them to work to implement this much-needed extension, and\nconclude the image viewer story we began in Chapter 8 (well, almost).\nExample 9-15 is a mutation of the last chapter\u2019s code, which displays thumbnails in a\nscrollable canvas. See the prior chapter for more details on its operation, including\nthe ImageTk module imported from the required Python Imaging Library (PIL) third-\nparty extension (needed for thumbnails and JPEG images).\nIn fact, to fully understand Example 9-15, you must also refer to Example 8-45, since\nwe\u2019re reusing that module\u2019s thumbnail creator and photo viewer tools. Here, we are\njust adding a canvas, positioning the fixed-size thumbnail buttons at absolute coordi-\nnates in the canvas, and computing the scrollable size using concepts outlined in the\nprior section. Both horizontal and vertical scrollbars allow us to move through the\ncanvas of image buttons freely, regardless of how many there may be.\nExample 9-15. PP4E\\Gui\\PIL\\viewer_thumbs_scrolled.py\n\"\"\"\nimage viewer extension: uses fixed-size thumbnail buttons for uniform layout, and\nadds scrolling for large image sets by displaying thumbs in a canvas widget with\nscroll bars;  requires PIL to view image formats such as JPEG, and reuses thumbs\nmaker and single photo viewer in viewer_thumbs.py;  caveat/to do: this could also\nscroll popped-up images that are too large for the screen, and are cropped on\nWindows as is;  see PyPhoto later in Chapter 11 for a much more complete version;\n\"\"\"\nimport sys, math\nfrom tkinter import *\nfrom PIL.ImageTk import PhotoImage\nfrom viewer_thumbs import makeThumbs, ViewOne\ndef viewer(imgdir, kind=Toplevel, numcols=None, height=300, width=300):\n    \"\"\"\n    use fixed-size buttons, scrollable canvas;\n    sets scrollable (full) size, and places thumbs at absolute x,y\n    coordinates in canvas;  caveat: assumes all thumbs are same size\n    \"\"\"\n    win = kind()\n    win.title('Simple viewer: ' + imgdir)\n    quit = Button(win, text='Quit', command=win.quit, bg='beige')\n    quit.pack(side=BOTTOM, fill=X)\n    canvas = Canvas(win, borderwidth=0)\n    vbar = Scrollbar(win)\n    hbar = Scrollbar(win, orient='horizontal')\n    vbar.pack(side=RIGHT,  fill=Y)                  # pack canvas after bars\nCanvas | 557hbar.pack(side=BOTTOM, fill=X)                  # so clipped first\n    canvas.pack(side=TOP, fill=BOTH, expand=YES)\n    vbar.config(command=canvas.yview)               # call on scroll move\n    hbar.config(command=canvas.xview)\n    canvas.config(yscrollcommand=vbar.set)          # call on canvas move\n    canvas.config(xscrollcommand=hbar.set)\n    canvas.config(height=height, width=width)       # init viewable area size\n                                                    # changes if user resizes\n    thumbs = makeThumbs(imgdir)                     # [(imgfile, imgobj)]\n    numthumbs = len(thumbs)\n    if not numcols:\n        numcols = int(math.ceil(math.sqrt(numthumbs)))  # fixed or N x N\n    numrows = int(math.ceil(numthumbs / numcols))       # 3.x true div\n    linksize = max(thumbs[0][1].size)                   # (width, height)\n    fullsize = (0, 0,                                   # upper left  X,Y\n        (linksize * numcols), (linksize * numrows) )    # lower right X,Y\n    canvas.config(scrollregion=fullsize)                # scrollable area size\n    rowpos = 0\n    savephotos = []\n    while thumbs:\n        thumbsrow, thumbs = thumbs[:numcols], thumbs[numcols:]\n        colpos = 0\n        for (imgfile, imgobj) in thumbsrow:\n            photo   = PhotoImage(imgobj)\n            link    = Button(canvas, image=photo)\n            handler = lambda savefile=imgfile: ViewOne(imgdir, savefile)\n            link.config(command=handler, width=linksize, height=linksize)\n            link.pack(side=LEFT, expand=YES)\n            canvas.create_window(colpos, rowpos, anchor=NW,\n                    window=link, width=linksize, height=linksize)\n            colpos += linksize\n            savephotos.append(photo)\n        rowpos += linksize\n    return win, savephotos\nif __name__ == '__main__':\n    imgdir = 'images' if len(sys.argv) < 2 else sys.argv[1]\n    main, save = viewer(imgdir, kind=Tk)\n    main.mainloop()\nTo see this program in action, make sure you\u2019ve installed the PIL extension described \nnear the end of Chapter 8 and launch the script from a command line, passing the name \nof the image directory to be viewed as a command-line argument:\n...\\PP4E\\Gui\\PIL> viewer_thumbs_scrolled.py C:\\Users\\mark\\temp\\101MSDCF\nAs before, clicking on a thumbnail image opens the corresponding image at its full size \nin a new pop-up window. Figure 9-25 shows the viewer at work on a large directory \ncopied from my digital camera; the initial run must create and cache thumbnails, but \nlater runs start quickly.\n558 | Chapter 9:\u2002A tkinter Tour, Part 2Figure 9-25. Scrolled thumbnail image viewer\nOr simply run the script as is from a command line, by clicking its file icon, or within\nIDLE\u2014without command-line arguments, it displays the contents of the default sam-\nple images subdirectory in the book\u2019s source code tree, as captured in Figure 9-26.\nFigure 9-26. Displaying the default images directory\nCanvas | 559Scrolling images too: PyPhoto (ahead)\nDespite its evolutionary twists, the scrollable thumbnail viewer in Example 9-15 still\nhas one major limitation remaining: images that are larger than the physical screen are\nsimply truncated on Windows when popped up. This becomes glaringly obvious when\nopening large photos copied from a digital camera like those in Figure 9-25. Moreover,\nthere is no way to resize images once opened, to open other directories, and so on. It\u2019s\na fairly simplistic demonstration of canvas programming.\nIn Chapter 11, we\u2019ll learn how to do better when we meet the PyPhoto example pro-\ngram. PyPhoto will scroll the full size of images as well. In addition, it has tools for a\nvariety of resizing effects, and it supports saving images to files and opening other image\ndirectories on the fly. At its core, though, PyPhoto will reuse the techniques of our\nsimple browser here, as well as the thumbnail generation code we wrote in the prior\nchapter; much like our simple text editor earlier in the chapter, the code here is essen-\ntially a prototype for the more complete PyPhoto program we\u2019ll put together later in\nChapter 11. Stay tuned for the thrilling conclusion of the PyPhoto story (or flip ahead\nnow if the suspense is too much to bear).\nFor the purposes of this chapter, notice how in Example 9-15 the thumbnail viewer\u2019s\nactions are associated with embedded button widgets, not with the canvas itself. In\nfact, the canvas isn\u2019t much but a display device. To see how to enrich it with events of\nits own, let\u2019s move on to the next section.\nUsing Canvas Events\nLike Text and Listbox, there is no notion of a single command callback for Canvas. Instead,\ncanvas programs generally use other widgets (as we did with Example 9-15\u2019s thumbnail\nbuttons) or the lower-level bind call to set up handlers for mouse clicks, key presses,\nand the like (as we did for Example 9-14\u2019s scrolling canvas). Example 9-16 takes the\nlatter approach further, showing how to bind additional events for the canvas itself, in\norder to implement a few of the more common canvas drawing operations.\nExample 9-16. PP4E\\Gui\\Tour\\canvasDraw.py\n\"\"\"\ndraw elastic shapes on a canvas on drag, move on right click;\nsee canvasDraw_tags*.py for extensions with tags and animation\n\"\"\"\nfrom tkinter import *\ntrace = False\nclass CanvasEventsDemo:\n    def __init__(self, parent=None):\n        canvas = Canvas(width=300, height=300, bg='beige')\n        canvas.pack()\n        canvas.bind('<ButtonPress-1>', self.onStart)      # click\n        canvas.bind('<B1-Motion>',     self.onGrow)       # and drag\n560 | Chapter 9:\u2002A tkinter Tour, Part 2canvas.bind('<Double-1>',      self.onClear)      # delete all\n        canvas.bind('<ButtonPress-3>', self.onMove)       # move latest\n        self.canvas = canvas\n        self.drawn  = None\n        self.kinds = [canvas.create_oval, canvas.create_rectangle]\n    def onStart(self, event):\n        self.shape = self.kinds[0]\n        self.kinds = self.kinds[1:] + self.kinds[:1]      # start dragout\n        self.start = event\n        self.drawn = None\n    def onGrow(self, event):                              # delete and redraw\n        canvas = event.widget\n        if self.drawn: canvas.delete(self.drawn)\n        objectId = self.shape(self.start.x, self.start.y, event.x, event.y)\n        if trace: print(objectId)\n        self.drawn = objectId\n    def onClear(self, event):\n        event.widget.delete('all')                        # use tag all\n    def onMove(self, event):\n        if self.drawn:                                    # move to click spot\n            if trace: print(self.drawn)\n            canvas = event.widget\n            diffX, diffY = (event.x - self.start.x), (event.y - self.start.y)\n            canvas.move(self.drawn, diffX, diffY)\n            self.start = event\nif __name__ == '__main__':\n    CanvasEventsDemo()\n    mainloop()\nThis script intercepts and processes three mouse-controlled actions:\nClearing the canvas\nTo erase everything on the canvas, the script binds the double left-click event to\nrun the canvas\u2019s delete method with the all tag\u2014again, a built-in tag that asso-\nciates every object on the screen. Notice that the Canvas widget clicked is available\nin the event object passed in to the callback handler (it\u2019s also available as\nself.canvas).\nDragging out object shapes\nPressing the left mouse button and dragging (moving it while the button is still\npressed) creates a rectangle or oval shape as you drag. This is often called dragging\nout an object\u2014the shape grows and shrinks in an elastic rubber-band fashion as\nyou drag the mouse and winds up with a final size and location given by the point\nwhere you release the mouse button.\nTo make this work in tkinter, all you need to do is delete the old shape and draw\nanother as each drag event fires; both delete and draw operations are fast enough\nto achieve the elastic drag-out effect. Of course, to draw a shape to the current\nCanvas | 561mouse location, you need a starting point; to delete before a redraw, you also must\nremember the last drawn object\u2019s identifier. Two events come into play: the initial\nbutton press event saves the start coordinates (really, the initial press event object,\nwhich contains the start coordinates), and mouse movement events erase and re-\ndraw from the start coordinates to the new mouse coordinates and save the new\nobject ID for the next event\u2019s erase.\nObject moves\nWhen you click the right mouse button (button 3), the script moves the most\nrecently drawn object to the spot you clicked in a single step. The event argument\ngives the (X,Y) coordinates of the spot clicked, and we subtract the saved starting\ncoordinates of the last drawn object to get the (X,Y) offsets to pass to the canvas\nmove method (again, move does not take positions). Remember to scale event coor-\ndinates first if your canvas is scrolled.\nThe net result creates a window like that shown in Figure 9-27 after user interaction.\nAs you drag out objects, the script alternates between ovals and rectangles; set the\nscript\u2019s trace global to watch object identifiers scroll on stdout as new objects are drawn\nduring a drag. This screenshot was taken after a few object drag-outs and moves, but\nyou\u2019d never tell from looking at it; run this example on your own computer to get a\nbetter feel for the operations it supports.\nFigure 9-27. canvasDraw after a few drags and moves\n562 | Chapter 9:\u2002A tkinter Tour, Part 2Binding events on specific items\nMuch like we did for the Text widget, it is also possible to bind events for one or more\nspecific objects drawn on a Canvas with its tag_bind method. This call accepts either a\ntag name string or an object ID in its first argument. For instance, you can register a\ndifferent callback handler for mouse clicks on every drawn item or on any in a group\nof drawn and tagged items, rather than for the entire canvas at large. Example 9-17\nbinds a double-click handler on both the canvas itself and on two specific text items\nwithin it, to illustrate the interfaces. It generates Figure 9-28 when run.\nExample 9-17. PP4E\\Gui\\Tour\\canvas-bind.py\n# bind events on both canvas and its items\nfrom tkinter import *\ndef onCanvasClick(event):\n    print('Got canvas click', event.x, event.y, event.widget)\ndef onObjectClick(event):\n    print('Got object click', event.x, event.y, event.widget, end=' ')\n    print(event.widget.find_closest(event.x, event.y))  # find text object's ID\nroot = Tk()\ncanv = Canvas(root, width=100, height=100)\nobj1 = canv.create_text(50, 30, text='Click me one')\nobj2 = canv.create_text(50, 70, text='Click me two')\ncanv.bind('<Double-1>', onCanvasClick)                  # bind to whole canvas\ncanv.tag_bind(obj1, '<Double-1>', onObjectClick)        # bind to drawn item\ncanv.tag_bind(obj2, '<Double-1>', onObjectClick)        # a tag works here too\ncanv.pack()\nroot.mainloop()\nFigure 9-28. Canvas-bind window\nObject IDs are passed to tag_bind here, but a tag name string would work too, and\nwould allow you to associate multiple canvas objects as a group for event purposes.\nWhen you click outside the text items in this script\u2019s window, the canvas event handler\nfires; when either text item is clicked, both the canvas and the text object handlers fire.\nHere is the stdout result after clicking on the canvas twice and on each text item once;\nCanvas | 563the script uses the canvas find_closest method to fetch the object ID of the particular\ntext item clicked (the one closest to the click spot):\nC:\\...\\PP4E\\Gui\\Tour> python canvas-bind.py\nGot canvas click 3 6 .8217952               canvas clicks\nGot canvas click 46 52 .8217952\nGot object click 51 33 .8217952 (1,)        first text click\nGot canvas click 51 33 .8217952\nGot object click 55 69 .8217952 (2,)        second text click\nGot canvas click 55 69 .8217952\nWe\u2019ll revisit the notion of events bound to canvases in the PyDraw example in Chap-\nter 11, where we\u2019ll use them to implement a feature-rich paint and motion program.\nWe\u2019ll also return to the canvasDraw script later in this chapter, to add tag-based moves\nand simple animation with time-based tools, so keep this page bookmarked for refer-\nence. First, though, let\u2019s follow a promising side road to explore another way to lay out\nwidgets within windows\u2014the gridding layout model.\nGrids\nSo far, we\u2019ve mostly been arranging widgets in displays by calling their pack methods\u2014\nan interface to the packer geometry manager in tkinter. We\u2019ve also used absolute co-\nordinates in canvases, which are a kind of layout scheme, too, but not a high-level\nmanaged one like the packer. This section introduces grid, the most commonly used\nalternative to the packer. We previewed this alternative in Chapter 8 when discussing\ninput forms and arranging image thumbnails. Here, we\u2019ll study gridding in its full form.\nAs we learned earlier, tkinter geometry managers work by arranging child widgets\nwithin a parent container widget (parents are typically Frames or top-level windows).\nWhen we ask a widget to pack or grid itself, we\u2019re really asking its parent to place it\namong its siblings. With pack, we provide constraints or sides and let the geometry\nmanager lay out widgets appropriately. With grid, we arrange widgets in rows and\ncolumns in their parent, as though the parent container widget was a table.\nGridding is an entirely distinct geometry management system in tkinter. In fact, at this\nwriting, pack and grid are mutually exclusive for widgets that have the same parent\u2014\nwithin a given parent container, we can either pack widgets or grid them, but we cannot\ndo both. That makes sense, if you realize that geometry managers do their jobs as\nparents, and a widget can be arranged by only one geometry manager.\nWhy Grids?\nAt least within one container, though, that means you must pick either grid or pack\nand stick with it. So why grid, then? In general, grid is handy for displays in which\notherwise unrelated widgets must line up horizontally. This includes both tabular dis-\nplays and form-like displays; arranging input fields in row/column grid fashion can be\nat least as easy as laying out the display with nested frames.\n564 | Chapter 9:\u2002A tkinter Tour, Part 2As mentioned in the preceding chapter, input forms are generally best arranged either\nas grids or as row frames with fixed-width labels, so that labels and entry fields line up\nhorizontally as expected on all platforms (as we learned, column frames don\u2019t work\nreliably, because they may misalign rows). Although grids and row frames are roughly\nthe same amount of work, grids are useful if calculating maximum label width is in-\nconvenient. Moreover, grids also apply to tables more complex than forms.\nAs we\u2019ll see, though, for input forms, grid doesn\u2019t offer substantial code or complexity\nsavings compared to equivalent packer solutions, especially when things like resizabil-\nity are added to the GUI picture. In other words, the choice between the two layout\nschemes is often largely one of style, not technology.\nGrid Basics: Input Forms Revisited\nLet\u2019s start off with the basics; Example 9-18 lays out a table of Labels and Entry fields\u2014\nwidgets we\u2019ve already met. Here, though, they are arrayed on a grid.\nExample 9-18. PP4E\\Gui\\Tour\\Grid\\grid1.py\nfrom tkinter import *\ncolors = ['red', 'green', 'orange', 'white', 'yellow', 'blue']\nr = 0\nfor c in colors:\n    Label(text=c, relief=RIDGE,  width=25).grid(row=r, column=0)\n    Entry(bg=c,   relief=SUNKEN, width=50).grid(row=r, column=1)\n    r += 1\nmainloop()\nGridding assigns widgets to row and column numbers, which both begin at number 0;\ntkinter uses these coordinates, along with widget size in general, to lay out the con-\ntainer\u2019s display automatically. This is similar to the packer, except that rows and col-\numns replace the packer\u2019s notion of sides and packing order.\nWhen run, this script creates the window shown in Figure 9-29, pictured with data\ntyped into a few of the input fields. Once again, this book won\u2019t do justice to the colors\ndisplayed on the right, so you\u2019ll have to stretch your imagination a little (or run this\nscript on a computer of your own).\nDespite its colors, this is really just a classic input form layout again, of the same kind\nwe met in the prior chapter. Labels on the left describe data to type into entry fields on\nthe right. Here, though, we achieve the layout with gridding instead of packed frames.\nJust for fun, this script displays color names on the left and the entry field of the cor-\nresponding color on the right. It achieves its table-like layout with these lines:\n    Label(...).grid(row=r, column=0)\n    Entry(...).grid(row=r, column=1)\nGrids | 565From the perspective of the container window, the label is gridded to column 0 in the\ncurrent row number (a counter that starts at 0) and the entry is placed in column 1.\nThe upshot is that the grid system lays out all the labels and entries in a two-dimensional\ntable automatically, with both evenly sized rows and evenly sized columns large enough\nto hold the largest item in each column.\nThat is, because widgets are arranged by both row and column when gridded, they align\nproperly in both dimensions. Although packed row frames can achieve the same effect\nif labels are fixed width (as we learned in Chapter 8), grids directly reflect the structure\nof tabular displays; this includes input forms, as well as larger tables in general. The\nnext section illustrates this difference in code.\nComparing grid and pack\nTime for some compare-and-contrast: Example 9-19 implements the same sort of\ncolorized input form with both grid and pack, to make it easy to see the differences\nbetween the two approaches.\nExample 9-19. PP4E\\Gui\\Tour\\Grid\\grid2.py\n\"\"\"\nadd equivalent pack window using row frames and fixed-width labels;\nLabels and Entrys in packed column frames may not line up horizontally;\nsame length code, though enumerate built-in could trim 2 lines off grid;\n\"\"\"\nfrom tkinter import *\ncolors = ['red', 'green', 'orange', 'white', 'yellow', 'blue']\ndef gridbox(parent):\n    \"grid by row/column numbers\"\n    row = 0\n    for color in colors:\n        lab = Label(parent, text=color, relief=RIDGE,  width=25)\n        ent = Entry(parent, bg=color,   relief=SUNKEN, width=50)\n        lab.grid(row=row, column=0)\n        ent.grid(row=row, column=1)\nFigure 9-29. The grid geometry manager in pseudoliving color\n566 | Chapter 9:\u2002A tkinter Tour, Part 2ent.insert(0, 'grid')\n        row += 1\ndef packbox(parent):\n    \"row frames with fixed-width labels\"\n    for color in colors:\n        row = Frame(parent)\n        lab = Label(row, text=color, relief=RIDGE,  width=25)\n        ent = Entry(row, bg=color,   relief=SUNKEN, width=50)\n        row.pack(side=TOP)\n        lab.pack(side=LEFT)\n        ent.pack(side=RIGHT)\n        ent.insert(0, 'pack')\nif __name__ == '__main__':\n    root = Tk()\n    gridbox(Toplevel())\n    packbox(Toplevel())\n    Button(root, text='Quit', command=root.quit).pack()\n    mainloop()\nThe pack version here uses row frames with fixed-width labels (again, column frames\ncan skew rows). The basic label and entry widgets are created the same way by these\ntwo functions, but they are arranged in very different ways:\n\u2022 With pack, we use side options to attach labels and rows on the left and right, and\ncreate a Frame for each row (itself attached to the parent\u2019s current top).\n\u2022 With grid, we instead assign each widget a row and column position in the implied\ntabular grid of the parent, using options of the same name.\nAs we\u2019ve learned, with pack, the packing order can matter, too: a widget gets an entire\nside of the remaining space (mostly irrelevant here), and items packed first are clipped\nlast (labels and topmost rows disappear last here). The grid alternative achieves the\nsame clipping effect by virtue of grid behavior. Running the script makes the windows\nin Figure 9-30\u2014one window for each scheme.\nIf you study this example closely, you\u2019ll find that the difference in the amount of code\nrequired for each layout scheme is roughly a wash, at least in this simple form. The\npack scheme must create a Frame per row, but the grid scheme must keep track of the\ncurrent row number.\nIn fact, both schemes require the same number of code lines as shown, though to be\nfair we could shave one line from each by packing or gridding the label immediately,\nand could shave two more lines from the grid layout by using the built-in enumerate\nfunction to avoid manual counting. Here\u2019s a minimalist\u2019s version of the grid box func-\ntion for reference:\n def gridbox(parent):\n    for (row, color) in enumerate(colors):\n        Label(parent, text=color, relief=RIDGE,  width=25).grid(row=row, column=0)\n        ent = Entry(parent, bg=color, relief=SUNKEN, width=50)\nGrids | 567ent.grid(row=row, column=1)\n        ent.insert(0, 'grid')\nWe\u2019ll leave further code compaction to the more serious sports fans in the audience\n(this code isn\u2019t too horrific, but making your code concise in general is not always in\nyour coworkers\u2019 best interest!). Irrespective of coding tricks, the complexity of packing\nand gridding here seems similar. As we\u2019ll see later, though, gridding can require more\ncode when widget resizing is factored into the mix.\nCombining grid and pack\nNotice that the prior section\u2019s Example 9-19 passes a brand-new Toplevel to each form\nconstructor function so that the grid and pack versions wind up in distinct top-level\nwindows. Because the two geometry managers are mutually exclusive within a given\nparent container, we have to be careful not to mix them improperly. For instance,\nExample 9-20 is able to put both the packed and the gridded widgets on the same\nwindow, but only by isolating each in its own Frame container widget.\nExample 9-20. PP4E\\Gui\\Tour\\Grid\\grid2-same.py\n\"\"\"\nbuild pack and grid forms on different frames in same window;\ncan't grid and pack in same parent container (e.g., root window)\nbut can mix in same window if done in different parent frames;\n\"\"\"\nfrom tkinter import *\nfrom grid2 import gridbox, packbox\nroot = Tk()\nLabel(root, text='Grid:').pack()\nFigure 9-30. Equivalent grid and pack windows\n568 | Chapter 9:\u2002A tkinter Tour, Part 2frm = Frame(root, bd=5, relief=RAISED)\nfrm.pack(padx=5, pady=5)\ngridbox(frm)\nLabel(root, text='Pack:').pack()\nfrm = Frame(root, bd=5, relief=RAISED)\nfrm.pack(padx=5, pady=5)\npackbox(frm)\nButton(root, text='Quit', command=root.quit).pack()\nmainloop()\nWhen this runs we get a composite window with two forms that look identical (Fig-\nure 9-31), but the two nested frames are actually controlled by completely different\ngeometry managers.\nFigure 9-31. grid and pack in the same window\nOn the other hand, the sort of code in Example 9-21 fails badly, because it attempts to\nuse pack and grid within the same parent\u2014only one geometry manager can be used\non any one parent.\nExample 9-21. PP4E\\Gui\\Tour\\Grid\\grid2-fails.py\n\"\"\"\nFAILS-- can't grid and pack in same parent container (here, root window)\n\"\"\"\nGrids | 569from tkinter import *\nfrom grid2 import gridbox, packbox\nroot = Tk()\ngridbox(root)\npackbox(root)\nButton(root, text='Quit', command=root.quit).pack()\nmainloop()\nThis script passes the same parent (the top-level window) to each function in an effort\nto make both forms appear in one window. It also utterly hangs the Python process on\nmy machine, without ever showing any windows at all (on some versions of Windows,\nI\u2019ve had to resort to Ctrl-Alt-Delete to kill it; on others, the Command Prompt shell\nwindow must sometimes be restarted altogether).\nGeometry manager combinations can be subtle until you get the hang of this. To make\nthis example work, for instance, we simply need to isolate the grid box in a parent\ncontainer all its own to keep it away from the packing going on in the root window\u2014\nas in the following bold alternative code:\nroot = Tk()\nfrm = Frame(root)\nfrm.pack()            # this works\ngridbox(frm)          # gridbox must have its own parent in which to grid\npackbox(root)\nButton(root, text='Quit', command=root.quit).pack()\nmainloop()\nAgain, today you must either pack or grid within one parent, but not both. It\u2019s possible\nthat this restriction may be lifted in the future, but it\u2019s been a long-lived constraint, and\nit seems unlikely to be removed, given the disparity in the two window manager\nschemes; try your Python to be sure.\nMaking Gridded Widgets Expandable\nAnd now, some practical bits: the grids we\u2019ve seen so far are fixed in size; they do not\ngrow when the enclosing window is resized by a user. Example 9-22 implements an\nunreasonably patriotic input form with both grid and pack again, but adds the config-\nuration steps needed to make all widgets in both windows expand along with their\nwindow on a resize.\nExample 9-22. PP4E\\Gui\\Tour\\Grid\\grid3.py\n\"add a label on the top and form resizing\"\nfrom tkinter import *\ncolors = ['red',  'white',  'blue']\ndef gridbox(root):\n    Label(root, text='Grid').grid(columnspan=2)\n570 | Chapter 9:\u2002A tkinter Tour, Part 2row = 1\n    for color in colors:\n        lab = Label(root, text=color, relief=RIDGE,  width=25)\n        ent = Entry(root, bg=color,   relief=SUNKEN, width=50)\n        lab.grid(row=row, column=0, sticky=NSEW)\n        ent.grid(row=row, column=1, sticky=NSEW)\n        root.rowconfigure(row, weight=1)\n        row += 1\n    root.columnconfigure(0, weight=1)\n    root.columnconfigure(1, weight=1)\ndef packbox(root):\n    Label(root, text='Pack').pack()\n    for color in colors:\n        row = Frame(root)\n        lab = Label(row, text=color, relief=RIDGE,  width=25)\n        ent = Entry(row, bg=color,   relief=SUNKEN, width=50)\n        row.pack(side=TOP,   expand=YES, fill=BOTH)\n        lab.pack(side=LEFT,  expand=YES, fill=BOTH)\n        ent.pack(side=RIGHT, expand=YES, fill=BOTH)\nroot = Tk()\ngridbox(Toplevel(root))\npackbox(Toplevel(root))\nButton(root, text='Quit', command=root.quit).pack()\nmainloop()\nWhen run, this script makes the scene in Figure 9-32. It builds distinct pack and grid\nwindows again, with entry fields on the right colored red, white, and blue (or for readers\nnot working along on a computer, gray, white, and a marginally darker gray).\nFigure 9-32. grid and pack windows before resizing\nThis time, though, resizing both windows with mouse drags makes all their embedded\nlabels and entry fields expand along with the parent window, as we see in Fig-\nure 9-33 (with text typed into the form).\nGrids | 571Figure 9-33. grid and pack windows resized\nAs coded, shrinking the pack window clips items packed last; shrinking the grid win-\ndow shrinks all labels and entries together unlike grid2\u2019s default behavior (try this on\nyour own).\nResizing in grids\nNow that I\u2019ve shown you what these windows do, I need to explain how they do it.\nWe learned in Chapter 7 how to make widgets expand with pack: we use expand and\nfill options to increase space allocations and stretch into them, respectively. To make\nexpansion work for widgets arranged by grid, we need to use different protocols. Rows\nand columns must be marked with a weight to make them expandable, and widgets\nmust also be made sticky so that they are stretched within their allocated grid cell:\nHeavy rows and columns\nWith pack, we make each row expandable by making the corresponding Frame\nexpandable, with expand=YES and fill=BOTH. Gridders must be a bit more specific:\nto get full expandability, call the grid container\u2019s rowconfigure method for each\nrow and its columnconfigure for each column. To both methods, pass a weight\noption with a value greater than zero to enable rows and columns to expand.\nWeight defaults to zero (which means no expansion), and the grid container in this\nscript is just the top-level window. Using different weights for different rows and\ncolumns makes them grow at proportionally different rates.\nSticky widgets\nWith pack, we use fill options to stretch widgets to fill their allocated space hor-\nizontally or vertically, and anchor options to position widgets within their allocated\n572 | Chapter 9:\u2002A tkinter Tour, Part 2space. With grid, the sticky option serves the roles of both fill and anchor in the\npacker. Gridded widgets can optionally be made sticky on one side of their allo-\ncated cell space (such as anchor) or on more than one side to make them stretch\n(such as fill). Widgets can be made sticky in four directions\u2014N, S, E, and W, and\nconcatenations of these letters specify multiple-side stickiness. For instance, a\nsticky setting of W left justifies the widget in its allocated space (such as a packer\nanchor=W), and NS stretches the widget vertically within its allocated space (such as\na packer fill=Y).\nWidget stickiness hasn\u2019t been useful in examples thus far because the layouts were\nregularly sized (widgets were no smaller than their allocated grid cell space), and\nresizes weren\u2019t supported at all. Here, though, Example 9-22 specifies NSEW stick-\niness to make widgets stretch in all directions with their allocated cells.\nDifferent combinations of row and column weights and sticky settings generate differ-\nent resize effects. For instance, deleting the columnconfig lines in the grid3 script makes\nthe display expand vertically but not horizontally. Try changing some of these settings\nyourself to see the sorts of effects they produce.\nSpanning columns and rows\nThere is one other big difference in how the grid3 script configures its windows. Both\nthe grid and the pack windows display a label on the top that spans the entire window.\nFor the packer scheme, we simply make a label attached to the top of the window at\nlarge (remember, side defaults to TOP):\nLabel(root, text='Pack').pack()\nBecause this label is attached to the window\u2019s top before any row frames are, it appears\nacross the entire window top as expected. But laying out such a label takes a bit more\nwork in the rigid world of grids; the first line of the grid implementation function does\nit like this:\nLabel(root, text='Grid').grid(columnspan=2)\nTo make a widget span across multiple columns, we pass grid a columnspan option with\na spanned-column count. Here, it just specifies that the label at the top of the window\nshould stretch over the entire window\u2014across both the label and the entry columns.\nTo make a widget span across multiple rows, pass a rowspan option instead. The regular\nlayouts of grids can be either an asset or a liability, depending on how regular your user\ninterface will be; these two span settings let you specify exceptions to the rule when\nneeded.\nSo which geometry manager comes out on top here? When resizing is factored in, as\nin the script in Example 9-22, gridding actually becomes slightly more complex; in fact,\ngridding requires three extra lines of code. On the other hand, enumerate could again\nmake the race close, grid is still convenient for simple forms, and your grids and packs\nmay vary.\nGrids | 573For more on input form layout, stay tuned for the form builder utilities\nwe\u2019ll code near the end of Chapter 12 and use again in Chapter 13, when\ndeveloping a file transfer and FTP client user interface. As we\u2019ll see,\ndoing forms well once allows us to skip the details later. We\u2019ll also use\nmore custom form layout code in the PyEdit program\u2019s change dialog\nin Chapter 11, and the PyMailGUI example\u2019s email header fields in\nChapter 14.\nLaying Out Larger Tables with grid\nSo far, we\u2019ve been building two-column arrays of labels and input fields. That\u2019s typical\nof input forms, but the tkinter grid manager is capable of configuring much grander\nmatrixes. For instance, Example 9-23 builds a five-row by four-column array of labels,\nwhere each label simply displays its row and column number (row.col). When run, the\nwindow in Figure 9-34 appears on-screen.\nExample 9-23. PP4E\\Gui\\Tour\\Grid\\grid4.py\n# simple 2D table, in default Tk root window\nfrom tkinter import *\nfor i in range(5):\n    for j in range(4):\n        lab = Label(text='%d.%d' % (i, j), relief=RIDGE)\n        lab.grid(row=i, column=j, sticky=NSEW)\nmainloop()\nFigure 9-34. A 5 \u00d7 4 array of coordinate labels\nIf you think this is starting to look like it might be a way to program spreadsheets, you\nmay be on to something. Example 9-24 takes this idea a bit further and adds a button\nthat prints the table\u2019s current input field values to the stdout stream (usually, to the\nconsole window).\n574 | Chapter 9:\u2002A tkinter Tour, Part 2Example 9-24. PP4E\\Gui\\Tour\\Grid\\grid5.py\n# 2D table of input fields, default Tk root window\nfrom tkinter import *\nrows = []\nfor i in range(5):\n    cols = []\n    for j in range(4):\n        ent = Entry(relief=RIDGE)\n        ent.grid(row=i, column=j, sticky=NSEW)\n        ent.insert(END, '%d.%d' % (i, j))\n        cols.append(ent)\n    rows.append(cols)\ndef onPress():\n    for row in rows:\n        for col in row:\n            print(col.get(), end=' ')\n        print()\nButton(text='Fetch', command=onPress).grid()\nmainloop()\nWhen run, this script creates the window in Figure 9-35 and saves away all the grid\u2019s\nentry field widgets in a two-dimensional list of lists. When its Fetch button is pressed,\nthe script steps through the saved list of lists of entry widgets, to fetch and display all\nthe current values in the grid. Here is the output of two Fetch presses\u2014one before I\nmade input field changes, and one after:\nC:\\...\\PP4E\\Gui\\Tour\\Grid> python grid5.py\n0.0 0.1 0.2 0.3\n1.0 1.1 1.2 1.3\n2.0 2.1 2.2 2.3\n3.0 3.1 3.2 3.3\n4.0 4.1 4.2 4.3\n0.0 0.1 0.2 42\n1.0 1.1 1.2 43\n2.0 2.1 2.2 44\n3.0 3.1 3.2 45\n4.0 4.1 4.2 46\nNow that we know how to build and step through arrays of input fields, let\u2019s add a few\nmore useful buttons. Example 9-25 adds another row to display column sums and adds\nbuttons to clear all fields to zero and calculate column sums.\nExample 9-25. PP4E\\Gui\\Tour\\Grid\\grid5b.py\n# add column sums, clearing\nfrom tkinter import *\nnumrow, numcol = 5, 4\nGrids | 575rows = []\nfor i in range(numrow):\n    cols = []\n    for j in range(numcol):\n        ent = Entry(relief=RIDGE)\n        ent.grid(row=i, column=j, sticky=NSEW)\n        ent.insert(END, '%d.%d' % (i, j))\n        cols.append(ent)\n    rows.append(cols)\nsums = []\nfor i in range(numcol):\n    lab = Label(text='?', relief=SUNKEN)\n    lab.grid(row=numrow, column=i, sticky=NSEW)\n    sums.append(lab)\ndef onPrint():\n    for row in rows:\n        for col in row:\n            print(col.get(), end=' ')\n        print()\n    print()\ndef onSum():\n    tots = [0] * numcol\n    for i in range(numcol):\n        for j in range(numrow):\n            tots[i] += eval(rows[j][i].get())        # sum column\n    for i in range(numcol):\n        sums[i].config(text=str(tots[i]))            # display in GUI\ndef onClear():\n    for row in rows:\n        for col in row:\n            col.delete('0', END)\n            col.insert(END, '0.0')\n    for sum in sums:\n        sum.config(text='?')\nimport sys\nButton(text='Sum',   command=onSum).grid(row=numrow+1, column=0)\nButton(text='Print', command=onPrint).grid(row=numrow+1, column=1)\nFigure 9-35. A larger grid of input fields\n576 | Chapter 9:\u2002A tkinter Tour, Part 2Button(text='Clear', command=onClear).grid(row=numrow+1, column=2)\nButton(text='Quit',  command=sys.exit).grid(row=numrow+1, column=3)\nmainloop()\nFigure 9-36 shows this script at work summing up four columns of numbers; to get a\ndifferent-size table, change the numrow and numcol variables at the top of the script.\nFigure 9-36. Adding column sums\nAnd finally, Example 9-26 is one last extension that is coded as a class for reusability,\nand it adds a button to load the table\u2019s data from a file. Data files are assumed to be\ncoded as one line per row, with whitespace (spaces or tabs) between each column within\na row line. Loading a file of data automatically resizes the table GUI to accommodate\nthe number of columns in the table based upon the file\u2019s content.\nExample 9-26. PP4E\\Gui\\Tour\\Grid\\grid5c.py\n# recode as an embeddable class\nfrom tkinter import *\nfrom tkinter.filedialog import askopenfilename\nfrom PP4E.Gui.Tour.quitter import Quitter          # reuse, pack, and grid\nclass SumGrid(Frame):\n    def __init__(self, parent=None, numrow=5, numcol=5):\n        Frame.__init__(self, parent)\n        self.numrow = numrow                       # I am a frame container\n        self.numcol = numcol                       # caller packs or grids me\n        self.makeWidgets(numrow, numcol)           # else only usable one way\n    def makeWidgets(self, numrow, numcol):\n        self.rows = []\n        for i in range(numrow):\n            cols = []\n            for j in range(numcol):\n                ent = Entry(self, relief=RIDGE)\n                ent.grid(row=i+1, column=j, sticky=NSEW)\n                ent.insert(END, '%d.%d' % (i, j))\n                cols.append(ent)\n            self.rows.append(cols)\nGrids | 577self.sums = []\n        for i in range(numcol):\n            lab = Label(self, text='?', relief=SUNKEN)\n            lab.grid(row=numrow+1, column=i, sticky=NSEW)\n            self.sums.append(lab)\n        Button(self, text='Sum',   command=self.onSum).grid(row=0, column=0)\n        Button(self, text='Print', command=self.onPrint).grid(row=0, column=1)\n        Button(self, text='Clear', command=self.onClear).grid(row=0, column=2)\n        Button(self, text='Load',  command=self.onLoad).grid(row=0, column=3)\n        Quitter(self).grid(row=0, column=4)    # fails: Quitter(self).pack()\n    def onPrint(self):\n        for row in self.rows:\n            for col in row:\n                print(col.get(), end=' ')\n            print()\n        print()\n    def onSum(self):\n        tots = [0] * self.numcol\n        for i in range(self.numcol):\n            for j in range(self.numrow):\n                tots[i] += eval(self.rows[j][i].get())        # sum current data\n        for i in range(self.numcol):\n            self.sums[i].config(text=str(tots[i]))\n    def onClear(self):\n        for row in self.rows:\n            for col in row:\n                col.delete('0', END)                          # delete content\n                col.insert(END, '0.0')                        # preserve display\n        for sum in self.sums:\n            sum.config(text='?')\n    def onLoad(self):\n        file = askopenfilename()\n        if file:\n            for row in self.rows:\n                for col in row: col.grid_forget()             # erase current gui\n            for sum in self.sums:\n                sum.grid_forget()\n            filelines   = open(file, 'r').readlines()         # load file data\n            self.numrow = len(filelines)                      # resize to data\n            self.numcol = len(filelines[0].split())\n            self.makeWidgets(self.numrow, self.numcol)\n            for (row, line) in enumerate(filelines):          # load into gui\n                fields = line.split()\n                for col in range(self.numcol):\n                    self.rows[row][col].delete('0', END)\n                    self.rows[row][col].insert(END, fields[col])\n578 | Chapter 9:\u2002A tkinter Tour, Part 2if __name__ == '__main__':\n    import sys\n    root = Tk()\n    root.title('Summer Grid')\n    if len(sys.argv) != 3:\n        SumGrid(root).pack()    # .grid() works here too\n    else:\n        rows, cols = eval(sys.argv[1]), eval(sys.argv[2])\n        SumGrid(root, rows, cols).pack()\n    mainloop()\nNotice that this module\u2019s SumGrid class is careful not to either grid or pack itself. In\norder to be attachable to containers where other widgets are being gridded or packed,\nit leaves its own geometry management ambiguous and requires callers to pack or grid\nits instances. It\u2019s OK for containers to pick either scheme for their own children because\nthey effectively seal off the pack-or-grid choice. But attachable component classes that\naim to be reused under both geometry managers cannot manage themselves because\nthey cannot predict their parent\u2019s policy.\nThis is a fairly long example that doesn\u2019t say much else about gridding or widgets in\ngeneral, so I\u2019ll leave most of it as suggested reading and just show what it does. Fig-\nure 9-37 shows the initial window created by this script after changing the last column\nand requesting a sum; make sure the directory containing the PP4E examples root is\non your module search path (e.g., PYTHONPATH) for the package import.\nBy default, the class makes the 5 \u00d7 5 grid here, but we can pass in other dimensions to\nboth the class constructor and the script\u2019s command line. When you press the Load\nbutton, you get the standard file selection dialog we met earlier on this tour\n(Figure 9-38).\nThe datafile grid-data1.txt contains seven rows and six columns of data:\nC:\\...\\PP4E\\Gui\\Tour\\Grid> type grid5-data1.txt\n1 2 3 4 5 6\n1 2 3 4 5 6\n1 2 3 4 5 6\n1 2 3 4 5 6\n1 2 3 4 5 6\n1 2 3 4 5 6\n1 2 3 4 5 6\nLoading this file\u2019s data into our GUI makes the dimensions of the grid change accord-\ningly\u2014the class simply reruns its widget construction logic after erasing all the old entry\nwidgets with the grid_forget method. The grid_forget method unmaps gridded widg-\nets and so effectively erases them from the display. Also watch for the pack_forget\nwidget and window withdraw methods used in the after event \u201calarm\u201d examples of the\nnext section for other ways to erase and redraw GUI components.\nOnce the GUI is erased and redrawn for the new data, Figure 9-39 captures the scene\nafter the file Load and a new Sum have been requested by the user in the GUI.\nGrids | 579Figure 9-39. Data file loaded, displayed, and summed\nFigure 9-37. Adding datafile loads\nFigure 9-38. Opening a data file for SumGrid\n580 | Chapter 9:\u2002A tkinter Tour, Part 2The grid5-data2.txt datafile has the same dimensions but contains expressions in two\nof its columns, not just simple numbers. Because this script converts input field values\nwith the Python eval built-in function, any Python syntax will work in this table\u2019s fields,\nas long as it can be parsed and evaluated within the scope of the onSum method:\nC:\\...\\PP4E\\Gui\\Tour\\Grid> type grid5-data2.txt\n1 2 3 2*2 5 6\n1 3-1 3 2<<1 5 6\n1 5%3 3 pow(2,2) 5 6\n1 2 3 2**2 5 6\n1 2 3 [4,3][0] 5 6\n1 {'a':2}['a'] 3 len('abcd') 5 6\n1 abs(-2) 3 eval('2+2') 5 6\nSumming these fields runs the Python code they contain, as seen in Figure 9-40. This\ncan be a powerful feature; imagine a full-blown spreadsheet grid, for instance\u2014field\nvalues could be Python code \u201csnippets\u201d that compute values on the fly, call functions\nin modules, and even download current stock quotes over the Internet with tools we\u2019ll\nmeet in the next part of this book.\nFigure 9-40. Python expressions in the data and table\nIt\u2019s also a potentially dangerous tool\u2014a field might just contain an expression that\nerases your hard drive!\u2020 If you\u2019re not sure what expressions may do, either don\u2019t use\neval (convert with more limited built-in functions like int and float instead) or make\nsure your Python is running in a process with restricted access permissions for system\ncomponents you don\u2019t want to expose to the code you run.\nOf course, this still is nowhere near a true spreadsheet program. There are fixed column\nsums and file loads, for instance, but individual cells cannot contain formulas based\n\u2020 I debated showing this, but since understanding a danger is a big part of avoiding it\u2014if the Python process\nhad permission to delete files, passing the code string __import__('os').system('rm \u2013rf *') to eval on Unix\nwould delete all files at and below the current directory by running a shell command (and 'rmdir /S /Q .'\nwould have a similar effect on Windows). Don\u2019t do this! To see how this works in a less devious and potentially\nuseful way, type __import__('math').pi into one of the GUI table\u2019s cells\u2014on Sum, the cell evaluates to pi\n(3.14159). Passing \"__import__('os').system('dir')\" to eval interactively proves the point safely as well.\nAll of this also applies to the exec built-in\u2014eval runs expression strings and exec statements, but expressions\nare statements (though not vice versa). A typical user of most GUIs is unlikely to type this kind of code\naccidentally, of course, especially if that user is always you, but be careful out there!\nGrids | 581upon other cells. In the interest of space, further mutations toward that goal are left as\nexercises.\nI should also point out that there is more to gridding than we have time to present fully\nhere. For instance, by creating subframes that have grids of their own, we can build up\nmore sophisticated layouts as component hierarchies in much the same way as nested\nframes arranged with the packer. For now, let\u2019s move on to one last widget survey topic.\nTime Tools, Threads, and Animation\nThe last stop on our widget tour is perhaps the most unique. tkinter also comes with\na handful of tools that have to do with the event-driven programming model, not\ngraphics displayed on a computer screen.\nSome GUI applications need to perform background activities periodically. For exam-\nple, to \u201cblink\u201d a widget\u2019s appearance, we\u2019d like to register a callback handler to be\ninvoked at regular time intervals. Similarly, it\u2019s not a good idea to let a long-running\nfile operation block other activity in a GUI; if the event loop could be forced to update\nperiodically, the GUI could remain responsive. tkinter comes with tools for both sched-\nuling such delayed actions and forcing screen updates:\nwidget.after(milliseconds, function, *args)\nThis tool schedules the function to be called once by the GUI\u2019s event processing\nsystem after a number of milliseconds. This form of the call does not pause the\nprogram\u2014the callback function is scheduled to be run later from the normal\ntkinter event loop, but the calling program continues normally, and the GUI re-\nmains active while the function call is pending. As also discussed in Chapter 5,\nunlike the threading module\u2019s Timer object, widget.after events are dispatched in\nthe main GUI thread and so can freely update the GUI.\nThe function event handler argument can be any callable Python object: a function,\nbound method, lambda and so on. The milliseconds timer duration argument is\nan integer which can be used to specify both fractions and multiples of a second;\nits value divided by 1,000 gives equivalent seconds. Any args arguments are passed\nby position to function when it is later called.\nIn practice, a lambda can be used in place of individually-listed arguments to make\nthe association of arguments to function explicit, but that is not required. When\nthe function is a method, object state information (attributes) might also provide\nits data instead of listed arguments. The after method returns an ID that can be\npassed to after_cancel to cancel the callback. Since this method is so commonly\nused, I\u2019ll say more about it by example in a moment.\nwidget.after(milliseconds)\nThis tool pauses the calling program for a number of milliseconds\u2014for example,\nan argument of 5,000 pauses the caller for 5 seconds. This is essentially equivalent\nto Python\u2019s library function time.sleep(seconds), and both calls can be used to\n582 | Chapter 9:\u2002A tkinter Tour, Part 2add a delay in time-sensitive displays (e.g., animation programs such as PyDraw\nand the simpler examples ahead).\nwidget.after_idle(function, *args)\nThis tool schedules the function to be called once when there are no more pending\nevents to process. That is, function becomes an idle handler, which is invoked\nwhen the GUI isn\u2019t busy doing anything else.\nwidget.after_cancel(id)\nThis tool cancels a pending after callback event before it occurs; id is the return\nvalue of an after event scheduling call.\nwidget.update()\nThis tool forces tkinter to process all pending events in the event queue, including\ngeometry resizing and widget updates and redraws. You can call this periodically\nfrom a long-running callback handler to refresh the screen and perform any updates\nto it that your handler has already requested. If you don\u2019t, your updates may not\nappear on-screen until your callback handler exits. In fact, your display may hang\ncompletely during long-running handlers if not manually updated (and handlers\nare not run in threads, as described in the next section); the window won\u2019t even\nredraw itself until the handler returns if covered and uncovered by another.\nFor instance, programs that animate by repeatedly moving an object and pausing\nmust call for an update before the end of the animation or only the final object\nposition will appear on-screen; worse, the GUI will be completely inactive until\nthe animation callback returns (see the simple animation examples later in this\nchapter, as well as PyDraw in Chapter 11).\nwidget.update_idletasks()\nThis tool processes any pending idle events. This may sometimes be safer than\nafter, which has the potential to set up race (looping) conditions in some scenarios.\nTk widgets use idle events to display themselves.\n_tkinter.createfilehandler(file, mask, function)\nThis tool schedules the function to be called when a file\u2019s status changes. The\nfunction may be invoked when the file has data for reading, is available for writing,\nor triggers an exception. The file argument is a Python file or socket object (tech-\nnically, anything with a fileno() method) or an integer file descriptor; mask is\ntkinter.READABLE or tkinter.WRITABLE to specify the mode; and the callback\nfunction takes two arguments\u2014the file ready to converse and a mask. File handlers\nare often used to process pipes or sockets, since normal input/output requests can\nblock the caller.\nBecause this call is not available on Windows, it won\u2019t be used in this book. Since\nit\u2019s currently a Unix-only alternative, portable GUIs may be better off using\nafter timer loops to poll for data and spawning threads to read data and place it\non queues if needed\u2014see Chapter 10 for more details. Threads are a much more\ngeneral solution to nonblocking data transfers.\nTime Tools, Threads, and Animation | 583widget.wait_variable(var)\nwidget.wait_window(win)\nwidget.wait_visibility(win)\nThese tools pause the caller until a tkinter variable changes its value, a window is\ndestroyed, or a window becomes visible. All of these enter a local event loop, such\nthat the application\u2019s mainloop continues to handle events. Note that var is a tkinter\nvariable object (discussed earlier), not a simple Python variable. To use for modal\ndialogs, first call widget.focus() (to set input focus) and widget.grab() (to make\na window be the only one active).\nAlthough we\u2019ll put some of these to work in examples, we won\u2019t go into exhaustive\ndetails on all of these tools here; see other Tk and tkinter documentation for more\ninformation.\nUsing Threads with tkinter GUIs\nKeep in mind that for many programs, Python\u2019s thread support that we discussed in\nChapter 5 can serve some of the same roles as the tkinter tools listed in the preceding\nsection and can even make use of them. For instance, to avoid blocking a GUI (and its\nusers) during a long-running file or socket transfer, the transfer can simply be run in a\nspawned thread, while the rest of the program continues to run normally. Similarly,\nGUIs that must watch for inputs on pipes or sockets can do so in spawned threads or\nafter callbacks, or some combination thereof, without blocking the GUI itself.\nIf you do use threads in tkinter programs, however, you need to remember that only\nthe main thread (the one that built the GUI and started the mainloop) should generally\nmake GUI calls. At the least, multiple threads should not attempt to update the GUI\nat the same time. For example, the update method described in the preceding section\nhas historically caused problems in threaded GUIs\u2014if a spawned thread calls this\nmethod (or calls a method that does), it can sometimes trigger very strange and even\nspectacular program crashes.\nIn fact, for a simple and more vivid example of the lack of thread safety in tkinter GUIs,\nsee and run the following files in the book examples distribution package:\n...\\PP4E\\Gui\\Tour\\threads-demoAll-frm.py\n...\\PP4E\\Gui\\Tour threads-demoAll-win.py\nThese scripts are takeoffs of the prior chapter\u2019s Examples 8-32 and 8-33, which run the\nconstruction of four GUI demo components in parallel threads. They also both crash\nhorrifically on Windows and require forced shutdown of the program. While some\nGUI operations appear to be safe to perform in parallel threads (e.g., see the canvas\nmoves in Example 9-32), thread safety is not guaranteed by tkinter in general. (For\nfurther proof of tkinter\u2019s lack of thread safety, see the discussion of threaded update\nloops in the next chapter, just after Example 10-28; a thread there that attempts to pop\nup a new window also makes the GUI fail resoundingly.)\n584 | Chapter 9:\u2002A tkinter Tour, Part 2This GUI thread story is prone to change over time, but it imposes a few structural\nconstraints on programs. For example, because spawned threads cannot usually per-\nform GUI processing, they must generally communicate with the main thread using\nglobal variables or shared mutable objects such as queues, as required by the applica-\ntion. A spawned thread which watches a socket for data, for instance, might simply set\nglobal variables or append to shared queues, which in turn triggers GUI changes in the\nmain thread\u2019s periodic after event callbacks. The main thread\u2019s timer events process\nthe spawned thread\u2019s results.\nAlthough some GUI operations or toolkits may support multiple threads better than\nothers, GUI programs are generally best structured as a main GUI thread and non-GUI\n\u201cworker\u201d threads this way, both to avoid potential collisions and to finesse the thread\nsafety issue altogether. The PyMailGUI example later in the book, for instance, will\ncollect and dispatch callbacks produced by threads and stored on a queue.\nAlso remember that irrespective of thread safety of the GUI itself, threaded GUI pro-\ngrams must follow the same principles of threaded programs in general\u2014as we learned\nin Chapter 5, such programs must still synchronize access to mutable state shared\nbetween threads, if it may be changed by threads running in parallel. Although a\nproducer/consumer thread model based upon queues can alleviate many thread issues\nfor the GUI itself, a program that spawns non-GUI threads to update shared informa-\ntion used by the GUI thread may still need to use thread locks to avoid concurrent\nupdate issues.\nWe\u2019ll explore GUI threading in more detail in Chapter 10, and we\u2019ll meet more realistic\nthreaded GUI programs in Part IV, especially in Chapter 14\u2019s PyMailGUI. The latter,\nfor instance, runs long-running tasks in threads to avoid blocking the GUI, but both\nrestricts GUI updates to the main thread and uses locks to prevent overlap of operations\nthat may change shared caches.\nUsing the after Method\nOf all the event tools in the preceding list, the after method may be the most interesting.\nIt allows scripts to schedule a callback handler to be run at some time in the future.\nThough a simple device, we\u2019ll use this often in later examples in this book. For instance,\nin Chapter 11, we\u2019ll meet a clock program that uses after to wake up 10 times per\nsecond and check for a new time, and we\u2019ll see an image slideshow program that uses\nafter to schedule the next photo display (see PyClock and PyView). To illustrate the\nbasics of scheduled callbacks, Example 9-27 does something a bit different.\nExample 9-27. PP4E\\Gui\\Tour\\alarm.py\n# flash and beep every second using after() callback loop\nfrom tkinter import *\nclass Alarm(Frame):\nTime Tools, Threads, and Animation | 585def __init__(self, msecs=1000):              # default = 1 second\n        Frame.__init__(self)\n        self.msecs = msecs\n        self.pack()\n        stopper = Button(self, text='Stop the beeps!', command=self.quit)\n        stopper.pack()\n        stopper.config(bg='navy', fg='white', bd=8)\n        self.stopper = stopper\n        self.repeater()\n    def repeater(self):                          # on every N millisecs\n        self.bell()                              # beep now\n        self.stopper.flash()                     # flash button now\n        self.after(self.msecs, self.repeater)    # reschedule handler\nif __name__ == '__main__': Alarm(msecs=1000).mainloop()\nThis script builds the window in Figure 9-41 and periodically calls both the button\nwidget\u2019s flash method to make the button flash momentarily (it alternates colors\nquickly) and the tkinter bell method to call your system\u2019s sound interface. The\nrepeater method beeps and flashes once and schedules a callback to be invoked after\na specific amount of time with the after method.\nFigure 9-41. Stop the beeps!\nBut after doesn\u2019t pause the caller: callbacks are scheduled to occur in the background,\nwhile the program performs other processing\u2014technically, as soon as the Tk event\nloop is able to notice the time rollover. To make this work, repeater calls after each\ntime through, to reschedule the callback. Delayed events are one-shot callbacks; to\nrepeat the event as a loop, we need to reschedule it anew.\nThe net effect is that when this script runs, it starts beeping and flashing once its one-\nbutton window pops up. And it keeps beeping and flashing. And beeping. And flashing.\nOther activities and GUI operations don\u2019t affect it. Even if the window is iconified, the\nbeeping continues, because tkinter timer events fire in the background. You need to\nkill the window or press the button to stop the alarm. By changing the msecs delay, you\ncan make this beep as fast or as slow as your system allows (some platforms can\u2019t beep\nas fast as others\u2026). This may or may not be the best demo to launch in a crowded office,\nbut at least you\u2019ve been warned.\n586 | Chapter 9:\u2002A tkinter Tour, Part 2Hiding and redrawing widgets and windows\nThe button flash method flashes the widget, but it\u2019s easy to dynamically change other\nappearance options of widgets, such as buttons, labels, and text, with the widget\nconfig method. For instance, you can also achieve a flash-like effect by manually re-\nversing foreground and background colors with the widget config method in scheduled\nafter callbacks. Largely for fun, Example 9-28 specializes the alarm to go a step further.\nExample 9-28. PP4E\\Gui\\Tour\\alarm-hide.py\n# customize to erase or show button on after() timer callbacks\nfrom tkinter import *\nimport alarm\nclass Alarm(alarm.Alarm):                        # change alarm callback\n    def __init__(self, msecs=1000):              # default = 1 second\n        self.shown = False\n        alarm.Alarm.__init__(self, msecs)\n    def repeater(self):                          # on every N millisecs\n        self.bell()                              # beep now\n        if self.shown:\n            self.stopper.pack_forget()           # hide or erase button now\n        else:                                    # or reverse colors, flash...\n            self.stopper.pack()\n        self.shown = not self.shown              # toggle state for next time\n        self.after(self.msecs, self.repeater)    # reschedule handler\nif __name__ == '__main__': Alarm(msecs=500).mainloop()\nWhen this script is run, the same window appears, but the button is erased or redrawn\non alternating timer events. The widget pack_forget method erases (unmaps) a drawn\nwidget and pack makes it show up again; grid_forget and grid similarly hide and show\nwidgets in a grid. The pack_forget method is useful for dynamically drawing and\nchanging a running GUI. For instance, you can be selective about which components\nare displayed, and you can build widgets ahead of time and show them only as needed.\nHere, it just means that users must press the button while it\u2019s displayed, or else the\nnoise keeps going.\nExample 9-29 goes even further. There are a handful of methods for hiding and un-\nhiding entire top-level windows:\n\u2022 To hide and unhide the entire window instead of just one widget within it, use\nthe top-level window widget withdraw and deiconify methods. The withdraw\nmethod, demonstrated in Example 9-29, completely erases the window and its icon\n(use iconify if you want the window\u2019s icon to appear during a hide).\n\u2022 The lift method raises a window above all its siblings or relative to another you\npass in. This method is also known as tkraise, but not raise\u2014its name in Tk\u2014\nbecause raise is a reserved word in Python.\nTime Tools, Threads, and Animation | 587\u2022 The state method returns or changes the window\u2019s current state\u2014it accepts\nnormal, iconic, zoomed (full screen), or withdrawn.\nExperiment with these methods on your own to see how they differ. They are also useful\nto pop up prebuilt dialog windows dynamically, but are perhaps less practical here.\nExample 9-29. PP4E\\Gui\\Tour\\alarm-withdraw.py\n# same, but hide or show entire window on after() timer callbacks\nfrom tkinter import *\nimport alarm\nclass Alarm(alarm.Alarm):\n    def repeater(self):                           # on every N millisecs\n        self.bell()                               # beep now\n        if self.master.state() == 'normal':       # is window displayed?\n            self.master.withdraw()                # hide entire window, no icon\n        else:                                     # iconify shrinks to an icon\n            self.master.deiconify()               # else redraw entire window\n            self.master.lift()                    # and raise above others\n        self.after(self.msecs, self.repeater)     # reschedule handler\nif __name__ == '__main__': Alarm().mainloop()     # master = default Tk root\nThis works the same, but the entire window appears or disappears on beeps\u2014you have\nto press it when it\u2019s shown. You could add lots of other effects to the alarm, and their\ntimer-based callbacks technique is widely applicable. Whether your buttons and win-\ndows should flash and disappear, though, probably depends less on tkinter technology\nthan on your users\u2019 patience.\nSimple Animation Techniques\nApart from the direct shape moves of the canvasDraw example we met earlier in this\nchapter, all of the GUIs presented so far in this part of the book have been fairly static.\nThis last section shows you how to change that, by adding simple shape movement\nanimations to the canvas drawing example listed in Example 9-16.\nIt also demonstrates and expands on the notion of canvas tags\u2014the move operations\nperformed here move all canvas objects associated with a tag at once. All oval shapes\nmove if you press \u201co,\u201d and all rectangles move if you press \u201cr\u201d; as mentioned earlier,\ncanvas operation methods accept both object IDs and tag names.\nBut the main goal here is to illustrate simple animation techniques using the time-based\ntools described earlier in this section. There are three basic ways to move objects around\na canvas:\n\u2022 By loops that use time.sleep to pause for fractions of a second between multiple\nmove operations, along with manual update calls. The script moves, sleeps, moves\na bit more, and so on. A time.sleep call pauses the caller and so fails to return\n588 | Chapter 9:\u2002A tkinter Tour, Part 2control to the GUI event loop\u2014any new requests that arrive during a move are\ndeferred. Because of that, canvas.update must be called to redraw the screen after\neach move, or else updates don\u2019t appear until the entire movement loop callback\nfinishes and returns. This is a classic long-running callback scenario; without man-\nual update calls, no new GUI events are handled until the callback returns in this\nscheme (including both new user requests and basic window redraws).\n\u2022 By using the widget.after method to schedule multiple move operations to occur\nevery few milliseconds. Because this approach is based upon scheduled events dis-\npatched by tkinter to your handlers, it allows multiple moves to occur in parallel\nand doesn\u2019t require canvas.update calls. You rely on the event loop to run moves,\nso there\u2019s no reason for sleep pauses, and the GUI is not blocked while moves are\nin progress.\n\u2022 By using threads to run multiple copies of the time.sleep pausing loops of the first\napproach. Because threads run in parallel, a sleep in any thread blocks neither the\nGUI nor other motion threads. As described earlier, GUIs should not be updated\nfrom spawned threads in general, but some canvas calls such as move seem to be\nthread-safe today in the current tkinter implementation.\nOf these three schemes, the first yields the smoothest animations but makes other\noperations sluggish during movement, the second seems to yield slower motion than\nthe others but is safer than using threads in general, and the second and third allow\nmultiple objects to be in motion at the same time.\nUsing time.sleep loops\nThe next three sections demonstrate the code structure of all three approaches in turn,\nwith new subclasses of the canvasDraw example we met in Example 9-16 earlier in this\nchapter. Refer back to that example for its other event bindings and basic draw, move,\nand clear operations; here, we customize its object creators for tags and add new event\nbindings and actions. Example 9-30 illustrates the first approach.\nExample 9-30. PP4E\\Gui\\Tour\\canvasDraw_tags.py\n\"\"\"\nadd tagged moves with time.sleep (not widget.after or threads);\ntime.sleep does not block the GUI event loop while pausing, but screen not redrawn\nuntil callback returns or widget.update call;  currently running onMove callback has\nexclusive attention until it returns: others pause if press 'r' or 'o' during move;\n\"\"\"\nfrom tkinter import *\nimport canvasDraw, time\nclass CanvasEventsDemo(canvasDraw.CanvasEventsDemo):\n    def __init__(self, parent=None):\n        canvasDraw.CanvasEventsDemo.__init__(self, parent)\n        self.canvas.create_text(100, 10, text='Press o and r to move shapes')\n        self.canvas.master.bind('<KeyPress-o>', self.onMoveOvals)\nTime Tools, Threads, and Animation | 589self.canvas.master.bind('<KeyPress-r>', self.onMoveRectangles)\n        self.kinds = self.create_oval_tagged, self.create_rectangle_tagged\n    def create_oval_tagged(self, x1, y1, x2, y2):\n        objectId = self.canvas.create_oval(x1, y1, x2, y2)\n        self.canvas.itemconfig(objectId, tag='ovals', fill='blue')\n        return objectId\n    def create_rectangle_tagged(self, x1, y1, x2, y2):\n        objectId = self.canvas.create_rectangle(x1, y1, x2, y2)\n        self.canvas.itemconfig(objectId, tag='rectangles', fill='red')\n        return objectId\n    def onMoveOvals(self, event):\n        print('moving ovals')\n        self.moveInSquares(tag='ovals')           # move all tagged ovals\n    def onMoveRectangles(self, event):\n        print('moving rectangles')\n        self.moveInSquares(tag='rectangles')\n    def moveInSquares(self, tag):                 # 5 reps of 4 times per sec\n        for i in range(5):\n            for (diffx, diffy) in [(+20, 0), (0, +20), (\u221220, 0), (0, \u221220)]:\n                self.canvas.move(tag, diffx, diffy)\n                self.canvas.update()              # force screen redraw/update\n                time.sleep(0.25)                  # pause, but don't block GUI\nif __name__ == '__main__':\n    CanvasEventsDemo()\n    mainloop()\nAll three of the scripts in this section create a window of blue ovals and red rectangles\nas you drag new shapes out with the left mouse button. The drag-out implementation\nitself is inherited from the superclass. A right-mouse-button click still moves a single\nshape immediately, and a double-left click still clears the canvas, too\u2014other operations\ninherited from the original superclass. In fact, all this new script really does is change\nthe object creation calls to add tags and colors to drawn objects here, add a text field\nat the top of the canvas, and add bindings and callbacks for motion requests. Fig-\nure 9-42 shows what this subclass\u2019s window looks like after dragging out a few shapes\nto be animated.\nThe \u201co\u201d and \u201cr\u201d keys are set up to start animation of all the ovals and rectangles you\u2019ve\ndrawn, respectively. Pressing \u201co,\u201d for example, makes all the blue ovals start moving\nsynchronously. Objects are animated to mark out five squares around their location\nand to move four times per second. New objects drawn while others are in motion start\nto move, too, because they are tagged. You need to run these live to get a feel for the\nsimple animations they implement, of course. (You could try moving this book back\nand forth and up and down, but it\u2019s not quite the same, and might look silly in public\nplaces.)\n590 | Chapter 9:\u2002A tkinter Tour, Part 2Figure 9-42. Drag-out objects ready to be animated\nUsing widget.after events\nThe main drawback of this first approach is that only one animation can be going at\nonce: if you press \u201cr\u201d or \u201co\u201d while a move is in progress, the new request puts the prior\nmovement on hold until it finishes because each move callback handler assumes the\nonly thread of control while it runs. That is, only one time.sleep loop callback can be\nrunning at a time, and a new one started by an update call is effectively a recursive call\nwhich pauses another loop already in progress.\nScreen updates are a bit sluggish while moves are in progress, too, because they happen\nonly as often as manual update calls are made (try a drag-out or a cover/uncover of the\nwindow during a move to see for yourself). In fact, uncommenting the canvas update\ncall in Example 9-30 makes the GUI completely unresponsive during the move\u2014it\nwon\u2019t redraw itself if covered, doesn\u2019t respond to new user requests, and doesn\u2019t show\nany of its progress (you only get to see the final state). This effectively simulates the\nimpact of long-running operations on GUIs in general.\nExample 9-31 specializes just the moveInSquares method of the prior example to remove\nall such limitations\u2014by using after timer callback loops, it schedules moves without\npotential pauses. It also reflects the most common (and likely best) way that tkinter\nGUIs handle time-based events at large. By breaking tasks into parts this way instead\nof running them all at once, they are naturally both distributed over time and\noverlapped.\nTime Tools, Threads, and Animation | 591Example 9-31. PP4E\\Gui\\Tour\\canvasDraw_tags_after.py\n\"\"\"\nsimilar, but with widget.after() scheduled events, not time.sleep loops;\nbecause these are scheduled events, this allows both ovals and rectangles\nto be moving at the _same_ time and does not require update calls to refresh\nthe GUI; the motion gets wild if you press 'o' or 'r' while move in progress:\nmultiple move updates start firing around the same time;\n\"\"\"\nfrom tkinter import *\nimport canvasDraw_tags\nclass CanvasEventsDemo(canvasDraw_tags.CanvasEventsDemo):\n    def moveEm(self, tag, moremoves):\n        (diffx, diffy), moremoves = moremoves[0], moremoves[1:]\n        self.canvas.move(tag, diffx, diffy)\n        if moremoves:\n            self.canvas.after(250, self.moveEm, tag, moremoves)\n    def moveInSquares(self, tag):\n        allmoves = [(+20, 0), (0, +20), (\u221220, 0), (0, \u221220)] * 5\n        self.moveEm(tag, allmoves)\nif __name__ == '__main__':\n    CanvasEventsDemo()\n    mainloop()\nThis version inherits the drawing customizations of the prior, but lets you make both\novals and rectangles move at the same time\u2014drag out a few ovals and rectangles, and\nthen press \u201co\u201d and then \u201cr\u201d right away to make this go. In fact, try pressing both keys\na few times; the more you press, the more the objects move, because multiple scheduled\nevents are firing and moving objects from wherever they happen to be positioned. If\nyou drag out a new shape during a move, it starts moving immediately as before.\nUsing multiple time.sleep loop threads\nRunning animations in threads can sometimes achieve the same effect. As discussed\nearlier, it can be dangerous to update the screen from a spawned thread in general, but\nit works in this example (on the test platform used, at least). Example 9-32 runs each\nanimation task as an independent and parallel thread. That is, each time you press the\n\u201co\u201d or \u201cr\u201d key to start an animation, a new thread is spawned to do the work.\nExample 9-32. PP4E\\Gui\\Tour\\canvasDraw_tags_thread.py\n\"\"\"\nsimilar, but run time.sleep loops in parallel with threads, not after() events\nor single active time.sleep loop; because threads run in parallel, this also\nallows ovals and rectangles to be moving at the _same_ time and does not require\nupdate calls to refresh the GUI: in fact, calling .update() once made this crash\nbadly, though some canvas calls must be thread safe or this wouldn't work at all;\n\"\"\"\n592 | Chapter 9:\u2002A tkinter Tour, Part 2from tkinter import *\nimport canvasDraw_tags\nimport _thread, time\nclass CanvasEventsDemo(canvasDraw_tags.CanvasEventsDemo):\n    def moveEm(self, tag):\n        for i in range(5):\n            for (diffx, diffy) in [(+20, 0), (0, +20), (\u221220, 0), (0, \u221220)]:\n                self.canvas.move(tag, diffx, diffy)\n                time.sleep(0.25)                      # pause this thread only\n    def moveInSquares(self, tag):\n        _thread.start_new_thread(self.moveEm, (tag,))\nif __name__ == '__main__':\n    CanvasEventsDemo()\n    mainloop()\nThis version lets you move shapes at the same time, just like Example 9-31, but this\ntime it\u2019s a reflection of threads running in parallel. In fact, this uses the same scheme\nas the first time.sleep version. Here, though, there is more than one active thread of\ncontrol, so move handlers can overlap in time\u2014time.sleep blocks only the calling\nthread, not the program at large.\nThis example works on Windows today, but it failed on Linux at one point in this\nbook\u2019s lifetime\u2014the screen was not updated as threads changed it, so you couldn\u2019t see\nany changes until later GUI events. The usual rule of thumb about avoiding GUI up-\ndates in spawned threads laid out earlier still holds true. It is usually safer to have your\nthreads do number crunching only and let the main thread (the one that built the GUI)\nhandle any screen updates. Even under this model, though, the main thread can still\nuse after event loops like that of Example 9-31 to watch for results from worker threads\nto appear without being blocked while waiting (more on this in the next section and\nchapter).\nParts of this story are implementation details prone to change over time, and it\u2019s not\nimpossible that GUI updates in threads may be better supported by tkinter in the future,\nso be sure to explore the state of threading in future releases for more details.\nOther Animation Topics\nWe\u2019ll revisit animation in Chapter 11\u2019s PyDraw example; there, all three of the tech-\nniques we just met\u2014sleeps, timers, and threads\u2014will be resurrected to move shapes,\ntext, and photos to arbitrary spots on a canvas marked with a mouse click. And although\nthe canvas widget\u2019s absolute coordinate system makes it the workhorse of most non-\ntrivial animations, tkinter animation in general is limited mostly by your imagination.\nIn closing, here are a few more words on the topic to hint at the possibilities.\nTime Tools, Threads, and Animation | 593Other animation effects\nBesides canvas-based animations, widget configuration tools support a variety of ani-\nmation effects. For example, as we saw in the flashing and hiding alarm scripts earlier\n(see Example 9-28), it is also easy to change the appearance of other kinds of widgets\ndynamically with after timer-event loops. With timer-based loops, you can periodi-\ncally flash widgets, completely erase and redraw widgets and windows on the fly, re-\nverse or change widget colors, and so on. See \u201cFor a Good Time\u2026\u201d on page 51 for\nanother example in this category which changes fonts and colors on the fly (albeit, with\nquestionable ergonomic intentions).\nThreads and animation\nTechniques for running long-running tasks in parallel threads become more important\nif animations must remain active while your program waits. For instance, imagine a\nprogram that spends minutes downloading data from a network, calculating the output\nof a numeric model, or performing other long-running tasks. If such a program\u2019s GUI\nmust display an animation or otherwise show progress while waiting for the task, it can\ndo so by either altering a widget\u2019s appearance or by moving objects in a canvas peri-\nodically\u2014simply use the after method to wake up intermittently to modify the GUI\nas we\u2019ve seen. A progress bar or counter, for instance, may be updated during after\ntimer-event handling.\nIn addition, though, the long-running task itself will likely have to be run in a spawned\nparallel thread so that your GUI remains active and performs the animation during the\nwait. Otherwise, no GUI updates will occur until the task returns control to the GUI.\nDuring after timer-event processing, the main GUI thread might check variables or\nobjects set by the long-running task\u2019s thread to determine completion or progress.\nEspecially if more than one long-running task may be active at the same time, the\nspawned thread might also communicate with the GUI thread by storing information\nin a Python Queue object, to be picked up and handled by the GUI during after events.\nFor generality, the Queue might even contain function objects that are run by the GUI\nto update the display.\nAgain, we\u2019ll study such threaded GUI programming and communication techniques\nin Chapter 10, and employ them in the PyMailGUI example later in the book. For now,\nkeep in mind that spawning computational tasks in threads can allow the GUI itself to\nboth perform animations and remain active in general during wait states.\nGraphics and gaming toolkits\nUnless you stopped playing video games shortly after the ascent of Pong, you probably\nalso know that the sorts of movement and animation techniques shown in this chapter\nand book are suitable for some simple game-like programs, but not all. For more de-\nmanding tasks, Python also has additional graphics and gaming support we haven\u2019t\nstudied here.\n594 | Chapter 9:\u2002A tkinter Tour, Part 2For more advanced 3-D animation needs, also see the support in the PIL extension\npackage for common animation and movie file formats such as FLI and MPEG. Other\nthird-party toolkits such as OpenGL, Blender, PyGame, Maya, and VPython provide\neven higher-level graphics and animation toolkits. The PyOpenGL system also offers\nTk support for GUIs. See the PyPI websites for links or search the Web.\nIf you\u2019re interest in gaming specifically, PyGame and other packages support game\ndevelopment in Python, and other books and web resources focus on this topic. Al-\nthough Python is not widely used as the sole implementation language of graphics-\nintensive game programs, it is used as both a prototyping and a scripting language for\nsuch products.\u2021 When integrated with 3D graphics libraries, it can serve even broader\nroles. See http://www.python.org for links to available extensions in this domain.\nThe End of the Tour\nAnd that\u2019s a wrap for our tour of the tkinter library. You've now seen all the core widgets\nand tools previewed in Chapter 7 (flip back for a summary of territory covered on this\ntour). For more details, watch for all of the tools introduced here to appear again in the\nadvanced GUI techniques in Chapter 10, the larger GUI examples in Chapter 11, and\nthe remainder of the book at large. To some extent, the last few chapters have laid the\ngroundwork needed to step up to the larger programs that follow.\nOther Widgets and Options\nI should point out, though, that this story is still not quite complete. Although we\u2019ve\ncovered the entire basic tkinter widget arsenal and mastered GUI fundamentals along\nthe way, we\u2019ve skipped a handful of newer and more advanced widgets introduced to\ntkinter recently:\nSpinbox\nAn Entry used to select among a set or range of values\nLabelFrame\nA Frame with a border and title around a group of items\nPanedWindow\nA geometry manager widget containing multiple widgets that can be resized by\nmoving separator lines with the mouse\n\u2021 Perhaps most prominently today, the popular Eve Online game uses Python for scripting and much of the\nfunctionality\u2014both on the server and the client. It uses the Stackless Python implementation to boost\nmassively parallel multitasking responsiveness. Other notable game companies using Python include the\nmakers of Civilization IV, and the now-defunct Origin Systems (at last report, its game Ultima Online II was\nto use Python for scripting its animation).\nThe End of the Tour | 595Moreover, we haven\u2019t even mentioned any of the higher-level widgets available in the\npopular Pmw, Tix, or ttk extension packages for tkinter (described in Chapter 7) or\nany other third-party packages in general. For instance:\n\u2022 Tix and ttk both provide additional widget options outlined in Chapter 7, which\nare now part of Python\u2019s standard library.\n\u2022 The third-party domain tends to change over time, but has hosted tree widgets,\nHTML viewers, font selection dialogs, tables, and much more for tkinter, and in-\ncludes the Pmw megawidget set.\n\u2022 Many tkinter programs such as Python\u2019s standard IDLE development GUI include\nfont dialogs, tree widgets, and more that you may be able to use in your own\napplications.\nBecause such extensions are too complex for us to cover in a useful fashion here,\nthough, we\u2019ll defer to other resources in the interest of space. To sample richer options\nfor your GUI scripts, be sure to consult tkinter, Tk, Tix, ttk, and Pmw documentation\nfor more details on additional widgets, and visit the PyPI website at http://python.org/\nor search the Web for other third-party tkinter extensions.\nI should also mention that there are more widget configuration options than we have\nmet on this tour. Consult Tk and tkinter resources for options not listed explicitly here.\nAlthough other tkinter tools are analogous to those presented here, the space I have for\nillustrating additional widgets and options in this book is limited by both my publisher\nand the finite nature of trees.\n596 | Chapter 9:\u2002A tkinter Tour, Part 2", "10": "CHAPTER 10\nGUI Coding Techniques\n\u201cBuilding a Better Mousetrap\u201d\nThis chapter continues our look at building GUIs with Python and the tkinter library \nby presenting a collection of more advanced GUI programming patterns and techni-\nques. In the preceding three chapters, we explored all the fundamentals of tkinter itself. \nHere, our goal is to put them to work to add higher-level structures that will be useful \nin larger programs. That is, our focus shifts here to writing code of our own which \nimplements utility above and beyond the basic tkinter toolkit\u2014utility that we\u2019ll ac-\ntually find useful in more complete examples later in the book.\nSome of the techniques we will be studying in this chapter are as follows:\n\u2022 Providing common GUI operations in \u201cmixin\u201d classes\n\u2022 Building menus and toolbars from data structure templates\n\u2022 Adding GUI interfaces to command-line tools\n\u2022 Redirecting input and output streams to GUI widgets\n\u2022 Reloading GUI callback handlers on the fly\n\u2022 Wrapping up and automating top-level window interfaces\n\u2022 Using threads and queues to avoiding blocking in GUIs\n\u2022 Popping up GUI windows on demand from non-GUI programs\n\u2022 Adding GUIs as separate programs with sockets and pipes\nAs with other chapters in this book, this chapter has a dual agenda\u2014not only will we \nbe studying GUI programming, but we\u2019ll also be learning more about general Python \ndevelopment concepts such as object-oriented programming (OOP) and code reuse. \nAs we\u2019ll see, by coding GUI tools in Python, it\u2019s easy to apply them in a wide variety \nof contexts and programs.\nAs a segue to the next chapter, this one also closes with a look at the PyDemos and \nPyGadgets launcher toolbars\u2014GUIs used to start larger GUI examples. Although most\n597of their code is external to this book, we\u2019ll explore enough of their structure to help\nyou study them in the examples distribution package.\nTwo notes before we begin: first, be sure to read the code listings in this chapter for\ndetails we won\u2019t present in the narrative. Second, although small examples that apply\nin this chapter\u2019s techniques will show up along the way, more realistic application will\nhave to await more realistic programs. We\u2019ll put these techniques to use in the larger\nexamples in the next chapter and throughout the rest of the book. In fact, we\u2019ll be\nreusing the modules we develop here often, as tools in other programs in this book;\nreusable software wants to be reused. First, though, let\u2019s do what our species does best\nand build some tools.\nGuiMixin: Common Tool Mixin Classes\nIf you read the last three chapters, you probably noticed that the code used to construct\nnontrivial GUIs can become long if we make each widget by hand. Not only do we have\nto link up all the widgets manually, but we also need to remember and then set dozens\nof options. If we stick to this strategy, GUI programming often becomes an exercise in\ntyping, or at least in cut-and-paste text editor operations.\nWidget Builder Functions\nInstead of performing each step by hand, a better idea is to wrap or automate as much\nof the GUI construction process as possible. One approach is to code functions that\nprovide typical widget configurations, and automate the construction process for cases\nto which they apply. For instance, we could define a button function to handle con-\nfiguration and packing details and support most of the buttons we draw. Exam-\nple 10-1 provides a handful of such widget builder calls.\nExample 10-1. PP4E\\Gui\\Tools\\widgets.py\n\"\"\"\n###############################################################################\nwrap up widget construction in functions for easier use, based upon some\nassumptions (e.g., expansion); use **extras fkw args for width, font/color,\netc., and repack result manually later to override defaults if needed;\n###############################################################################\n\"\"\"\nfrom tkinter import *\ndef frame(root, side=TOP, **extras):\n    widget = Frame(root)\n    widget.pack(side=side, expand=YES, fill=BOTH)\n    if extras: widget.config(**extras)\n    return widget\n598 | Chapter 10:\u2002GUI Coding Techniquesdef label(root, side, text, **extras):\n    widget = Label(root, text=text, relief=RIDGE)        # default config\n    widget.pack(side=side, expand=YES, fill=BOTH)        # pack automatically\n    if extras: widget.config(**extras)                   # apply any extras\n    return widget\ndef button(root, side, text, command, **extras):\n    widget = Button(root, text=text, command=command)\n    widget.pack(side=side, expand=YES, fill=BOTH)\n    if extras: widget.config(**extras)\n    return widget\ndef entry(root, side, linkvar, **extras):\n    widget = Entry(root, relief=SUNKEN, textvariable=linkvar)\n    widget.pack(side=side, expand=YES, fill=BOTH)\n    if extras: widget.config(**extras)\n    return widget\nif __name__ == '__main__':\n    app = Tk()\n    frm = frame(app, TOP)               # much less code required here!\n    label(frm, LEFT, 'SPAM')\n    button(frm, BOTTOM, 'Press', lambda: print('Pushed'))\n    mainloop()\nThis module makes some assumptions about its clients\u2019 use cases, which allows it to\nautomate typical construction chores such as packing. The net effect is to reduce the\namount of code required of its importers. When run as a script, Example 10-1 creates\na simple window with a ridged label on the left and a button on the right that prints a\nmessage when pressed, both of which expand along with the window. Run this on your\nown for a look; its window isn\u2019t really anything new for us, and its code is meant more\nas library than script\u2014as we\u2019ll see when we make use of it later in Chapter 19\u2019s PyCalc.\nThis function-based approach can cut down on the amount of code required. As func-\ntions, though, its tools don\u2019t lend themselves to customization in the broader OOP\nsense. Moreover, because they are not methods, they do not have access to the state of\nan object representing the GUI.\nMixin Utility Classes\nAlternatively, we can implement common methods in a class and inherit them every-\nwhere they are needed. Such classes are commonly called mixin classes because their\nmethods are \u201cmixed in\u201d with other classes. Mixins serve to package generally useful\ntools as methods. The concept is almost like importing a module, but mixin classes can\naccess the subject instance, self, to utilize both per-instance state and inherited meth-\nods. The script in Example 10-2 shows how.\nGuiMixin: Common Tool Mixin Classes | 599Example 10-2. PP4E\\Gui\\Tools\\guimixin.py\n\"\"\"\n###############################################################################\na \"mixin\" class for other frames: common methods for canned dialogs,\nspawning programs, simple text viewers, etc; this class must be mixed\nwith a Frame (or a subclass derived from Frame) for its quit method\n###############################################################################\n\"\"\"\nfrom tkinter import *\nfrom tkinter.messagebox import *\nfrom tkinter.filedialog import *\nfrom PP4E.Gui.Tour.scrolledtext import ScrolledText     # or tkinter.scrolledtext\nfrom PP4E.launchmodes import PortableLauncher, System   # or use multiprocessing\nclass GuiMixin:\n    def infobox(self, title, text, *args):              # use standard dialogs\n        return showinfo(title, text)                    # *args for bkwd compat\n    def errorbox(self, text):\n        showerror('Error!', text)\n    def question(self, title, text, *args):\n        return askyesno(title, text)                    # return True or False\n    def notdone(self):\n        showerror('Not implemented', 'Option not available')\n    def quit(self):\n        ans = self.question('Verify quit', 'Are you sure you want to quit?')\n        if ans:\n            Frame.quit(self)                            # quit not recursive!\n    def help(self):\n        self.infobox('RTFM', 'See figure 1...')         # override this better\n    def selectOpenFile(self, file=\"\", dir=\".\"):         # use standard dialogs\n        return askopenfilename(initialdir=dir, initialfile=file)\n    def selectSaveFile(self, file=\"\", dir=\".\"):\n        return asksaveasfilename(initialfile=file, initialdir=dir)\n    def clone(self, args=()):              # optional constructor args\n        new = Toplevel()                   # make new in-process version of me\n        myclass = self.__class__           # instance's (lowest) class object\n        myclass(new, *args)                # attach/run instance to new window\n    def spawn(self, pycmdline, wait=False):\n        if not wait:                                     # start new process\n            PortableLauncher(pycmdline, pycmdline)()     # run Python progam\n        else:\n            System(pycmdline, pycmdline)()               # wait for it to exit\n    def browser(self, filename):\n        new  = Toplevel()                                # make new window\n600 | Chapter 10:\u2002GUI Coding Techniquesview = ScrolledText(new, file=filename)          # Text with Scrollbar\n        view.text.config(height=30, width=85)            # config Text in Frame\n        view.text.config(font=('courier', 10, 'normal')) # use fixed-width font\n        new.title(\"Text Viewer\")                         # set window mgr attrs\n        new.iconname(\"browser\")                          # file text added auto\n    \"\"\"\n    def browser(self, filename):                         # if tkinter.scrolledtext\n        new  = Toplevel()                                # included for reference\n        text = ScrolledText(new, height=30, width=85)\n        text.config(font=('courier', 10, 'normal'))\n        text.pack(expand=YES, fill=BOTH)\n        new.title(\"Text Viewer\")\n        new.iconname(\"browser\")\n        text.insert('0.0', open(filename, 'r').read() )\n    \"\"\"\nif __name__ == '__main__':\n    class TestMixin(GuiMixin, Frame):      # standalone test\n        def __init__(self, parent=None):\n            Frame.__init__(self, parent)\n            self.pack()\n            Button(self, text='quit',  command=self.quit).pack(fill=X)\n            Button(self, text='help',  command=self.help).pack(fill=X)\n            Button(self, text='clone', command=self.clone).pack(fill=X)\n            Button(self, text='spawn', command=self.other).pack(fill=X)\n        def other(self):\n            self.spawn('guimixin.py')  # spawn self as separate process\n    TestMixin().mainloop()\nAlthough Example 10-2 is geared toward GUIs, it\u2019s really about design concepts. The\nGuiMixin class implements common operations with standard interfaces that are im-\nmune to changes in implementation. In fact, the implementations of some of this class\u2019s\nmethods did change\u2014between the first and second editions of this book, old-style\nDialog calls were replaced with the new Tk standard dialog calls; in the fourth edition,\nthe file browser was updated to use a different scrolled text class. Because this class\u2019s\ninterface hides such details, its clients did not have to be changed to use the new\ntechniques.\nAs is, GuiMixin provides methods for common dialogs, window cloning, program\nspawning, text file browsing, and so on. We can add more methods to such a mixin\nlater if we find ourselves coding the same methods repeatedly; they will all become\navailable immediately everywhere this class is imported and mixed. Moreover, Gui\nMixin\u2019s methods can be inherited and used as is, or they can be redefined in subclasses.\nSuch are the natural advantages of classes over functions.\nGuiMixin: Common Tool Mixin Classes | 601There are a few details worth highlighting here:\n\u2022 The quit method serves some of the same purpose as the reusable Quitter button\nwe used in earlier chapters. Because mixin classes can define a large library of\nreusable methods, they can be a more powerful way to package reusable compo-\nnents than individual classes. If the mixin is packaged well, we can get a lot more\nfrom it than a single button\u2019s callback.\n\u2022 The clone method makes a new in-process copy, in a new top-level window, of the\nmost specific class that mixes in a GuiMixin (self.__class__ is the class object that\nthe instance was created from). Assuming that the class requires no constructor\narguments other than a parent container, this opens a new independent copy of\nthe window (pass in any extra constructor arguments required).\n\u2022 The browser method opens the ScrolledText object we wrote in Chapter 9 in a new\nwindow and fills it with the text of a file to be viewed. As noted in the preceding\nchapter, there is also a ScrolledText widget in standard library module\ntkinter.scrolledtext, but its interface differs, it does not load a file automatically,\nand it is prone to becoming deprecated (though it hasn\u2019t over many years). For\nreference, its alternative code is included.\n\u2022 The spawn method launches a Python program command line as a new independent\nprocess and waits for it to end or not (depending on the default False wait\nargument\u2014GUIs usually shouldn\u2019t wait). This method is simple, though, because\nwe wrapped launching details in the launchmodes module presented at the end of\nChapter 5. GuiMixin both fosters and practices good code reuse habits.\nThe GuiMixin class is meant to be a library of reusable tool methods and is essentially\nuseless by itself. In fact, it must generally be mixed with a Frame-based class to be used:\nquit assumes it\u2019s mixed with a Frame, and clone assumes it\u2019s mixed with a widget class.\nTo satisfy such constraints, this module\u2019s self-test code at the bottom combines Gui\nMixin with a Frame widget.\nFigure 10-1 shows the scene created by the module\u2019s self-test after pressing \u201cclone\u201d and\n\u201cspawn\u201d once each, and then \u201chelp\u201d in one of the three copies. Because they are separate\nprocesses, windows started with \u201cspawn\u201d keep running after other windows are closed\nand do not impact other windows when closed themselves; a \u201cclone\u201d window is in-\nprocess instead\u2014it is closed with others, but its \u201cX\u201d destroys just itself. Make sure your\nPYTHONPATH includes the PP4E directory\u2019s container for the cross-directory pack-\nage imports in this example and later examples which use it.\nWe\u2019ll see GuiMixin show up again as a mixin in later examples; that\u2019s the whole point\nof code reuse, after all. Although functions are often useful, classes support inheritance\nand access to instance state, and provide an extra organizational structure\u2014features\nthat are especially useful given the coding requirements of GUIs. For instance, many\nof GuiMixin\u2019s methods could be replaced with simple functions, but clone and quit\ncould not. The next section carries these talents of mixin classes even further.\n602 | Chapter 10:\u2002GUI Coding TechniquesGuiMaker: Automating Menus and Toolbars\nThe last section\u2019s mixin class makes common tasks simpler, but it still doesn\u2019t address\nthe complexity of linking up widgets such as menus and toolbars. Of course, if we had\naccess to a GUI layout tool that generates Python code, this would not be an issue, at\nleast for some of the more static interfaces we may require. We\u2019d design our widgets\ninteractively, press a button, and fill in the callback handler blanks.\nEspecially for a relatively simple toolkit like tkinter, though, a programming-based\napproach can often work just as well. We\u2019d like to be able to inherit something that\ndoes all the grunt work of construction for us, given a template for the menus and\ntoolbars in a window. Here\u2019s one way it can be done\u2014using trees of simple objects.\nThe class in Example 10-3 interprets data structure representations of menus and tool-\nbars and builds all the widgets automatically.\nExample 10-3. PP4E\\Gui\\Tools\\guimaker.py\n\"\"\"\n###############################################################################\nAn extended Frame that makes window menus and toolbars automatically.\nUse GuiMakerFrameMenu for embedded components (makes frame-based menus).\nUse GuiMakerWindowMenu for top-level windows (makes Tk8.0 window menus).\nSee the self-test code (and PyEdit) for an example layout tree format.\n###############################################################################\n\"\"\"\nimport sys\nfrom tkinter import *                     # widget classes\nfrom tkinter.messagebox import showinfo\nclass GuiMaker(Frame):\n    menuBar    = []                       # class defaults\nFigure 10-1. GuiMixin self-test code in action\nGuiMaker: Automating Menus and Toolbars | 603toolBar    = []                       # change per instance in subclasses\n    helpButton = True                     # set these in start() if need self\n    def __init__(self, parent=None):\n        Frame.__init__(self, parent)\n        self.pack(expand=YES, fill=BOTH)        # make frame stretchable\n        self.start()                            # for subclass: set menu/toolBar\n        self.makeMenuBar()                      # done here: build menu bar\n        self.makeToolBar()                      # done here: build toolbar\n        self.makeWidgets()                      # for subclass: add middle part\n    def makeMenuBar(self):\n        \"\"\"\n        make menu bar at the top (Tk8.0 menus below)\n        expand=no, fill=x so same width on resize\n        \"\"\"\n        menubar = Frame(self, relief=RAISED, bd=2)\n        menubar.pack(side=TOP, fill=X)\n        for (name, key, items) in self.menuBar:\n            mbutton  = Menubutton(menubar, text=name, underline=key)\n            mbutton.pack(side=LEFT)\n            pulldown = Menu(mbutton)\n            self.addMenuItems(pulldown, items)\n            mbutton.config(menu=pulldown)\n        if self.helpButton:\n            Button(menubar, text    = 'Help',\n                            cursor  = 'gumby',\n                            relief  = FLAT,\n                            command = self.help).pack(side=RIGHT)\n    def addMenuItems(self, menu, items):\n        for item in items:                     # scan nested items list\n            if item == 'separator':            # string: add separator\n                menu.add_separator({})\n            elif type(item) == list:           # list: disabled item list\n                for num in item:\n                    menu.entryconfig(num, state=DISABLED)\n            elif type(item[2]) != list:\n                menu.add_command(label     = item[0],         # command:\n                                 underline = item[1],         # add command\n                                 command   = item[2])         # cmd=callable\n            else:\n                pullover = Menu(menu)\n                self.addMenuItems(pullover, item[2])          # sublist:\n                menu.add_cascade(label     = item[0],         # make submenu\n                                 underline = item[1],         # add cascade\n                                 menu      = pullover)\n    def makeToolBar(self):\n        \"\"\"\n        make button bar at bottom, if any\n        expand=no, fill=x so same width on resize\n        this could support images too: see Chapter 9,\n604 | Chapter 10:\u2002GUI Coding Techniqueswould need prebuilt gifs or PIL for thumbnails\n        \"\"\"\n        if self.toolBar:\n            toolbar = Frame(self, cursor='hand2', relief=SUNKEN, bd=2)\n            toolbar.pack(side=BOTTOM, fill=X)\n            for (name, action, where) in self.toolBar:\n                Button(toolbar, text=name, command=action).pack(where)\n    def makeWidgets(self):\n        \"\"\"\n        make 'middle' part last, so menu/toolbar\n        is always on top/bottom and clipped last;\n        override this default, pack middle any side;\n        for grid: grid middle part in a packed frame\n        \"\"\"\n        name = Label(self,\n                     width=40, height=10,\n                     relief=SUNKEN, bg='white',\n                     text   = self.__class__.__name__,\n                     cursor = 'crosshair')\n        name.pack(expand=YES, fill=BOTH, side=TOP)\n    def help(self):\n        \"override me in subclass\"\n        showinfo('Help', 'Sorry, no help for ' + self.__class__.__name__)\n    def start(self):\n        \"override me in subclass: set menu/toolbar with self\"\n        pass\n###############################################################################\n# Customize for Tk 8.0 main window menu bar, instead of a frame\n###############################################################################\nGuiMakerFrameMenu = GuiMaker           # use this for embedded component menus\nclass GuiMakerWindowMenu(GuiMaker):    # use this for top-level window menus\n    def makeMenuBar(self):\n        menubar = Menu(self.master)\n        self.master.config(menu=menubar)\n        for (name, key, items) in self.menuBar:\n            pulldown = Menu(menubar)\n            self.addMenuItems(pulldown, items)\n            menubar.add_cascade(label=name, underline=key, menu=pulldown)\n        if self.helpButton:\n            if sys.platform[:3] == 'win':\n                menubar.add_command(label='Help', command=self.help)\n            else:\n                pulldown = Menu(menubar)  # Linux needs real pull down\n                pulldown.add_command(label='About', command=self.help)\n                menubar.add_cascade(label='Help', menu=pulldown)\nGuiMaker: Automating Menus and Toolbars | 605###############################################################################\n# Self-test when file run standalone: 'python guimaker.py'\n###############################################################################\nif __name__ == '__main__':\n    from guimixin import GuiMixin            # mix in a help method\n    menuBar = [\n        ('File', 0,\n            [('Open',  0, lambda:0),         # lambda:0 is a no-op\n             ('Quit',  0, sys.exit)]),       # use sys, no self here\n        ('Edit', 0,\n            [('Cut',   0, lambda:0),\n             ('Paste', 0, lambda:0)]) ]\n    toolBar = [('Quit', sys.exit, {'side': LEFT})]\n    class TestAppFrameMenu(GuiMixin, GuiMakerFrameMenu):\n        def start(self):\n            self.menuBar = menuBar\n            self.toolBar = toolBar\n    class TestAppWindowMenu(GuiMixin, GuiMakerWindowMenu):\n        def start(self):\n            self.menuBar = menuBar\n            self.toolBar = toolBar\n    class TestAppWindowMenuBasic(GuiMakerWindowMenu):\n        def start(self):\n            self.menuBar = menuBar\n            self.toolBar = toolBar    # guimaker help, not guimixin\n    root = Tk()\n    TestAppFrameMenu(Toplevel())\n    TestAppWindowMenu(Toplevel())\n    TestAppWindowMenuBasic(root)\n    root.mainloop()\nTo make sense of this module, you have to be familiar with the menu fundamentals\nintroduced in Chapter 9. If you are, though, it\u2019s straightforward\u2014the GuiMaker class\nsimply traverses the menu and toolbar structures and builds menu and toolbar widgets\nalong the way. This module\u2019s self-test code includes a simple example of the data\nstructures used to lay out menus and toolbars:\nMenu bar templates\nLists and nested sublists of (label, underline, handler) triples. If a handler is a\nsublist rather than a function or method, it is assumed to be a cascading submenu.\nToolbar templates\nList of (label, handler, pack-options) triples. pack-options is coded as a dictionary\nof options passed on to the widget pack method; we can code these as {'k':v}\nliterals, or with the dict(k=v) call\u2019s keyword syntax. pack accepts a dictionary ar-\ngument, but we could also transform the dictionary into individual keyword\n606 | Chapter 10:\u2002GUI Coding Techniquesarguments by using Python\u2019s func(**kargs) call syntax. As is, labels are assumed\nto be text, but images could be supported too (see the note under \u201cBigGui: A Client\nDemo Program\u201d on page 609).\nFor variety, the mouse cursor changes based upon its location: a hand in the toolbar,\ncrosshairs in the default middle part, and something else over Help buttons of frame-\nbased menus (customize as desired).\nSubclass Protocols\nIn addition to menu and toolbar layouts, clients of this class can also tap into and\ncustomize the method and geometry protocols the class implements:\nTemplate attributes\nClients of this class are expected to set menuBar and toolBar attributes somewhere\nin the inheritance chain by the time the start method has finished.\nInitialization\nThe start method can be overridden to construct menu and toolbar templates\ndynamically, since self is available when it is called; start is also where general\ninitializations should be performed\u2014GuiMixin\u2019s __init__ constructor must be run,\nnot overridden.\nAdding widgets\nThe makeWidgets method can be redefined to construct the middle part of the win-\ndow\u2014the application portion between the menu bar and the toolbar. By default,\nmakeWidgets adds a label in the middle with the name of the most specific class,\nbut this method is expected to be specialized.\nPacking protocol\nIn a specialized makeWidgets method, clients may attach their middle portion\u2019s\nwidgets to any side of self (a Frame) since the menu and toolbars have already\nclaimed the container\u2019s top and bottom by the time makeWidgets is run. The middle\npart does not need to be a nested frame if its parts are packed. The menu and\ntoolbars are also automatically packed first so that they are clipped last if the win-\ndow shrinks.\nGridding protocol\nThe middle part can contain a grid layout, as long as it is gridded in a nested\nFrame that is itself packed within the self parent. (Remember that each container\nlevel may use grid or pack, not both, and that self is a Frame with already packed\nbars by the time makeWidgets is called.) Because the GuiMaker Frame packs itself\nwithin its parent, it is not directly embeddable in a container with widgets arranged\nin a grid, for similar reasons; add an intermediate gridded Frame to use it in this\ncontext.\nGuiMaker: Automating Menus and Toolbars | 607GuiMaker Classes\nIn return for conforming to GuiMaker protocols and templates, client subclasses get a \nFrame that knows how to automatically build up its own menus and toolbars from \ntemplate data structures. If you read the preceding chapter\u2019s menu examples, you \nprobably know that this is a big win in terms of reduced coding requirements. Gui\nMaker is also clever enough to export interfaces for both menu styles that we met in \nChapter 9:\nGuiMakerWindowMenu\nImplements Tk 8.0-style top-level window menus, useful for menus associated \nwith standalone programs and pop ups.\nGuiMakerFrameMenu\nImplements alternative Frame/Menubutton-based menus, useful for menus on ob-\njects embedded as components of a larger GUI.\nBoth classes build toolbars, export the same protocols, and expect to find the same \ntemplate structures; they differ only in the way they process menu templates. In fact, \none is simply a subclass of the other with a specialized menu maker method\u2014only top-\nlevel menu processing differs between the two styles (a Menu with Menu cascades rather \nthan a Frame with Menubuttons).\nGuiMaker Self-Test\nLike GuiMixin, when we run Example 10-3 as a top-level program, we trigger the self-\ntest logic at the bottom of its file; Figure 10-2 shows the windows we get. Three windows \ncome up, representing each of the self-test code\u2019s TestApp classes. All three have a menu \nand toolbar with the options specified in the template data structures created in the \nself-test code: File and Edit menu pull downs, plus a Quit toolbar button and a standard \nHelp menu button. In the screenshot, one window\u2019s File menu has been torn off and \nthe Edit menu of another is being pulled down; the lower window was resized for effect.\nGuiMaker can be mixed in with other superclasses, but it\u2019s primarily intended to serve \nthe same extending and embedding roles as a tkinter Frame widget class (which makes \nsense, given that it\u2019s really just a customized Frame with extra construction protocols). \nIn fact, its self-test combines a GuiMaker frame with the prior section\u2019s GuiMixin tools \npackage class.\nBecause of the superclass relationships coded, two of the three windows get their \nhelp callback handler from GuiMixin; TestAppWindowMenuBasic gets GuiMaker\u2019s instead. \nNotice that the order in which these two classes are mixed can be important: because \nboth GuiMixin and Frame define a quit method, we need to list the class from which we \nwant to get it first in the mixed class\u2019s header line due to the left-to-right search rule of \nmultiple inheritance. To select GuiMixin\u2019s methods, it should usually be listed before a \nsuperclass derived from real widgets.\n608 | Chapter 10:\u2002GUI Coding TechniquesWe\u2019ll put GuiMaker to more practical use in instances such as the PyEdit example in\nChapter 11. The next section shows another way to use GuiMaker\u2019s templates to build\nup a sophisticated interface, and serves as another test of its functionality.\nBigGui: A Client Demo Program\nLet\u2019s look at a program that makes better use of the two automation classes we just\nwrote. In the module in Example 10-4, the Hello class inherits from both GuiMixin and\nGuiMaker. GuiMaker provides the link to the Frame widget, plus the menu/toolbar con-\nstruction logic. GuiMixin provides extra common-behavior methods. Really, Hello is\nanother kind of extended Frame widget because it is derived from GuiMaker. To get a\nmenu and toolbar for free, it simply follows the protocols defined by GuiMaker\u2014it sets\nthe menuBar and toolBar attributes in its start method, and overrides makeWidgets to\nput a custom label in the middle.\nExample 10-4. PP4E\\Gui\\Tools\\big_gui.py\n\"\"\"\nGUI demo implementation - combines maker, mixin, and this\n\"\"\"\nimport sys, os\nfrom tkinter import *                        # widget classes\nfrom PP4E.Gui.Tools.guimixin import *        # mix-in methods: quit, spawn, etc.\nfrom PP4E.Gui.Tools.guimaker import *        # frame, plus menu/toolbar builder\nFigure 10-2. GuiMaker self-test at work\nGuiMaker: Automating Menus and Toolbars | 609class Hello(GuiMixin, GuiMakerWindowMenu):   # or GuiMakerFrameMenu\n    def start(self):\n        self.hellos = 0\n        self.master.title(\"GuiMaker Demo\")\n        self.master.iconname(\"GuiMaker\")\n        def spawnme(): self.spawn('big_gui.py')        # defer call vs lambda\n        self.menuBar = [                               # a tree: 3 pull downs\n          ('File', 0,                                  # (pull-down)\n              [('New...',  0, spawnme),\n               ('Open...', 0, self.fileOpen),          # [menu items list]\n               ('Quit',    0, self.quit)]              # label,underline,action\n          ),\n          ('Edit', 0,\n              [('Cut',    \u22121, self.notdone),           # no underline|action\n               ('Paste',  \u22121, self.notdone),           # lambda:0 works too\n               'separator',                            # add a separator\n               ('Stuff',  \u22121,\n                   [('Clone', \u22121, self.clone),         # cascaded submenu\n                    ('More',  \u22121, self.more)]\n               ),\n               ('Delete', \u22121, lambda:0),\n               [5]]                                    # disable 'delete'\n          ),\n          ('Play', 0,\n              [('Hello',     0, self.greeting),\n               ('Popup...',  0, self.dialog),\n               ('Demos',     0,\n                  [('Toplevels', 0,\n                       lambda: self.spawn(r'..\\Tour\\toplevel2.py')),\n                   ('Frames',    0,\n                       lambda: self.spawn(r'..\\Tour\\demoAll-frm-ridge.py')),\n                   ('Images',    0,\n                       lambda: self.spawn(r'..\\Tour\\buttonpics.py')),\n                   ('Alarm',     0,\n                       lambda: self.spawn(r'..\\Tour\\alarm.py', wait=False)),\n                   ('Other...', \u22121, self.pickDemo)]\n               )]\n          )]\n        self.toolBar = [                                     # add 3 buttons\n          ('Quit',  self.quit,     dict(side=RIGHT)),        # or {'side': RIGHT}\n          ('Hello', self.greeting, dict(side=LEFT)),\n          ('Popup', self.dialog,   dict(side=LEFT, expand=YES)) ]\n    def makeWidgets(self):                                   # override default\n        middle = Label(self, text='Hello maker world!',      # middle of window\n                       width=40, height=10,\n                       relief=SUNKEN, cursor='pencil', bg='white')\n        middle.pack(expand=YES, fill=BOTH)\n    def greeting(self):\n        self.hellos += 1\n610 | Chapter 10:\u2002GUI Coding Techniquesif self.hellos % 3:\n            print(\"hi\")\n        else:\n            self.infobox(\"Three\", 'HELLO!')    # on every third press\n    def dialog(self):\n        button = self.question('OOPS!',\n                               'You typed \"rm*\" ... continue?',  # old style\n                               'questhead', ('yes', 'no'))       # args ignored\n        [lambda: None, self.quit][button]()\n    def fileOpen(self):\n        pick = self.selectOpenFile(file='big_gui.py')\n        if pick:\n            self.browser(pick)     # browse my source file, or other\n    def more(self):\n        new = Toplevel()\n        Label(new,  text='A new non-modal window').pack()\n        Button(new, text='Quit', command=self.quit).pack(side=LEFT)\n        Button(new, text='More', command=self.more).pack(side=RIGHT)\n    def pickDemo(self):\n        pick = self.selectOpenFile(dir='..')\n        if pick:\n            self.spawn(pick)    # spawn any Python program\nif __name__ == '__main__':  Hello().mainloop()   # make one, run one\nThis script lays out a fairly large menu and toolbar structure, and also adds callback\nmethods of its own that print stdout messages, pop up text file browsers and new\nwindows, and run other programs. Many of the callbacks don\u2019t do much more than\nrun the notDone method inherited from GuiMixin, though; this code is intended mostly\nas a GuiMaker and GuiMixin demo.\nWhen big_gui is run as a top-level program, it creates a window with four menu pull\ndowns on top and a three-button toolbar on the bottom, shown in Figure 10-3 along\nwith some of the pop-up windows its callbacks create. The menus have separators,\ndisabled entries, and cascading submenus, all as defined by the menuBar template used\nby GuiMaker, and Quit invokes the verifying dialog inherited from GuiMixin\u2014some of\nthe many tools we\u2019re getting for free here.\nFigure 10-4 shows this script\u2019s window again, after its Play pull down has been used to\nlaunch three independently running demos that we wrote in Chapters 8 and 9. These\ndemos are ultimately started by using the portable launcher tools we wrote in Chap-\nter 5, and acquired from the GuiMixin class. If you want to run other demos on your\ncomputer, select the Play menu\u2019s Other option to pop up a standard file selection dialog\ninstead and navigate to the desired program\u2019s file. One note: I copied the icon bitmap\nused by the top-levels demo in the Play menu to this script\u2019s directory; later, we\u2019ll write\ntools that attempt to locate one automatically.\nGuiMaker: Automating Menus and Toolbars | 611Finally, I should note that GuiMaker could be redesigned to use trees of embedded class\ninstances that know how to apply themselves to the tkinter widget tree being con-\nstructed, instead of branching on the types of items in template data structures. In the\ninterest of space, though, we\u2019ll banish that extension to the land of suggested exercises\nin this edition.\nFigure 10-3. big_gui with various pop ups\nFigure 10-4. big_gui with spawned demos\n612 | Chapter 10:\u2002GUI Coding TechniquesSpeaking of suggested enhancements, in Chapter 9, I showed you a first-\ncut way to use images instead of text for buttons in toolbars at the bot-\ntom of windows. Adding this option to the GUI maker class as a subclass\nwhich redefines its toolbar construction method would be both a great\nway to experiment with the code and a useful utility. If I added every\ncool feature imaginable, though, this book could easily become big\nenough to be gravitationally significant\u2026\nShellGui: GUIs for Command-Line Tools\nDemos are fun, but to better show how things like the GuiMixin class can be of practical\nuse, we need a more realistic application. Here\u2019s one: suppose you\u2019ve written a set of\ncommand-line system administration scripts, along the lines of those we studied in\nPart II. As we saw, such scripts work well from a command line, but require you to\nremember all their options each time they are run; if you\u2019re like me, this usually implies\nhaving to pore over the source code after a period of nonuse.\nInstead of requiring users of such tools (including yourself) to type cryptic commands\nat a shell, why not also provide an easy-to-use tkinter GUI interface for running such\nprograms? Such a GUI can prompt for command-line inputs, instead of expecting users\nto remember them. While we\u2019re at it, why not generalize the whole notion of running\ncommand-line tools from a GUI, to make it easy to support future tools too?\nA Generic Shell-Tools Display\nExamples 10-5 through 10-11\u2014seven files, spanning two command-line scripts, one \nGUI utility module, two GUI dialogs, and a main GUI and its options specification\nmodule\u2014comprise a concrete implementation of these artificially rhetorical musings.\nBecause I want this to be a general-purpose tool that can run any command-line pro-\ngram, its design is factored into modules that become more application-specific as we\ngo lower in the software hierarchy. At the top, things are about as generic as they can\nbe, as shown in Example 10-5.\nExample 10-5. PP4E\\Gui\\ShellGui\\shellgui.py\n#!/usr/local/bin/python\n\"\"\"\n################################################################################\ntools launcher; uses guimaker templates, guimixin std quit dialog;\nI am just a class library: run mytools script to display the GUI;\n################################################################################\n\"\"\"\nfrom tkinter import *                               # get widgets\nfrom PP4E.Gui.Tools.guimixin import GuiMixin        # get quit, not done\nfrom PP4E.Gui.Tools.guimaker import *               # menu/toolbar builder\nclass ShellGui(GuiMixin, GuiMakerWindowMenu):       # a frame + maker + mixins\nShellGui: GUIs for Command-Line Tools | 613def start(self):                                # use GuiMaker if component\n        self.setMenuBar()\n        self.setToolBar()\n        self.master.title(\"Shell Tools Listbox\")\n        self.master.iconname(\"Shell Tools\")\n    def handleList(self, event):                    # on listbox double-click\n        label = self.listbox.get(ACTIVE)            # fetch selection text\n        self.runCommand(label)                      # and call action here\n    def makeWidgets(self):                          # add listbox in middle\n        sbar = Scrollbar(self)                      # cross link sbar, list\n        list = Listbox(self, bg='white')            # or use Tour.ScrolledList\n        sbar.config(command=list.yview)\n        list.config(yscrollcommand=sbar.set)\n        sbar.pack(side=RIGHT, fill=Y)                     # pack 1st=clip last\n        list.pack(side=LEFT, expand=YES, fill=BOTH)       # list clipped first\n        for (label, action) in self.fetchCommands():      # add to listbox\n            list.insert(END, label)                       # and menu/toolbars\n        list.bind('<Double-1>', self.handleList)          # set event handler\n        self.listbox = list\n    def forToolBar(self, label):                          # put on toolbar?\n        return True                                       # default = all\n    def setToolBar(self):\n        self.toolBar = []\n        for (label, action) in self.fetchCommands():\n            if self.forToolBar(label):\n                self.toolBar.append((label, action, dict(side=LEFT)))\n        self.toolBar.append(('Quit', self.quit, dict(side=RIGHT)))\n    def setMenuBar(self):\n        toolEntries  = []\n        self.menuBar = [\n            ('File',  0, [('Quit', \u22121, self.quit)]),    # pull-down name\n            ('Tools', 0, toolEntries)                   # menu items list\n            ]                                           # label,underline,action\n        for (label, action) in self.fetchCommands():\n            toolEntries.append((label, \u22121, action))     # add app items to menu\n################################################################################\n# delegate to template type-specific subclasses\n# which delegate to app tool-set-specific subclasses\n################################################################################\nclass ListMenuGui(ShellGui):\n    def fetchCommands(self):             # subclass: set 'myMenu'\n        return self.myMenu               # list of (label, callback)\n    def runCommand(self, cmd):\n        for (label, action) in self.myMenu:\n            if label == cmd: action()\nclass DictMenuGui(ShellGui):\n    def fetchCommands(self):\n614 | Chapter 10:\u2002GUI Coding Techniquesreturn self.myMenu.items()\n    def runCommand(self, cmd):\n        self.myMenu[cmd]()\nThe ShellGui class in this module knows how to use the GuiMaker and GuiMixin inter-\nfaces to construct a selection window that displays tool names in menus, a scrolled list,\nand a toolbar. It also provides a forToolBar method that you can override and that\nallows subclasses to specify which tools should and should not be added to the win-\ndow\u2019s toolbar (the toolbar can become crowded in a hurry). However, it is deliberately\nignorant about both the names of tools that should be displayed in those places and\nabout the actions to be run when tool names are selected.\nInstead, ShellGui relies on the ListMenuGui and DictMenuGui subclasses in this file to\nprovide a list of tool names from a fetchCommands method and dispatch actions by name\nin a runCommand method. These two subclasses really just serve to interface to\napplication-specific tool sets laid out as lists or dictionaries, though; they are still na\u00efve\nabout what tool names really go up on the GUI. That\u2019s by design, too\u2014because the\ntool sets displayed are defined by lower subclasses, we can use ShellGui to display a\nvariety of different tool sets.\nApplication-Specific Tool Set Classes\nTo get to the actual tool sets, we need to go one level down. The module in Exam-\nple 10-6 defines subclasses of the two type-specific ShellGui classes, to provide sets of\navailable tools in both list and dictionary formats (you would normally need only one,\nbut this module is meant for illustration). This is also the module that is actually run\nto kick off the GUI\u2014the shellgui module is a class library only.\nExample 10-6. PP4E\\Gui\\ShellGui\\mytools.py\n#!/usr/local/bin/python\n\"\"\"\n################################################################################\nprovide type-specific option sets for application\n################################################################################\n\"\"\"\nfrom shellgui import *                 # type-specific option gui\nfrom packdlg  import runPackDialog     # dialogs for data entry\nfrom unpkdlg  import runUnpackDialog   # they both run app classes\nclass TextPak1(ListMenuGui):\n    def __init__(self):\n        self.myMenu = [('Pack  ', runPackDialog),      # simple functions\n                       ('Unpack', runUnpackDialog),    # use same width here\n                       ('Mtool ', self.notdone)]       # method from guimixin\n        ListMenuGui.__init__(self)\n    def forToolBar(self, label):\n        return label in {'Pack  ', 'Unpack'}           # 3.x set syntax\nShellGui: GUIs for Command-Line Tools | 615class TextPak2(DictMenuGui):\n    def __init__(self):\n        self.myMenu = {'Pack  ': runPackDialog,        # or use input here...\n                       'Unpack': runUnpackDialog,      # instead of in dialogs\n                       'Mtool ': self.notdone}\n        DictMenuGui.__init__(self)\nif __name__ == '__main__':                           # self-test code...\n    from sys import argv                             # 'menugui.py list|^'\n    if len(argv) > 1 and argv[1] == 'list':\n        print('list test')\n        TextPak1().mainloop()\n    else:\n        print('dict test')\n        TextPak2().mainloop()\nThe classes in this module are specific to a particular tool set; to display a different set\nof tool names, simply code and run a new subclass. By separating out application logic\ninto distinct subclasses and modules like this, software can become widely reusable.\nFigure 10-5 shows the main ShellGui window created when the mytools script is run\nwith its list-based menu layout class on Windows 7, along with menu tear-offs so that\nyou can see what they contain. This window\u2019s menu and toolbar are built by Gui\nMaker, and its Quit and Help buttons and menu selections trigger quit and help methods\ninherited from GuiMixin through the ShellGui module\u2019s superclasses. Are you starting\nto see why this book preaches code reuse so often?\nFigure 10-5. mytools items in a ShellGui window\n616 | Chapter 10:\u2002GUI Coding TechniquesAdding GUI Frontends to Command Lines\nSo far, we\u2019ve coded a general shell tools class library, as well as an application-specific\ntool set module that names callback handlers in its option menus. To complete the\npicture, we still need to define the callback handlers run by the GUI, as well as the\nscripts they ultimately invoke.\nNon-GUI scripts\nTo test the shell GUI\u2019s ability to run command-line scripts, we need a few command-\nline scripts, of course. At the bottom of the hierarchy, the following two scripts make\nuse of system tools and techniques from Part II to implement a simple text file archive\nutility. The first, Example 10-7, simply concatenates the contents of multiple text files\ninto a single file, with predefined separator lines between them.\nExample 10-7. PP4E\\Gui\\ShellGui\\packer.py\n# pack text files into a single file with separator lines (simple archive)\nimport sys, glob\nmarker = ':' * 20 + 'textpak=>'      # hopefully unique separator\ndef pack(ofile, ifiles):\n    output = open(ofile, 'w')\n    for name in ifiles:\n        print('packing:', name)\n        input = open(name, 'r').read()        # open the next input file\n        if input[-1] != '\\n': input += '\\n'   # make sure it has endline\n        output.write(marker + name + '\\n')    # write a separator line\n        output.write(input)                   # and write the file's contents\nif __name__ == '__main__':\n    ifiles = []\n    for patt in sys.argv[2:]:\n        ifiles += glob.glob(patt)             # not globbed auto on Windows\n    pack(sys.argv[1], ifiles)                 # pack files listed on cmdline\nThe second script, Example 10-8, scans archive files created by the first, to unpack into\nindividual files again.\nExample 10-8. PP4E\\Gui\\ShellGui\\unpacker.py\n# unpack files created by packer.py (simple textfile archive)\nimport sys\nfrom packer import marker             # use common separator key\nmlen = len(marker)                    # filenames after markers\ndef unpack(ifile, prefix='new-'):\n    for line in open(ifile):                # for all input lines\n        if line[:mlen] != marker:\n            output.write(line)              # write real lines\nShellGui: GUIs for Command-Line Tools | 617else:\n            name = prefix + line[mlen:-1]   # or make new output\n            print('creating:', name)\n            output = open(name, 'w')\nif __name__ == '__main__': unpack(sys.argv[1])\nThese scripts are fairly basic, and this GUI part of the book assumes you\u2019ve already\nscanned the system tools chapters, so we won\u2019t go into their code in depth. Variants\nof these scripts appeared in the first edition of this book in 1996; I actually used them\nearly on in my Python career to bundle files before I could rely on tools like tar and zip\nto be present on all the machines I used (and before Python grew tar and zip support\nmodules in its standard library). Their operation is straightforward\u2014consider these\nthree text files:\nC:\\...\\PP4E\\Gui\\ShellGui> type spam.txt\nspam\nSpam\nSPAM\nC:\\...\\PP4E\\Gui\\ShellGui> type eggs.txt\neggs\nC:\\...\\PP4E\\Gui\\ShellGui> type ham.txt\nh\n  a\n     m\nWhen run from the command line, the packer script combines them into a single text\nfile, and the unpacker extracts them from there; the packer must take care to glob\n(expand) filename patterns, because this isn\u2019t done by default in Windows:\nC:\\...\\PP4E\\Gui\\ShellGui> packer.py packed.txt *.txt\npacking: eggs.txt\npacking: ham.txt\npacking: spam.txt\nC:\\...\\PP4E\\Gui\\ShellGui> unpacker.py packed.txt\ncreating: new-eggs.txt\ncreating: new-ham.txt\ncreating: new-spam.txt\nThe result files have a unique name by default (with an added prefix to avoid accidental\noverwrites, especially during testing), but you otherwise get back what you packed:\nC:\\...\\PP4E\\Gui\\ShellGui> type new-spam.txt\nspam\nSpam\nSPAM\nC:\\...\\PP4E\\Gui\\ShellGui> type packed.txt\n::::::::::::::::::::textpak=>eggs.txt\neggs\n::::::::::::::::::::textpak=>ham.txt\n618 | Chapter 10:\u2002GUI Coding Techniquesh\n  a\n     m\n::::::::::::::::::::textpak=>spam.txt\nspam\nSpam\nSPAM\nThese scripts don\u2019t do anything about binary files, compression, or the like, but they\nserve to illustrate command-line scripts that require arguments when run. Although\nthey can be launched with shell commands as above (and hence Python tools like\nos.popen and subprocess), their logic is also packaged to be imported and called. For\nrunning them from a GUI, we\u2019ll use the latter direct call interface.\nGUI input dialogs\nOne final piece remains. As is, the packing and unpacking scripts function well as\ncommand-line tools. The callback actions named in Example 10-6\u2019s mytools.py GUI,\nthough, are expected to do something GUI-oriented. Because the original file packing\nand unpacking scripts live in the world of text-based streams and shells, we need to\ncode wrappers that accept input parameters from more GUI-minded users. In partic-\nular, we need dialogs that prompt for the command-line arguments required.\nFirst, the module in Example 10-9 and its client script in Example 10-10 use the custom\nmodal dialog techniques we studied in Chapter 8 to pop up an input display to collect\npack script parameters. The code in Example 10-9 was split off to a separate module\nbecause it\u2019s generally useful, In fact, we will reuse it, in both the unpack dialog and\nagain in PyEdit in Chapter 11.\nThis is yet another way to automate GUI construction\u2014using it to build a form\u2019s rows\ntrades 7 or more lines of code per row (6 without a linked variable or browse button)\nfor just 1. We\u2019ll see another even more automatic form building approach in Chap-\nter 12\u2019s form.py. The utility here, though, is sufficient to shave dozens of lines of code\nfor nontrivial forms.\nExample 10-9. PP4E\\Gui\\ShellGui\\formrows.py\n\"\"\"\"\ncreate a label+entry row frame, with optional file open browse button;\nthis is a separate module because it can save code in other programs too;\ncaller (or callbacks here): retain returned linked var while row is in use;\n\"\"\"\nfrom tkinter import *                                # widgets and presets\nfrom tkinter.filedialog import askopenfilename       # file selector dialog\ndef makeFormRow(parent, label, width=15, browse=True, extend=False):\n    var = StringVar()\n    row = Frame(parent)\n    lab = Label(row, text=label + '?', relief=RIDGE, width=width)\n    ent = Entry(row, relief=SUNKEN, textvariable=var)\nShellGui: GUIs for Command-Line Tools | 619row.pack(fill=X)                                  # uses packed row frames\n    lab.pack(side=LEFT)                               # and fixed-width labels\n    ent.pack(side=LEFT, expand=YES, fill=X)           # or use grid(row, col)\n    if browse:\n        btn = Button(row, text='browse...')\n        btn.pack(side=RIGHT)\n        if not extend:\n            btn.config(command=\n                 lambda: var.set(askopenfilename() or var.get()) )\n        else:\n            btn.config(command=\n                 lambda: var.set(var.get() + ' ' + askopenfilename()) )\n    return var\nNext, Example 10-10\u2019s runPackDialog function is the actual callback handler invoked\nwhen tool names are selected in the main ShellGui window. It uses the form row builder\nmodule of Example 10-9 and applies the custom modal dialog techniques we studied\nearlier.\nExample 10-10. PP4E\\Gui\\ShellGui\\packdlg.py\n# popup a GUI dialog for packer script arguments, and run it\nfrom glob import glob                           # filename expansion\nfrom tkinter import *                           # GUI widget stuff\nfrom packer import pack                         # use pack script/module\nfrom formrows import makeFormRow                # use form builder tool\ndef packDialog():                               # a new top-level window\n    win = Toplevel()                            # with 2 row frames + ok button\n    win.title('Enter Pack Parameters')\n    var1 = makeFormRow(win, label='Output file')\n    var2 = makeFormRow(win, label='Files to pack', extend=True)\n    Button(win, text='OK', command=win.destroy).pack()\n    win.grab_set()\n    win.focus_set()                  # go modal: mouse grab, keyboard focus, wait\n    win.wait_window()                # wait till destroy; else returns now\n    return var1.get(), var2.get()    # fetch linked var values\ndef runPackDialog():\n    output, patterns = packDialog()                  # pop-up GUI dialog\n    if output != \"\" and patterns != \"\":              # till ok or wm-destroy\n        patterns = patterns.split()                  # do non-GUI part now\n        filenames = []\n        for sublist in map(glob, patterns):          # do expansion manually\n            filenames += sublist                     # Unix shells do this auto\n        print('Packer:', output, filenames)\n        pack(ofile=output, ifiles=filenames)         # should show msgs in GUI too\nif __name__ == '__main__':\n    root = Tk()\n    Button(root, text='popup', command=runPackDialog).pack(fill=X)\n    Button(root, text='bye',   command=root.quit).pack(fill=X)\n    root.mainloop()\n620 | Chapter 10:\u2002GUI Coding TechniquesWhen run standalone, the \u201cpopup\u201d button of script in Example 10-10 creates the input\nform shown in Figure 10-6; this is also what we get when its main function is launched\nby the mytools.py shell tools GUI. Users may either type input and output filenames\ninto the entry fields or press the \u201cbrowse\u201d buttons to pop up standard file selection\ndialogs. They can also enter filename patterns\u2014the manual glob call in this script ex-\npands filename patterns to match names and filters out nonexistent input filenames.\nAgain, the Unix command line does this pattern expansion automatically when running\nthe packer from a shell, but Windows does not.\nFigure 10-6. The packdlg input form\nWhen the form is filled in and submitted with its OK button, parameters are finally\npassed along to the main function of the non-GUI packer script listed earlier to perform\nfile concatenations.\nThe GUI interface to the unpacking script is simpler because there is only one input\nfield\u2014the name of the packed file to scan. We also get to reuse the form row builder\nmodule developed for the packer\u2019s dialog, because this task is so similar. The script in\nExample 10-11 (and its main function run by the mytools.py shell tool GUI\u2019s selections)\ngenerates the input form window shown in Figure 10-7.\nFigure 10-7. The unpkdlg input form\nExample 10-11. PP4E\\Gui\\ShellGui\\unpkdlg.py\n# popup a GUI dialog for unpacker script arguments, and run it\nfrom tkinter import *                             # widget classes\nfrom unpacker import unpack                       # use unpack script/module\nfrom formrows import makeFormRow                  # form fields builder\ndef unpackDialog():\nShellGui: GUIs for Command-Line Tools | 621win = Toplevel()\n    win.title('Enter Unpack Parameters')\n    var = makeFormRow(win, label='Input file', width=11)\n    win.bind('<Key-Return>', lambda event: win.destroy())\n    win.grab_set()\n    win.focus_set()                  # make myself modal\n    win.wait_window()                # till I'm destroyed on return\n    return var.get()                 # or closed by wm action\ndef runUnpackDialog():\n    input = unpackDialog()                    # get input from GUI\n    if input != '':                           # do non-GUI file stuff\n        print('Unpacker:', input)             # run with input from dialog\n        unpack(ifile=input, prefix='')\nif __name__ == \"__main__\":\n    Button(None, text='popup', command=runUnpackDialog).pack()\n    mainloop()\nThe \u201cbrowse\u201d button in Figure 10-7 pops up a file selection dialog just as the packdlg\nform did. Instead of an OK button, this dialog binds the Enter key-press event to kill\nthe window and end the modal wait state pause; on submission, the name of the packed\nfile is passed to the main function of the unpacker script shown earlier to perform the\nactual file scan process.\nRoom for improvement\nAll of this works as advertised\u2014by making command-line tools available in graphical\nform like this, they become much more attractive to users accustomed to the GUI way\nof life. We\u2019ve effectively added a simple GUI front-end to command-line tools. Still,\ntwo aspects of this design seem prime for improvement.\nFirst, both of the input dialogs use common code to build the rows of their input forms,\nbut it\u2019s tailored to this specific use case; we might be able to simplify the dialogs further\nby importing a more generic form-builder module instead. We met general form builder\ncode in Chapters 8 and 9, and we\u2019ll meet more later\u2014see the form.py module in Chap-\nter 12 for pointers on further genericizing form construction.\nSecond, at the point where the user submits input data in either form dialog, we\u2019ve lost\nthe GUI trail\u2014the GUI is blocked, and messages are routed back to the console. The\nGUI is technically blocked and will not update itself while the pack and unpack utilities\nrun; although these operations are fast enough for my files as to be negligible, we would\nprobably want to spawn these calls off in threads for very large files to keep the main\nGUI thread active (more on threads later in this chapter).\nThe console issue is more blatant: packer and unpacker messages still show up in the\nstdout console window, not in the GUI (all the filenames here include full directory\npaths if you select them with the GUI\u2019s Browse buttons, courtesy of the standard Open\ndialog):\n622 | Chapter 10:\u2002GUI Coding TechniquesC:\\...\\PP4E\\Gui\\ShellGui\\temp> python ..\\mytools.py list\nPP4E scrolledtext\nlist test\nPacker: packed.all ['spam.txt', 'ham.txt', 'eggs.txt']\npacking: spam.txt\npacking: ham.txt\npacking: eggs.txt\nUnpacker: packed.all\ncreating: spam.txt\ncreating: ham.txt\ncreating: eggs.txt\nThis may be less than ideal for a GUI\u2019s users; they may not expect (or even be able to\nfind) the command-line console. We can do better here, by redirecting stdout to an\nobject that throws text up in a GUI window as it is received. You\u2019ll have to read the\nnext section to see how.\nGuiStreams: Redirecting Streams to Widgets\nOn to our next GUI coding technique: in response to the challenge posed at the end of\nthe last section, the script in Example 10-12 arranges to map input and output sources\nto pop-up windows in a GUI application, much as we did with strings in the stream\nredirection topics in Chapter 3. Although this module is really just a first-cut prototype\nand needs improvement itself (e.g., each input line request pops up a new input\ndialog\u2014not exactly award winning ergonomics!), it demonstrates the concepts in\ngeneral.\nExample 10-12\u2019s GuiOutput and GuiInput objects define methods that allow them to\nmasquerade as files in any interface that expects a real file. As we learned earlier in\nChapter 3, this includes both the print and input built-in functions for accessing\nstandard streams, as well as explicit calls to the read and write methods of file objects.\nThe two top-level interfaces in this module handle common use cases:\n\u2022 The redirectedGuiFunc function uses this plug-and-play file compatibility to run a\nfunction with its standard input and output streams mapped completely to pop-\nup windows rather than to the console window (or wherever streams would oth-\nerwise be mapped in the system shell).\n\u2022 The redirectedGuiShellCmd function similarly routes the output of a spawned shell\ncommand line to a pop-up window. It can be used to display the output of any\nprogram in a GUI\u2014including that printed by a Python program.\nThe module\u2019s GuiInput and GuiOutput classes can also be used or customized directly\nby clients that need to match a more direct file method interface or need more fine-\ngrained control over the process.\nGuiStreams: Redirecting Streams to Widgets | 623Example 10-12. PP4E\\Gui\\Tools\\guiStreams.py\n\"\"\"\n###############################################################################\nfirst-cut implementation of file-like classes that can be used to redirect\ninput and output streams to GUI displays; as is, input comes from a common\ndialog pop-up (a single output+input interface or a persistent Entry field\nfor input would be better); this also does not properly span lines for read\nrequests with a byte count > len(line); could also add __iter__/__next__ to\nGuiInput to support line iteration like files but would be too many popups;\n###############################################################################\n\"\"\"\nfrom tkinter import *\nfrom tkinter.simpledialog import askstring\nfrom tkinter.scrolledtext import ScrolledText    # or PP4E.Gui.Tour.scrolledtext\nclass GuiOutput:\n    font = ('courier', 9, 'normal')              # in class for all, self for one\n    def __init__(self, parent=None):\n        self.text = None\n        if parent: self.popupnow(parent)         # pop up now or on first write\n    def popupnow(self, parent=None):             # in parent now, Toplevel later\n        if self.text: return\n        self.text = ScrolledText(parent or Toplevel())\n        self.text.config(font=self.font)\n        self.text.pack()\n    def write(self, text):\n        self.popupnow()\n        self.text.insert(END, str(text))\n        self.text.see(END)\n        self.text.update()                       # update gui after each line\n    def writelines(self, lines):                 # lines already have '\\n'\n        for line in lines: self.write(line)      # or map(self.write, lines)\nclass GuiInput:\n    def __init__(self):\n        self.buff = ''\n    def inputLine(self):\n        line = askstring('GuiInput', 'Enter input line + <crlf> (cancel=eof)')\n        if line == None:\n            return ''                            # pop-up dialog for each line\n        else:                                    # cancel button means eof\n            return line + '\\n'                   # else add end-line marker\n    def read(self, bytes=None):\n        if not self.buff:\n            self.buff = self.inputLine()\n        if bytes:                                # read by byte count\n            text = self.buff[:bytes]             # doesn't span lines\n            self.buff = self.buff[bytes:]\n        else:\n624 | Chapter 10:\u2002GUI Coding Techniquestext = ''                            # read all till eof\n            line = self.buff\n            while line:\n                text = text + line\n                line = self.inputLine()          # until cancel=eof=''\n        return text\n    def readline(self):\n        text = self.buff or self.inputLine()     # emulate file read methods\n        self.buff = ''\n        return text\n    def readlines(self):\n        lines = []                               # read all lines\n        while True:\n            next = self.readline()\n            if not next: break\n            lines.append(next)\n        return lines\ndef redirectedGuiFunc(func, *pargs, **kargs):\n    import sys\n    saveStreams = sys.stdin, sys.stdout          # map func streams to pop ups\n    sys.stdin   = GuiInput()                     # pops up dialog as needed\n    sys.stdout  = GuiOutput()                    # new output window per call\n    sys.stderr  = sys.stdout\n    result = func(*pargs, **kargs)               # this is a blocking call\n    sys.stdin, sys.stdout = saveStreams\n    return result\ndef redirectedGuiShellCmd(command):\n    import os\n    input  = os.popen(command, 'r')\n    output = GuiOutput()\n    def reader(input, output):                   # show a shell command's\n        while True:                              # standard output in a new\n            line = input.readline()              # pop-up text box widget;\n            if not line: break                   # the readline call may block\n            output.write(line)\n    reader(input, output)\nif __name__ == '__main__':                       # self test when run\n    def makeUpper():                             # use standard streams\n        while True:\n            try:\n                line = input('Line? ')\n            except:\n                break\n            print(line.upper())\n        print('end of file')\n    def makeLower(input, output):                # use explicit files\n        while True:\n            line = input.readline()\n            if not line: break\nGuiStreams: Redirecting Streams to Widgets | 625output.write(line.lower())\n        print('end of file')\n    root = Tk()\n    Button(root, text='test streams',\n           command=lambda: redirectedGuiFunc(makeUpper)).pack(fill=X)\n    Button(root, text='test files  ',\n           command=lambda: makeLower(GuiInput(), GuiOutput()) ).pack(fill=X)\n    Button(root, text='test popen  ',\n           command=lambda: redirectedGuiShellCmd('dir *')).pack(fill=X)\n    root.mainloop()\nAs coded here, GuiOutput attaches a ScrolledText (Python\u2019s standard library flavor) to\neither a passed-in parent container or a new top-level window popped up to serve as\nthe container on the first write call. GuiInput pops up a new standard input dialog every\ntime a read request requires a new line of input. Neither one of these policies is ideal\nfor all scenarios (input would be better mapped to a more long-lived widget), but they\nprove the general point intended.\nFigure 10-8 shows the scene generated by this script\u2019s self-test code, after capturing the\noutput of a Windows shell dir listing command (on the left) and two interactive loop\ntests (the one with \u201cLine?\u201d prompts and uppercase letters represents the makeUpper\nstreams redirection test). An input dialog has just popped up for a new makeLower files\ninterface test.\nFigure 10-8. guiStreams routing streams to pop-up windows\nThis scene may not be spectacular to look at, but it reflects file and stream input and\noutput operations being automatically mapped to GUI devices\u2014as we\u2019ll see in a mo-\nment, this accomplishes most of the solution to the prior section\u2019s closing challenge.\nBefore we move on, we should note that this module\u2019s calls to a redirected function as\nwell as its loop that reads from a spawned shell command are potentially blocking\u2014\n626 | Chapter 10:\u2002GUI Coding Techniquesthey won\u2019t return to the GUI\u2019s event loop until the function or shell command exits.\nAlthough GuiOutput takes care to call tkinter\u2019s update method to update the display\nafter each line is written, this module has no control in general over the duration of\nfunctions or shell commands it runs.\nIn redirectedGuiShellCmd, for example, the call to input.readline will pause until an\noutput line is received from the spawned program, rendering the GUI unresponsive.\nBecause the output object runs an update call, the display is still updated during the\nprogram\u2019s execution (an update call enters the Tk event loop momentarily), but only\nas often as lines are received from the spawned program. In addition, because of this\nfunction\u2019s loop, the GUI is committed to the shell command in general until it exits.\nCalls to a redirected function in redirectedGuiFunc are similarly blocking in general;\nmoreover, during the call\u2019s duration the display is updated only as often as the function\nissues output requests. In other words, this blocking model is simplistic and might be\nan issue in a larger GUI. We\u2019ll revisit this later in the chapter when we meet threads.\nFor now, the code suits our present purpose.\nUsing Redirection for the Packing Scripts\nNow, finally, to use such redirection tools to map command-line script output back to\na GUI, we simply run calls and command lines with the two redirected functions in\nthis module. Example 10-13 shows one way to wrap the packing operation dialog of\nthe shell GUI section\u2019s Example 10-10 to force its printed output to appear in a pop-\nup window when generated, instead of in the console.\nExample 10-13. PP4E\\Gui\\ShellGui\\packdlg-redirect.py\n# wrap command-line script in GUI redirection tool to pop up its output\nfrom tkinter import *\nfrom packdlg import runPackDialog\nfrom PP4E.Gui.Tools.guiStreams import redirectedGuiFunc\ndef runPackDialog_Wrapped():            # callback to run in mytools.py\n    redirectedGuiFunc(runPackDialog)    # wrap entire callback handler\nif __name__ == '__main__':\n    root = Tk()\n    Button(root, text='pop', command=runPackDialog_Wrapped).pack(fill=X)\n    root.mainloop()\nYou can run this script directly to test its effect, without bringing up the ShellGui\nwindow. Figure 10-9 shows the resulting stdout window after the pack input dialog is\ndismissed. This window pops up as soon as script output is generated, and it is a bit\nmore GUI user friendly than hunting for messages in a console. You can similarly code\nthe unpack parameters dialog to route its output to a pop-up. Simply change\nGuiStreams: Redirecting Streams to Widgets | 627mytools.py in Example 10-6 to register code like the function wrapper here as its call-\nback handlers.\nIn fact, you can use this technique to route the output of any function call or command\nline to a pop-up window; as usual, the notion of compatible object interfaces is at the\nheart of much of Python code\u2019s flexibility.\nReloading Callback Handlers Dynamically\nOur next GUI programming technique is all about changing a GUI while it is running\u2014\nthe ultimate in customization. The Python imp.reload function lets you dynamically\nchange and reload a program\u2019s modules without stopping the program. For instance,\nyou can bring up a text editor window to change the source code of selected parts of a\nsystem while it is running and see those changes show up immediately after reloading\nthe changed module.\nThis is a powerful feature, especially for developing programs that take a long time to\nrestart. Programs that connect to databases or network servers, initialize large objects,\nimplement long-running services, or travel through a long series of steps to retrigger a\ncallback are prime candidates for reload. It can shave substantial time from the devel-\nopment cycle and make systems more flexible.\nThe catch for GUIs, though, is that because callback handlers are registered as object\nreferences rather than module and object names, reloads of callback handler functions\nare ineffective after the callback has been registered. The Python imp.reload operation\nworks by changing a module object\u2019s contents in place. Because tkinter stores a pointer\nto the registered handler object directly, though, it is oblivious to any reloads of the\nmodule that the handler came from. That is, tkinter will still reference a module\u2019s old\nobjects even after the module is reloaded and changed.\nThis is a subtle thing, but you really only need to remember that you must do something\nspecial to reload callback handler functions dynamically. Not only do you need to\nFigure 10-9. Routing script outputs to GUI pop ups\n628 | Chapter 10:\u2002GUI Coding Techniquesexplicitly request reloading of the modules that you change, but you must also generally\nprovide an indirection layer that routes callbacks from registered objects to modules\nso that reloads have impact.\nFor example, the script in Example 10-14 goes the extra mile to indirectly dispatch\ncallbacks to functions in an explicitly reloaded module. The callback handlers regis-\ntered with tkinter are method objects that do nothing but reload and dispatch again.\nBecause the true callback handler functions are fetched through a module object, re-\nloading that module makes the latest versions of the functions accessible.\nExample 10-14. PP4E\\Gui\\Tools\\rad.py\n# reload callback handlers dynamically\nfrom tkinter import *\nimport radactions           # get initial callback handlers\nfrom imp import reload      # moved to a module in Python 3.X\nclass Hello(Frame):\n    def __init__(self, master=None):\n        Frame.__init__(self, master)\n        self.pack()\n        self.make_widgets()\n    def make_widgets(self):\n        Button(self, text='message1', command=self.message1).pack(side=LEFT)\n        Button(self, text='message2', command=self.message2).pack(side=RIGHT)\n    def message1(self):\n        reload(radactions)         # need to reload actions module before calling\n        radactions.message1()      # now new version triggered by pressing button\n    def message2(self):\n        reload(radactions)         # changes to radactions.py picked up by reload\n        radactions.message2(self)  # call the most recent version; pass self\n    def method1(self):\n        print('exposed method...')       # called from radactions function\nHello().mainloop()\nWhen run, this script makes a two-button window that triggers the message1 and\nmessage2 methods. Example 10-15 contains the actual callback handler code. Its func-\ntions receive a self argument that gives access back to the Hello class object, as though\nthese were real methods. You can change this file any number of times while the rad\nscript\u2019s GUI is active; each time you do so, you\u2019ll change the behavior of the GUI when\na button press occurs.\nExample 10-15. PP4E\\Gui\\Tools\\radactions.py\n# callback handlers: reloaded each time triggered\ndef message1():                 # change me\nReloading Callback Handlers Dynamically | 629print('spamSpamSPAM')       # or could build a dialog...\ndef message2(self):\n    print('Ni! Ni!')            # change me\n    self.method1()              # access the 'Hello' instance...\nTry running rad and editing the messages printed by radactions in another window;\nyou should see your new messages printed in the stdout console window each time the\nGUI\u2019s buttons are pressed. This example is deliberately simple to illustrate the concept,\nbut the actions reloaded like this in practice might build pop-up dialogs, new top-level\nwindows, and so on. Reloading the code that creates such windows would also let us\ndynamically change their appearances.\nThere are other ways to change a GUI while it\u2019s running. For instance, we saw in\nChapter 9 that appearances can be altered at any time by calling the widget config\nmethod, and widgets can be added and deleted from a display dynamically with meth-\nods such as pack_forget and pack (and their grid manager relatives). Furthermore,\npassing a new command=action option setting to a widget\u2019s config method might reset\na callback handler to a new action object on the fly; with enough support code, this\nmay be a viable alternative to the indirection scheme used earlier to make reloads more\neffective in GUIs.\nOf course, not all GUIs need to be so dynamic. Imagine a game which allows character\nmodification, though\u2014dynamic reloads in such a system can greatly enhance their\nutility. (I\u2019ll leave the task of extending this example with a massively multiplayer online\nrole-playing game server as suggested exercise.)\nWrapping Up Top-Level Window Interfaces\nTop-level window interfaces were introduced in Chapter 8. This section picks up where\nthat introduction left off and wraps up those interfaces in classes that automate much\nof the work of building top-level windows\u2014setting titles, finding and displaying win-\ndow icons, issuing proper close actions based on a window\u2019s role, intercepting window\nmanager close button clicks, and so on.\nExample 10-16 provides wrapper classes for the most common window types\u2014a main\napplication window, a transient pop-up window, and an embedded GUI component\nwindow. These window types vary slightly in terms of their close operations, but most\ninherit common functionality related to window borders: icons, titles, and close but-\ntons. By creating, mixing in, or subclassing the class for the type of window you wish\nto make, you\u2019ll get all its setup logic for free.\nExample 10-16. PP4E\\Gui\\Tools\\windows.py\n\"\"\"\n###############################################################################\nClasses that encapsulate top-level interfaces.\nAllows same GUI to be main, pop-up, or attached; content classes may inherit\n630 | Chapter 10:\u2002GUI Coding Techniquesfrom these directly, or be mixed together with them per usage mode; may also\nbe called directly without a subclass; designed to be mixed in after (further\nto the right than) app-specific classes: else, subclass gets methods here\n(destroy, okayToQuit), instead of from app-specific classes--can't redefine.\n###############################################################################\n\"\"\"\nimport os, glob\nfrom tkinter import Tk, Toplevel, Frame, YES, BOTH, RIDGE\nfrom tkinter.messagebox import showinfo, askyesno\nclass _window:\n    \"\"\"\n    mixin shared by main and pop-up windows\n    \"\"\"\n    foundicon = None                                       # shared by all inst\n    iconpatt  = '*.ico'                                    # may be reset\n    iconmine  = 'py.ico'\n    def configBorders(self, app, kind, iconfile):\n        if not iconfile:                                   # no icon passed?\n            iconfile = self.findIcon()                     # try curr,tool dirs\n        title = app\n        if kind: title += ' - ' + kind\n        self.title(title)                                  # on window border\n        self.iconname(app)                                 # when minimized\n        if iconfile:\n            try:\n                self.iconbitmap(iconfile)                  # window icon image\n            except:                                        # bad py or platform\n                pass\n        self.protocol('WM_DELETE_WINDOW', self.quit)       # don't close silent\n    def findIcon(self):\n        if _window.foundicon:                              # already found one?\n            return _window.foundicon\n        iconfile  = None                                   # try curr dir first\n        iconshere = glob.glob(self.iconpatt)               # assume just one\n        if iconshere:                                      # del icon for red Tk\n            iconfile = iconshere[0]\n        else:                                              # try tools dir icon\n            mymod  = __import__(__name__)                  # import self for dir\n            path   = __name__.split('.')                   # poss a package path\n            for mod in path[1:]:                           # follow path to end\n                mymod = getattr(mymod, mod)                # only have leftmost\n            mydir  = os.path.dirname(mymod.__file__)\n            myicon = os.path.join(mydir, self.iconmine)    # use myicon, not tk\n            if os.path.exists(myicon): iconfile = myicon\n        _window.foundicon = iconfile                       # don't search again\n        return iconfile\nclass MainWindow(Tk, _window):\n    \"\"\"\n    when run in main top-level window\n    \"\"\"\nWrapping Up Top-Level Window Interfaces | 631def __init__(self, app, kind='', iconfile=None):\n        Tk.__init__(self)\n        self.__app = app\n        self.configBorders(app, kind, iconfile)\n    def quit(self):\n        if self.okayToQuit():                                # threads running?\n            if askyesno(self.__app, 'Verify Quit Program?'):\n                self.destroy()                               # quit whole app\n        else:\n            showinfo(self.__app, 'Quit not allowed')         # or in okayToQuit?\n    def destroy(self):                                       # exit app silently\n        Tk.quit(self)                                        # redef if exit ops\n    def okayToQuit(self):                                    # redef me if used\n        return True                                          # e.g., thread busy\nclass PopupWindow(Toplevel, _window):\n    \"\"\"\n    when run in secondary pop-up window\n    \"\"\"\n    def __init__(self, app, kind='', iconfile=None):\n        Toplevel.__init__(self)\n        self.__app = app\n        self.configBorders(app, kind, iconfile)\n    def quit(self):                                        # redef me to change\n        if askyesno(self.__app, 'Verify Quit Window?'):    # or call destroy\n            self.destroy()                                 # quit this window\n    def destroy(self):                                     # close win silently\n        Toplevel.destroy(self)                             # redef for close ops\nclass QuietPopupWindow(PopupWindow):\n    def quit(self):\n        self.destroy()                                     # don't verify close\nclass ComponentWindow(Frame):\n    \"\"\"\n    when attached to another display\n    \"\"\"\n    def __init__(self, parent):                            # if not a frame\n        Frame.__init__(self, parent)                       # provide container\n        self.pack(expand=YES, fill=BOTH)\n        self.config(relief=RIDGE, border=2)                # reconfig to change\n    def quit(self):\n        showinfo('Quit', 'Not supported in attachment mode')\n    # destroy from Frame: erase frame silent               # redef for close ops\nSo why not just set an application\u2019s icon and title by calling protocol methods directly?\nFor one thing, those are the sorts of details that are easy to forget (you will probably\nwind up cutting and pasting code much of the time). For another, these classes add\n632 | Chapter 10:\u2002GUI Coding Techniqueshigher-level functionality that we might otherwise have to code redundantly. Among\nother things, the classes arrange for automatic quit verification dialog pop ups and icon\nfile searching. For instance, the window classes always search the current working\ndirectory and the directory containing this module for a window icon file, once per\nprocess.\nBy using classes that encapsulate\u2014that is, hide\u2014such details, we inherit powerful tools\nwithout having to think about their implementation again in the future. Moreover, by\nusing such classes, we\u2019ll give our applications a standard look-and-feel and behavior.\nAnd if we ever need to change that appearance or behavior, we have to change code in\nonly one place, not in every window we implement.\nTo test this utility module, Example 10-17 exercises its classes in a variety of modes\u2014\nas mix-in classes, as superclasses, and as calls from nonclass code.\nExample 10-17. PP4E\\Gui\\Tools\\windows-test.py\n# must import windows to test, else __name__ is __main__ in findIcon\nfrom tkinter import Button, mainloop\nfrom windows import MainWindow, PopupWindow, ComponentWindow\ndef _selftest():\n    # mixin usage\n    class content:\n        \"same code used as a Tk, Toplevel, and Frame\"\n        def __init__(self):\n            Button(self, text='Larch', command=self.quit).pack()\n            Button(self, text='Sing ', command=self.destroy).pack()\n    class contentmix(MainWindow, content):\n        def __init__(self):\n            MainWindow.__init__(self, 'mixin', 'Main')\n            content.__init__(self)\n    contentmix()\n    class contentmix(PopupWindow, content):\n        def __init__(self):\n            PopupWindow.__init__(self, 'mixin', 'Popup')\n            content.__init__(self)\n    prev = contentmix()\n    class contentmix(ComponentWindow, content):\n        def __init__(self):                               # nested frame\n            ComponentWindow.__init__(self, prev)          # on prior window\n            content.__init__(self)                        # Sing erases frame\n    contentmix()\n    # subclass usage\n    class contentsub(PopupWindow):\n        def __init__(self):\n            PopupWindow.__init__(self, 'popup', 'subclass')\nWrapping Up Top-Level Window Interfaces | 633Button(self, text='Pine', command=self.quit).pack()\n            Button(self, text='Sing', command=self.destroy).pack()\n    contentsub()\n    # non-class usage\n    win = PopupWindow('popup', 'attachment')\n    Button(win, text='Redwood', command=win.quit).pack()\n    Button(win, text='Sing   ', command=win.destroy).pack()\n    mainloop()\nif __name__ == '__main__':\n    _selftest()\nWhen run, the test generates the window in Figure 10-10. All generated windows get\na blue \u201cPY\u201d icon automatically, and intercept and verify the window manager\u2019s upper\nright corner \u201cX\u201d close button, thanks to the search and configuration logic they inherit\nfrom the window module\u2019s classes. Some of the buttons on the test windows close just\nthe enclosing window, some close the entire application, some erase an attached win-\ndow, and others pop up a quit verification dialog. Run this on your own to see what\nthe examples\u2019 buttons do, so you can correlate with the test code; quit actions are\ntailored to make sense for the type of window being run.\nFigure 10-10. windows-test display\nWe\u2019ll use these window protocol wrappers in the next chapter\u2019s PyClock example, and\nthen again later in Chapter 14 where they\u2019ll come in handy to reduce the complexity\nof the PyMailGUI program. Part of the benefit of doing OOP in Python now is that we\ncan forget the details later.\n634 | Chapter 10:\u2002GUI Coding TechniquesGUIs, Threads, and Queues\nIn Chapter 5, we learned about threads and the queue mechanism that threads typically\nuse to communicate with one another. We also described the application of those ideas\nto GUIs in the abstract. In Chapter 9, we specialized some of these topics to the tkinter\nGUI toolkit we\u2019re using in this book and expanded on the threaded GUI model in\ngeneral, including thread safety (or lack thereof) and the roles of queues and locks.\nNow that we\u2019ve become fully functional GUI programmers, we can finally see what\nthese ideas translate to in terms of code. If you skipped the related material in Chap-\nter 5 or Chapter 9, you should probably go back and take a look first; we won\u2019t be\nrepeating the thread or queue background material in its entirety here.\nThe application to GUIs, however, is straightforward. Recall that long-running oper-\nations must generally be run in parallel threads, to avoid blocking the GUI from up-\ndating itself or responding to new user requests. Long-running operations can include\ntime-intensive function calls, downloads from servers, blocking input/output calls, and\nany task which might insert a noticeable delay. In our packing and unpacking examples\nearlier in this chapter, for instance, we noted that the calls to run the actual file pro-\ncessing should generally run in threads so that the main GUI thread is not blocked until\nthey finish.\nIn the general case, if a GUI waits for anything to finish, it will be completely unre-\nsponsive during the wait\u2014it can\u2019t be resized, it can\u2019t be minimized, and it won\u2019t even\nredraw itself if it is covered and uncovered by other windows. To avoid being blocked\nthis way, the GUI must run long-running tasks in parallel, usually with threads that\ncan share program state. That way, the main GUI thread is freed up to update the\ndisplay and respond to new user interactions while threads do other work. As we\u2019ve\nalso seen, the tkinter update call can help in some contexts, but it only refreshes the\ndisplay when it can be called; threads fully parallelize long-running operations and offer\na more general solution.\nHowever, because, as we learned in Chapter 9, only the main thread should generally\nupdate a GUI\u2019s display, threads you start to handle long-running tasks should not\nupdate the display with results themselves. Rather, they should place data on a queue\n(or other mechanism), to be picked up and displayed by the main GUI thread. To make\nthis work, the main thread typically runs a timer-based loop that periodically checks\nthe queue for new results to be displayed. Spawned threads produce and queue data\nbut know nothing about the GUI; the main GUI thread consumes and displays results\nbut does not generate them.\nBecause of its division of labor, we usually call this a producer/consumer model\u2014task\nthreads produce data which the GUI thread consumes. The long-running task threads\nare also sometimes called workers, because they handle the work of producing results\nbehind the scenes, for the GUI to present to a user. In some sense, the GUI is also a\nclient to worker thread servers, though that terminology is usually reserved for more\nGUIs, Threads, and Queues | 635specific process-based roles; servers provide data sources which are longer-lived and\nmore loosely coupled (though a GUI can also display data from independent servers).\nWhatever we call it, this model both avoids blocking the GUI while tasks run and avoids\npotentially parallel updates to the GUI itself.\nAs a more concrete example, suppose your GUI needs to display telemetry data sent in\nreal time from a satellite over sockets (an IPC tool introduced in Chapter 5). Your\nprogram has to be responsive enough to not lose incoming data, but it also cannot get\nstuck waiting for or processing that data. To achieve both goals, spawn threads that\nfetch the incoming data and throw it on a queue, to be picked up and displayed peri-\nodically by the main GUI thread. With such a separation of labor, the GUI isn\u2019t blocked\nby the satellite, nor vice versa\u2014the GUI itself will run independently of the data\nstreams, but because the data stream threads can run at full speed, they\u2019ll be able to\npick up incoming data as fast as it\u2019s sent. GUI event loops are not generally responsive\nenough to handle real-time inputs. Without the data stream threads, we might lose\nincoming telemetry; with them, we\u2019ll receive data as it is sent and display it as soon as\nthe GUI\u2019s event loop gets around to picking it up off the queue\u2014plenty fast for the real\nhuman user to see. If no data is sent, only the spawned threads wait, not the GUI itself.\nIn other scenarios, threads are required just so that the GUI remains active during long-\nrunning tasks. While downloading a reply from a web server, for example, your GUI\nmust be able to redraw itself if covered or resized. Because of that, the download call\ncannot be a simple function call; it must run in parallel with the rest of your program\u2014\ntypically, as a thread. When the result is fetched, the thread must notify the GUI that\ndata is ready to be displayed; by placing the result on a queue, the notification is\nsimple\u2014the main GUI thread will find it the next time it checks the queue in its timer\ncallback function. For example, we\u2019ll use threads and queues this way in the PyMailGUI\nprogram in Chapter 14, to allow multiple overlapping mail transfers to occur without\nblocking the GUI itself.\nPlacing Data on Queues\nWhether your GUIs interface with satellites, websites, or something else, this thread-\nbased model turns out to be fairly simple in terms of code. Example 10-18 is the GUI\nequivalent of the queue-based threaded program we met earlier in Chapter 5 (compare\nthis with Example 5-14). In the context of a GUI, the consumer thread becomes the\nGUI itself, and producer threads add data to be displayed to the shared queue as it is\nproduced. The main GUI thread uses the tkinter after method to check the queue for\nresults instead of an explicit loop.\nExample 10-18. PP4E\\Gui\\Tools\\queuetest-gui.py\n# GUI that displays data produced and queued by worker threads\nimport _thread, queue, time\ndataQueue = queue.Queue()    # infinite size\n636 | Chapter 10:\u2002GUI Coding Techniquesdef producer(id):\n    for i in range(5):\n        time.sleep(0.1)\n        print('put')\n        dataQueue.put('[producer id=%d, count=%d]' % (id, i))\ndef consumer(root):\n    try:\n        print('get')\n        data = dataQueue.get(block=False)\n    except queue.Empty:\n        pass\n    else:\n        root.insert('end', 'consumer got => %s\\n' % str(data))\n        root.see('end')\n    root.after(250, lambda: consumer(root))    # 4 times per sec\ndef makethreads():\n    for i in range(4):\n        _thread.start_new_thread(producer, (i,))\nif __name__ == '__main__':\n    # main GUI thread: spawn batch of worker threads on each mouse click\n    from tkinter.scrolledtext import ScrolledText\n    root = ScrolledText()\n    root.pack()\n    root.bind('<Button-1>', lambda event: makethreads())\n    consumer(root)                       # start queue check loop in main thread\n    root.mainloop()                      # pop-up window, enter tk event loop\nObserve how we fetch one queued data item per timer event here. This is on purpose;\nalthough we could loop through all the data items queued on each timer event, this\nmight block the GUI indefinitely in pathological cases where many items are queued\nquickly (imagine a fast telemetry interface suddenly queueing hundreds or thousands\nof results all at once). Processing one item at a time ensures that the GUI will return to\nits event loop to update the display and process new user inputs without becoming\nblocked. The downside of this approach is that it may take awhile to work through\nvery many items placed on the queue. Hybrid schemes, such as dispatching at most N\nqueued items per timer event callback, might be useful in some such scenarios; we\u2019ll\nsee an example like this later in this section (Example 10-20).\nWhen this script is run, the main GUI thread displays the data it grabs off the queue\nin the ScrolledText window captured in Figure 10-11. A new batch of four producer\nthreads is started each time you left-click in the window, and threads issue \u201cget\u201d and\n\u201cput\u201d messages to the standard output stream (which isn\u2019t synchronized in this exam-\nple\u2014printed messages might overlap occasionally on some platforms, including Win-\ndows). The producer threads issue sleep calls to simulate long-running tasks such as\ndownloading mail, fetching a query result, or waiting for input to show up on a socket\n(more on sockets later in this chapter). I left-clicked multiple times to encourage thread\noverlap in Figure 10-11.\nGUIs, Threads, and Queues | 637Recoding with classes and bound methods\nExample 10-19 takes the model one small step further and migrates it to a class to allow\nfor future customization and reuse. Its operation, window, and output are the same as\nthe prior non-object-oriented version, but the queue is checked more often, and there\nare no standard output prints. Notice how we use bound methods for button callbacks\nand thread actions here; because bound methods retain both instance and method, the\nthreaded action has access to state information, including the shared queue. This allows\nus to move the queue and the window itself from the prior version\u2019s global variables to\ninstance object state.\nExample 10-19. PP4E\\Gui\\Tools\\queuetest-gui-class.py\n# GUI that displays data produced and queued by worker threads (class-based)\nimport threading, queue, time\nfrom tkinter.scrolledtext import ScrolledText       # or PP4E.Gui.Tour.scrolledtext\nclass ThreadGui(ScrolledText):\n    threadsPerClick = 4\n    def __init__(self, parent=None):\n        ScrolledText.__init__(self, parent)\n        self.pack()\n        self.dataQueue = queue.Queue()              # infinite size\n        self.bind('<Button-1>', self.makethreads)   # on left mouse click\n        self.consumer()                             # queue loop in main thread\nFigure 10-11. Display updated by main GUI thread\n638 | Chapter 10:\u2002GUI Coding Techniquesdef producer(self, id):\n        for i in range(5):\n            time.sleep(0.1)\n            self.dataQueue.put('[producer id=%d, count=%d]' % (id, i))\n    def consumer(self):\n        try:\n            data = self.dataQueue.get(block=False)\n        except queue.Empty:\n            pass\n        else:\n            self.insert('end', 'consumer got => %s\\n' % str(data))\n            self.see('end')\n        self.after(100, self.consumer)    # 10 times per sec\n    def makethreads(self, event):\n        for i in range(self.threadsPerClick):\n            threading.Thread(target=self.producer, args=(i,)).start()\nif __name__ == '__main__':\n    root = ThreadGui()      # in main thread: make GUI, run timer loop\n    root.mainloop()         # pop-up window, enter tk event loop\nWatch for this thread, timer loop, and shared queue technique to resurface later in this\nchapter, as well as in Chapter 11\u2019s more realistic PyEdit program example. In PyEdit,\nwe\u2019ll use it to run external file searches in threads, so they avoid blocking the GUI and\nmay overlap in time. We\u2019ll also revisit the classic producer/consumer thread queue\nmodel in a more realistic scenario later in this chapter, as a way to avoid blocking a\nGUI that must read an input stream\u2014the output of another program.\nThread exits in GUIs\nExample 10-19 also uses Python\u2019s threading module instead of _thread. This would\nnormally mean that, unlike the prior version, the program would not exit if any pro-\nducer threads are still running, unless they are made daemons manually by setting their\ndaemon flag to True. Remember that under threading, programs exit when only dae-\nmonic threads remain; the producer threads here inherit a False daemon value from\nthe thread that creates them, which prevents program exit while they run.\nHowever, in this example the spawned threads finish too quickly to noticeably defer\nprogram exit. Change this script\u2019s time.sleep call to 2.0 seconds to simulate longer-\nlived worker threads and witness this effect in action\u2014closing the window after a left-\nclick erases the window, but the program itself then does not exit for roughly 10 seconds\n(e.g., its shell window is paused). If you do the same to the prior _thread version, or\nset this version\u2019s threads\u2019 daemon flags to True, the program exits immediately instead.\nIn more realistic GUIs, you\u2019ll want to analyze exit policies in the context of running\nthreads, and code accordingly; both nondaemonic threading threads and thread locks\nin general can be used to defer exits if needed. Conversely, a perpetually running\nGUIs, Threads, and Queues | 639threading thread might preclude a desired shutdown if nondaemonic. See Chapter 5\nfor more on program exits and daemonic threads (and other scary topics!).\nPlacing Callbacks on Queues\nIn the prior section\u2019s examples, the data placed on the queue is always a string. That\u2019s\nsufficient for simple applications where there is just one type of producer. If you may\nhave many different kinds of threads producing many different types of results running\nat once, though, this can become difficult to manage. You\u2019ll probably have to insert\nand parse out some sort of type or action information in the string so that the GUI\nknows how to process it.\nImagine an email client, for instance, where multiple sends and receives may overlap\nin time; if all threads share the same single queue, the information they place on it must\nsomehow designate the sort of event it represents\u2014a downloaded mail to display, a\nprogress indicator update, a successful send completion, and so on. This isn\u2019t entirely\nhypothetical: we\u2019ll confront this exact issue in Chapter 14\u2019s PyMailGUI.\nLuckily, queues support much more than just strings\u2014any type of Python object can\nbe placed on a queue. Perhaps the most general of these is a callable object: by placing\na function or other callable object on the queue, a producer thread can tell the GUI\nhow to handle the message in a very direct way. The GUI simply calls the objects it\npulls off the queue. Since threads all run within the same process and memory space,\nany type of callable object works on a queue\u2014simple functions, lambdas, and even\nbound methods that combine a function with an implied subject object that gives access\nto state information and methods. Any updates performed by the callback object up-\ndate state shared across the entire process.\nBecause Python makes it easy to handle functions and their argument lists in generic\nfashion, this turns out to be easier than it might sound. Example 10-20, for instance,\nshows one way to throw callbacks on a queue that we\u2019ll be using in Chapter 14 for\nPyMailGUI. This module comes with a handful of tools. Its ThreadCounter class can be\nused as a shared counter and Boolean flag (for example, to manage operation overlap).\nThe real meat here, though, is the queue interface functions\u2014in short, they allow cli-\nents to launch threads which queue their exit actions, to be dispatched in the main\nthread by a timer loop.\nIn some ways this example is just a variation on those of the prior section\u2014we still run\na timer loop here to pull items off the queue in the main thread. For both responsiveness\nand efficiency, this timer loop pulls at most N items on each timer event, not just one\n(which may take too long or incur overheads for a short timer delay), and not all queued\n(which may block indefinitely when many items are produced quickly). We\u2019ll leverage\nthis per-event batching feature to work through many progress updates in PyMailGUI\nwithout having to devote CPU resources to quick timer events that are normally\nunnecessary.\n640 | Chapter 10:\u2002GUI Coding TechniquesThe main difference to notice here, though, is that we call the object pulled off the\nqueue, and the producer threads have been generalized to place a success or failure\ncallback on the queue in response to exits and exceptions. Moreover, the actions that\nrun in producer threads receive a progress status function which, when called, simply\nadds a progress indicator callback to the queue to be dispatched by the main thread.\nWe can use this, for example, to show progress in the GUI during network downloads.\nExample 10-20. PP4E\\Gui\\Tools\\threadtools.py\n\"\"\"\n#################################################################################\nSystem-wide thread interface utilities for GUIs.\nImplements a single thread callback queue and checker timer loop shared by\nall the windows in a program; worker threads queue their exit and progress\nactions to be run in the main thread; this doesn't block the GUI - it just\nspawns operations and manages and dispatches exits and progress; worker\nthreads can overlap freely with the main thread, and with other workers.\nUsing a queue of callback functions and arguments is more useful than a\nsimple data queue if there can be many kinds of threads running at the\nsame time - each kind may have different implied exit actions.\nBecause GUI API is not completely thread-safe, instead of calling GUI\nupdate callbacks directly after thread main action, place them on a shared\nqueue, to be run from a timer loop in the main thread, not a child thread;\nthis also makes GUI update points less random and unpredictable; requires\nthreads to be split into main action, exit actions, and progress action.\nAssumes threaded action raises an exception on failure, and has a 'progress'\ncallback argument if it supports progress updates;  also assumes callbacks\nare either short-lived or update as they run, and that queue will contain\ncallback functions (or other callables) for use in a GUI app - requires a\nwidget in order to schedule and catch 'after' event loop callbacks; to use\nthis model in non-GUI contexts, could use simple thread timer instead.\n#################################################################################\n\"\"\"\n# run even if no threads                 # in standard lib now\ntry:                                     # raise ImportError to\n    import _thread as thread             # run with GUI blocking\nexcept ImportError:                      # if threads not available\n    import _dummy_thread as thread       # same interface, no threads\n# shared cross-process queue\n# named in shared global scope, lives in shared object memory\nimport queue, sys\nthreadQueue = queue.Queue(maxsize=0)              # infinite size\n#################################################################################\n# IN MAIN THREAD - periodically check thread completions queue; run implied GUI\n# actions on queue in this main GUI thread; one consumer (GUI), and multiple\n# producers (load, del, send); a simple list may suffice too: list.append and\nGUIs, Threads, and Queues | 641# pop atomic?; 4E: runs at most N actions per timer event: looping through all\n# queued callbacks on each timer event may block GUI indefinitely, but running\n# only one can take a long time or consume CPU for timer events (e.g., progress);\n# assumes callback is either short-lived or updates display as it runs: after a\n# callback run, the code here reschedules and returns to event loop and updates;\n# because this perpetual loop runs in main thread, does not stop program exit;\n#################################################################################\ndef threadChecker(widget, delayMsecs=100, perEvent=1):       # 10x/sec, 1/timer\n    for i in range(perEvent):                                # pass to set speed\n        try:\n            (callback, args) = threadQueue.get(block=False)  # run <= N callbacks\n        except queue.Empty:\n            break                                            # anything ready?\n        else:\n            callback(*args)                                  # run callback here\n    widget.after(delayMsecs,                                 # reset timer event\n        lambda: threadChecker(widget, delayMsecs, perEvent)) # back to event loop\n#################################################################################\n# IN A NEW THREAD - run action, manage thread queue puts for exits and progress;\n# run action with args now, later run on* calls with context; calls added to\n# queue here are dispatched in main thread only, to avoid parallel GUI updates;\n# allows action to be fully ignorant of use in a thread here; avoids running\n# callbacks in thread directly: may update GUI in thread, since passed func in\n# shared memory called in thread; progress callback just adds callback to queue\n# with passed args; don't update in-progress counters here: not finished till\n# exit actions taken off queue and dispatched in main thread by threadChecker;\n#################################################################################\ndef threaded(action, args, context, onExit, onFail, onProgress):\n    try:\n        if not onProgress:            # wait for action in this thread\n            action(*args)             # assume raises exception if fails\n        else:\n            def progress(*any):\n                threadQueue.put((onProgress, any + context))\n            action(progress=progress, *args)\n    except:\n        threadQueue.put((onFail, (sys.exc_info(), ) + context))\n    else:\n        threadQueue.put((onExit, context))\ndef startThread(action, args, context, onExit, onFail, onProgress=None):\n    thread.start_new_thread(\n        threaded, (action, args, context, onExit, onFail, onProgress))\n#################################################################################\n# a thread-safe counter or flag: useful to avoid operation overlap if threads\n# update other shared state beyond that managed by the thread callback queue\n#################################################################################\n642 | Chapter 10:\u2002GUI Coding Techniquesclass ThreadCounter:\n    def __init__(self):\n        self.count = 0\n        self.mutex = thread.allocate_lock()     # or use Threading.semaphore\n    def incr(self):\n        self.mutex.acquire()                    # or with self.mutex:\n        self.count += 1\n        self.mutex.release()\n    def decr(self):\n        self.mutex.acquire()\n        self.count -= 1\n        self.mutex.release()\n    def __len__(self): return self.count        # True/False if used as a flag\n#################################################################################\n# self-test code: split thread action into main, exits, progress\n#################################################################################\nif __name__ == '__main__':                      # self-test code when run\n    import time                                 # or PP4E.Gui.Tour.scrolledtext\n    from tkinter.scrolledtext import ScrolledText\n    def onEvent(i):                             # code that spawns thread\n        myname = 'thread-%s' % i\n        startThread(\n            action     = threadaction,\n            args       = (i, 3),\n            context    = (myname,),\n            onExit     = threadexit,\n            onFail     = threadfail,\n            onProgress = threadprogress)\n    # thread's main action\n    def threadaction(id, reps, progress):       # what the thread does\n        for i in range(reps):\n            time.sleep(1)\n            if progress: progress(i)            # progress callback: queued\n        if id % 2 == 1: raise Exception         # odd numbered: fail\n    # thread exit/progress callbacks: dispatched off queue in main thread\n    def threadexit(myname):\n        text.insert('end', '%s\\texit\\n' % myname)\n        text.see('end')\n    def threadfail(exc_info, myname):\n        text.insert('end', '%s\\tfail\\t%s\\n' % (myname, exc_info[0]))\n        text.see('end')\n    def threadprogress(count, myname):\n        text.insert('end', '%s\\tprog\\t%s\\n' % (myname, count))\n        text.see('end')\n        text.update()   # works here: run in main thread\n    # make enclosing GUI and start timer loop in main thread\nGUIs, Threads, and Queues | 643# spawn batch of worker threads on each mouse click: may overlap\n    text = ScrolledText()\n    text.pack()\n    threadChecker(text)                 # start thread loop in main thread\n    text.bind('<Button-1>',             # 3.x need list for map, range ok\n              lambda event: list(map(onEvent, range(6))) )\n    text.mainloop()                     # pop-up window, enter tk event loop\nThis module\u2019s comments describe its implementation, and its self-test code demon-\nstrates how this interface is used. Notice how a thread\u2019s behavior is split into main\naction, exit actions, and optional progress action\u2014the main action runs in the new\nthread, but the others are queued to be dispatched in the main thread. That is, to use\nthis module, you will essentially break a modal operation into thread and post-thread\nsteps, with an optional progress call. Generally, only the thread step should be long\nrunning.\nWhen Example 10-20 is run standalone, on each button click in a ScrolledTest, it starts\nup six threads, all running the threadaction function. As this threaded function runs,\ncalls to the passed-in progress function place a callback on the queue, which invokes\nthreadprogress in the main thread. When the threaded function exits, the interface\nlayer will place a callback on the queue that will invoke either threadexit or thread\nfail in the main thread, depending upon whether the threaded function raised an ex-\nception. Because all the callbacks placed on the queue are pulled off and run in the\nmain thread\u2019s timer loop, this guarantees that GUI updates occur in the main thread\nonly and won\u2019t overlap in parallel.\nFigure 10-12 shows part of the output generated after clicking the example\u2019s window.\nIts exit, failure, and progress messages are produced by callbacks added to the queue\nby spawned threads and invoked from the timer loop running in the main thread.\nStudy this code for more details and try to trace through the self-test code. This is a bit\ncomplex, and you may have to make more than one pass over this code to make sense\nof its juggling act. Once you get the hang of this paradigm, though, it provides a general\nscheme for handling heterogeneous overlapping threads in a uniform way. PyMailGUI,\nfor example, will do very much the same as onEvent in the self-test code here, whenever\nit needs to start a mail transfer.\nPassing bound method callbacks on queues\nTechnically, to make this even more flexible, PyMailGUI in Chapter 14 will queue\nbound methods with this module\u2014callable objects that, as mentioned, pair a method\nfunction with an instance that gives access to state information and other methods. In\nthis mode, the thread manager module\u2019s client code takes a form that looks more like\nExample 10-21: a revision of the prior example\u2019s self-test using classes and methods.\n644 | Chapter 10:\u2002GUI Coding TechniquesExample 10-21. PP4E\\Gui\\Tools\\threadtools-test-classes.py\n# tests thread callback queue, but uses class bound methods for action and callbacks\nimport time\nfrom threadtools import threadChecker, startThread\nfrom tkinter.scrolledtext import ScrolledText\nclass MyGUI:\n    def __init__(self, reps=3):\n        self.reps = reps                        # uses default Tk root\n        self.text = ScrolledText()              # save widget as state\n        self.text.pack()\n        threadChecker(self.text)                # start thread check loop\n        self.text.bind('<Button-1>',            # 3.x need list for map, range ok\n              lambda event: list(map(self.onEvent, range(6))) )\n    def onEvent(self, i):                       # code that spawns thread\n        myname = 'thread-%s' % i\n        startThread(\n            action     = self.threadaction,\n            args       = (i, ),\n            context    = (myname,),\n            onExit     = self.threadexit,\n            onFail     = self.threadfail,\n            onProgress = self.threadprogress)\n    # thread's main action\n    def threadaction(self, id, progress):       # what the thread does\nFigure 10-12. Messages from queued callbacks\nGUIs, Threads, and Queues | 645for i in range(self.reps):              # access to object state here\n            time.sleep(1)\n            if progress: progress(i)            # progress callback: queued\n        if id % 2 == 1: raise Exception         # odd numbered: fail\n    # thread callbacks: dispatched off queue in main thread\n    def threadexit(self, myname):\n        self.text.insert('end', '%s\\texit\\n' % myname)\n        self.text.see('end')\n    def threadfail(self, exc_info, myname):     # have access to self state\n        self.text.insert('end', '%s\\tfail\\t%s\\n' % (myname, exc_info[0]))\n        self.text.see('end')\n    def threadprogress(self, count, myname):\n        self.text.insert('end', '%s\\tprog\\t%s\\n' % (myname, count))\n        self.text.see('end')\n        self.text.update()   # works here: run in main thread\nif __name__ == '__main__': MyGUI().text.mainloop()\nThis code both queues bound methods as thread exit and progress actions and runs\nbound methods as the thread\u2019s main action itself. As we learned in Chapter 5, because\nthreads all run in the same process and memory space, bound methods reference the\noriginal in-process instance object, not a copy of it. This allows them to update the GUI\nand other implementation state directly. Furthermore, because bound methods are\nnormal objects which pass for callables interchangeably with simple functions, using\nthem both on queues and in threads this way just works. To many, this broadly shared\nstate of threads is one of their primary advantages over processes.\nWatch for the more realistic application of this module in Chapter 14\u2019s PyMailGUI,\nwhere it will serve as the core thread exit and progress dispatch engine. There, we\u2019ll\nalso run bound methods as thread actions, too, allowing both threads and their queued\nactions to access shared mutable object state of the GUI. As we\u2019ll see, queued action\nupdates are automatically made thread-safe by this module\u2019s protocol, because they\nrun in the main thread only. Other state updates to shared objects performed in\nspawned threads, though, may still have to be synchronized separately if they might\noverlap with other threads, and are made outside the scope of the callback queue. A\ndirect update to a mail cache, for instance, might lock out other operations until \nfinished.\nMore Ways to Add GUIs to Non-GUI Code\nSometimes, GUIs pop up quite unexpectedly. Perhaps you haven\u2019t learned GUI pro-\ngramming yet; or perhaps you\u2019re just pining for non-event-driven days past. But for\nwhatever reason, you may have written a program to interact with a user in an inter-\nactive console, only to decide later that interaction in a real GUI would be much nicer.\nWhat to do?\n646 | Chapter 10:\u2002GUI Coding TechniquesProbably the real answer to converting a non-GUI program is to truly convert it\u2014\nrestructure it to initialize widgets on startup, call mainloop once to start event processing\nand display the main window, and move all program logic into callback functions trig-\ngered by user actions. Your original program\u2019s actions become event handlers, and your\noriginal main flow of control becomes a program that builds a main window, calls the\nGUI\u2019s event loop once, and waits.\nThis is the traditional way to structure a GUI program, and it makes for a coherent user\nexperience; windows pop up on request, instead of showing up at seemingly random\ntimes. Until you\u2019re ready to bite the bullet and perform such a structural conversion,\nthough, there are other possibilities. For example, in the ShellGui section earlier in this\nchapter, we saw how to add windows to file packing scripts to collect inputs (Exam-\nple 10-5 and beyond); later, we also saw how to redirect such scripts\u2019 outputs to GUIs\nwith the GuiOutput class (Example 10-13). This approach works if the non-GUI oper-\nation we\u2019re wrapping up in a GUI is a single operation; for more dynamic user inter-\naction, other techniques might be needed.\nIt\u2019s possible, for instance, to launch GUI windows from a non-GUI main program, by\ncalling the tkinter mainloop each time a window must be displayed. It\u2019s also possible to\ntake a more grandiose approach and add a completely separate program for the GUI\nportion of your application. To wrap up our survey of GUI programming techniques,\nlet\u2019s briefly explore each scheme.\nPopping Up GUI Windows on Demand\nIf you just want to add a simple GUI user interaction to an existing non-GUI script\n(e.g., to select files to open or save), it is possible to do so by configuring widgets and\ncalling mainloop from the non-GUI main program when you need to interact with the\nuser. This essentially makes the program GUI-capable, but without a persistent main\nwindow. The trick is that mainloop doesn\u2019t return until the GUI main window is closed\nby the user (or quit method calls), so you cannot retrieve user inputs from the destroyed\nwindow\u2019s widgets after mainloop returns. To work around this, all you have to do is be\nsure to save user inputs in a Python object: the object lives on after the GUI is destroyed.\nExample 10-22 shows one way to code this idea in Python.\nExample 10-22. PP4E\\Gui\\Tools\\mainloopdemo.py\n\"\"\"\ndemo running two distinct mainloop calls; each returns after the main window is\nclosed; save user results on Python object: GUI is gone; GUIs normally configure\nwidgets and then run just one mainloop, and have all their logic in callbacks; this\ndemo uses mainloop calls to implement two modal user interactions from a non-GUI\nmain program; it shows one way to add a GUI component to an existing non-GUI script,\nwithout restructuring code;\n\"\"\"\nfrom tkinter import *\nfrom tkinter.filedialog import askopenfilename, asksaveasfilename\nMore Ways to Add GUIs to Non-GUI Code | 647class Demo(Frame):\n    def __init__(self,parent=None):\n        Frame.__init__(self,parent)\n        self.pack()\n        Label(self, text =\"Basic demos\").pack()\n        Button(self, text='open', command=self.openfile).pack(fill=BOTH)\n        Button(self, text='save', command=self.savefile).pack(fill=BOTH)\n        self.open_name = self.save_name = \"\"\n    def openfile(self):                         # save user results\n        self.open_name = askopenfilename()      # use dialog options here\n    def savefile(self):\n        self.save_name = asksaveasfilename(initialdir='C:\\\\Python31')\nif  __name__ == \"__main__\":\n    # display window once\n    print('popup1...')\n    mydialog = Demo()                # attaches Frame to default Tk()\n    mydialog.mainloop()              # display; returns after windows closed\n    print(mydialog.open_name)        # names still on object, though GUI gone\n    print(mydialog.save_name)\n    # Non GUI section of the program uses mydialog here\n    # display window again\n    print('popup2...')\n    mydialog = Demo()              # re-create widgets again\n    mydialog.mainloop()            # window pops up again\n    print(mydialog.open_name)      # new values on the object again\n    print(mydialog.save_name)\n    # Non GUI section of the program uses mydialog again\n    print('ending...')\nThis program twice builds and displays a simple two-button main window that\nlaunches file selection dialogs, shown in Figure 10-13. Its output, printed as the GUI\nwindows are closed, looks like this:\nC:\\...\\PP4E\\Gui\\Tools> mainloopdemo.py\npopup1...\nC:/Users/mark/Stuff/Books/4E/PP4E/dev/Examples/PP4E/Gui/Tools/widgets.py\nC:/Python31/python.exe\npopup2...\nC:/Users/mark/Stuff/Books/4E/PP4E/dev/Examples/PP4E/Gui/Tools/guimixin.py\nC:/Python31/Lib/tkinter/__init__.py\nending...\nNotice how this program calls mainloop twice, to implement two modal user interac-\ntions from an otherwise non-GUI script. It\u2019s OK to call mainloop more than once, but\nthis script takes care to re-create the GUI\u2019s widgets before each call because they are\ndestroyed when the previous mainloop call exits (widgets are destroyed internally inside\nTk, even though the corresponding Python widget object still exists). Again, this can\nmake for an odd user experience compared to a traditional GUI program structure\u2014\nwindows seem to pop up from nowhere\u2014but it\u2019s a quick way to put a GUI face on a\nscript without reworking its code.\n648 | Chapter 10:\u2002GUI Coding TechniquesNote that this is different from using nested (recursive) mainloop calls to implement\nmodal dialogs, as we did in Chapter 8. In that mode, the nested mainloop call returns\nwhen the dialog\u2019s quit method is called, but we return to the enclosing mainloop layer\nand remain in the realm of event-driven programming. Example 10-22 instead runs\nmainloop two different times, stepping into and out of the event-driven model twice.\nFinally, note that this scheme works only if you don\u2019t have to run any non-GUI code\nwhile the GUI is open, because your script\u2019s mainline code is inactive and blocked while\nmainloop runs. You cannot, for example, apply this technique to use utilities like those\nin the guiStreams module we met earlier in this chapter to route user interaction from\nnon-GUI code to GUI windows. The GuiInput and GuiOutput classes in that example\nassume that there is a mainloop call running somewhere (they\u2019re GUI-based, after all).\nBut once you call mainloop to pop up these windows, you can\u2019t return to your non-GUI\ncode to interact with the user or the GUI until the GUI is closed and the mainloop call\nreturns. The net effect is that these classes can be used only in the context of a fully\nGUI program.\nBut really, this is an artificial way to use tkinter. Example 10-22 works only because\nthe GUI can interact with the user independently, while the mainloop call runs; the\nscript is able to surrender control to the tkinter mainloop call and wait for results. That\nscheme won\u2019t work if you must run any non-GUI code while the GUI is open. Because\nof such constraints, you will generally need a main-window-plus-callbacks model in\nmost GUI programs\u2014callback code runs in response to user interaction while the GUI\nremains open. That way, your code can run while GUI windows are active. For an\nexample, see earlier in this chapter for the way the non-GUI packer and unpacker scripts\nwere run from a GUI so that their results appear in a GUI; technically, these scripts are\nrun in a GUI callback handler so that their output can be routed to a widget.\nAdding a GUI As a Separate Program: Sockets (A Second Look)\nAs mentioned earlier, it\u2019s also possible to spawn the GUI part of your application as a\ncompletely separate program. This is a more advanced technique, but it can make\nintegration simple for some applications because of the loose coupling it implies. It can,\nfor instance, help with the guiStreams issues of the prior section, as long as inputs and\noutputs are communicated to the GUI over Inter-Process Communication (IPC)\nFigure 10-13. GUI window popped up by non-GUI main program\nMore Ways to Add GUIs to Non-GUI Code | 649mechanisms, and the widget after method (or similar) is used by the GUI program to\ndetect incoming output to be displayed. The non-GUI script would not be blocked by\na mainloop call.\nFor example, the GUI could be spawned by the non-GUI script as a separate program,\nwhere user interaction results can be communicated from the spawned GUI to the script\nusing pipes, sockets, files, or other IPC mechanisms we met in Chapter 5. The advantage\nto this approach is that it provides a separation of GUI and non-GUI code\u2014the non-\nGUI script would have to be modified only to spawn and wait for user results to appear\nfrom the separate GUI program, but could otherwise be used as is. Moreover, the non-\nGUI script would not be blocked while an in-process mainloop call runs (only the GUI\nprocess would run a mainloop), and the GUI program could persist after the point at\nwhich user inputs are required by the script, leading to fewer pop-up windows.\nIn other scenarios, the GUI may spawn the non-GUI script instead, and listen for its\nfeedback on an IPC device connected to the script\u2019s output stream. In even more com-\nplex arrangements, the GUI and non-GUI script may converse back and forth over\nbidirectional connections.\nExamples 10-23, 10-24, and 10-25 provide a simple example of these techniques in\naction: a non-GUI script sending output to a GUI. They represent non-GUI and GUI\nprograms that communicate over sockets\u2014the IPC and networking device we met\nbriefly in Chapter 5 and will explore in depth in the next part of the book. The important\npoint to notice as we study these files is the way the programs are linked: when the\nnon-GUI script prints to its standard output, the printed text is sent over a socket\nconnection to the GUI program. Other than the import and call to the socket redirection\ncode, the non-GUI program knows nothing at all about GUIs or sockets, and the GUI\nprogram knows nothing about the program whose output it displays. Because this\nmodel does not require existing scripts to be entirely rewritten to support a GUI, it is\nideal for scripts that otherwise run on the world of shells and command lines.\nIn terms of code, we first need some IPC linkage in between the script and the GUI.\nExample 10-23 encapsulates the client-side socket connection used by non-GUI code\nfor reuse. As is, it\u2019s a partial work in progress (notice the ... ellipses operator in its last\nfew functions\u2014Python\u2019s notion of \u201cTo be decided,\u201d and equivalent to a pass in this\ncontext). Because sockets are covered in full in Chapter 12, we\u2019ll defer other stream\nredirection modes until then, when we\u2019ll also flesh out the rest of this module. The\nversion of this module here implements just the client-side connection of the standard\noutput stream to a socket\u2014perfect for a GUI that wants to intercept a non-GUI script\u2019s\nprinted text.\nExample 10-23. PP4E\\Gui\\Tools\\socket_stream_redirect0.py\n\"\"\"\n[partial] Tools for connecting streams of non-GUI programs to sockets\nthat a GUI (or other) can use to interact with the non-GUI program;\nsee Chapter 12 and PP4E\\Sockets\\Internet for a more complete treatment\n\"\"\"\n650 | Chapter 10:\u2002GUI Coding Techniquesimport sys\nfrom socket import *\nport = 50008\nhost = 'localhost'\ndef redirectOut(port=port, host=host):\n    \"\"\"\n    connect caller's standard output stream to a socket for GUI to listen;\n    start caller after listener started, else connect fails before accept\n    \"\"\"\n    sock = socket(AF_INET, SOCK_STREAM)\n    sock.connect((host, port))                # caller operates in client mode\n    file = sock.makefile('w')                 # file interface: text, bufferred\n    sys.stdout = file                         # make prints go to sock.send\ndef redirectIn(port=port, host=host): ...               # see Chapter 12\ndef redirectBothAsClient(port=port, host=host): ...     # see Chapter 12\ndef redirectBothAsServer(port=port, host=host): ...     # see Chapter 12\nNext, Example 10-24 uses Example 10-23 to redirect its prints to a socket on which a\nGUI server program may listen; this requires just two lines of code at the top of the\nscript, and is done selectively based upon the value of a command-line argument (with-\nout the argument, the script runs in fully non-GUI mode):\nExample 10-24. PP4E\\Gui\\Tools\\socket-nongui.py\n# non-GUI side: connect stream to socket and proceed normally\nimport time, sys\nif len(sys.argv) > 1:                            # link to gui only if requested\n    from socket_stream_redirect0 import *        # connect my sys.stdout to socket\n    redirectOut()                                # GUI must be started first as is\n# non-GUI code\nwhile True:                                      # print data to stdout:\n    print(time.asctime())                        # sent to GUI process via socket\n    sys.stdout.flush()                           # must flush to send: buffered!\n    time.sleep(2.0)                              # no unbuffered mode, -u irrelevant\nAnd finally, the GUI part of this exchange is the program in Example 10-25. This script\nimplements a GUI to display the text printed by the non-GUI program, but it knows\nnothing of that other program\u2019s logic. For the display, the GUI program prints to the\nstream redirection object we met earlier in this chapter (Example 10-12); because this\nprogram runs a GUI mainloop call, this all just works.\nWe\u2019re also running a timer loop here to detect incoming data on the socket as it arrives,\ninstead of waiting for the non-GUI program to run to completion. Because the socket\nis set to be nonblocking, input calls don\u2019t wait for data to appear, and hence, do not\nblock the GUI.\nMore Ways to Add GUIs to Non-GUI Code | 651Example 10-25. PP4E\\Gui\\Tools\\socket-gui.py\n# GUI server side: read and display non-GUI script's output\nimport sys, os\nfrom socket import *                         # including socket.error\nfrom tkinter import Tk\nfrom PP4E.launchmodes import PortableLauncher\nfrom PP4E.Gui.Tools.guiStreams import GuiOutput\nmyport = 50008\nsockobj = socket(AF_INET, SOCK_STREAM)       # GUI is server, script is client\nsockobj.bind(('', myport))                   # config server before client\nsockobj.listen(5)\nprint('starting')\nPortableLauncher('nongui', 'socket-nongui.py -gui')()  # spawn non-GUI script\nprint('accepting')\nconn, addr = sockobj.accept()                # wait for client to connect\nconn.setblocking(False)                      # use nonblocking socket (False=0)\nprint('accepted')\ndef checkdata():\n    try:\n        message = conn.recv(1024)            # don't block for input\n        #output.write(message + '\\n')        # could do sys.stdout=output too\n        print(message, file=output)          # if ready, show text in GUI window\n    except error:                            # raises socket.error if not ready\n        print('no data')                     # print to sys.stdout\n    root.after(1000, checkdata)              # check once per second\nroot = Tk()\noutput = GuiOutput(root)                     # socket text is displayed on this\ncheckdata()\nroot.mainloop()\nStart Example 10-25\u2019s file to launch this example. When both the GUI and the non-\nGUI processes are running, the GUI picks up a new message over the socket roughly\nonce every two seconds and displays it in the window shown in Figure 10-14. The GUI\u2019s\ntimer loop checks for data once per second, but the non-GUI script sends a message\nevery two seconds only due to its time.sleep calls. The printed output in the terminal\nwindows is as follows\u2014\u201cno data\u201d messages and lines in the GUI alternate each second:\nC:\\...\\PP4E\\Gui\\Tools> socket-gui.py\nstarting\nnongui\naccepting\naccepted\nno data\nno data\nno data\nno data\n...more...\n652 | Chapter 10:\u2002GUI Coding TechniquesNotice how we\u2019re displaying bytes strings in Figure 10-14\u2014even though the non-GUI\nscript prints text, the GUI script reads it with the raw socket interface, and sockets deal\nin binary byte strings in Python 3.X.\nRun this example by yourself for a closer look. In high-level terms, the GUI script\nspawns the non-GUI script and displays a pop-up window that shows the text printed\nby the non-GUI script (the date and time). The non-GUI script can keep running linear,\nprocedural code to produce data, because only the GUI script\u2019s process runs an event-\ndriven mainloop call.\nMoreover, unlike our earlier stream redirection explorations which simply connected\nthe script\u2019s streams to GUI objects running in the same process, this decoupled two-\nprocess approach prevents the GUI from being blocked while waiting for the script to\nproduce output; the GUI process remains fully and independently active, and simply\npicks up new results as they appear (more on this in the next section). This model is\nsimilar in spirit to our earlier thread queue examples, but the actors here are separate\nprograms linked by a socket, not in-process function calls.\nAlthough we aren\u2019t going to get into enough socket details in this chapter to fully\nexplain this script\u2019s code, there are a few fine points worth underscoring here:\n\u2022 This example should probably be augmented to detect and handle an end-of-file\nsignal from the spawned program, and then terminate its timer loop.\n\u2022 The non-GUI script could also start the GUI instead, but in the socket world, the\nserver\u2019s end (the GUI) must be configured to accept connections before the client\nFigure 10-14. Messages printed to a GUI from a non-GUI program (socket)\nMore Ways to Add GUIs to Non-GUI Code | 653(the non-GUI) can connect. One way or another, the GUI has to start before the\nnon-GUI connects to it or the non-GUI script will be denied a connection and\nwill fail.\n\u2022 Because of the buffered text nature of the socket.makefile objects used for streams\nhere, the client program is required to flush its printed output with\nsys.stdout.flush to send data to the GUI\u2014without this call, the GUI receives and\ndisplays nothing. As we\u2019ll learn in Chapter 12, this isn\u2019t required for command\npipes, but it is when streams are reset to wrapped sockets as done here. These\nwrappers don\u2019t support unbuffered modes in Python 3.X, and there is no equivalent\nto the -u flag in this context (more on -u and command pipes in the next section).\nStay tuned for much more on this example and topic in Chapter 12. Its socket client/\nserver model works well and is a general approach to connecting GUI and non-GUI\ncode, but there are other coding alternatives worth exploring in the next section before\nwe move on.\nAdding a GUI As a Separate Program: Command Pipes\nThe net effect of the two programs of the preceding section is similar to a GUI program\nreading the output of a shell command over a pipe file with os.popen (or the\nsubprocess.Popen interface upon which it is based). As we\u2019ll see later, though, sockets\nalso support independent servers, and can link programs running on remote machines\nacross a network\u2014a much larger idea we\u2019ll be exploring in Chapter 12.\nPerhaps subtler and more significant for our GUI exploration here is the fact that with-\nout an after timer loop and nonblocking input sources of the sort used in the prior\nsection, the GUI may become stuck and unresponsive while waiting for data from the\nnon-GUI program and may not be able to handle more than one data stream.\nFor instance, consider the guiStreams call we wrote in Example 10-12 to redirect the\noutput of a shell command spawned with os.popen to a GUI window. We could use\nthis with simplistic code like that in Example 10-26 to capture the output of a spawned\nPython program and display it in a separately running GUI program\u2019s window. This is\nas concise as it is because it relies on the read/write loop and GuiOutput class in Exam-\nple 10-12 to both manage the GUI and read the pipe; it\u2019s essentially the same as one of\nthe options in that example\u2019s self-test code, but we read the printed output of a Python\nprogram here.\nExample 10-26. PP4E\\Gui\\Tools\\pipe-gui1.py\n# GUI reader side: route spawned program standard output to a GUI window\nfrom PP4E.Gui.Tools.guiStreams import redirectedGuiShellCmd       # uses GuiOutput\nredirectedGuiShellCmd('python -u pipe-nongui.py')                 # -u: unbuffered\n654 | Chapter 10:\u2002GUI Coding TechniquesNotice the -u Python command-line flag used here: it forces the spawned program\u2019s\nstandard streams to be unbuffered, so we get printed text immediately as it is produced,\ninstead of waiting for the spawned program to completely finish.\nWe talked about this option in Chapter 5, when discussing deadlocks and pipes. Recall\nthat print writes to sys.stdout, which is normally buffered when connected to a pipe\nthis way. If we don\u2019t use the -u flag here and the spawned program doesn\u2019t manually\ncall sys.stdout.flush, we won\u2019t see any output in the GUI until the spawned program\nexits or until its buffers fill up. If the spawned program is a perpetual loop that does\nnot exit, we may be waiting a long time for output to appear on the pipe, and hence,\nin the GUI.\nThis approach makes the non-GUI code in Example 10-27 much simpler: it just writes\nto standard output as usual, and it need not be concerned with creating a socket in-\nterface. Compare this with its socket-based equivalent in Example 10-24\u2014the loop is\nthe same, but we don\u2019t need to connect to sockets first (the spawning parent reads the\nnormal output stream), and don\u2019t need to manually flush output as it\u2019s produced (the\n-u flag in the spawning parent prevents buffering).\nExample 10-27. PP4E\\Gui\\Tools\\pipe-nongui.py\n# non-GUI side: proceed normally, no need for special code\nimport time\nwhile True:                          # non-GUI code\n    print(time.asctime())            # sends to GUI process\n    time.sleep(2.0)                  # no need to flush here\nStart the GUI script in Example 10-26: it launches the non-GUI program automatically,\nreads its output as it is created, and produces the window in Figure 10-15\u2014it\u2019s similar\nto the socket-based example\u2019s result in Figure 10-14, but displays the str text strings\nwe get from reading pipes, not the byte strings of sockets.\nThis works, but the GUI is odd\u2014we never call mainloop ourselves, and we get a default\nempty top-level window. In fact, it apparently works at all only because the tkinter\nupdate call issued within the redirect function enters the Tk event loop momentarily to\nprocess pending events. To do better, Example 10-28 creates an enclosing GUI and\nkicks off an event loop manually by the time the shell command is spawned; when run,\nit produces the same output window (Figure 10-15).\nExample 10-28. PP4E\\Gui\\Tools\\pipe-gui2.py\n# GUI reader side: like pipes-gui1, but make root window and mainloop explicit\nfrom tkinter import *\nfrom PP4E.Gui.Tools.guiStreams import redirectedGuiShellCmd\ndef launch():\n    redirectedGuiShellCmd('python -u pipe-nongui.py')\nMore Ways to Add GUIs to Non-GUI Code | 655window = Tk()\nButton(window, text='GO!', command=launch).pack()\nwindow.mainloop()\nThe -u unbuffered flag is crucial here again\u2014without it, you won\u2019t see the text output\nwindow. The GUI will be blocked in the initial pipe input call indefinitely because the\nspawned program\u2019s standard output will be queued up in an in-memory buffer.\nOn the other hand, this -u unbuffered flag doesn\u2019t prevent blocking in the prior sec-\ntion\u2019s socket scheme, because that example resets streams to other objects after the\nspawned program starts; more on this in Chapter 12. Also remember that the buffering\nargument in os.popen (and subprocess.Popen) controls buffering in the caller, not in the\nspawned program; -u pertains to the latter.\nThe specter of blocking input calls\nEither way we code them, however, when the GUIs of Example 10-26 and Exam-\nple 10-28 are run they become unresponsive for two seconds at a time while they read\ndata from the os.popen pipe. In fact, they are just plain sluggish\u2014window moves, re-\nsizes, redraws, raises, and so on, are delayed for up to two seconds, until the non-GUI\nprogram sends data to the GUI to make the pipe read call return. Perhaps worse, if you\npress the \u201cGO!\u201d button twice in the second version of the GUI, only one window\nupdates itself every two seconds, because the GUI is stuck in the second button press\ncallback\u2014it never exits the loop that reads from the pipe until the spawned non-GUI\nFigure 10-15. Messages printed to a GUI from a non-GUI program (command pipe)\n656 | Chapter 10:\u2002GUI Coding Techniquesprogram exits. Exits are not necessarily graceful either (you get multiple error messages\nin the terminal window).\nBecause of such constraints, to avoid blocked states, a separately running GUI cannot\ngenerally read data directly if its appearance may be delayed. For instance, in the socket-\nbased scripts of the prior section (Example 10-25), the after timer loop allows the GUI\nto poll for data instead of waiting, and display it as it arrives. Because it doesn\u2019t wait\nfor the data to show up, its GUI remains active in between outputs.\nOf course, the real issue here is that the read/write loop in the guiStreams utility function\nused is too simplistic; issuing a read call within a GUI is generally prone to blocking.\nThere are a variety of ways we might try to avoid this.\nUpdating GUIs within threads\u2026and other nonsolutions\nOne candidate fix is to try to run the redirection loop call in a thread\u2014for example, by\nchanging the launch function in Example 10-28 as follows (this is from file pipe-gui2-\nthread.py on the examples distribution):\ndef launch():\n    import _thread\n    _thread.start_new_thread(redirectedGuiShellCmd, ('python -u pipe-nongui.py',))\nBut then we would be updating the GUI from a spawned thread, which, as we\u2019ve\nlearned, is a generally bad idea. Parallel updates can wreak havoc in GUIs.\nIf fact, with this change the GUI fails spectacularly\u2014it hangs immediately on the first\n\u201cGO!\u201d button press on my Windows 7 laptop, becomes unresponsive, and must be\nforcibly closed. This happens before (or perhaps during) the creation of the new pop-\nup scrolled-text window. When this example was run on Windows XP for the prior\nedition of this book, it also hung on the first \u201cGO!\u201d press occasionally and always hung\neventually if you pressed the button enough times; the process had to be forcibly killed.\nDirect GUI updates in threads are not a viable solution.\nAlternatively, we could try to use the Python select.select call (described in Chap-\nter 12) to implement polling for data on the input pipe; unfortunately, select works\nonly on sockets in Windows today (it also works on pipes and other file descriptors in\nUnix).\nIn other contexts, a separately spawned GUI might also use signals to inform the non-\nGUI program when points of interaction arise, and vice versa (the Python signal mod-\nule and os.kill call were introduced in Chapter 5). The downside with this approach\nis that it still requires changes to the non-GUI program to handle the signals.\nNamed pipes (the fifo files introduced in Chapter 5) are sometimes an alternative to\nthe socket calls of the original Examples 10-23 through 10-25, but sockets work on\nstandard Windows Python, and fifos do not (os.mkfifo is not available in Windows in\nPython 3.1, though it is in Cygwin Python). Even where they do work, we would still\nneed an after timer loop in the GUI to avoid blocking.\nMore Ways to Add GUIs to Non-GUI Code | 657We might also use tkinter\u2019s createfilehandler to register a callback to be run when \ninput shows up on the input pipe:\ndef callback(file, mask):\n    ...read from file here...\nimport _tkinter, tkinter\n_tkinter.createfilehandler(file, tkinter.READABLE, callback)\nThe file handler creation call is also available within tkinter and as a method of a Tk\ninstance object. Unfortunately again, as noted near the end of Chapter 9, this call is \nnot available on Windows and is a Unix-only alternative.\nAvoiding blocking input calls with non-GUI threads\nAs a far more general solution to the blocking input delays of the prior section, the GUI \nprocess might instead spawn a thread that reads the socket or pipe and places the data \non a queue. In fact, the thread techniques we met earlier in this chapter could be used \ndirectly in such a role. This way, the GUI is not blocked while the thread waits for data \nto show up, and the thread does not attempt to update the GUI itself. Moreover, more \nthan one data stream or long-running activity can overlap in time.\nExample 10-29 shows how. The main trick this script employs is to split up the input \nand output parts of the original redirectedGuiShellCmd of the guiStreams module we \nmet earlier in Example 10-12. By so doing, the input portion can be spawned off in a \nparallel thread and not block the GUI. The main GUI thread uses an after timer loop \nas usual, to watch for data to be added by the reader thread to a shared queue. Because \nthe main thread doesn\u2019t read program output itself, it does not get stuck in wait states.\nExample 10-29. PP4E\\Gui\\Tools\\pipe_gui3.py \n\"\"\"\nread command pipe in a thread and place output on a queue checked in timer loop;\nallows script to display program's output without being blocked between its outputs;\nspawned programs need not connect or flush, but this approaches complexity of sockets\n\"\"\"\nimport _thread as thread, queue, os\nfrom tkinter import Tk\nfrom PP4E.Gui.Tools.guiStreams import GuiOutput\nstdoutQueue = queue.Queue()                        # infinite size\ndef producer(input):\n    while True:\n        line = input.readline()                    # OK to block: child thread\n        stdoutQueue.put(line)                      # empty at end-of-file\n        if not line: break\ndef consumer(output, root, term='<end>'):\n    try:\n        line = stdoutQueue.get(block=False)        # main thread: check queue\n    except queue.Empty:                            # 4 times/sec, OK if empty\n658 | Chapter 10:\u2002GUI Coding Techniquespass\n    else:\n        if not line:                               # stop loop at end-of-file\n            output.write(term)                     # else display next line\n            return\n        output.write(line)\n    root.after(250, lambda: consumer(output, root, term))\ndef redirectedGuiShellCmd(command, root):\n    input  = os.popen(command, 'r')                # start non-GUI program\n    output = GuiOutput(root)\n    thread.start_new_thread(producer, (input,))    # start reader thread\n    consumer(output, root)\nif __name__ == '__main__':\n    win = Tk()\n    redirectedGuiShellCmd('python -u pipe-nongui.py', win)\n    win.mainloop()\nAs usual, we use a queue here to avoid updating the GUI except in the main thread.\nNote that we didn\u2019t need a thread or queue in the prior section\u2019s socket example, just\nbecause we\u2019re able to poll a socket to see whether it has data without blocking; an\nafter timer loop was enough. For a shell-command pipe, though, a thread is an easy\nway to avoid blocking.\nWhen run, this program\u2019s self-test code creates a ScrolledText window that displays\nthe current date and time sent from the pipes-nongui.py script in Example 10-27. In\nfact, its window is identical to that of the prior versions (see Figure 10-15). The window\nis updated with a new line every two seconds because that\u2019s how often the spawned\npipes-nongui script prints a message to stdout.\nNote how the producer thread calls readline() to load just one line at a time. We can\u2019t\nuse input calls that consume the entire stream all at once (e.g., read(), readlines()),\nbecause such calls would not return until the program exits and sends end-of-file. The\nread(N) call would work to grab one piece of the output as well, but we assume that\nthe output stream is text here. Also notice that the -u unbuffered stream flag is used\nhere again, to get output as it is produced; without it, output won\u2019t show up in the GUI\nat all because it is buffered in the spawned program (try it yourself).\nSockets and pipes: Compare and contrast\nLet\u2019s see how we\u2019ve done. This script is similar in spirit to what we did in Exam-\nple 10-28. Because of the way its code is structured, though, Example 10-29 has a major\nadvantage: because input calls are spawned off in a thread this time, the GUI is com-\npletely responsive. Window moves, resizes, and so forth, happen immediately because\nthe GUI is not blocked while waiting for the next output from the non-GUI program.\nThe combination of a pipe, thread, and queue works wonders here\u2014the GUI need not\nwait for the spawned program, and the spawned thread need not update the GUI itself.\nMore Ways to Add GUIs to Non-GUI Code | 659Although it is more complex and requires thread support, Example 10-29\u2019s lack of\nblocking makes this redirectedGuiShellCmd much more generally useful than the orig-\ninal pipe version we coded. Compared to the sockets of the prior section, though, this\nsolution is a bit of a mixed bag:\n\u2022 Because this GUI reads the spawned program\u2019s standard output, no changes are\nrequired in the non-GUI program. Unlike the socket-based example in the prior\nsection, the non-GUI program here needs no knowledge of the GUI that will display\nits results\u2014it need not connect to a socket and need not flush its input stream, as\nrequired for the earlier socket-based option.\n\u2022 Although it requires no changes to the programs whose output is displayed, the\nGUI code\u2019s complexity begins to approach that of the socket-based alternative,\nespecially if you strip away the boilerplate code required for all socket programs.\n\u2022 It does not directly support running the GUI and non-GUI programs separately,\nor on remote machines. As we\u2019ll see in Chapter 12, sockets allow data to be passed\nbetween programs running on the same machine or across networks.\n\u2022 Sockets apply to more use cases than displaying a program\u2019s output stream. If the\nGUI must do more than display another program\u2019s output, sockets become a more\ngeneral solution\u2014as we\u2019ll also learn later, because sockets are bidirectional data\nstreams, they allow data to be passed back and forth between two programs in\nmore arbitrary ways.\nOther uses for threaded pipe GUIs\nDespite its tradeoffs, the thread/queue/pipe-based approach for GUIs has fairly wide\napplicability. To illustrate, here\u2019s another quick usage example. The following runs a\nsimple script normally from a shell/terminal window; it prints one successively longer\noutput line every two seconds:\nC:\\...\\PP4E\\Gui\\Tools> type spams.py\nimport time\nfor i in range(1, 10, 2):\n    time.sleep(2)                   # print to standard output\n    print('spam' * i)               # nothing GUI about this, eh?\nC:\\...\\PP4E\\Gui\\Tools> python spams.py\nspam\nspamspamspam\nspamspamspamspamspam\nspamspamspamspamspamspamspam\nspamspamspamspamspamspamspamspamspam\nLet\u2019s wrap this up in a GUI, with code typed at the interactive prompt for variety. The\nfollowing imports the new GUI redirection function as a library component and uses\nit to create a window that displays the script\u2019s five lines, appearing every two seconds\njust as in the terminal window, followed by a final line containing <end> reflecting the\nspawned program\u2019s exit. The resulting output window is captured in Figure 10-16:\n660 | Chapter 10:\u2002GUI Coding TechniquesC:\\...\\PP4E\\Gui\\Tools> python\n>>> from tkinter import Tk\n>>> from pipe_gui3 import redirectedGuiShellCmd\n>>> root = Tk()\n>>> redirectedGuiShellCmd('python -u spams.py', root)\nFigure 10-16. Command pipe GUI displaying another program\u2019s output\nIf the spawned program exits, Example 10-29\u2019s producer thread detects end-of-file on\nthe pipe and puts a final empty line in the queue; in response the consumer loop displays\nan <end> line in the GUI by default when it detects this condition. In this case, program\nexit is normal and silent; in other cases, we may need to add shutdown logic to suppress\nerror messages. Note that here again, the sleep call in the spawned program simulates\na long-running task, and we really need the -u unbuffered streams flag\u2014without it, no\noutput appears in the GUI for eight seconds, until the spawned program is completely\nfinished. With it, the GUI receives and displays each line as it is printed, one every two\nseconds.\nThis is also, finally, the sort of code you could use to display the output of a non-GUI\nprogram in a GUI, without sockets, changes in the original program, or blocking the\nGUI. Of course, in many cases, if you have to work this hard to add a GUI anyhow,\nyou might as well just make your script a traditional GUI program with a main window\nand event loop. Furthermore, the GUIs we\u2019ve coded in this section are limited to dis-\nplaying another program\u2019s output; sometimes the GUI may have to do more. For many\nprograms, though, the general separation of display and program logic provided by the\nspawned GUI model can be an advantage\u2014it\u2019s easier to understand both parts if they\nare not mixed together.\nWe\u2019ll learn more about sockets in the next part of the book, so you should consider\nparts of this discussion something of a preview. As we\u2019ll see, things start to become\nmore and more interesting when we start combining GUIs, threads, and network\nsockets.\nBefore we do, though, the next chapter rounds out the purely GUI part of this book by\napplying the widgets and techniques we\u2019ve learned in more realistically scaled pro-\ngrams. And before that, the next section wraps up here with a preview of some of the\nMore Ways to Add GUIs to Non-GUI Code | 661larger GUI examples coming up, with a quick look at scripts that launch them auto-\nmatically, and allow you to sample some of what is possible with Python and tkinter.\nThe PyDemos and PyGadgets Launchers\nTo close out this chapter, let\u2019s explore the implementations of the two GUIs used to\nrun major book examples. The following GUIs, PyDemos and PyGadgets, are simply\nGUIs for launching other GUI programs. In fact, we\u2019ve now come to the end of the\ndemo launcher story\u2014both of the new programs here interact with modules that we\nmet earlier in Part II:\nlaunchmodes.py\nStarts independent Python programs portably.\nLauncher.py\nFinds programs, and ultimately runs both PyDemos and PyGadgets when used by\nthe self-configuring top-level launcher scripts.\nLaunchBrowser.pyw\nSpawns web browsers portably to open local or remote pages.\nSee Part II (especially the ends of Chapter 5 and Chapter 6) for links to the code for\nthese modules. The programs introduced here add the GUI components to the\nprogram-launching system\u2014they simply provide easy-to-use pushbuttons that spawn\nmost of the larger examples in this text when pressed.\nBoth of these scripts also assume that they will be run with the current working directory\nset to their directory (they hardcode paths to other programs relative to that). Either\nclick on their names in a file explorer or run them from a command-line shell after a\ncd to the top-level PP4E examples root directory. These scripts could allow invocations\nfrom other directories by prepending an environment variable\u2019s value to program script\npaths, but they were really designed to be run only out of the PP4E root.\nBecause these demo launchers are long programs, in the interest of space and time only\ntheir crucial and representative parts are listed in this book; as usual, see the examples\npackage distribution for the portions omitted here.\nPyDemos Launcher Bar (Mostly External)\nThe PyDemos script constructs a bar of buttons that run programs in demonstration\nmode, not for day-to-day use. I use PyDemos to show off Python programs\u2014it\u2019s much\neasier to press its buttons than to run command lines or fish through a file explorer\nGUI to find scripts.\nYou can use PyDemos (and PyGadgets) to start and interact with examples presented\nin this book\u2014all of the buttons on this GUI represent examples we will meet in later\nchapters. Unlike when using the Launch_PyDemos and Launch_PyGadgets_bar scripts\n662 | Chapter 10:\u2002GUI Coding Techniquesat the top of the examples package, though, make sure your PYTHONPATH system variable\nis set to include the directory containing the PP4E examples root directory if you wish\nto run the scripts here directly; they don\u2019t attempt to automatically configure your\nsystem or module import search paths.\nTo make this launcher bar even easier to run, drag it out to your desktop to generate a\nclickable Windows shortcut (do something similar on other systems). Since this script\nhardcodes command lines for running programs elsewhere in the examples tree, it is\nalso useful as an index to major book examples. Figure 10-17 shows what PyDemos\nlooks like when run on Windows, along with some of the demos it launches\u2014PyDemos\nis the vertical button bar on the right; it looks slightly different but works the same on\nLinux.\nFigure 10-17. PyDemos with its pop ups and a few demos\nThe source code that constructs this scene is listed in Example 10-30 (its first page may\ndiffer slightly from that shown being edited in Figure 10-17 due to last minute tweaks\nwhich engineers can\u2019t seem to avoid). Because PyDemos doesn\u2019t present much that\u2019s\nnew in terms of GUI interface programming, though, much of it has been removed\nhere; again, see the examples package for the remainder.\nIn short, its demoButton function simply attaches a new button to the main window,\nspring-loaded to spawn a Python program when pressed. To start programs, PyDemos\ncalls an instance of the launchmodes.PortableLauncher object we met at the end of\nChapter 5\u2014its role as a tkinter callback handler here is why a function-call operation\nis used to kick off the launched program.\nThe PyDemos and PyGadgets Launchers | 663As pictured in Figure 10-17, PyDemos also constructs two pop-up windows when but-\ntons at the bottom of the main window are pressed\u2014an Info pop up giving a short\ndescription of the last demo spawned, and a Links pop up containing radio buttons\nthat open a local web browser on book-related sites when pressed:\n\u2022 The Info pop up displays a simple message line and changes its font every second\nto draw attention to itself; since this can be a bit distracting, the pop up starts out\niconified (click the Info button to see or hide it).\n\u2022 The Links pop up\u2019s radio buttons are much like hyperlinks in a web page, but this\nGUI isn\u2019t a browser: when the Links pop up is pressed, the portable Launch\nBrowser script mentioned in Part II is used to find and start a web browser used to\nconnect to the relevant site, assuming you have an Internet connection. This in\nturn uses Python\u2019s webbrowser modules today.\n\u2022 The windows module we coded earlier in this chapter (Example 10-16) is used to\ngive this GUI\u2019s windows a blue \u201cPY\u201d icon, instead of the standard red \u201cTk.\u201d\nThe PyDemos GUI also comes with \u201ccode\u201d buttons to the right of each demo\u2019s button,\nwhich open the source files that implement the associated example. These files open\nin pop-up versions of the PyEdit text editor that we\u2019ll meet in Chapter 11. Fig-\nure 10-18 captures some of these code viewer windows in action, resized slightly for\ndisplay here.\nFor the web-based examples opened by the last two demo buttons in the launcher, this\nGUI also attempts to spawn a locally running web server for web-based demos not\nshown running here (we\u2019ll meet the server in Chapter 15). For this edition, the web\nservers are spawned only when the corresponding web demo button is first selected\n(not on PyDemos startup), and the web servers generate a pop-up command prompt\nwindow on Windows to monitor server status.\nPyDemos runs on Windows, Macs, and Linux, but that\u2019s largely due to the inherent\nportability of both Python and tkinter. For more details, consult the source, which is\nshown in part in Example 10-30.\nExample 10-30. PP4E\\PyDemos.pyw (external)\n\"\"\"\n################################################################################\nPyDemos.pyw\nProgramming Python, 2nd, 3rd, and 4th Editions (PP4E), 2001--2006--2010\nVersion 2.1 (4E), April '10: updated to run under Python 3.X, and spawn\nlocal web servers for web demos only on first demo button selection.\nVersion 2.0 (3E), March '06: add source-code file viewer buttons; add new\nDemos (PyPhoto, PyMailGUI); spawn locally running web servers for the\nbrowser-based Demos; add window icons; and probably more I've forgotten.\nLaunch major Python+Tk GUI examples from the book, in a platform-neutral way.\nThis file also serves as an index to major program examples, though many book\n664 | Chapter 10:\u2002GUI Coding Techniquesexamples aren't GUI-based, and so aren't listed here.  Also see:\n- PyGadgets.py, a simpler script for starting programs in non-demo mode\n  that you wish to use on a regular basis\n- PyGadgets_bar.pyw, which creates a button bar for starting all PyGadgets\n  programs on demand, not all at once\n- Launcher.py for starting programs without environment settings--finds\n  Python, sets PYTHONPATH, etc.\n- Launch_*.pyw for starting PyDemos and PyGadgets with Launcher.py--run these\n  for a quick look\n- LaunchBrowser.pyw for running example web pages with an automatically\n  located web browser\n- README-PP4E.txt, for general examples information\nCaveat: this program tries to start a locally running web server and web\nBrowser automatically, for web-based demos,  but does not kill the server.\n################################################################################\n\"\"\"\n...code omitted: see examples package...\n################################################################################\n# start building main GUI windows\n################################################################################\nfrom PP4E.Gui.Tools.windows import MainWindow    # a Tk with icon, title, quit\nfrom PP4E.Gui.Tools.windows import PopupWindow   # same but Toplevel, diff quit\nRoot = MainWindow('PP4E Demos 2.1')\nFigure 10-18. PyDemos with its \u201ccode\u201d source code viewer pop-ups\nThe PyDemos and PyGadgets Launchers | 665# build message window\nStat = PopupWindow('PP4E demo info')\nStat.protocol('WM_DELETE_WINDOW', lambda:0)      # ignore wm delete\nInfo = Label(Stat, text = 'Select demo',\n             font=('courier', 20, 'italic'), padx=12, pady=12, bg='lightblue')\nInfo.pack(expand=YES, fill=BOTH)\n################################################################################\n# add launcher buttons with callback objects\n################################################################################\nfrom PP4E.Gui.TextEditor.textEditor import TextEditorMainPopup\n# demo launcher class\nclass Launcher(launchmodes.PortableLauncher):    # use wrapped launcher class\n    def announce(self, text):                    # customize to set GUI label\n        Info.config(text=text)\ndef viewer(sources):\n    for filename in sources:\n        TextEditorMainPopup(Root, filename,      # as pop up in this process\n                            loadEncode='utf-8')  # else PyEdit may ask each!\ndef demoButton(name, what, doit, code):\n    \"\"\"\n    add buttons that runs doit command-line, and open all files in code;\n    doit button retains state in an object, code in an enclosing scope;\n    \"\"\"\n    rowfrm = Frame(Root)\n    rowfrm.pack(side=TOP, expand=YES, fill=BOTH)\n    b = Button(rowfrm, bg='navy', fg='white', relief=RIDGE, border=4)\n    b.config(text=name, width=20, command=Launcher(what, doit))\n    b.pack(side=LEFT, expand=YES, fill=BOTH)\n    b = Button(rowfrm, bg='beige', fg='navy')\n    b.config(text='code', command=(lambda: viewer(code)))\n    b.pack(side=LEFT, fill=BOTH)\n################################################################################\n# tkinter GUI demos - some use network connections\n################################################################################\ndemoButton(name='PyEdit',\n           what='Text file editor',                            # edit myself\n           doit='Gui/TextEditor/textEditor.py PyDemos.pyw',    # assume in cwd\n           code=['launchmodes.py',\n                 'Tools/find.py',\n                 'Gui/Tour/scrolledlist.py',          # show in PyEdit viewer\n                 'Gui/ShellGui/formrows.py',          # last = top of stacking\n                 'Gui/Tools/guimaker.py',\n                 'Gui/TextEditor/textConfig.py',\n                 'Gui/TextEditor/textEditor.py'])\n666 | Chapter 10:\u2002GUI Coding TechniquesdemoButton(name='PyView',\n           what='Image slideshow, plus note editor',\n           doit='Gui/SlideShow/slideShowPlus.py Gui/gifs',\n           code=['Gui/Texteditor/textEditor.py',\n                 'Gui/SlideShow/slideShow.py',\n                 'Gui/SlideShow/slideShowPlus.py'])\n...code omitted: see examples package...\n################################################################################\n# toggle info message box font once a second\n################################################################################\ndef refreshMe(info, ncall):\n    slant = ['normal', 'italic', 'bold', 'bold italic'][ncall % 4]\n    info.config(font=('courier', 20, slant))\n    Root.after(1000, (lambda: refreshMe(info, ncall+1)) )\n################################################################################\n# unhide/hide status box on info clicks\n################################################################################\nStat.iconify()\ndef onInfo():\n    if Stat.state() == 'iconic':\n        Stat.deiconify()\n    else:\n        Stat.iconify()  # was 'normal'\n################################################################################\n# finish building main GUI, start event loop\n################################################################################\ndef onLinks():\n    ...code omitted: see examples package...\nButton(Root, text='Info',  command=onInfo).pack(side=TOP, fill=X)\nButton(Root, text='Links', command=onLinks).pack(side=TOP, fill=X)\nButton(Root, text='Quit',  command=Root.quit).pack(side=BOTTOM, fill=X)\nrefreshMe(Info, 0)  # start toggling\nRoot.mainloop()\nPyGadgets Launcher Bar\nThe PyGadgets script runs some of the same programs as PyDemos, but for real, prac-\ntical use, not as demonstrations. Both scripts use launchmodes to spawn other programs,\nand display bars of launcher buttons, but PyGadgets is a bit simpler because its task is\nmore focused. PyGadgets also supports two spawning modes\u2014it can either start a\ncanned list of programs immediately and all at once, or display a GUI for running each\nprogram on demand. Figure 10-19 shows the launch bar GUI made in on-demand mode\nwhen it first starts; PyDemos and PyGadgets can be run at the same time, and both\ngrow with their window if resized (try it on your own to see how).\nThe PyDemos and PyGadgets Launchers | 667Figure 10-19. PyGadgets launcher bar\nBecause of its different role, PyGadgets takes a more data-driven approach to building\nthe GUI: it stores program names in a list and steps through it as needed instead of\nusing a sequence of precoded demoButton calls. The set of buttons on the launcher bar\nGUI in Figure 10-19, for example, depends entirely upon the contents of the programs\nlist.\nThe source code behind this GUI is listed in Example 10-31. It\u2019s not much because it\nrelies on other modules we wrote earlier to work most of its magic: launchmodes for\nprogram spawns, windows for window icons and quits, and LaunchBrowser for web\nbrowser starts. PyGadgets gets a clickable shortcut on my desktop and is usually open\non my machines. I use to gain quick access to Python tools that I use on a daily basis\u2014\ntext editors, calculators, email and photo tools, and so on\u2014all of which we\u2019ll meet in\nupcoming chapters.\nTo customize PyGadgets for your own use, simply import and call its functions with\nprogram command-line lists of your own or change the mytools list of spawnable pro-\ngrams near the end of this file. This is Python, after all.\nExample 10-31. PP4E\\PyGadgets.py\n\"\"\"\n##############################################################################\nStart various examples; run me at start time to make them always available.\nThis file is meant for starting programs you actually wish to use; see\nPyDemos for starting Python/Tk demos and more details on program start\noptions.  Windows usage note: this is a '.py' to show messages in a console\nwindow when run or clicked (including a 10 second pause to make sure it's\nvisible while gadgets start if clicked).  To avoid Windows console pop up,\nrun with the 'pythonw' program (not 'python'), rename to '.pyw' suffix,\nmark with 'run minimized' window property, or spawn elsewhere (see PyDemos).\n##############################################################################\n\"\"\"\nimport sys, time, os, time\nfrom tkinter import *\nfrom launchmodes import PortableLauncher           # reuse program start class\nfrom Gui.Tools.windows import MainWindow           # reuse window tools: icon, quit\ndef runImmediate(mytools):\n    \"\"\"\n    launch gadget programs immediately\n    \"\"\"\n    print('Starting Python/Tk gadgets...')         # msgs to stdout (poss temp)\n668 | Chapter 10:\u2002GUI Coding Techniquesfor (name, commandLine) in mytools:\n        PortableLauncher(name, commandLine)()      # call now to start now\n    print('One moment please...')\n    if sys.platform[:3] == 'win':                  # windows: keep console 10 secs\n        for i in range(10):\n            time.sleep(1); print('.' * 5 * (i+1))\ndef runLauncher(mytools):\n    \"\"\"\n    pop up a simple launcher bar for later use\n    \"\"\"\n    root = MainWindow('PyGadgets PP4E')            # or root = Tk() if prefer\n    for (name, commandLine) in mytools:\n        b = Button(root, text=name, fg='black', bg='beige', border=2,\n                   command=PortableLauncher(name, commandLine))\n        b.pack(side=LEFT, expand=YES, fill=BOTH)\n    root.mainloop()\nmytools = [\n    ('PyEdit',   'Gui/TextEditor/textEditor.py'),\n    ('PyCalc',   'Lang/Calculator/calculator.py'),\n    ('PyPhoto',  'Gui/PIL/pyphoto1.py Gui/PIL/images'),\n    ('PyMail',   'Internet/Email/PyMailGui/PyMailGui.py'),\n    ('PyClock',  'Gui/Clock/clock.py -size 175 -bg white'\n                          ' -picture Gui/gifs/pythonPowered.gif'),\n    ('PyToe',    'Ai/TicTacToe/tictactoe.py'\n                          ' -mode Minimax -fg white -bg navy'),\n    ('PyWeb',    'LaunchBrowser.pyw'\n                          ' -live index.html learning-python.com')]\n                         #' -live PyInternetDemos.html localhost:80')]\n                         #' -file')] # PyInternetDemos assumes local server started\nif __name__ == '__main__':\n    prestart, toolbar = True, False\n    if prestart:\n        runImmediate(mytools)\n    if toolbar:\n        runLauncher(mytools)\nBy default, PyGadgets starts programs immediately when it is run. To run PyGadgets\nin launcher bar mode instead, Example 10-32 simply imports and calls the appropriate\nfunction with an imported program list. Because it is a .pyw file, you see only the\nlauncher bar GUI it constructs initially, not a DOS console streams window\u2014nice for\nregular use, but not if you want to see error messages (use a .py).\nExample 10-32. PP4E\\PyGadgets_bar.pyw\n\"\"\"\nrun a PyGadgets toolbar only, instead of starting all the gadgets immediately;\nfilename avoids DOS pop up on Windows: rename to '.py' to see console messages;\n\"\"\"\nimport PyGadgets\nPyGadgets.runLauncher(PyGadgets.mytools)\nThe PyDemos and PyGadgets Launchers | 669This script is the file my desktop shortcut invokes, because I prefer to run gadget GUIs\non demand. On many platforms, you can drag this out as a shortcut on your desktop\nfor easy access this way. You can also run a script like this at your system\u2019s startup to\nmake it always available (and to save a mouse click). For instance, on Windows, such\na script might be automatically started by adding it to your Startup folder, and on Unix\nand its kin you can automatically start such a script by spawning it with a command\nline in your system startup scripts after X Windows has been started.\nWhether run via a shortcut, a file explorer click, a typed command line, or other means,\nthe PyGadgets launcher bar near the center of Figure 10-20 appears.\nFigure 10-20. PyGadgets launcher bar with gadgets\nOf course, the whole point of PyGadgets is to spawn other programs. Pressing on its\nlauncher bar\u2019s buttons starts programs like those shown in the rest of Figure 10-20, but\nif you want to know more about those, you\u2019ll have to turn the page and move on to the\nnext chapter.\n670 | Chapter 10:\u2002GUI Coding Techniques", "11": "CHAPTER 11\nComplete GUI Programs\n\u201cPython, Open Source, and Camaros\u201d\nThis chapter concludes our look at building GUIs with Python and its standard tkinter \nlibrary, by presenting a collection of realistic GUI programs. In the preceding four \nchapters, we met all the basics of tkinter programming. We toured the core set of \nwidgets\u2014Python classes that generate devices on a computer screen and respond to \nuser events\u2014and we studied a handful of advanced GUI programming techniques, \nincluding automation tools, redirection with sockets and pipes, and threading. Here, \nour focus is on putting those widgets and techniques together to create more useful \nGUIs. We\u2019ll study:\nPyEdit \nA text editor program\nPyPhoto\nA thumbnail photo viewer\nPyView\nAn image slideshow\nPyDraw\nA painting program\nPyClock\nA graphical clock\nPyToe\nA simple tic-tac-toe game, just for fun*\n* All of the larger examples in this book have Py at the start of their names. This is by convention in the Python \nworld. If you shop around at http://www.python.org, you\u2019ll find other free software that follows this pattern \ntoo: PyOpenGL (a Python interface to the OpenGL graphics library), PyGame (a Python game development \nkit), and many more. I\u2019m not sure who started this pattern, but it has turned out to be a more or less subtle \nway to advertise programming language preferences to the rest of the open source world. Pythonistas are \nnothing if not PySubtle.\n671As in Part II\u2019s Chapter 6, I\u2019ve pulled the examples in this chapter from my own library\nof Python programs that I really use. For instance, the text editor and clock GUIs that\nwe\u2019ll meet here are day-to-day workhorses on my machines. Because they are written\nin Python and tkinter, they work unchanged on my Windows and Linux machines,\nand they should work on Macs too.\nSince these are pure Python scripts, their future evolution is entirely up to their users\u2014\nonce you get a handle on tkinter interfaces, changing or augmenting the behavior of\nsuch programs by editing their Python code is a snap. Although some of these examples\nare similar to commercially available programs (e.g., PyEdit is reminiscent of the Win-\ndows Notepad accessory), the portability and almost infinite configurability of Python\nscripts can be a decided advantage.\nExamples in Other Chapters\nLater in the book, we\u2019ll meet other tkinter GUI programs that put a good face on specific\napplication domains. For instance, the following larger GUI examples show up in later\nchapters also:\nPyMailGUI\nA comprehensive email client (Chapter 14)\nPyForm\nA (mostly external) persistent object table viewer (Chapter 17)\nPyTree\nA (mostly external) tree data structure viewer (Chapter 18 and Chapter 19)\nPyCalc\nA customizable calculator widget (Chapter 19)\nSmaller examples, including FTP and file-transfer GUIs, pop up in the Internet part as\nwell. Most of these programs see regular action on my desktop, too. Because GUI\nlibraries are general-purpose tools, there are very few domains that cannot benefit from\nan easy-to-use, easy-to-program, and widely portable user interface coded in Python\nand tkinter.\nBeyond the examples in this book, you can also find higher-level GUI toolkits for Py-\nthon, such as the Pmw, Tix, and ttk packages introduced in Chapter 7. Some such\nsystems build upon tkinter to provide compound components such as notebook tabbed\nwidgets, tree views, and balloon pop-up help.\nIn the next part of the book, we\u2019ll also explore programs that build user interfaces in\nweb browsers, instead of tkinter\u2014a very different way of approaching the user interface\nexperience. Although web browser interfaces have been historically limited in func-\ntionality and slowed by network latency, when combined with the rich Internet appli-\ncation (RIA) toolkits mentioned at the start of Chapter 7, browser-based GUIs today\n672 | Chapter 11:\u2002Complete GUI Programscan sometimes approach the utility of traditional GUIs, albeit at substantial cost in\nsoftware complexity and dependencies.\nEspecially for highly interactive and nontrivial interfaces, though, standalone/desktop\ntkinter GUIs can be an indispensable feature of almost any Python program you write.\nThe programs in this chapter underscore just how far Python and tkinter can take you.\nThis Chapter\u2019s Strategy\nAs for all case-study chapters in this text, this one is largely a learn-by-example exercise;\nmost of the programs here are listed with minimal details. Along the way, I\u2019ll highlight\nsalient points and underscore new tkinter features that examples introduce, but I\u2019ll also\nassume that you will study the listed source code and its comments for more informa-\ntion. Once we reach the level of complexity demonstrated by programs here, Python\u2019s\nreadability becomes a substantial advantage for programmers (and writers of books).\nAll of this book\u2019s GUI examples are available in source code form in the book\u2019s exam-\nples distribution described in the Preface. Because I\u2019ve already shown the interfaces\nthese scripts employ, this section consists mostly of screenshots, program listings, and\na few brief words describing some of the most important aspects of these programs. In\nother words, this is a self-study section: read the source, run the examples on your own\ncomputer, and refer to the previous chapters for further details on the code listed here.\nSome of these programs may also be accompanied in the book examples distribution\nby alternative or experimental implementations not listed here; see the distribution for\nextra code examples.\nFinally, I want to remind you that all of the larger programs listed in the previous\nsections can be run from the PyDemos and PyGadgets launcher bar GUIs that we met\nat the end of Chapter 10. Although I will try hard to capture some of their behavior in\nscreenshots here, GUIs are event-driven systems by nature, and there is nothing quite\nlike running one live to sample the flavor of its user interactions. Because of that, the\nlauncher bars are really a supplement to the material in this chapter. They should run\non most platforms and are designed to be easy to start (see the top-level README-\nPP4E.txt file for hints). You should go there and start clicking things immediately if\nyou haven\u2019t done so already.\nOpen Source Software and Camaros\nSome of the GUI programs in this chapter, as well as the rest of the book, are analogous\nto utilities found on commonly used operating systems like Windows. For instance,\nwe\u2019ll meet calculators, text editors, image viewers, clocks, email clients, and more.\nUnlike most utilities, though, these programs are portable\u2014because they are written\nin Python with tkinter, they will work on all major platforms (Windows, Unix/Linux,\nand Macs). Perhaps more important, because their source code is available, they can\nbe scripted\u2014you can change their appearance or function however you like, just by\nwriting or modifying a little Python code.\n\u201cPython, Open Source, and Camaros\u201d | 673An analogy might help underscore the importance of scriptability. There are still a few\nof us who remember a time when it was completely normal for car owners to work on\nand repair their own automobiles. I still fondly remember huddling with friends under\nthe hood of a 1970 Camaro in my youth, tweaking and customizing its engine. With a\nlittle work, we could make it as fast, flashy, and loud as we liked. Moreover, a break-\ndown in one of those older cars wasn\u2019t necessarily the end of the world. There was at\nleast some chance that I could get the car going again on my own.\nThat\u2019s not quite true today. With the introduction of electronic controls and diaboli-\ncally cramped engine compartments, car owners are usually better off taking their cars\nback to the dealer or another repair professional for all but the simplest kinds of\nchanges. By and large, cars are no longer user-maintainable products. And if I have a\nbreakdown in my shiny new ride, I\u2019m probably going to be completely stuck until an\nauthorized repair person can get around to towing and fixing it.\nI like to think of the closed and open software models in the same terms. When I use\nMicrosoft-provided programs such as Notepad and Outlook, I\u2019m stuck with the feature\nset that a large company dictates, as well as any bugs that it may harbor. But with\nprogrammable tools such as PyEdit and PyMailGUI, I can still get under the hood. I\ncan add features, customize the system, and work my way out of any lurking bugs. And\nI can do so long before the next Microsoft patch or release is available. I\u2019m no longer\ndependent on a self-interested company to support\u2014or even to continue producing\u2014\nthe tools I use.\nOf course, I\u2019m still dependent on Python and whatever changes it may dictate over time\n(and after updating two 1,000+ page books for Python 3.X, I can say with some con-\nfidence that this dependency isn\u2019t always completely trivial). Having all the source code\nfor every layer of the tools you depend on, though, is still a powerful last resort, and a\nmajor net win. As an added bonus, it fosters robustness by providing a built-in group\nof people to test and hone the system.\nAt the end of the day, open source software and Python are as much about freedom as\nthey are about cost. Users, not an arbitrarily far-removed company, have the final say.\nNot everyone wants to work on his own car, of course. On the other hand, software\ntends to fail much more often than cars, and Python scripting is generally less greasy\nthan auto mechanics.\nPyEdit: A Text Editor Program/Object\nIn the last few decades, I\u2019ve typed text into a lot of programs. Most were closed systems\n(I had to live with whatever decisions their designers made), and many ran on only one\nplatform. The PyEdit program presented in this section does better on both counts:\naccording to its own Tools/Info option, PyEdit implements a full-featured, graphical\ntext editor program in a total of 1,133 new lines of portable Python code, including\nwhitespace and comments, divided between 1,088 lines in the main file and 45 lines of\nconfiguration module settings (at release, at least\u2014final sizes may vary slightly in future\nrevisions). Despite its relatively modest size, by systems programming standards,\n674 | Chapter 11:\u2002Complete GUI ProgramsPyEdit is sufficiently powerful and robust to have served as the primary tool for coding\nmost of the examples in this book.\nPyEdit supports all the usual mouse and keyboard text-editing operations: cut and\npaste, search and replace, open and save, undo and redo, and so on. But really, PyEdit\nis a bit more than just another text editor\u2014it is designed to be used as both a program\nand a library component, and it can be run in a variety of roles:\nStandalone mode\nAs a standalone text-editor program, with or without the name of a file to be edited\npassed in on the command line. In this mode, PyEdit is roughly like other text-\nediting utility programs (e.g., Notepad on Windows), but it also provides advanced\nfunctions such as running Python program code being edited, changing fonts and\ncolors, \u201cgrep\u201d threaded external file search, a multiple window interface, and so\non. More important, because it is coded in Python, PyEdit is easy to customize,\nand it runs portably on Windows, X Windows, and Macintosh.\nPop-up mode\nWithin a new pop-up window, allowing an arbitrary number of copies to appear\nas pop ups at once in a program. Because state information is stored in class in-\nstance attributes, each PyEdit object created operates independently. In this mode\nand the next, PyEdit serves as a library object for use in other scripts, not as a canned\napplication. For example, Chapter 14\u2019s PyMailGUI employs PyEdit in pop-up\nmode to view email attachments and raw text, and both PyMailGUI and the pre-\nceding chapter\u2019s PyDemos display source code files this way.\nEmbedded mode\nAs an attached component, to provide a text-editing widget for other GUIs. When\nattached, PyEdit uses a frame-based menu and can optionally disable some of its\nmenu options for an embedded role. For instance, PyView (later in this chapter)\nuses PyEdit in embedded mode this way to serve as a note editor for photos, and\nPyMailGUI (in Chapter 14) attaches it to get an email text editor for free.\nWhile such mixed-mode behavior may sound complicated to implement, most of\nPyEdit\u2019s modes are a natural byproduct of coding GUIs with the class-based techniques\nwe\u2019ve seen in the last four chapters.\nRunning PyEdit\nPyEdit sports lots of features, and the best way to learn how it works is to test-drive it\nfor yourself\u2014you can run it by starting the main file textEditor.py, by running files\ntextEditorNoConsole.pyw or pyedit.pyw to suppress a console window on Windows,\nor from the PyDemos and PyGadgets launcher bars described at the end of Chap-\nter 10 (the launchers themselves live in the top level of the book examples directory\ntree). To give you a sampling of PyEdit\u2019s interfaces, Figure 11-1 shows the main\nPyEdit: A Text Editor Program/Object | 675window\u2019s default appearance running in Windows 7, after opening PyEdit\u2019s own source\ncode file.\nThe main part of this window is a Text widget object, and if you read Chapter 9\u2019s\ncoverage of this widget, PyEdit text-editing operations will be familiar. It uses text\nmarks, tags, and indexes, and it implements cut-and-paste operations with the system\nclipboard so that PyEdit can paste data to and from other applications, even after an\napplication of origin is closed. Both vertical and horizontal scroll bars are cross-linked\nto the Text widget, to support movement through arbitrary files.\nMenus and toolbars\nIf PyEdit\u2019s menu and toolbars look familiar, they should\u2014PyEdit builds the main win-\ndow with minimal code and appropriate clipping and expansion policies by mixing in\nthe GuiMaker class we coded in the prior chapter (Example 10-3). The toolbar at the\nbottom contains shortcut buttons for operations I tend to use most often; if my pref-\nerences don\u2019t match yours, simply change the toolbar list in the source code to show\nthe buttons you want (this is Python, after all).\nAs usual for tkinter menus, shortcut key combinations can be used to invoke menu\noptions quickly, too\u2014press Alt plus all the underlined keys of entries along the path\nto the desired action. Menus can also be torn off at their dashed line to provide quick\naccess to menu options in new top-level windows (handy for options without toolbar\nbuttons).\nFigure 11-1. PyEdit main window, editing itself\n676 | Chapter 11:\u2002Complete GUI ProgramsDialogs\nPyEdit pops up a variety of modal and nonmodal dialogs, both standard and custom.\nFigure 11-2 shows the custom and nonmodal change, font, and grep dialogs, along with\na standard dialog used to display file statistics (the final line count may vary, as I tend\nto tweak code and comments right up until final draft).\nFigure 11-2. PyEdit with colors, a font, and a few pop ups\nThe main window in Figure 11-2 has been given new foreground and background colors\n(with the standard color selection dialog), and a new text font has been selected from\neither the font dialog or a canned list in the script that users can change to suit their\npreferences (this is Python, after all). Other toolbar and menu operations generally use\npopped-up standard dialogs, with a few new twists. For instance, the standard file open\nand save selection dialogs in PyEdit use object-based interfaces to remember the last\ndirectory visited, so you don\u2019t have to navigate there every time.\nRunning program code\nOne of the more unique features of PyEdit is that it can actually run Python program\ncode that you are editing. This isn\u2019t as hard as it may sound either\u2014because Python\nprovides built-ins for compiling and running code strings and for launching programs,\nPyEdit simply has to make the right calls for this to work. For example, it\u2019s easy to code\na simple-minded Python interpreter in Python, using code like the following (see file\nPyEdit: A Text Editor Program/Object | 677simpleShell.py in the PyEdit\u2019s directory if you wish to experiment with this), though\nyou need a bit more to handle multiple-line statements and expression result displays:\n# read and run Python statement strings: like PyEdit's run code menu option\nnamespace = {}\nwhile True:\n    try:\n        line = input('>>> ')          # single-line statements only\n    except EOFError:\n        break\n    else:\n        exec(line, namespace)         # or eval() and print result\nDepending on the user\u2019s preference, PyEdit either does something similar to this to run\ncode fetched from the text widget or uses the launchmodes module we wrote at the end\nof Chapter 5 to run the code\u2019s file as an independent program. There are a variety of\noptions in both schemes that you can customize as you like (this is Python, after all).\nSee the onRunCode method for details or simply edit and run some Python code in PyEdit\non your own to experiment. When edited code is run in nonfile mode, you can view\nits printed output in PyEdit\u2019s console window. As we footnoted about eval and exec\nin Chapter 9, also make sure you trust the source of code you run this way; it has all\npermissions that the Python process does.\nMultiple windows\nPyEdit not only pops up multiple special-purpose windows, it also allows multiple edit\nwindows to be open concurrently, in either the same process or as independent pro-\ngrams. For illustration, Figure 11-3 shows three independently started instances of\nPyEdit, resized and running with a variety of color schemes and fonts. Since these are\nseparate programs, closing any of these does not close the others. This figure also cap-\ntures PyEdit torn-off menus at the bottom and the PyEdit help pop up on the right. The\nedit windows\u2019 backgrounds are shades of green, red, and blue; use the Tools menu\u2019s\nPick options to set colors as you like.\nSince these three PyEdit sessions are editing Python source-coded text, you can run\ntheir contents with the Run Code option in the Tools pull-down menu. Code run from\nfiles is spawned independently; the standard streams of code run not from a file (i.e.,\nfetched from the text widget itself) are mapped to the PyEdit session\u2019s console window.\nThis isn\u2019t an IDE by any means; it\u2019s just something I added because I found it to be\nuseful. It\u2019s nice to run code you\u2019re editing without fishing through directories.\nTo run multiple edit windows in the same process, use the Tools menu\u2019s Clone option\nto open a new empty window without erasing the content of another. Figure 11-4 shows\nthe single-process scene with a window and its clone, along with pop-ups related to\nthe Search menu\u2019s Grep option, described in the next section\u2014a tool that walks di-\nrectory trees in parallel threads, collecting files of matching names that contain a search\nstring, and opening them on request. In Figure 11-4, Grep has produced an input dialog,\n678 | Chapter 11:\u2002Complete GUI Programsa matches list, and a new PyEdit window positioned at a match after a double-click in\nthe list box.\nAnother pop up appears while a Grep search is in progress, but the GUI remains fully\nactive; in fact, you can launch new Greps while others are in progress. Notice how the\nGrep dialog also allows input of a Unicode encoding, used to decode file content in all\ntext files visited during the tree search; I\u2019ll describe how this works in the changes\nsection ahead, but in most cases, you can accept the prefilled platform default encoding.\nFor more fun, use this dialog to run a Grep in directory C:\\Python31 for all *.py files\nthat contain string %\u2014a quick look at how common the original string formatting ex-\npression is, even in Python 3.1\u2019s own library code. Though not all % are related to string\nformatting, most appear to be. Per a message printed to standard output on Grep thread\nexit, the string '%' (which includes substitution targets) occurs 6,050 times, and the\nstring ' % ' (with surrounding spaces to better narrow in on operator appearances)\nappears 3,741 times, including 130 in the installed PIL extension\u2014not exactly an ob-\nscure language tool! Here are the messages printed to standard output during this\nsearch; matches appear in a list box window:\n...errors may vary per encoding type...\nUnicode error in: C:\\Python31\\Lib\\lib2to3\\tests\\data\\different_encoding.py\nUnicode error in: C:\\Python31\\Lib\\test\\test_doctest2.py\nUnicode error in: C:\\Python31\\Lib\\test\\test_tokenize.py\nMatches for  % : 3741\nFigure 11-3. Multiple PyEdit sessions at work\nPyEdit: A Text Editor Program/Object | 679PyEdit generates additional pop-up windows\u2014including transient Goto and Find di-\nalogs, color selection dialogs, dialogs that appear to collect arguments and modes for\nRun Code, and dialogs that prompt for entry of Unicode encoding names on file Open\nand Save if PyEdit is configured to ask (more on this ahead). In the interest of space,\nI\u2019ll leave most other such behavior for you to witness live.\nProminently new in this edition, though, and subject to user configurations, PyEdit\nmay ask for a file\u2019s Unicode encoding name when opening a file, saving a new file begun\nfrom scratch, or running a Save As operation. For example, Figure 11-5 captures the\nscene after I\u2019ve opened a file encoded in a Chinese character set scheme and pressed\nOpen again to open a new file encoded in a Russian encoding. The encoding name\ninput dialog shown in the figure appears immediately after the standard file selection\ndialog is dismissed, and it is prefilled with the default encoding choice configured (an\nexplicit setting or the platform\u2019s default). The displayed default can be accepted in most\ncases, unless you know the file\u2019s encoding differs.\nIn general, PyEdit supports any Unicode character set that Python and tkinter do, for\nopens, display, and saves. The text in Figure 11-5, for instance, was encoding in a\nspecific Chinese encoding in the file it came from (\u201cgb2321\u201d for file email-part--\ngb2312). An alternative UTF-8 encoding of this text is available in the same directory\n(file email-part--gb2312--utf8) which works per the default Windows encoding in\nPyEdit and Notepad, but the specific Chinese encoding file requires the explicitly\nFigure 11-4. Multiple PyEdit windows in a single process\n680 | Chapter 11:\u2002Complete GUI Programsentered encoding name to display properly in PyEdit (and won\u2019t display correctly at all\nin Notepad).\nAfter I enter the encoding name for the selected file (\u201ckoi8-r\u201d for the file selected to\nopen) in the input dialog of Figure 11-5, PyEdit decodes and pops up the text in its\ndisplay. Figure 11-6 show the scene after this file has been opened and I\u2019ve selected the\nSave As option in this window\u2014immediately after a file selection dialog is dismissed,\nanother encoding input dialog is presented for the new file, prefilled with the known\nencoding from the last Open or Save. As configured, Save reuses the known encoding\nautomatically to write to the file again, but SaveAs always asks to allow for a new one,\nbefore trying defaults. Again, I\u2019ll say more on the Unicode/Internationalization policies\nof PyEdit in the next section, when we discuss version 2.1 changes; in short, because\nuser preferences can\u2019t be predicted, a variety of policies may be selected by\nconfiguration.\nFinally, when it\u2019s time to shut down for the day, PyEdit does what it can to avoid losing\nchanges not saved. When a Quit is requested for any edit window, PyEdit checks for\nchanges and verifies the operation in a dialog if the window\u2019s text has been modified\nand not saved. Because there may be multiple edit windows in the same process, when\na Quit is requested in a main window, PyEdit also checks for changes in all other win-\ndows still open, and verifies exit if any have been altered\u2014otherwise the Quit would\nclose every window silently. Quits in pop-up edit windows destroy that window only,\nso no cross-process check is made. If no changes have been made, Quit requests in the\nGUI close windows and programs silently. Other operations verify changes in similar \nways.\nFigure 11-5. PyEdit displaying Chinese text and prompting for encoding on Open\nPyEdit: A Text Editor Program/Object | 681Other PyEdit examples and screenshots in this book\nFor other screenshots showing PyEdit in action, see the coverage of the following client\nprograms:\n\u2022 PyDemos in Chapter 10 deploys PyEdit pop-ups to show source-code files.\n\u2022 PyView later in this chapter embeds PyEdit to display image note files.\n\u2022 PyMailGUI in Chapter 14 uses PyEdit to display email text, text attachments, and\nsource.\nThe last of these especially makes heavy use of PyEdit\u2019s functionality and includes\nscreenshots showing PyEdit displaying additional Unicode text with Internationalized\ncharacter sets. In this role, the text is either parsed from messages or loaded from tem-\nporary files, with encodings determined by mail headers.\nPyEdit Changes in Version 2.0 (Third Edition)\nI\u2019ve updated this example in both the third and fourth editions of this book. Because\nthis chapter is intended to reflect realistic programming practice, and because this ex-\nample reflects that way that software evolves over time, this section and the one fol-\nlowing it provide a quick rundown of some of the major changes made along the way\nto help you study the code.\nFigure 11-6. PyEdit displaying Russian text and prompting for encoding on Save As\n682 | Chapter 11:\u2002Complete GUI ProgramsSince the current version inherits all the enhancements of the one preceding it, let\u2019s\nbegin with the previous version\u2019s additions. In the third edition, PyEdit was enhanced\nwith:\n\u2022 A simple font specification dialog\n\u2022 Unlimited undo and redo of editing operations\n\u2022 File modified tests whenever content might be erased or changed\n\u2022 A user configurations module\nHere are some quick notes about these extensions.\nFont dialog\nFor the third edition of the book, PyEdit grew a font input dialog\u2014a simple, three-entry,\nnonmodal dialog where you can type the font family, size, and style, instead of picking\nthem from a list of preset options. Though functional, you can find more sophisticated\ntkinter font selection dialogs in both the public domain and within the implementation\nof Python\u2019s standard IDLE development GUI (as mentioned earlier, it is itself a Python/\ntkinter program).\nUndo, redo, and modified tests\nAlso new in the third edition, PyEdit supports unlimited edit undo and redo, as well as\nan accurate modified check before quit, open, run, and new actions to prompt for saves.\nIt now verifies exits or overwrites only if text has been changed, instead of always asking\nna\u00efvely. The underlying Tk 8.4 (or later) library provides an API, which makes both\nthese enhancements simple\u2014Tk keeps undo and redo stacks automatically. They are\nenabled with the Text widget\u2019s undo configuration option and are accessed with the\nwidget methods edit_undo and edit_redo. Similarly, edit_reset clears the stacks (e.g.,\nafter a new file open), and edit_modified checks or sets the automatic text modified flag.\nIt\u2019s also possible to undo cuts and pastes right after you\u2019ve done them (simply paste\nback from the clipboard or cut the pasted and selected text), but the new undo/redo\noperations are more complete and simpler to use. Undo was a suggested exercise in the\nsecond edition of this book, but it has been made almost trivial by the new Tk API.\nConfiguration module\nFor usability, the third edition\u2019s version of PyEdit also allows users to set startup con-\nfiguration options by assigning variables in a module, textConfig.py. If present on the\nmodule search path when PyEdit is imported or run, these assignments give initial\nvalues for font, colors, text window size, and search case sensitivity. Fonts and colors\ncan be changed interactively in the menus and windows can be freely resized, so this\nis largely just a convenience. Also note that this module\u2019s settings will be inherited by\nall instances of PyEdit if it is importable in the client program\u2014even when it is a pop-\nup window or an embedded component of another application. Client applications\nPyEdit: A Text Editor Program/Object | 683may define their own version or configure this file on the module search path per their\nneeds.\nPyEdit Changes in Version 2.1 (Fourth Edition)\nBesides the updates described in the prior section, the following additional enhance-\nments were made for this current fourth edition of this book:\n\u2022 PyEdit has been ported to run under Python 3.1, and its tkinter library.\n\u2022 The nonmodal change and font dialogs were fixed to work better if multiple in-\nstance windows are open: they now use per-dialog state.\n\u2022 A Quit request in main windows now verifies program exit if any other edit win-\ndows in the process have changed content, instead of exiting silently.\n\u2022 There\u2019s a new Grep menu option and dialog for searching external files; searches\nare run in threads to avoid blocking the GUI and to allow multiple searches to\noverlap in time and support Unicode text.\n\u2022 There was a minor fix for initial positioning when text is inserted initially into a\nnewly created editor, reflecting a change in underlying libraries.\n\u2022 The Run Code option for files now uses the base file name instead of the full di-\nrectory path after a chdir to better support relative paths; allows for command-line\narguments to code run from files; and inherits a patch made in Chapter 5\u2019s\nlaunchmodes which converts / to \\ in script paths. In addition, this option always\nnow runs an update between pop-up dialogs to ensure proper display.\n\u2022 Perhaps most prominently, PyEdit now processes files in such a way as to support\ndisplay and editing of text with arbitrary Unicode encodings, to the extent allowed\nby the underlying Tk GUI library for Unicode strings. Specifically, Unicode is taken\ninto account when opening and saving files; when displaying text in the GUI; and\nwhen searching files in directories.\nThe following sections provide additional implementation notes on these changes.\nModal dialog state fix\nThe change dialog in the prior version saved its entry widgets on the text editor object,\nwhich meant that the most recent change dialog\u2019s fields were used for every change\ndialog open. This could even lead to program aborts for finds in an older change dialog\nwindow if newer ones had been closed, since the closed window\u2019s widgets had been\ndestroyed\u2014an unanticipated usage mode, which has been present since at least the\nsecond edition, and which I\u2019d like to chalk up to operator error, but which was really\na lesson in state retention! The same phenomenon existed in the font dialog\u2014its most\nrecently opened instance stole the show, though its brute force exception handler pre-\nvented program aborts (it issued error pop ups instead). To fix, the change and font\n684 | Chapter 11:\u2002Complete GUI Programsdialogs now send per-dialog-window input fields as arguments to their callbacks. We\ncould instead allow just one of each dialog to be open, but that\u2019s less functional.\nCross-process change tests on Quit\nThough not quite as grievous, PyEdit also used to ignore changes in other open edit\nwindows on Quit in main windows. As a policy, on a Quit in the GUI, pop-up edit\nwindows destroy themselves only, but main edit windows run a tkinter quit to end the\nentire program. Although all windows verify closes if their own content has changed,\nother edit windows were ignored in the prior version\u2014quitting a main window could\nlose changes in other windows closed on program exit.\nTo do better, this version keeps a list of all open managed edit windows in the process;\non Quit in main windows it checks them all for changes, and verifies exit if any have\nchanged. This scheme isn\u2019t foolproof (it doesn\u2019t address quits run on widgets outside\nPyEdit\u2019s scope), but it is an improvement. A more ultimate solution probably involves\nredefining or intercepting tkinter\u2019s own quit method. To avoid getting too detailed\nhere, I\u2019ll defer more on this topic until later in this section (see the <Destroy> event\ncoverage ahead); also see the relevant comments near the end of PyEdit\u2019s source file for\nimplementation notes.\nNew Grep dialog: Threaded and Unicode-aware file tree search\nIn addition, there is a new Grep option in the Search pull-down menu, which imple-\nments an external file search tool. This tool scans an entire directory tree for files whose\nnames match a pattern, and which contain a given search string. Names of matches are\npopped up in a new nonmodal scrolled list window, with lines that identify all matches\nby filename, line number, and line content. Clicking on a list item opens the matched\nfile in a new nonmodal and in-process PyEdit pop-up edit window and automatically\nmoves to and selects the line of the match. This achieves its goal by reusing much code\nwe wrote earlier:\n\u2022 The find utility we wrote in Chapter 6 to do its tree walking\n\u2022 The scrolled list utility we coded in Chapter 9 for displaying matches\n\u2022 The form row builder we wrote in Chapter 10 for the nonmodal input dialog\n\u2022 The existing PyEdit pop-up window mode logic to display matched files on request\n\u2022 The existing PyEdit go-to callback and logic to move to the matched line in a file\nTo avoid blocking the GUI while files are searched during tree\nwalks, Grep runs searches in parallel threads. This also allows multiple greps to be\nrunning at once and to overlap in time arbitrarily (especially useful if you grep in larger\ntrees, such as Python\u2019s own library or full source trees). The standard threads, queues,\nand after timer loops technique we learned in Chapter 10 is applied here\u2014non-GUI\nproducer threads find matches and place them on a queue to be detected by a timer\nloop in the main GUI thread.\nGrep threading model.\nPyEdit: A Text Editor Program/Object | 685As coded, a timer loop is run only when a grep is in progress, and each grep uses its\nown thread, timer loop, and queue. There may be multiple threads and loops running,\nand there may be other unrelated threads, queues, and timer loops in the process. For\ninstance, an attached PyEdit component in Chapter 14\u2019s PyMailGUI program can run\ngrep threads and loops of its own, while PyMailGUI runs its own email-related threads\nand queue checker. Each loop\u2019s handler is dispatched independently from the tkinter\nevent stream processor. Because of the simpler structure here, the general thread\ntools callback queue of Chapter 10 is not used here. For more notes on grep thread\nimplementation see the source code ahead, and compare to file _unthreaded-\ntextEditor.py in the examples package, a nonthreaded version of PyEdit.\nIf you study the Grep option\u2019s code, you\u2019ll notice that it also allows\ninput of a tree-wide Unicode encoding, and catches and skips any Unicode decoding\nerror exceptions generated both when processing file content and walking the tree\u2019s\nfilenames. As we learned in Chapters 4 and 6, files opened in text mode in Python 3.X\nmust be decodable per a provided or platform default Unicode encoding. This is par-\nticular problematic for Grep, as directory trees may contain files of arbitrarily mixed\nencoding types.\nIn fact, it\u2019s common on Windows to have files with content in ASCII, UTF-8, and\nUTF-16 form mixed in the same tree (Notepad\u2019s \u201cANSI,\u201d \u201cUtf-8,\u201d and \u201cUnicode\u201d),\nand even others in trees that contain content obtained from the Web or email. Opening\nall these with UTF-8 would trigger exceptions in Python 3.X, and opening all these in\nbinary mode yields encoded text that will likely fail to match a search key string. Tech-\nnically, to compare at all, we\u2019d still have to decode the bytes read to text or encode the\nsearch key string to bytes, and the two would only match if the encodings used both\nsucceed and agree.\nTo allow for mixed encoding trees, the Grep dialog opens in text mode and allows an\nencoding name to be input and used to decode file content for all files in the tree\nsearched. This encoding name is prefilled with the platform content default for con-\nvenience, as this will often suffice. To search trees of mixed file types, users may run\nmultiple Greps with different encoding names. The names of files searched might fail\nto decode as well, but this is largely ignored in the current release: they are assumed to\nsatisfy the platform filename convention, and end the search if they don\u2019t (see Chapters\n4 and 6 for more on filename encoding issues in Python itself, as well as the find walker\nreused here).\nIn addition, Grep must take care to catch and recover from encoding errors, since some\nfiles with matching names that it searches might still not be decodable per the input\nencoding, and in fact might not be text files at all. For example, searches in\nPython 3.1\u2019s standard library (like the example Grep for % described earlier) run into a\nhandful of files which do not decode properly on my Windows machine and would\notherwise crash PyEdit. Binary files which happen to match the filename patterns would\nfare even worse.\nGrep Unicode model.\n686 | Chapter 11:\u2002Complete GUI ProgramsIn general, programs can avoid Unicode encoding errors by either catching exceptions\nor opening files in binary mode; since Grep might not be able to interpret some of the\nfiles it visits as text at all, it takes the former approach. Really, opening even text files\nin binary mode to read raw byte strings in 3.X mimics the behavior of text files in 2.X,\nand underscores why forcing programs to deal with Unicode is sometimes a good\nthing\u2014binary mode avoids decoding exceptions, but probably shouldn\u2019t, because the\nstill-encoded text might not work as expected. In this case, it might yield invalid com-\nparison results.\nFor more details on Grep\u2019s Unicode support, and a set of open issues and options\nsurrounding it, see the source code listed ahead. For a suggested enhancement, see also\nthe re pattern matching module in Chapter 19\u2014a tool we could use to search for\npatterns instead of specific strings.\nUpdate for initial positioning\nAlso in this version, text editor updates itself before inserting text into its text widget\nat construction time when it is passed an initial file name in its loadFirst argument.\nSometime after the third edition and Python 2.5, either Tk or tkinter changed such that\ninserting text before an update call caused the scroll position to be off by one\u2014the text\neditor started with line 2 at its top in this mode instead of line 1. This also occurs in\nthe third edition\u2019s version of this example under Python 2.6, but not 2.5; adding an\nupdate correctly positions at line 1 initially. Obscure but true in the real world of library\ndependencies!\u2020\nClients of the classes here should also update before manually inserting text into a newly\ncreated (or packed) text editor object for accurate positioning; PyView later in this\nchapter as well as PyMailGUI in Chapter 14 now do. PyEdit doesn\u2019t update itself on\nevery construction, because it may be created early by, or even hidden in, an enclosing\nGUI (for instance, this would show a half-complete window in PyView). Moreover,\nPyEdit could automatically update itself at the start of setAllText instead of requiring\nthis step of clients, but forced update is required only once initially after being packed\n(not before each text insertion), and this too might be an undesirable side effect in some\nconceivable use cases. As a rule of thumb, adding unrelated operations to methods this\nway tends to limit their scope.\nImprovements for running code\nThe Run Code option in the Tools menu was fixed in three ways that make it more\nuseful for running code being edited from its external file, rather than in-process:\n\u2020 Interestingly, Python\u2019s own IDLE text editor in Python 3.1 suffers from two of the same bugs described here\nand resolved in this edition\u2019s PyEdit\u2014in 3.1, IDLE positions at line 2 instead of line 1 on file opens, and its\nexternal files search (similar to PyEdit\u2019s Grep) crashes on 3.X Unicode decoding errors when scanning the\nPython standard library, causing IDLE to exit altogether. Insert snarky comment about the shoemaker\u2019s\nchildren having no shoes here\u2026\nPyEdit: A Text Editor Program/Object | 6871. After changing to the file\u2019s directory in order to make any relative filenames in its\ncode accurate, PyEdit now strips off any directory path prefix in the file\u2019s name\nbefore launching it, because its original directory path may no longer be valid if it\nis relative instead of absolute. For instance, paths of files opened manually are\nabsolute, but file paths in PyDemos\u2019s Code pop ups are all relative to the example\npackage root and would fail after a chdir.\n2. PyEdit now correctly uses launcher tools that support command-line arguments\nfor file mode on Windows.\n3. PyEdit inherits a fix in the underlying launchmodes module that changes forward\nslashes in script path names to backslashes (though this was later made a moot\npoint by stripping relative path prefixes). PyEdit gets by with forward slashes on\nWindows because open allows them, but some Windows launch tools do not.\nAdditionally, for both code run from files and code run in memory, this version adds\nan update call between pop-up dialogs to ensure that later dialogs appear in all cases\n(the second occasionally failed to pop up in rare contexts). Even with these fixes, Run\nCode is useful but still not fully robust. For example, if the edited code is not run from\na file, it is run in-process and not spawned off in a thread, and so may block the GUI.\nIt\u2019s also not clear how best to handle import paths and directories for files run in nonfile\nmode, or whether this mode is worth retaining in general. Improve as desired.\nUnicode (Internationalized) text support\nFinally, because Python 3.X now fully supports Unicode text, this version of PyEdit\ndoes, too\u2014it allows text of arbitrary Unicode encodings and character sets to be opened\nand saved in files, viewed and edited in its GUI, and searched by its directory search\nutility. This support is reflected in PyMailGUI\u2019s user interface in a variety of ways:\n\u2022 Opens must ask the user for an encoding (suggesting the platform default) if one\nis not provided by the client application or configuration\n\u2022 Saves of new files must ask for an encoding if one is not provided by configuration\n\u2022 Display and edit must rely on the GUI toolkit\u2019s own support for Unicode text\n\u2022 Grep directory searches must allow for input of an encoding to apply to all files in\nthe tree and skip files that fail to decode, as described earlier\nThe net result is to support Internationalized text which may differ from the platform\u2019s\ndefault encoding. This is particularly useful for text files fetched over the Internet by\nemail or FTP. Chapter 14\u2019s PyMailGUI, for example, uses an embedded PyEdit object\nto view text attachments of arbitrary origin and encoding. The Grep utility\u2019s Unicode\nsupport was described earlier; the remainder of this model essentially reduces to file\nopens and saves, as the next section describes.\nBecause strings are always Unicode code-point strings once\nthey are created in memory, Unicode support really means supporting arbitrary en-\ncodings for text files when they are read and written. Recall that text can be stored in\nUnicode file and display model.\n688 | Chapter 11:\u2002Complete GUI Programsfiles in a variety of Unicode encoding format schemes; strings are decoded from these\nformats when read and encoded to them when written. Unless text is always stored in\nfiles using the platform\u2019s default encoding, we need to know which encoding to use,\nboth to load and to save.\nTo make this work, PyEdit uses the approaches described in detail in Chapter 9, which\nwe won\u2019t repeat in full here. In brief, though, tkinter\u2019s Text widget accepts content as\neither str and bytes and always returns it as str. PyEdit maps this interface to and from\nPython file objects as follows:\nInput files (Open)\nDecoding from file bytes to strings in general requires the name of an encoding\ntype that is compatible with data in the file, and fails if the two do not agree (e.g.,\ndecoding 8-bit data to ASCII). In some cases, the Unicode type of the text file to\nbe opened may be unknown.\nTo load, PyEdit first tries to open input files in text mode to read str strings, using\nan encoding obtained from a variety of sources\u2014a method argument for a known\ntype (e.g., from headers of email attachments or source files opened by demos), a\nuser dialog reply, a configuration module setting, and the platform default. When-\never prompting users for an open encoding, the dialog is prefilled with the first\nchoice implied by the configuration file, as a default and suggestion.\nIf all these encoding sources fail to decode, the file is opened in binary mode to\nread text as bytes without an encoding name, effectively delegating encoding issues\nto the Tk GUI library; in this case, any \\r\\n end-lines are manually converted to\n\\n on Windows so they correctly display and save later. Binary mode is used only\nas a last resort, to avoid relying on Tk\u2019s policies and limited character set support\nfor raw bytes.\nText Processing\nThe tkinter Text widget returns its content on request as str strings, regardless of\nwhether str or bytes were inserted. Because of that, all text processing of content\nfetched from the GUI is conducted in terms of str Unicode strings here.\nOutput files (Save, Save As)\nEncoding from strings to file bytes is generally more flexible than decoding and\nneed not use the same encoding from which the string was decoded, but can also\nfail if the chosen scheme is too narrow to handle the string\u2019s content (e.g., encoding\n8-bit text to ASCII).\nTo save, PyEdit opens output files in text mode to perform end-line mappings and\nUnicode encoding of str content. An encoding name is again fetched from one of\na variety of sources\u2014the same encoding used when the file was first opened or\nsaved (if any), a user dialog reply, a configuration module setting, and the platform\ndefault. Unlike opens, save dialogs that prompt for encodings are prefilled with\nthe known encoding if there is one as a suggestion; otherwise, the dialog is prefilled\nwith the next configured choice as a default, as for opens.\nPyEdit: A Text Editor Program/Object | 689The user input dialog on opens and saves is the only GUI implication of these policies;\nother options are selected in configuration module assignments. Since it\u2019s impossible\nto predict all possible use case scenarios, PyEdit takes a liberal approach: it supports\nall conceivable modes, and allows the way it obtains file encodings to be heavily tailored\nby users in the package\u2019s own textConfig module. It attempts one encoding name\nsource after another, if enabled in textConfig, until it finds an encoding that works.\nThis aims to provide maximum flexibility in the face of an uncertain Unicode world.\nFor example, subject to settings in the configuration file, saves reuse the encoding used\nfor the file when it was opened or initially saved, if known. Both new files begun from\nscratch (with New or manual text inserts) and files opened in binary mode as a last\nresort have no known encoding until saved, but files previously opened as text do. Also\nsubject to configuration file settings, we may prompt users for an encoding on Save As\n(and possibly Save) because they may have a preference for new files they create. We\nalso may prompt when opening an existing file, because this requires its current en-\ncoding; although the user may not always know what this is (e.g., files fetched over the\nInternet), the user may wish to provide it in others. Rather than choosing a course of\naction in such cases, we rely on user configuration.\nAll of this is really relevant only to PyEdit clients that request an initial file load or allow\nfiles to be opened and saved in the GUI. Because content can be inserted as str or\nbytes, clients can always open and read input files themselves prior to creating a text\neditor object and insert the text manually for viewing. Moreover, clients can fetch con-\ntent manually and save in any fashion preferred. Such a manual approach might prove\nuseful if PyEdit\u2019s polices are undesirable for a given context. Since the Text widget\nalways returns content as a str, the rest of this program is unaffected by the data type\nof text inserted.\nKeep in mind that these policies are still subject to the Unicode support and constraints\nof the underlying Tk GUI toolkit, as well as Python\u2019s tkinter interface to it. Although\nPyEdit allows text to be loaded and saved in arbitrary Unicode encodings, it cannot\nguarantee that the GUI library will display such text as you wish. That is, even if we\nget the Unicode story right on the Python side of the fence, we\u2019re still at the mercy of\nother software layers which are beyond the scope of this book. Tk seems to be robust\nacross a wide range of character sets if we pass it already decoded Python str Unicode\nstrings (see the Internationalization support in Chapter 14\u2019s PyMailGUI for samples),\nbut your mileage might vary.\nAlso keep in mind that the Unicode policies adopted in PyEdit\nreflect the use cases of its sole current user, and have not been broadly tested for ergo-\nnomics and generality; as a book example, this doesn\u2019t enjoy the built-in test environ-\nment of open source projects. Other schemes and source orderings might work well,\ntoo, and it\u2019s impossible to guess the preferences of every user in every context. For\ninstance:\nUnicode options and choices.\n690 | Chapter 11:\u2002Complete GUI Programs\u2022 It\u2019s not clear if user prompts should be attempted before configuration settings, or\nvice-versa.\n\u2022 Perhaps we also should always ask the user for an encoding as a last resort, irre-\nspective of configuration settings.\n\u2022 For saves, we could also try to guess an encoding to apply to the str content (e.g.,\ntry UTF-8, Latin-1, and other common types), but our guess may not be what the\nuser has in mind.\n\u2022 It\u2019s likely that users will wish to save a file in the same encoding with which it was\nfirst opened, or initially saved if started from scratch. PyEdit provides support to\ndo so, or else the GUI might ask for a given file\u2019s encoding more than once. How-\never, because some users might also want to use Save again to overwrite the same\nfile with a different encoding, this can be disabled in the configuration module.\nThe latter role might sound like a Save As, but the next bullet explains why it may\nnot.\n\u2022 Similarly, it\u2019s not obvious if Save As should also reuse the encoding used when the\nfile was first opened or initially saved or ask for a new one\u2014is this a new file entirely,\nor a copy of the prior text with its known encoding under a new name? Because of\nsuch ambiguities, we allow the known-encoding memory feature to be disabled for\nSave As, or for both Save and Save As in the configuration module. As shipped, it\nis enabled for Save only, not Save As. In all cases, save encoding prompt dialogs\nare prefilled with a known encoding name as a default.\n\u2022 The ordering of choice seems debatable in general. For instance, perhaps Save As\nshould fall back on the known encoding if not asking the user; as is, if configured\nto not ask and not use a known encoding, this operation will fall back on saving\nper an encoding in the configuration file or the platform default (e.g., UTF-8),\nwhich may be less than ideal for email parts of known encodings.\nAnd so on. Because such user interface choices require wider use to resolve well, the\ngeneral and partly heuristic policy here is to support every option for illustration pur-\nposes in this book, and rely on user configuration settings to resolve choices. In practice,\nthough, such wide flexibility may turn out to be overkill; most users probably just\nrequire one of the policies supported here.\nIt may also prove better to allow Unicode policies to be selected in the GUI itself, instead\nof coded in a configuration module. For instance, perhaps every Open, Save, and Save\nAs should allow a Unicode encoding selection, which defaults to the last known en-\ncoding, if any. Implementing this as a pull-down encoding list or entry field in the Save\nand Open dialogs would avoid an extra pop up and achieve much the same flexibility.\nIn PyEdit\u2019s current implementation, enabling user prompts in the configuration file for\nboth opens and saves will have much the same effect, and at least based upon use cases\nI\u2019ve encountered to date, that is probably the best policy to adopt for most contexts.\nPyEdit: A Text Editor Program/Object | 691Hence, as shipped:\n\u2022 Open uses a passed-in encoding, if any, or else prompts for an encoding name first\n\u2022 Save reuses a known encoding if it has one, and otherwise prompts for new file saves\n\u2022 Save As always prompts for an encoding name first for the new file\n\u2022 Grep allows an encoding to be input in its dialog to apply to the full tree searched\nOn the other hand, because the platform default will probably work silently without\nextra GUI complexity for the vast majority of users anyhow, the textConfig setting can\nprevent the pop ups altogether and fall back on an explicit encoding or platform default.\nUltimately, structuring encoding selection well requires the sort of broad user experi-\nence and feedback which is outside this book\u2019s scope, not the guesses of a single de-\nveloper. As always, feel free to tailor as you like.\nSee the test subdirectory in the examples for a few Unicode text files to experiment\nwith opening and saving, in conjunction with textConfig changes. As suggested when\nwe saw Figures 11-5 and 11-6, this directory contains files that use International char-\nacter sets, saved in different encodings. For instance, file email-part--koi8-r there is\nformatted per the Russian encoding koi8-r, and email-part--koi8-r--utf8 is the same file\nsaved in UTF-8 encoding format; the latter works well in Notepad on Windows, but\nthe former will only display properly when giving an explicit encoding name to PyEdit.\nBetter yet, make a few Unicode files yourself, by changing textConfig to hardcode\nencodings or always ask for encodings\u2014thanks largely to Python 3.X\u2019s Unicode sup-\nport, PyEdit allows you to save and load in whatever encoding you wish.\nMore on Quit checks: The <Destroy> event revisited\nBefore we get to the code, one of version 2.1\u2019s changes merits a few additional words,\nbecause it illustrates the fundamentals of tkinter window closure in a realistic context.\nWe learned in Chapter 8 that tkinter also has a <Destroy> event for the bind method\nwhich is run when windows and widgets are destroyed. Although we could bind this\nevent on PyEdit windows or their text widgets to catch destroys on program exit, this\nwon\u2019t quite help with the use case here. Scripts cannot generally do anything GUI-\nrelated in this event\u2019s callback, because the GUI is being torn down. In particular, both\ntesting a text widget for modifications and fetching its content in a <Destroy> handler\ncan fail with an exception. Popping up a save verification dialog at this point may act\noddly, too: it only shows up after some of the window\u2019s widgets may have already been\nerased (including the text widget whose contents the user may wish to inspect and\nsave!), and it might sometimes refuse to go away altogether.\nAs also mentioned in Chapter 8, running a quit method call does not trigger any\n<Destroy> events, but does trigger a fatal Python error message on exit. To use destroy\nevents at all, PyEdit would have to be redesigned to close windows on Quit requests\nwith the destroy method only, and rely on the Tk root window destruction protocol for\nexits; immediate shutdowns would be unsupported, or require tools such as\n692 | Chapter 11:\u2002Complete GUI Programssys.exit. Since <Destroy> doesn\u2019t allow GUI operations anyhow, this change is un-\nwarranted. Code after mainloop won\u2019t help here either, because mainloop is called out-\nside PyEdit\u2019s code, and this is far too late to detect text changes and save in any event\n(pun nearly accidental).\nIn other words, <Destroy> won\u2019t help\u2014it doesn\u2019t support the goal of verifying saves on\nwindow closes, and it doesn\u2019t address the issue of quit and destroy calls run for widgets\noutside the scope of PyEdit window classes. Because of such complications, PyEdit\ninstead relies on checking for changes in each individual window before closed, and\nfor changes in its cross-process window list before quits in any of its main windows.\nApplications that follow its expected window model check for changes automatically.\nApplications that embed a PyEdit as a component of a larger GUI, or use it in other\nways that are outside PyEdit\u2019s control, are responsible for testing for edit changes on\ncloses if they should be saved, before the PyEdit object or its widgets are destroyed.\nTo experiment with the <Destroy> event\u2019s behavior yourself, see file destroyer.py in the\nbook examples package; it simulates what PyEdit would need to do on <Destroy>. Here\nis the crucial subset of its code, with comments that explain behavior:\ndef onDeleteRequest():\n    print('Got wm delete')                          # on window X: can cancel destroy\n    root.destroy()                                  # triggers <Destroy>\ndef doRootDestroy(event):\n    print('Got event <destroy>')                    # called for each widget in root\n    if event.widget == text:\n        print('for text')\n        print(text.edit_modified())                 # <= Tcl error: invalid widget\n        ans = askyesno('Save stuff?', 'Save?')      # <= may behave badly\n        if ans: print(text.get('1.0', END+'-1c'))   # <= Tcl error: invalid widget\nroot = Tk()\ntext = Text(root, undo=1, autoseparators=1)\ntext.pack()\nroot.bind('<Destroy>', doRootDestroy)                      # for root and children\nroot.protocol('WM_DELETE_WINDOW', onDeleteRequest)         # on window X button\nButton(root, text='Destroy', command=root.destroy).pack()  # triggers <Destroy>\nButton(root, text='Quit',    command=root.quit).pack()     # <= fatal Python error,\nmainloop()                                                 # no <Destroy> on quit()\nSee the code listings in the next section for more on all of the above. Also be sure to see\nthe mail file\u2019s documentation string for a list of suggested enhancements and open\nissues (noted under \u201cTBD\u201d). PyEdit is largely designed to work according to my pref-\nerences, but it\u2019s open to customization for yours.\nPyEdit Source Code\nThe PyEdit program consists of only a small configuration module and one main source\nfile, which is just over 1,000 lines long\u2014a .py that can be either run or imported. For\nPyEdit: A Text Editor Program/Object | 693use on Windows, there is also a one-line .pyw file that just executes the .py file\u2019s contents\nwith an execfile('textEditor.py') call. The .pyw suffix avoids the DOS console\nstreams window pop up when launched by clicking on Windows.\nToday, .pyw files can be both imported and run, like normal .py files (they can also be\ndouble-clicked, and launched by Python tools such as os.system and os.startfile), so\nwe don\u2019t really need a separate file to support both import and console-less run modes.\nI retained the .py, though, in order to see printed text during development and to use\nPyEdit as a simple IDE\u2014when the run code option is selected, in nonfile mode, printed\noutput from code being edited shows up in PyEdit\u2019s DOS console window in Windows.\nClients will normally import the .py file.\nUser configurations file\nOn to the code. First, PyEdit\u2019s user configuration module is listed in Example 11-1.\nThis is mostly a convenience, for providing an initial look-and-feel other than the de-\nfault. PyEdit is coded to work even if this module is missing or contains syntax errors.\nThis file is primarily intended for when PyEdit is the top-level script run (in which case\nthe file is imported from the current directory), but you can also define your own version\nof this file elsewhere on your module import search path to customize PyEdit.\nSee textEditor.py ahead for more on how this module\u2019s settings are loaded. Its contents\nare loaded by two different imports\u2014one import for cosmetic settings assumes this\nmodule itself (not its package) is on the module search path and skips it if not found,\nand the other import for Unicode settings always locates this file regardless of launch\nmodes. Here\u2019s what this division of configuration labor means for clients:\n\u2022 Because the first import for cosmetic settings is relative to the module search path,\nnot to the main file\u2019s package, a new textConfig.py can be defined in each client\napplication\u2019s home directory to customize PyEdit windows per client.\n\u2022 Conversely, Unicode settings here are always loaded from this file using package\nrelative imports if needed, because they are more critical and unlikely to vary. The\npackage relative import used for this is equivalent to a full package import from\nthe PP4E root, but not dependent upon directory structure.\nLike much of the heuristic Unicode interface described earlier, this import model is\nsomewhat preliminary, and may require revision if actual usage patterns warrant.\nExample 11-1. PP4E\\Gui\\TextEditor\\textConfig.py\n\"\"\"\nPyEdit (textEditor.py) user startup configuration module;\n\"\"\"\n#----------------------------------------------------------------------------------\n# General configurations\n# comment-out any setting in this section to accept Tk or program defaults;\n# can also change font/colors from GUI menus, and resize window when open;\n# imported via search path: can define per client app, skipped if not on the path;\n694 | Chapter 11:\u2002Complete GUI Programs#----------------------------------------------------------------------------------\n# initial font                      # family, size, style\nfont = ('courier', 9, 'normal')     # e.g., style: 'bold italic'\n# initial color                     # default=white, black\nbg = 'lightcyan'                    # colorname or RGB hexstr\nfg = 'black'                        # e.g., 'powder blue', '#690f96'\n# initial size\nheight = 20                         # Tk default: 24 lines\nwidth  = 80                         # Tk default: 80 characters\n# search case-insensitive\ncaseinsens = True                   # default=1/True (on)\n#----------------------------------------------------------------------------------\n# 2.1: Unicode encoding behavior and names for file opens and saves;\n# attempts the cases listed below in the order shown, until the first one\n# that works; set all variables to false/empty/0 to use your platform's default\n# (which is 'utf-8' on Windows, or 'ascii' or 'latin-1' on others like Unix);\n# savesUseKnownEncoding: 0=No, 1=Yes for Save only, 2=Yes for Save and SaveAs;\n# imported from this file always: sys.path if main, else package relative;\n#----------------------------------------------------------------------------------\n                       # 1) tries internally known type first (e.g., email charset)\nopensAskUser = True    # 2) if True, try user input next (prefill with defaults)\nopensEncoding = ''     # 3) if nonempty, try this encoding next: 'latin-1', 'cp500'\n                       # 4) tries sys.getdefaultencoding() platform default next\n                       # 5) uses binary mode bytes and Tk policy as the last resort\nsavesUseKnownEncoding = 1    # 1) if > 0, try known encoding from last open or save\nsavesAskUser = True          # 2) if True, try user input next (prefill with known?)\nsavesEncoding = ''           # 3) if nonempty, try this encoding next: 'utf-8', etc\n                             # 4) tries sys.getdefaultencoding() as a last resort\nWindows (and other) launch files\nNext, Example 11-2 gives the .pyw launching file used to suppress a DOS pop up on\nWindows when run in some modes (for instance, when double-clicked), but still allow\nfor a console when the .py file is run directly (to see the output of edited code run in\nnonfile mode, for example). Clicking this directly is similar to the behavior when PyEdit\nis run from the PyDemos or PyGadgets demo launcher bars.\nExample 11-2. PP4E\\Gui\\TextEditor\\textEditorNoConsole.pyw\n\"\"\"\nrun without a DOS pop up on Windows; could use just a .pyw for both\nimports and launch, but .py file retained for seeing any printed text\n\"\"\"\nexec(open('textEditor.py').read())    # as if pasted here (or textEditor.main())\nPyEdit: A Text Editor Program/Object | 695Example 11-2 serves its purpose, but later in this book update project, I grew tired of\nusing Notepad to view text files from command lines run in arbitrary places and wrote\nthe script in Example 11-3 to launch PyEdit in a more general and automated fashion.\nThis script disables the DOS pop up, like Example 11-2, when clicked or run via a\ndesktop shortcut on Windows, but also takes care to configure the module search path\non machines where I haven\u2019t used Control Panel to do so, and allows for other launch-\ning scenarios where the current working directory may not be the same as the script\u2019s\ndirectory.\nExample 11-3. PP4E\\Gui\\TextEditor\\pyedit.pyw\n#!/usr/bin/python\n\"\"\"\nconvenience script to launch pyedit from arbitrary places with the import path set\nas required;  sys.path for imports and open() must be relative to the known top-level\nscript's dir, not cwd -- cwd is script's dir if run by shortcut or icon click, but may\nbe anything if run from command-line typed into a shell console window: use argv path;\nthis is a .pyw to suppress console pop-up on Windows;  add this script's dir to your\nsystem PATH to run from command-lines;  works on Unix too: / and \\ handled portably;\n\"\"\"\nimport sys, os\nmydir = os.path.dirname(sys.argv[0])                     # use my dir for open, path\nsys.path.insert(1, os.sep.join([mydir] + ['..']*3))      # imports: PP4E root, 3 up\nexec(open(os.path.join(mydir, 'textEditor.py')).read())\nTo run this from a command line in a console window, it simply has to be on your\nsystem path\u2014the action taken by the first line in the following could be performed just\nonce in Control Panel on Windows:\nC:\\...\\PP4E\\Internet\\Web> set PATH=%PATH%;C:\\...\\PP4E\\Gui\\TextEditor\nC:\\...\\PP4E\\Internet\\Web> pyedit.pyw test-cookies.py\nThis script works on Unix, too, and is unnecessary if you set your PYTHONPATH and\nPATH system variables (you could then just run textEditor.py directly), but I don\u2019t do\nso on all the machines I use. For more fun, try registering this script to open \u201c.txt\u201d files\nautomatically on your computer when their icons are clicked or their names are typed\nalone on a command line (if you can bear to part with Notepad, that is).\nMain implementation file\nAnd finally, the module in Example 11-4 is PyEdit\u2019s implementation. This file may run\ndirectly as a top-level script, or it can be imported from other applications. Its code is\norganized by the GUI\u2019s main menu options. The main classes used to start and embed\na PyEdit object appear at the end of this file. Study this listing while you experiment\nwith PyEdit, to learn about its features and techniques.\n696 | Chapter 11:\u2002Complete GUI ProgramsExample 11-4. PP4E\\Gui\\TextEditor\\textEditor.py\n\"\"\"\n################################################################################\nPyEdit 2.1: a Python/tkinter text file editor and component.\nUses the Tk text widget, plus GuiMaker menus and toolbar buttons to\nimplement a full-featured text editor that can be run as a standalone\nprogram, and attached as a component to other GUIs.  Also used by\nPyMailGUI and PyView to edit mail text and image file notes, and by\nPyMailGUI and PyDemos in pop-up mode to display source and text files.\nNew in version 2.1 (4E)\n-updated to run under Python 3.X (3.1)\n-added \"grep\" search menu option and dialog: threaded external files search\n-verify app exit on quit if changes in other edit windows in process\n-supports arbitrary Unicode encodings for files: per textConfig.py settings\n-update change and font dialog implementations to allow many to be open\n-runs self.update() before setting text in new editor for loadFirst\n-various improvements to the Run Code option, per the next section\n2.1 Run Code improvements:\n-use base name after chdir to run code file, not possibly relative path\n-use launch modes that support arguments for run code file mode on Windows\n-run code inherits launchmodes backslash conversion (no longer required)\nNew in version 2.0 (3E)\n-added simple font components input dialog\n-use Tk 8.4 undo stack API to add undo/redo text modifications\n-now verifies on quit, open, new, run, only if text modified and unsaved\n-searches are case-insensitive now by default\n-configuration module for initial font/color/size/searchcase\nTBD (and suggested exercises):\n-could also allow search case choice in GUI (not just config file)\n-could use re patterns for searches and greps (see text chapter)\n-could experiment with syntax-directed text colorization (see IDLE, others)\n-could try to verify app exit for quit() in non-managed windows too?\n-could queue each result as found in grep dialog thread to avoid delay\n-could use images in toolbar buttons (per examples of this in Chapter 9)\n-could scan line to map Tk insert position column to account for tabs on Info\n-could experiment with \"grep\" tbd Unicode issues (see notes in the code);\n################################################################################\n\"\"\"\nVersion = '2.1'\nimport sys, os                                    # platform, args, run tools\nfrom tkinter import *                             # base widgets, constants\nfrom tkinter.filedialog   import Open, SaveAs     # standard dialogs\nfrom tkinter.messagebox   import showinfo, showerror, askyesno\nfrom tkinter.simpledialog import askstring, askinteger\nfrom tkinter.colorchooser import askcolor\nfrom PP4E.Gui.Tools.guimaker import *             # Frame + menu/toolbar builders\n# general configurations\ntry:\nPyEdit: A Text Editor Program/Object | 697import textConfig                        # startup font and colors\n    configs = textConfig.__dict__            # work if not on the path or bad\nexcept:                                      # define in client app directory\n    configs = {}\nhelptext = \"\"\"PyEdit version %s\nApril, 2010\n(2.0: January, 2006)\n(1.0: October, 2000)\nProgramming Python, 4th Edition\nMark Lutz, for O'Reilly Media, Inc.\nA text editor program and embeddable object\ncomponent, written in Python/tkinter.  Use\nmenu tear-offs and toolbar for quick access\nto actions, and Alt-key shortcuts for menus.\nAdditions in version %s:\n- supports Python 3.X\n- new \"grep\" external files search dialog\n- verifies app quit if other edit windows changed\n- supports arbitrary Unicode encodings for files\n- allows multiple change and font dialogs\n- various improvements to the Run Code option\nPrior version additions:\n- font pick dialog\n- unlimited undo/redo\n- quit/open/new/run prompt save only if changed\n- searches are case-insensitive\n- startup configuration module textConfig.py\n\"\"\"\nSTART     = '1.0'                          # index of first char: row=1,col=0\nSEL_FIRST = SEL + '.first'                 # map sel tag to index\nSEL_LAST  = SEL + '.last'                  # same as 'sel.last'\nFontScale = 0                              # use bigger font on Linux\nif sys.platform[:3] != 'win':              # and other non-Windows boxes\n    FontScale = 3\n################################################################################\n# Main class: implements editor GUI, actions\n# requires a flavor of GuiMaker to be mixed in by more specific subclasses;\n# not a direct subclass of GuiMaker because that class takes multiple forms.\n################################################################################\nclass TextEditor:                        # mix with menu/toolbar Frame class\n    startfiledir = '.'                   # for dialogs\n    editwindows  = []                    # for process-wide quit check\n    # Unicode configurations\n    # imported in class to allow overrides in subclass or self\n698 | Chapter 11:\u2002Complete GUI Programsif __name__ == '__main__':\n        from textConfig import (               # my dir is on the path\n            opensAskUser, opensEncoding,\n            savesUseKnownEncoding, savesAskUser, savesEncoding)\n    else:\n        from .textConfig import (              # 2.1: always from this package\n            opensAskUser, opensEncoding,\n            savesUseKnownEncoding, savesAskUser, savesEncoding)\n    ftypes = [('All files',     '*'),                 # for file open dialog\n              ('Text files',   '.txt'),               # customize in subclass\n              ('Python files', '.py')]                # or set in each instance\n    colors = [{'fg':'black',      'bg':'white'},      # color pick list\n              {'fg':'yellow',     'bg':'black'},      # first item is default\n              {'fg':'white',      'bg':'blue'},       # tailor me as desired\n              {'fg':'black',      'bg':'beige'},      # or do PickBg/Fg chooser\n              {'fg':'yellow',     'bg':'purple'},\n              {'fg':'black',      'bg':'brown'},\n              {'fg':'lightgreen', 'bg':'darkgreen'},\n              {'fg':'darkblue',   'bg':'orange'},\n              {'fg':'orange',     'bg':'darkblue'}]\n    fonts  = [('courier',    9+FontScale, 'normal'),  # platform-neutral fonts\n              ('courier',   12+FontScale, 'normal'),  # (family, size, style)\n              ('courier',   10+FontScale, 'bold'),    # or pop up a listbox\n              ('courier',   10+FontScale, 'italic'),  # make bigger on Linux\n              ('times',     10+FontScale, 'normal'),  # use 'bold italic' for 2\n              ('helvetica', 10+FontScale, 'normal'),  # also 'underline', etc.\n              ('ariel',     10+FontScale, 'normal'),\n              ('system',    10+FontScale, 'normal'),\n              ('courier',   20+FontScale, 'normal')]\n    def __init__(self, loadFirst='', loadEncode=''):\n        if not isinstance(self, GuiMaker):\n            raise TypeError('TextEditor needs a GuiMaker mixin')\n        self.setFileName(None)\n        self.lastfind   = None\n        self.openDialog = None\n        self.saveDialog = None\n        self.knownEncoding = None                   # 2.1 Unicode: till Open or Save\n        self.text.focus()                           # else must click in text\n        if loadFirst:\n            self.update()                           # 2.1: else @ line 2; see book\n            self.onOpen(loadFirst, loadEncode)\n    def start(self):                                # run by GuiMaker.__init__\n        self.menuBar = [                            # configure menu/toolbar\n            ('File', 0,                             # a GuiMaker menu def tree\n                 [('Open...',    0, self.onOpen),   # build in method for self\n                  ('Save',       0, self.onSave),   # label, shortcut, callback\n                  ('Save As...', 5, self.onSaveAs),\n                  ('New',        0, self.onNew),\n                  'separator',\n                  ('Quit...',    0, self.onQuit)]\nPyEdit: A Text Editor Program/Object | 699),\n            ('Edit', 0,\n                 [('Undo',       0, self.onUndo),\n                  ('Redo',       0, self.onRedo),\n                  'separator',\n                  ('Cut',        0, self.onCut),\n                  ('Copy',       1, self.onCopy),\n                  ('Paste',      0, self.onPaste),\n                  'separator',\n                  ('Delete',     0, self.onDelete),\n                  ('Select All', 0, self.onSelectAll)]\n            ),\n            ('Search', 0,\n                 [('Goto...',    0, self.onGoto),\n                  ('Find...',    0, self.onFind),\n                  ('Refind',     0, self.onRefind),\n                  ('Change...',  0, self.onChange),\n                  ('Grep...',    3, self.onGrep)]\n            ),\n            ('Tools', 0,\n                 [('Pick Font...', 6, self.onPickFont),\n                  ('Font List',    0, self.onFontList),\n                  'separator',\n                  ('Pick Bg...',   3, self.onPickBg),\n                  ('Pick Fg...',   0, self.onPickFg),\n                  ('Color List',   0, self.onColorList),\n                  'separator',\n                  ('Info...',      0, self.onInfo),\n                  ('Clone',        1, self.onClone),\n                  ('Run Code',     0, self.onRunCode)]\n            )]\n        self.toolBar = [\n            ('Save',  self.onSave,   {'side': LEFT}),\n            ('Cut',   self.onCut,    {'side': LEFT}),\n            ('Copy',  self.onCopy,   {'side': LEFT}),\n            ('Paste', self.onPaste,  {'side': LEFT}),\n            ('Find',  self.onRefind, {'side': LEFT}),\n            ('Help',  self.help,     {'side': RIGHT}),\n            ('Quit',  self.onQuit,   {'side': RIGHT})]\n    def makeWidgets(self):                          # run by GuiMaker.__init__\n        name = Label(self, bg='black', fg='white')  # add below menu, above tool\n        name.pack(side=TOP, fill=X)                 # menu/toolbars are packed\n                                                    # GuiMaker frame packs itself\n        vbar  = Scrollbar(self)\n        hbar  = Scrollbar(self, orient='horizontal')\n        text  = Text(self, padx=5, wrap='none')        # disable line wrapping\n        text.config(undo=1, autoseparators=1)          # 2.0, default is 0, 1\n        vbar.pack(side=RIGHT,  fill=Y)\n        hbar.pack(side=BOTTOM, fill=X)                 # pack text last\n        text.pack(side=TOP,    fill=BOTH, expand=YES)  # else sbars clipped\n        text.config(yscrollcommand=vbar.set)    # call vbar.set on text move\n        text.config(xscrollcommand=hbar.set)\n700 | Chapter 11:\u2002Complete GUI Programsvbar.config(command=text.yview)         # call text.yview on scroll move\n        hbar.config(command=text.xview)         # or hbar['command']=text.xview\n        # 2.0: apply user configs or defaults\n        startfont = configs.get('font', self.fonts[0])\n        startbg   = configs.get('bg',   self.colors[0]['bg'])\n        startfg   = configs.get('fg',   self.colors[0]['fg'])\n        text.config(font=startfont, bg=startbg, fg=startfg)\n        if 'height' in configs: text.config(height=configs['height'])\n        if 'width'  in configs: text.config(width =configs['width'])\n        self.text = text\n        self.filelabel = name\n    ############################################################################\n    # File menu commands\n    ############################################################################\n    def my_askopenfilename(self):      # objects remember last result dir/file\n        if not self.openDialog:\n           self.openDialog = Open(initialdir=self.startfiledir,\n                                  filetypes=self.ftypes)\n        return self.openDialog.show()\n    def my_asksaveasfilename(self):    # objects remember last result dir/file\n        if not self.saveDialog:\n           self.saveDialog = SaveAs(initialdir=self.startfiledir,\n                                    filetypes=self.ftypes)\n        return self.saveDialog.show()\n    def onOpen(self, loadFirst='', loadEncode=''):\n        \"\"\"\n        2.1: total rewrite for Unicode support; open in text mode with\n        an encoding passed in, input from the user, in textconfig, or\n        platform default, or open as binary bytes for arbitrary Unicode\n        encodings as last resort and drop \\r in Windows end-lines if\n        present so text displays normally; content fetches are returned\n        as str, so need to  encode on saves: keep encoding used here;\n        tests if file is okay ahead of time to try to avoid opens;\n        we could also load and manually decode bytes to str to avoid\n        multiple open attempts, but this is unlikely to try all cases;\n        encoding behavior is configurable in the local textConfig.py:\n        1) tries known type first if passed in by client (email charsets)\n        2) if opensAskUser True, try user input next (prefill wih defaults)\n        3) if opensEncoding nonempty, try this encoding next: 'latin-1', etc.\n        4) tries sys.getdefaultencoding() platform default next\n        5) uses binary mode bytes and Tk policy as the last resort\n        \"\"\"\n        if self.text_edit_modified():    # 2.0\n            if not askyesno('PyEdit', 'Text has changed: discard changes?'):\n                return\nPyEdit: A Text Editor Program/Object | 701file = loadFirst or self.my_askopenfilename()\n        if not file:\n            return\n        if not os.path.isfile(file):\n            showerror('PyEdit', 'Could not open file ' + file)\n            return\n        # try known encoding if passed and accurate (e.g., email)\n        text = None     # empty file = '' = False: test for None!\n        if loadEncode:\n            try:\n                text = open(file, 'r', encoding=loadEncode).read()\n                self.knownEncoding = loadEncode\n            except (UnicodeError, LookupError, IOError):         # lookup: bad name\n                pass\n        # try user input, prefill with next choice as default\n        if text == None and self.opensAskUser:\n            self.update()  # else dialog doesn't appear in rare cases\n            askuser = askstring('PyEdit', 'Enter Unicode encoding for open',\n                                initialvalue=(self.opensEncoding or\n                                              sys.getdefaultencoding() or ''))\n            if askuser:\n                try:\n                    text = open(file, 'r', encoding=askuser).read()\n                    self.knownEncoding = askuser\n                except (UnicodeError, LookupError, IOError):\n                    pass\n        # try config file (or before ask user?)\n        if text == None and self.opensEncoding:\n            try:\n                text = open(file, 'r', encoding=self.opensEncoding).read()\n                self.knownEncoding = self.opensEncoding\n            except (UnicodeError, LookupError, IOError):\n                pass\n        # try platform default (utf-8 on windows; try utf8 always?)\n        if text == None:\n            try:\n                text = open(file, 'r', encoding=sys.getdefaultencoding()).read()\n                self.knownEncoding = sys.getdefaultencoding()\n            except (UnicodeError, LookupError, IOError):\n                pass\n        # last resort: use binary bytes and rely on Tk to decode\n        if text == None:\n            try:\n                text = open(file, 'rb').read()         # bytes for Unicode\n                text = text.replace(b'\\r\\n', b'\\n')    # for display, saves\n                self.knownEncoding = None\n            except IOError:\n                pass\n702 | Chapter 11:\u2002Complete GUI Programsif text == None:\n            showerror('PyEdit', 'Could not decode and open file ' + file)\n        else:\n            self.setAllText(text)\n            self.setFileName(file)\n            self.text.edit_reset()             # 2.0: clear undo/redo stks\n            self.text.edit_modified(0)         # 2.0: clear modified flag\n    def onSave(self):\n        self.onSaveAs(self.currfile)  # may be None\n    def onSaveAs(self, forcefile=None):\n        \"\"\"\n        2.1: total rewrite for Unicode support: Text content is always\n        returned as a str, so we must deal with encodings to save to\n        a file here, regardless of open mode of the output file (binary\n        requires bytes, and text must encode); tries the encoding used\n        when opened or saved (if known), user input, config file setting,\n        and platform default last; most users can use platform default;\n        retains successful encoding name here for next save, because this\n        may be the first Save after New or a manual text insertion;  Save\n        and SaveAs may both use last known encoding, per config file (it\n        probably should be used for Save, but SaveAs usage is unclear);\n        gui prompts are prefilled with the known encoding if there is one;\n        does manual text.encode() to avoid creating file; text mode files\n        perform platform specific end-line conversion: Windows \\r dropped\n        if present on open by text mode (auto) and binary mode (manually);\n        if manual content inserts, must delete \\r else duplicates here;\n        knownEncoding=None before first Open or Save, after New, if binary Open;\n        encoding behavior is configurable in the local textConfig.py:\n        1) if savesUseKnownEncoding > 0, try encoding from last open or save\n        2) if savesAskUser True, try user input next (prefill with known?)\n        3) if savesEncoding nonempty, try this encoding next: 'utf-8', etc\n        4) tries sys.getdefaultencoding() as a last resort\n        \"\"\"\n        filename = forcefile or self.my_asksaveasfilename()\n        if not filename:\n            return\n        text = self.getAllText()      # 2.1: a str string, with \\n eolns,\n        encpick = None                # even if read/inserted as bytes\n        # try known encoding at latest Open or Save, if any\n        if self.knownEncoding and (                                  # enc known?\n           (forcefile     and self.savesUseKnownEncoding >= 1) or    # on Save?\n           (not forcefile and self.savesUseKnownEncoding >= 2)):     # on SaveAs?\n            try:\n                text.encode(self.knownEncoding)\n                encpick = self.knownEncoding\n            except UnicodeError:\n                pass\nPyEdit: A Text Editor Program/Object | 703# try user input, prefill with known type, else next choice\n        if not encpick and self.savesAskUser:\n            self.update()  # else dialog doesn't appear in rare cases\n            askuser = askstring('PyEdit', 'Enter Unicode encoding for save',\n                                initialvalue=(self.knownEncoding or\n                                              self.savesEncoding or\n                                              sys.getdefaultencoding() or ''))\n            if askuser:\n                try:\n                    text.encode(askuser)\n                    encpick = askuser\n                except (UnicodeError, LookupError):    # LookupError:  bad name\n                    pass                               # UnicodeError: can't encode\n        # try config file\n        if not encpick and self.savesEncoding:\n            try:\n                text.encode(self.savesEncoding)\n                encpick = self.savesEncoding\n            except (UnicodeError, LookupError):\n                pass\n        # try platform default (utf8 on windows)\n        if not encpick:\n            try:\n                text.encode(sys.getdefaultencoding())\n                encpick = sys.getdefaultencoding()\n            except (UnicodeError, LookupError):\n                pass\n        # open in text mode for endlines + encoding\n        if not encpick:\n            showerror('PyEdit', 'Could not encode for file ' + filename)\n        else:\n            try:\n                file = open(filename, 'w', encoding=encpick)\n                file.write(text)\n                file.close()\n            except:\n                showerror('PyEdit', 'Could not write file ' + filename)\n            else:\n                self.setFileName(filename)          # may be newly created\n                self.text.edit_modified(0)          # 2.0: clear modified flag\n                self.knownEncoding = encpick        # 2.1: keep enc for next save\n                                                    # don't clear undo/redo stks!\n    def onNew(self):\n        \"\"\"\n        start editing a new file from scratch in current window;\n        see onClone to pop-up a new independent edit window instead;\n        \"\"\"\n        if self.text_edit_modified():    # 2.0\n            if not askyesno('PyEdit', 'Text has changed: discard changes?'):\n                return\n        self.setFileName(None)\n704 | Chapter 11:\u2002Complete GUI Programsself.clearAllText()\n        self.text.edit_reset()                 # 2.0: clear undo/redo stks\n        self.text.edit_modified(0)             # 2.0: clear modified flag\n        self.knownEncoding = None              # 2.1: Unicode type unknown\n    def onQuit(self):\n        \"\"\"\n        on Quit menu/toolbar select and wm border X button in toplevel windows;\n        2.1: don't exit app if others changed;  2.0: don't ask if self unchanged;\n        moved to the top-level window classes at the end since may vary per usage:\n        a Quit in GUI might quit() to exit, destroy() just one Toplevel, Tk, or\n        edit frame, or not be provided at all when run as an attached component;\n        check self for changes, and if might quit(), main windows should check\n        other windows in the process-wide list to see if they have changed too;\n        \"\"\"\n        assert False, 'onQuit must be defined in window-specific sublass'\n    def text_edit_modified(self):\n        \"\"\"\n        2.1: this now works! seems to have been a bool result type issue in tkinter;\n        2.0: self.text.edit_modified() broken in Python 2.4: do manually for now;\n        \"\"\"\n        return self.text.edit_modified()\n       #return self.tk.call((self.text._w, 'edit') + ('modified', None))\n    ############################################################################\n    # Edit menu commands\n    ############################################################################\n    def onUndo(self):                           # 2.0\n        try:                                    # tk8.4 keeps undo/redo stacks\n            self.text.edit_undo()               # exception if stacks empty\n        except TclError:                        # menu tear-offs for quick undo\n            showinfo('PyEdit', 'Nothing to undo')\n    def onRedo(self):                           # 2.0: redo an undone\n        try:\n            self.text.edit_redo()\n        except TclError:\n            showinfo('PyEdit', 'Nothing to redo')\n    def onCopy(self):                           # get text selected by mouse, etc.\n        if not self.text.tag_ranges(SEL):       # save in cross-app clipboard\n            showerror('PyEdit', 'No text selected')\n        else:\n            text = self.text.get(SEL_FIRST, SEL_LAST)\n            self.clipboard_clear()\n            self.clipboard_append(text)\n    def onDelete(self):                         # delete selected text, no save\n        if not self.text.tag_ranges(SEL):\n            showerror('PyEdit', 'No text selected')\n        else:\n            self.text.delete(SEL_FIRST, SEL_LAST)\nPyEdit: A Text Editor Program/Object | 705def onCut(self):\n        if not self.text.tag_ranges(SEL):\n            showerror('PyEdit', 'No text selected')\n        else:\n            self.onCopy()                       # save and delete selected text\n            self.onDelete()\n    def onPaste(self):\n        try:\n            text = self.selection_get(selection='CLIPBOARD')\n        except TclError:\n            showerror('PyEdit', 'Nothing to paste')\n            return\n        self.text.insert(INSERT, text)          # add at current insert cursor\n        self.text.tag_remove(SEL, '1.0', END)\n        self.text.tag_add(SEL, INSERT+'-%dc' % len(text), INSERT)\n        self.text.see(INSERT)                   # select it, so it can be cut\n    def onSelectAll(self):\n        self.text.tag_add(SEL, '1.0', END+'-1c')   # select entire text\n        self.text.mark_set(INSERT, '1.0')          # move insert point to top\n        self.text.see(INSERT)                      # scroll to top\n    ############################################################################\n    # Search menu commands\n    ############################################################################\n    def onGoto(self, forceline=None):\n        line = forceline or askinteger('PyEdit', 'Enter line number')\n        self.text.update()\n        self.text.focus()\n        if line is not None:\n            maxindex = self.text.index(END+'-1c')\n            maxline  = int(maxindex.split('.')[0])\n            if line > 0 and line <= maxline:\n                self.text.mark_set(INSERT, '%d.0' % line)      # goto line\n                self.text.tag_remove(SEL, '1.0', END)          # delete selects\n                self.text.tag_add(SEL, INSERT, 'insert + 1l')  # select line\n                self.text.see(INSERT)                          # scroll to line\n            else:\n                showerror('PyEdit', 'Bad line number')\n    def onFind(self, lastkey=None):\n        key = lastkey or askstring('PyEdit', 'Enter search string')\n        self.text.update()\n        self.text.focus()\n        self.lastfind = key\n        if key:                                                    # 2.0: nocase\n            nocase = configs.get('caseinsens', True)               # 2.0: config\n            where = self.text.search(key, INSERT, END, nocase=nocase)\n            if not where:                                          # don't wrap\n                showerror('PyEdit', 'String not found')\n            else:\n706 | Chapter 11:\u2002Complete GUI Programspastkey = where + '+%dc' % len(key)           # index past key\n                self.text.tag_remove(SEL, '1.0', END)         # remove any sel\n                self.text.tag_add(SEL, where, pastkey)        # select key\n                self.text.mark_set(INSERT, pastkey)           # for next find\n                self.text.see(where)                          # scroll display\n    def onRefind(self):\n        self.onFind(self.lastfind)\n    def onChange(self):\n        \"\"\"\n        non-modal find/change dialog\n        2.1: pass per-dialog inputs to callbacks, may be > 1 change dialog open\n        \"\"\"\n        new = Toplevel(self)\n        new.title('PyEdit - change')\n        Label(new, text='Find text?', relief=RIDGE, width=15).grid(row=0, column=0)\n        Label(new, text='Change to?', relief=RIDGE, width=15).grid(row=1, column=0)\n        entry1 = Entry(new)\n        entry2 = Entry(new)\n        entry1.grid(row=0, column=1, sticky=EW)\n        entry2.grid(row=1, column=1, sticky=EW)\n        def onFind():                         # use my entry in enclosing scope\n            self.onFind(entry1.get())         # runs normal find dialog callback\n        def onApply():\n            self.onDoChange(entry1.get(), entry2.get())\n        Button(new, text='Find',  command=onFind ).grid(row=0, column=2, sticky=EW)\n        Button(new, text='Apply', command=onApply).grid(row=1, column=2, sticky=EW)\n        new.columnconfigure(1, weight=1)      # expandable entries\n    def onDoChange(self, findtext, changeto):\n        # on Apply in change dialog: change and refind\n        if self.text.tag_ranges(SEL):                      # must find first\n            self.text.delete(SEL_FIRST, SEL_LAST)\n            self.text.insert(INSERT, changeto)             # deletes if empty\n            self.text.see(INSERT)\n            self.onFind(findtext)                          # goto next appear\n            self.text.update()                             # force refresh\n    def onGrep(self):\n        \"\"\"\n        new in version 2.1: threaded external file search;\n        search matched filenames in directory tree for string;\n        listbox clicks open matched file at line of occurrence;\n        search is threaded so the GUI remains active and is not\n        blocked, and to allow multiple greps to overlap in time;\n        could use threadtools, but avoid loop in no active grep;\n        grep Unicode policy: text files content in the searched tree\n        might be in any Unicode encoding: we don't ask about each (as\n        we do for opens), but allow the encoding used for the entire\nPyEdit: A Text Editor Program/Object | 707tree to be input, preset it to the platform filesystem or\n        text default, and skip files that fail to decode; in worst\n        cases, users may need to run grep N times if N encodings might\n        exist;  else opens may raise exceptions, and opening in binary\n        mode might fail to match encoded text against search string;\n        TBD: better to issue an error if any file fails to decode?\n        but utf-16 2-bytes/char format created in Notepad may decode\n        without error per utf-8, and search strings won't be found;\n        TBD: could allow input of multiple encoding names, split on\n        comma, try each one for every file, without open loadEncode?\n        \"\"\"\n        from PP4E.Gui.ShellGui.formrows import makeFormRow\n        # nonmodal dialog: get dirnname, filenamepatt, grepkey\n        popup = Toplevel()\n        popup.title('PyEdit - grep')\n        var1 = makeFormRow(popup, label='Directory root',   width=18, browse=False)\n        var2 = makeFormRow(popup, label='Filename pattern', width=18, browse=False)\n        var3 = makeFormRow(popup, label='Search string',    width=18, browse=False)\n        var4 = makeFormRow(popup, label='Content encoding', width=18, browse=False)\n        var1.set('.')      # current dir\n        var2.set('*.py')   # initial values\n        var4.set(sys.getdefaultencoding())    # for file content, not filenames\n        cb = lambda: self.onDoGrep(var1.get(), var2.get(), var3.get(), var4.get())\n        Button(popup, text='Go',command=cb).pack()\n    def onDoGrep(self, dirname, filenamepatt, grepkey, encoding):\n        \"\"\"\n        on Go in grep dialog: populate scrolled list with matches\n        tbd: should producer thread be daemon so it dies with app?\n        \"\"\"\n        import threading, queue\n        # make non-modal un-closeable dialog\n        mypopup = Tk()\n        mypopup.title('PyEdit - grepping')\n        status = Label(mypopup, text='Grep thread searching for: %r...' % grepkey)\n        status.pack(padx=20, pady=20)\n        mypopup.protocol('WM_DELETE_WINDOW', lambda: None)  # ignore X close\n        # start producer thread, consumer loop\n        myqueue = queue.Queue()\n        threadargs = (filenamepatt, dirname, grepkey, encoding, myqueue)\n        threading.Thread(target=self.grepThreadProducer, args=threadargs).start()\n        self.grepThreadConsumer(grepkey, encoding, myqueue, mypopup)\n    def grepThreadProducer(self, filenamepatt, dirname, grepkey, encoding, myqueue):\n        \"\"\"\n        in a non-GUI parallel thread: queue find.find results list;\n        could also queue matches as found, but need to keep window;\n        file content and file names may both fail to decode here;\n        TBD: could pass encoded bytes to find() to avoid filename\n        decoding excs in os.walk/listdir, but which encoding to use:\n708 | Chapter 11:\u2002Complete GUI Programssys.getfilesystemencoding() if not None?  see also Chapter6\n        footnote issue: 3.1 fnmatch always converts bytes per Latin-1;\n        \"\"\"\n        from PP4E.Tools.find import find\n        matches = []\n        try:\n            for filepath in find(pattern=filenamepatt, startdir=dirname):\n                try:\n                    textfile = open(filepath, encoding=encoding)\n                    for (linenum, linestr) in enumerate(textfile):\n                        if grepkey in linestr:\n                            msg = '%s@%d  [%s]' % (filepath, linenum + 1, linestr)\n                            matches.append(msg)\n                except UnicodeError as X:\n                    print('Unicode error in:', filepath, X)       # eg: decode, bom\n                except IOError as X:\n                    print('IO error in:', filepath, X)            # eg: permission\n        finally:\n            myqueue.put(matches)      # stop consumer loop on find excs: filenames?\n    def grepThreadConsumer(self, grepkey, encoding, myqueue, mypopup):\n        \"\"\"\n        in the main GUI thread: watch queue for results or [];\n        there may be multiple active grep threads/loops/queues;\n        there may be other types of threads/checkers in process,\n        especially when PyEdit is attached component (PyMailGUI);\n        \"\"\"\n        import queue\n        try:\n            matches = myqueue.get(block=False)\n        except queue.Empty:\n            myargs  = (grepkey, encoding, myqueue, mypopup)\n            self.after(250, self.grepThreadConsumer, *myargs)\n        else:\n            mypopup.destroy()     # close status\n            self.update()         # erase it now\n            if not matches:\n                showinfo('PyEdit', 'Grep found no matches for: %r' % grepkey)\n            else:\n                self.grepMatchesList(matches, grepkey, encoding)\n    def grepMatchesList(self, matches, grepkey, encoding):\n        \"\"\"\n        populate list after successful matches;\n        we already know Unicode encoding from the search: use\n        it here when filename clicked, so open doesn't ask user;\n        \"\"\"\n        from PP4E.Gui.Tour.scrolledlist import ScrolledList\n        print('Matches for %s: %s' % (grepkey, len(matches)))\n        # catch list double-click\n        class ScrolledFilenames(ScrolledList):\n            def runCommand(self, selection):\n                file, line = selection.split('  [', 1)[0].split('@')\n                editor = TextEditorMainPopup(\nPyEdit: A Text Editor Program/Object | 709loadFirst=file, winTitle=' grep match', loadEncode=encoding)\n                editor.onGoto(int(line))\n                editor.text.focus_force()   # no, really\n        # new non-modal widnow\n        popup = Tk()\n        popup.title('PyEdit - grep matches: %r (%s)' % (grepkey, encoding))\n        ScrolledFilenames(parent=popup, options=matches)\n    ############################################################################\n    # Tools menu commands\n    ############################################################################\n    def onFontList(self):\n        self.fonts.append(self.fonts[0])           # pick next font in list\n        del self.fonts[0]                          # resizes the text area\n        self.text.config(font=self.fonts[0])\n    def onColorList(self):\n        self.colors.append(self.colors[0])         # pick next color in list\n        del self.colors[0]                         # move current to end\n        self.text.config(fg=self.colors[0]['fg'], bg=self.colors[0]['bg'])\n    def onPickFg(self):\n        self.pickColor('fg')                       # added on 10/02/00\n    def onPickBg(self):                            # select arbitrary color\n        self.pickColor('bg')                       # in standard color dialog\n    def pickColor(self, part):                     # this is too easy\n        (triple, hexstr) = askcolor()\n        if hexstr:\n            self.text.config(**{part: hexstr})\n    def onInfo(self):\n        \"\"\"\n        pop-up dialog giving text statistics and cursor location;\n        caveat (2.1): Tk insert position column counts a tab as one\n        character: translate to next multiple of 8 to match visual?\n        \"\"\"\n        text  = self.getAllText()                  # added on 5/3/00 in 15 mins\n        bytes = len(text)                          # words uses a simple guess:\n        lines = len(text.split('\\n'))              # any separated by whitespace\n        words = len(text.split())                  # 3.x: bytes is really chars\n        index = self.text.index(INSERT)            # str is unicode code points\n        where = tuple(index.split('.'))\n        showinfo('PyEdit Information',\n                 'Current location:\\n\\n' +\n                 'line:\\t%s\\ncolumn:\\t%s\\n\\n' % where +\n                 'File text statistics:\\n\\n' +\n                 'chars:\\t%d\\nlines:\\t%d\\nwords:\\t%d\\n' % (bytes, lines, words))\n    def onClone(self, makewindow=True):\n        \"\"\"\n710 | Chapter 11:\u2002Complete GUI Programsopen a new edit window without changing one already open (onNew);\n        inherits quit and other behavior of the window that it clones;\n        2.1: subclass must redefine/replace this if makes its own popup,\n        else this creates a bogus extra window here which will be empty;\n        \"\"\"\n        if not makewindow:\n             new = None                 # assume class makes its own window\n        else:\n             new = Toplevel()           # a new edit window in same process\n        myclass = self.__class__        # instance's (lowest) class object\n        myclass(new)                    # attach/run instance of my class\n    def onRunCode(self, parallelmode=True):\n        \"\"\"\n        run Python code being edited--not an IDE, but handy;\n        tries to run in file's dir, not cwd (may be PP4E root);\n        inputs and adds command-line arguments for script files;\n        code's stdin/out/err = editor's start window, if any:\n        run with a console window to see code's print outputs;\n        but parallelmode uses start to open a DOS box for I/O;\n        module search path will include '.' dir where started;\n        in non-file mode, code's Tk root may be PyEdit's window;\n        subprocess or multiprocessing modules may work here too;\n        2.1: fixed to use base file name after chdir, not path;\n        2.1: use StartArgs to allow args in file mode on Windows;\n        2.1: run an update() after 1st dialog else 2nd dialog\n        sometimes does not appear in rare cases;\n        \"\"\"\n        def askcmdargs():\n            return askstring('PyEdit', 'Commandline arguments?') or ''\n        from PP4E.launchmodes import System, Start, StartArgs, Fork\n        filemode = False\n        thefile  = str(self.getFileName())\n        if os.path.exists(thefile):\n            filemode = askyesno('PyEdit', 'Run from file?')\n            self.update()                                   # 2.1: run update()\n        if not filemode:                                    # run text string\n            cmdargs   = askcmdargs()\n            namespace = {'__name__': '__main__'}            # run as top-level\n            sys.argv  = [thefile] + cmdargs.split()         # could use threads\n            exec(self.getAllText() + '\\n', namespace)       # exceptions ignored\n        elif self.text_edit_modified():                     # 2.0: changed test\n            showerror('PyEdit', 'Text changed: you must save before run')\n        else:\n            cmdargs = askcmdargs()\n            mycwd   = os.getcwd()                           # cwd may be root\n            dirname, filename = os.path.split(thefile)      # get dir, base\n            os.chdir(dirname or mycwd)                      # cd for filenames\n            thecmd  = filename + ' ' + cmdargs              # 2.1: not theFile\n            if not parallelmode:                            # run as file\n                System(thecmd, thecmd)()                    # block editor\n            else:\nPyEdit: A Text Editor Program/Object | 711if sys.platform[:3] == 'win':               # spawn in parallel\n                    run = StartArgs if cmdargs else Start   # 2.1: support args\n                    run(thecmd, thecmd)()                   # or always Spawn\n                else:\n                    Fork(thecmd, thecmd)()                  # spawn in parallel\n            os.chdir(mycwd)                                 # go back to my dir\n    def onPickFont(self):\n        \"\"\"\n        2.0 non-modal font spec dialog\n        2.1: pass per-dialog inputs to callback, may be > 1 font dialog open\n        \"\"\"\n        from PP4E.Gui.ShellGui.formrows import makeFormRow\n        popup = Toplevel(self)\n        popup.title('PyEdit - font')\n        var1 = makeFormRow(popup, label='Family', browse=False)\n        var2 = makeFormRow(popup, label='Size',   browse=False)\n        var3 = makeFormRow(popup, label='Style',  browse=False)\n        var1.set('courier')\n        var2.set('12')              # suggested vals\n        var3.set('bold italic')     # see pick list for valid inputs\n        Button(popup, text='Apply', command=\n               lambda: self.onDoFont(var1.get(), var2.get(), var3.get())).pack()\n    def onDoFont(self, family, size, style):\n        try:\n            self.text.config(font=(family, int(size), style))\n        except:\n            showerror('PyEdit', 'Bad font specification')\n    ############################################################################\n    # Utilities, useful outside this class\n    ############################################################################\n    def isEmpty(self):\n        return not self.getAllText()\n    def getAllText(self):\n        return self.text.get('1.0', END+'-1c')    # extract text as str string\n    def setAllText(self, text):\n        \"\"\"\n        caller: call self.update() first if just packed, else the\n        initial position may be at line 2, not line 1 (2.1; Tk bug?)\n        \"\"\"\n        self.text.delete('1.0', END)              # store text string in widget\n        self.text.insert(END, text)               # or '1.0'; text=bytes or str\n        self.text.mark_set(INSERT, '1.0')         # move insert point to top\n        self.text.see(INSERT)                     # scroll to top, insert set\n    def clearAllText(self):\n        self.text.delete('1.0', END)              # clear text in widget\n    def getFileName(self):\n        return self.currfile\n    def setFileName(self, name):                  # see also: onGoto(linenum)\n712 | Chapter 11:\u2002Complete GUI Programsself.currfile = name  # for save\n        self.filelabel.config(text=str(name))\n    def setKnownEncoding(self, encoding='utf-8'): # 2.1: for saves if inserted\n        self.knownEncoding = encoding             # else saves use config, ask?\n    def setBg(self, color):\n        self.text.config(bg=color)                # to set manually from code\n    def setFg(self, color):\n        self.text.config(fg=color)                # 'black', hexstring\n    def setFont(self, font):\n        self.text.config(font=font)               # ('family', size, 'style')\n    def setHeight(self, lines):                   # default = 24h x 80w\n        self.text.config(height=lines)            # may also be from textCongif.py\n    def setWidth(self, chars):\n        self.text.config(width=chars)\n    def clearModified(self):\n        self.text.edit_modified(0)                # clear modified flag\n    def isModified(self):\n        return self.text_edit_modified()          # changed since last reset?\n    def help(self):\n        showinfo('About PyEdit', helptext % ((Version,)*2))\n################################################################################\n# Ready-to-use editor classes\n# mixes in a GuiMaker Frame subclass which builds menu and toolbars\n#\n# these classes are common use cases, but other configurations are possible;\n# call TextEditorMain().mainloop() to start PyEdit as a standalone program;\n# redefine/extend onQuit in a subclass to catch exit or destroy (see PyView);\n# caveat: could use windows.py for icons, but quit protocol is custom here.\n################################################################################\n#-------------------------------------------------------------------------------\n# 2.1: on quit(), don't silently exit entire app if any other changed edit\n# windows are open in the process - changes would be lost because all other\n# windows are closed too, including multiple Tk editor parents;  uses a list\n# to keep track of all PyEdit window instances open in process; this may be\n# too broad (if we destroy() instead of quit(), need only check children\n# of parent being destroyed), but better to err on side of being too inclusive;\n# onQuit moved here because varies per window type and is not present for all;\n#\n# assumes a TextEditorMainPopup is never a parent to other editor windows -\n# Toplevel children are destroyed with their parents;  this does not address\n# closes outside the scope of PyEdit classes here (tkinter quit is available\n# on every widget, and any widget type may be a Toplevel parent!);  client is\n# responsible for checking for editor content changes in all uncovered cases;\n# note that tkinter's <Destroy> bind event won't help here, because its callback\n# cannot run GUI operations such as text change tests and fetches - see the\n# book and destroyer.py for more details on this event;\n#-------------------------------------------------------------------------------\nPyEdit: A Text Editor Program/Object | 713###################################\n# when text editor owns the window\n###################################\nclass TextEditorMain(TextEditor, GuiMakerWindowMenu):\n    \"\"\"\n    main PyEdit windows that quit() to exit app on a Quit in GUI, and build\n    a menu on a window;  parent may be default Tk, explicit Tk, or Toplevel:\n    parent must be a window, and probably should be a Tk so this isn't silently\n    destroyed and closed with a parent;  all main PyEdit windows check all other\n    PyEdit windows open in the process for changes on a Quit in the GUI, since\n    a quit() here will exit the entire app;  the editor's frame need not occupy\n    entire window (may have other parts: see PyView), but its Quit ends program;\n    onQuit is run for Quit in toolbar or File menu, as well as window border X;\n    \"\"\"\n    def __init__(self, parent=None, loadFirst='', loadEncode=''):\n        # editor fills whole parent window\n        GuiMaker.__init__(self, parent)                  # use main window menus\n        TextEditor.__init__(self, loadFirst, loadEncode) # GuiMaker frame packs self\n        self.master.title('PyEdit ' + Version)           # title, wm X if standalone\n        self.master.iconname('PyEdit')\n        self.master.protocol('WM_DELETE_WINDOW', self.onQuit)\n        TextEditor.editwindows.append(self)\n    def onQuit(self):                              # on a Quit request in the GUI\n        close = not self.text_edit_modified()      # check self, ask?, check others\n        if not close:\n            close = askyesno('PyEdit', 'Text changed: quit and discard changes?')\n        if close:\n            windows = TextEditor.editwindows\n            changed = [w for w in windows if w != self and w.text_edit_modified()]\n            if not changed:\n                GuiMaker.quit(self) # quit ends entire app regardless of widget type\n            else:\n                numchange = len(changed)\n                verify = '%s other edit window%s changed: quit and discard anyhow?'\n                verify = verify % (numchange, 's' if numchange > 1 else '')\n                if askyesno('PyEdit', verify):\n                    GuiMaker.quit(self)\nclass TextEditorMainPopup(TextEditor, GuiMakerWindowMenu):\n    \"\"\"\n    popup PyEdit windows that destroy() to close only self on a Quit in GUI,\n    and build a menu on a window;  makes own Toplevel parent, which is child\n    to default Tk (for None) or other passed-in window or widget (e.g., a frame);\n    adds to list so will be checked for changes if any PyEdit main window quits;\n    if any PyEdit main windows will be created, parent of this should also be a\n    PyEdit main window's parent so this is not closed silently while being tracked;\n    onQuit is run for Quit in toolbar or File menu, as well as window border X;\n    \"\"\"\n    def __init__(self, parent=None, loadFirst='', winTitle='', loadEncode=''):\n        # create own window\n        self.popup = Toplevel(parent)\n714 | Chapter 11:\u2002Complete GUI ProgramsGuiMaker.__init__(self, self.popup)               # use main window menus\n        TextEditor.__init__(self, loadFirst, loadEncode)  # a frame in a new popup\n        assert self.master == self.popup\n        self.popup.title('PyEdit ' + Version + winTitle)\n        self.popup.iconname('PyEdit')\n        self.popup.protocol('WM_DELETE_WINDOW', self.onQuit)\n        TextEditor.editwindows.append(self)\n    def onQuit(self):\n        close = not self.text_edit_modified()\n        if not close:\n            close = askyesno('PyEdit', 'Text changed: quit and discard changes?')\n        if close:\n            self.popup.destroy()                       # kill this window only\n            TextEditor.editwindows.remove(self)        # (plus any child windows)\n    def onClone(self):\n        TextEditor.onClone(self, makewindow=False)     # I make my own pop-up\n#########################################\n# when editor embedded in another window\n#########################################\nclass TextEditorComponent(TextEditor, GuiMakerFrameMenu):\n    \"\"\"\n    attached PyEdit component frames with full menu/toolbar options,\n    which run a destroy() on a Quit in the GUI to erase self only;\n    a Quit in the GUI verifies if any changes in self (only) here;\n    does not intercept window manager border X: doesn't own window;\n    does not add self to changes tracking list: part of larger app;\n    \"\"\"\n    def __init__(self, parent=None, loadFirst='', loadEncode=''):\n        # use Frame-based menus\n        GuiMaker.__init__(self, parent)                   # all menus, buttons on\n        TextEditor.__init__(self, loadFirst, loadEncode)  # GuiMaker must init 1st\n    def onQuit(self):\n        close = not self.text_edit_modified()\n        if not close:\n            close = askyesno('PyEdit', 'Text changed: quit and discard changes?')\n        if close:\n            self.destroy()   # erase self Frame but do not quit enclosing app\nclass TextEditorComponentMinimal(TextEditor, GuiMakerFrameMenu):\n    \"\"\"\n    attached PyEdit component frames without Quit and File menu options;\n    on startup, removes Quit from toolbar, and either deletes File menu\n    or disables all its items (possibly hackish, but sufficient); menu and\n    toolbar structures are per-instance data: changes do not impact others;\n    Quit in GUI never occurs, because it is removed from available options;\n    \"\"\"\n    def __init__(self, parent=None, loadFirst='', deleteFile=True, loadEncode=''):\n        self.deleteFile = deleteFile\n        GuiMaker.__init__(self, parent)                  # GuiMaker frame packs self\nPyEdit: A Text Editor Program/Object | 715TextEditor.__init__(self, loadFirst, loadEncode) # TextEditor adds middle\n    def start(self):\n        TextEditor.start(self)                         # GuiMaker start call\n        for i in range(len(self.toolBar)):             # delete quit in toolbar\n            if self.toolBar[i][0] == 'Quit':           # delete file menu items,\n                del self.toolBar[i]                    # or just disable file\n                break\n        if self.deleteFile:\n            for i in range(len(self.menuBar)):\n                if self.menuBar[i][0] == 'File':\n                    del self.menuBar[i]\n                    break\n        else:\n            for (name, key, items) in self.menuBar:\n                if name == 'File':\n                    items.append([1,2,3,4,6])\n################################################################################\n# standalone program run\n################################################################################\ndef testPopup():\n    # see PyView and PyMail for component tests\n    root = Tk()\n    TextEditorMainPopup(root)\n    TextEditorMainPopup(root)\n    Button(root, text='More', command=TextEditorMainPopup).pack(fill=X)\n    Button(root, text='Quit', command=root.quit).pack(fill=X)\n    root.mainloop()\ndef main():                                           # may be typed or clicked\n    try:                                              # or associated on Windows\n        fname = sys.argv[1]                           # arg = optional filename\n    except IndexError:                                # build in default Tk root\n        fname = None\n    TextEditorMain(loadFirst=fname).pack(expand=YES, fill=BOTH)   # pack optional\n    mainloop()\nif __name__ == '__main__':                            # when run as a script\n    #testPopup()\n    main()                                            # run .pyw for no DOS box\nPyPhoto: An Image Viewer and Resizer\nIn Chapter 9, we wrote a simple thumbnail image viewer that scrolled its thumbnails\nin a canvas. That program in turn built on techniques and code we developed at the\nend of Chapter 8 to handle images. In both places, I promised that we\u2019d eventually\nmeet a more full-featured extension of the ideas we deployed.\nIn this section, we finally wrap up the thumbnail images thread by studying PyPhoto\u2014\nan enhanced image viewing and resizing program. PyPhoto\u2019s basic operation is\n716 | Chapter 11:\u2002Complete GUI Programsstraightforward: given a directory of image files, PyPhoto displays their thumbnails in\na scrollable canvas. When a thumbnail is selected, the corresponding image is displayed\nfull size in a pop-up window.\nUnlike our prior viewers, though, PyPhoto is clever enough to scroll (rather than crop)\nimages too large for the physical display. Moreover, PyPhoto introduces the notion of\nimage resizing\u2014it supports mouse and keyboard events that resize the image to one of\nthe display\u2019s dimensions and zoom the image in and out. Once images are opened, the\nresizing logic allows images to be grown or shrunk arbitrarily, which is especially handy\nfor images produced by a digital camera that may be too large to view all at once.\nAs added touches, PyPhoto also allows the image to be saved in a file (possibly after\nbeing resized), and it allows image directories to be selected and opened in the GUI\nitself, instead of just as command-line arguments.\nPut together, PyPhoto\u2019s features make it an image-processing program, albeit one with\na currently small set of processing tools. I encourage you to experiment with adding\nnew features of your own; once you get the hang of the Python Imaging Library (PIL)\nAPI, the object-oriented nature of PyPhoto makes adding new tools remarkably simple.\nRunning PyPhoto\nIn order to run PyPhoto, you\u2019ll need to fetch and install the PIL extension package\ndescribed in Chapter 8. PyPhoto inherits much of its functionality from PIL\u2014PIL is\nused to support extra image types beyond those handled by standard tkinter (e.g., JPEG\nimages) and to perform image-processing operations such as resizes, thumbnail crea-\ntion, and saves. PIL is open source like Python, but it is not presently part of the Python\nstandard library. Search the Web for PIL\u2019s location (http://www.pythonware.com is\ncurrently a safe bet). Also check the Extensions directory of the examples distribution\npackage for a PIL self-installer.\nThe best way to get a feel for PyPhoto is to run it live on your own machine to see how\nimages are scrolled and resized. Here, we\u2019ll present a few screenshots to give the general\nflavor of the interaction. You can start PyPhoto by clicking its icon, or you can start it\nfrom the command line. When run directly, it opens the images subdirectory in its\nsource directory, which contains a handful of photos. When you run it from the com-\nmand line, you can pass in an initial image directory name as a command-line argument.\nFigure 11-7 captures the main thumbnail window when run directly.\nInternally, PyPhoto is loading or creating thumbnail images before this window ap-\npears, using tools coded in Chapter 8. Startup may take a few seconds the first time\nyou open a directory, but it is quick thereafter\u2014PyPhoto caches thumbnails in a local\nsubdirectory so that it can skip the generation step the next time the directory is opened.\nTechnically, there are three different ways PyPhoto may start up: viewing an explicit\ndirectory listed on the command line; viewing the default images directory when no\ncommand-line argument is given and when images is present where the program is run;\nPyPhoto: An Image Viewer and Resizer | 717or displaying a simple one-button window that allows you to select directories to open\non demand, when no initial directory is given or present (see the code\u2019s __main__ logic).\nPyPhoto also lets you open additional folders in new thumbnail windows, by pressing\nthe D key on your keyboard in either a thumbnail or an image window. Figure 11-8,\nfor instance, captures the pop-up window produced in Windows 7 to select a new image\nfolder, and Figure 11-9 shows the result when I select a directory copied from one of\nmy digital camera cards\u2014this is a second PyPhoto thumbnail window on the display.\nFigure 11-8 is also opened by the one-button window if no initial directory is available.\nWhen a thumbnail is selected, the image is displayed in a canvas, in a new pop-up\nwindow. If it\u2019s too large for the display, you can scroll through its full size with the\nwindow\u2019s scroll bars. Figure 11-10 captures one image after its thumbnail is clicked,\nand Figure 11-11 shows the Save As dialog issued when the S key is pressed in the image\nwindow; be sure to type the desired filename extension (e.g., .jpg) in this Save As dialog,\nbecause PIL uses it to know how to save the image to the file. In general, any number\nof PyPhoto thumbnail and image windows can be open at once, and each image can\nbe saved independently.\nBeyond the screenshots already shown, this system\u2019s interaction is difficult to capture\nin a static medium such as this book\u2014you\u2019re better off test-driving the program live.\nFigure 11-7. PyPhoto main window, default directory\n718 | Chapter 11:\u2002Complete GUI ProgramsFor example, clicking the left and right mouse buttons will resize the image to the\ndisplay\u2019s height and width dimensions, respectively, and pressing the I and O keys will\nzoom the image in and out in 10 percent increments. Both resizing schemes allow you\nto shrink an image too large to see all at once, as well as expand small photos. They\nalso preserve the original aspect ratio of the photo, by changing its height and width\nproportionally, while blindly resizing to the display\u2019s dimensions would not (height or\nwidth may be stretched).\nOnce resized, images may be saved in files at their current size. PyPhoto is also smart\nenough to make windows full size on Windows, if an image is larger than the display.\nPyPhoto Source Code\nBecause PyPhoto simply extends and reuses techniques and code we met earlier in the\nbook, we\u2019ll omit a detailed discussion of its code here. For background, see the dis-\ncussion of image processing and PIL in Chapter 8 and the coverage of the canvas widget\nin Chapter 9.\nIn short, PyPhoto uses canvases in two ways: for thumbnail collections and for opened\nimages. For thumbnails, the same sort of canvas layout code as the earlier thumbnails\nviewer in Example 9-15 is employed. For images, a canvas is used as well, but the\nFigure 11-8. PyPhoto open directory dialog (the D key)\nPyPhoto: An Image Viewer and Resizer | 719canvas\u2019s scrollable (full) size is the image size, and the viewable area size is the minimum\nof the physical screen size or the size of the image itself. The physical screen size is\navailable from the maxsize() method of Toplevel windows. The net effect is that selec-\nted images may be scrolled now, too, which comes in handy if they are too big for your\ndisplay (a common case for pictures snapped with newer digital cameras).\nIn addition, PyPhoto binds keyboard and mouse events to implement resizing and zoom\noperations. With PIL, this is simple\u2014we save the original PIL image, run its resize\nmethod with the new image size, and redraw the image in the canvas. PyPhoto also\nmakes use of file open and save dialog objects, to remember the last directory visited.\nPIL supports additional operations, which we could add as new events, but resizing is\nsufficient for a viewer. PyPhoto does not currently use threads, to avoid becoming\nblocked for long-running tasks (opening a large directory the first time, for instance).\nSuch enhancements are left as suggested exercises.\nFigure 11-9. PyPhoto thumbnail window, other directory\n720 | Chapter 11:\u2002Complete GUI ProgramsPyPhoto is implemented as the single file of Example 11-5, though it gets some utility\nfor free by reusing the thumbnail generation function of the viewer_thumbs module that\nwe originally wrote near the end of Chapter 8 in Example 8-45. To spare you from\nhaving to flip back and forth too much, here\u2019s a copy of the code of the thumbs function\nimported and used here:\n# imported from Chapter 8...\ndef makeThumbs(imgdir, size=(100, 100), subdir='thumbs'):\n    # returns a list of (image filename, thumb image object);\n    thumbdir = os.path.join(imgdir, subdir)\n    if not os.path.exists(thumbdir):\n        os.mkdir(thumbdir)\n    thumbs = []\n    for imgfile in os.listdir(imgdir):\n        thumbpath = os.path.join(thumbdir, imgfile)\n        if os.path.exists(thumbpath):\n            thumbobj = Image.open(thumbpath)            # use already created\n            thumbs.append((imgfile, thumbobj))\n        else:\n            print('making', thumbpath)\n            imgpath = os.path.join(imgdir, imgfile)\n            try:\nFigure 11-10. PyPhoto image view window\nPyPhoto: An Image Viewer and Resizer | 721imgobj = Image.open(imgpath)            # make new thumb\n                imgobj.thumbnail(size, Image.ANTIALIAS) # best downsize filter\n                imgobj.save(thumbpath)                  # type via ext or passed\n                thumbs.append((imgfile, imgobj))\n            except:                                     # not always IOError\n                print(\"Skipping: \", imgpath)\n    return thumbs\nSome of this example\u2019s thumbnail selection window code is also very similar to our\nearlier limited scrolled-thumbnails example in Chapter 9, but it is repeated in this file\ninstead of imported, to allow for future evolution (Chapter 9\u2019s functional subset is now\nofficially demoted to prototype).\nAs you study this file, pay particular attention to the way it factors code into reused\nfunctions and methods, to avoid redundancy; if we ever need to change the way zoom-\ning works, for example, we have just one method to change, not two. Also notice its\nScrolledCanvas class\u2014a reusable component that handles the work of linking scroll\nbars and canvases.\nFigure 11-11. PyPhoto Save As dialog (the S key; include an extension)\n722 | Chapter 11:\u2002Complete GUI ProgramsExample 11-5. PP4E\\Gui\\PIL\\pyphoto1.py\n\"\"\"\n############################################################################\nPyPhoto 1.1: thumbnail image viewer with resizing and saves.\nSupports multiple image directory thumb windows - the initial img dir\nis passed in as cmd arg, uses \"images\" default, or is selected via main\nwindow button; later directories are opened by pressing \"D\" in image view\nor thumbnail windows.\nViewer also scrolls popped-up images that are too large for the screen;\nstill to do: (1) rearrange thumbnails when window resized, based on current\nwindow size; (2) [DONE] option to resize images to fit current window size?\n(3) avoid scrolls if image size is less than window max size: use Label\nif imgwide <= scrwide and imghigh <= scrhigh?\nNew in 1.1: updated to run in Python 3.1 and latest PIL;\nNew in 1.0: now does a form of (2) above: image is resized to one of the\ndisplay's dimensions if clicked, and zoomed in or out in 10% increments\non key presses; generalize me;  caveat: seems to lose quality, pixels\nafter many resizes (this is probably a limitation of PIL)\nThe following scaler adapted from PIL's thumbnail code is similar to the\nscreen height scaler here, but only shrinks:\nx, y = imgwide, imghigh\nif x > scrwide: y = max(y * scrwide // x, 1); x = scrwide\nif y > scrhigh: x = max(x * scrhigh // y, 1); y = scrhigh\n############################################################################\n\"\"\"\nimport sys, math, os\nfrom tkinter import *\nfrom tkinter.filedialog import SaveAs, Directory\nfrom PIL import Image                         # PIL Image: also in tkinter\nfrom PIL.ImageTk import PhotoImage            # PIL photo widget replacement\nfrom viewer_thumbs import makeThumbs          # developed earlier in book\n# remember last dirs across all windows\nsaveDialog = SaveAs(title='Save As (filename gives image type)')\nopenDialog = Directory(title='Select Image Directory To Open')\ntrace = print  # or lambda *x: None\nappname = 'PyPhoto 1.1: '\nclass ScrolledCanvas(Canvas):\n    \"\"\"\n    a canvas in a container that automatically makes\n    vertical and horizontal scroll bars for itself\n    \"\"\"\n    def __init__(self, container):\n        Canvas.__init__(self, container)\n        self.config(borderwidth=0)\nPyPhoto: An Image Viewer and Resizer | 723vbar = Scrollbar(container)\n        hbar = Scrollbar(container, orient='horizontal')\n        vbar.pack(side=RIGHT,  fill=Y)                 # pack canvas after bars\n        hbar.pack(side=BOTTOM, fill=X)                 # so clipped first\n        self.pack(side=TOP, fill=BOTH, expand=YES)\n        vbar.config(command=self.yview)                # call on scroll move\n        hbar.config(command=self.xview)\n        self.config(yscrollcommand=vbar.set)           # call on canvas move\n        self.config(xscrollcommand=hbar.set)\nclass ViewOne(Toplevel):\n    \"\"\"\n    open a single image in a pop-up window when created;\n    a class because photoimage obj must be saved, else\n    erased if reclaimed; scroll if too big for display;\n    on mouse clicks, resizes to window's height or width:\n    stretches or shrinks; on I/O keypress, zooms in/out;\n    both resizing schemes maintain original aspect ratio;\n    code is factored to avoid redundancy here as possible;\n    \"\"\"\n    def __init__(self, imgdir, imgfile, forcesize=()):\n        Toplevel.__init__(self)\n        helptxt = '(click L/R or press I/O to resize, S to save, D to open)'\n        self.title(appname + imgfile + '  ' + helptxt)\n        imgpath = os.path.join(imgdir, imgfile)\n        imgpil  = Image.open(imgpath)\n        self.canvas = ScrolledCanvas(self)\n        self.drawImage(imgpil, forcesize)\n        self.canvas.bind('<Button-1>', self.onSizeToDisplayHeight)\n        self.canvas.bind('<Button-3>', self.onSizeToDisplayWidth)\n        self.bind('<KeyPress-i>',      self.onZoomIn)\n        self.bind('<KeyPress-o>',      self.onZoomOut)\n        self.bind('<KeyPress-s>',      self.onSaveImage)\n        self.bind('<KeyPress-d>',      onDirectoryOpen)\n        self.focus()\n    def drawImage(self, imgpil, forcesize=()):\n        imgtk = PhotoImage(image=imgpil)                 # not file=imgpath\n        scrwide, scrhigh = forcesize or self.maxsize()   # wm screen size x,y\n        imgwide  = imgtk.width()                         # size in pixels\n        imghigh  = imgtk.height()                        # same as imgpil.size\n        fullsize = (0, 0, imgwide, imghigh)              # scrollable\n        viewwide = min(imgwide, scrwide)                 # viewable\n        viewhigh = min(imghigh, scrhigh)\n        canvas = self.canvas\n        canvas.delete('all')                             # clear prior photo\n        canvas.config(height=viewhigh, width=viewwide)   # viewable window size\n        canvas.config(scrollregion=fullsize)             # scrollable area size\n        canvas.create_image(0, 0, image=imgtk, anchor=NW)\n724 | Chapter 11:\u2002Complete GUI Programsif imgwide <= scrwide and imghigh <= scrhigh:    # too big for display?\n            self.state('normal')                         # no: win size per img\n        elif sys.platform[:3] == 'win':                  # do windows fullscreen\n            self.state('zoomed')                         # others use geometry()\n        self.saveimage = imgpil\n        self.savephoto = imgtk                           # keep reference on me\n        trace((scrwide, scrhigh), imgpil.size)\n    def sizeToDisplaySide(self, scaler):\n        # resize to fill one side of the display\n        imgpil = self.saveimage\n        scrwide, scrhigh = self.maxsize()                 # wm screen size x,y\n        imgwide, imghigh = imgpil.size                    # img size in pixels\n        newwide, newhigh = scaler(scrwide, scrhigh, imgwide, imghigh)\n        if (newwide * newhigh < imgwide * imghigh):\n            filter = Image.ANTIALIAS                      # shrink: antialias\n        else:                                             # grow: bicub sharper\n            filter = Image.BICUBIC\n        imgnew  = imgpil.resize((newwide, newhigh), filter)\n        self.drawImage(imgnew)\n    def onSizeToDisplayHeight(self, event):\n        def scaleHigh(scrwide, scrhigh, imgwide, imghigh):\n            newhigh = scrhigh\n            newwide = int(scrhigh * (imgwide / imghigh))        # 3.x true div\n            return (newwide, newhigh)                           # proportional\n        self.sizeToDisplaySide(scaleHigh)\n    def onSizeToDisplayWidth(self, event):\n        def scaleWide(scrwide, scrhigh, imgwide, imghigh):\n            newwide = scrwide\n            newhigh = int(scrwide * (imghigh / imgwide))        # 3.x true div\n            return (newwide, newhigh)\n        self.sizeToDisplaySide(scaleWide)\n    def zoom(self, factor):\n        # zoom in or out in increments\n        imgpil = self.saveimage\n        wide, high = imgpil.size\n        if factor < 1.0:                     # antialias best if shrink\n            filter = Image.ANTIALIAS         # also nearest, bilinear\n        else:\n            filter = Image.BICUBIC\n        new = imgpil.resize((int(wide * factor), int(high * factor)), filter)\n        self.drawImage(new)\n    def onZoomIn(self, event, incr=.10):\n        self.zoom(1.0 + incr)\n    def onZoomOut(self, event, decr=.10):\n        self.zoom(1.0 - decr)\n    def onSaveImage(self, event):\n        # save current image state to file\n        filename = saveDialog.show()\nPyPhoto: An Image Viewer and Resizer | 725if filename:\n           self.saveimage.save(filename)\ndef onDirectoryOpen(event):\n    \"\"\"\n    open a new image directory in new pop up\n    available in both thumb and img windows\n    \"\"\"\n    dirname = openDialog.show()\n    if dirname:\n        viewThumbs(dirname, kind=Toplevel)\ndef viewThumbs(imgdir, kind=Toplevel, numcols=None, height=400, width=500):\n    \"\"\"\n    make main or pop-up thumbnail buttons window;\n    uses fixed-size buttons, scrollable canvas;\n    sets scrollable (full) size, and places\n    thumbs at abs x,y coordinates in canvas;\n    no longer assumes all thumbs are same size:\n    gets max of all (x,y), some may be smaller;\n    \"\"\"\n    win = kind()\n    helptxt = '(press D to open other)'\n    win.title(appname + imgdir + '  ' + helptxt)\n    quit = Button(win, text='Quit', command=win.quit, bg='beige')\n    quit.pack(side=BOTTOM, fill=X)\n    canvas = ScrolledCanvas(win)\n    canvas.config(height=height, width=width)       # init viewable window size\n                                                    # changes if user resizes\n    thumbs = makeThumbs(imgdir)                     # [(imgfile, imgobj)]\n    numthumbs = len(thumbs)\n    if not numcols:\n        numcols = int(math.ceil(math.sqrt(numthumbs)))  # fixed or N x N\n    numrows = int(math.ceil(numthumbs / numcols))       # 3.x true div\n    # max w|h: thumb=(name, obj), thumb.size=(width, height)\n    linksize = max(max(thumb[1].size) for thumb in thumbs)\n    trace(linksize)\n    fullsize = (0, 0,                                   # upper left  X,Y\n        (linksize * numcols), (linksize * numrows) )    # lower right X,Y\n    canvas.config(scrollregion=fullsize)                # scrollable area size\n    rowpos = 0\n    savephotos = []\n    while thumbs:\n        thumbsrow, thumbs = thumbs[:numcols], thumbs[numcols:]\n        colpos = 0\n        for (imgfile, imgobj) in thumbsrow:\n            photo   = PhotoImage(imgobj)\n            link    = Button(canvas, image=photo)\n            def handler(savefile=imgfile):\n                ViewOne(imgdir, savefile)\n            link.config(command=handler, width=linksize, height=linksize)\n726 | Chapter 11:\u2002Complete GUI Programslink.pack(side=LEFT, expand=YES)\n            canvas.create_window(colpos, rowpos, anchor=NW,\n                    window=link, width=linksize, height=linksize)\n            colpos += linksize\n            savephotos.append(photo)\n        rowpos += linksize\n    win.bind('<KeyPress-d>', onDirectoryOpen)\n    win.savephotos = savephotos\n    return win\nif __name__ == '__main__':\n    \"\"\"\n    open dir = default or cmdline arg\n    else show simple window to select\n    \"\"\"\n    imgdir = 'images'\n    if len(sys.argv) > 1: imgdir = sys.argv[1]\n    if os.path.exists(imgdir):\n        mainwin = viewThumbs(imgdir, kind=Tk)\n    else:\n        mainwin = Tk()\n        mainwin.title(appname + 'Open')\n        handler = lambda: onDirectoryOpen(None)\n        Button(mainwin, text='Open Image Directory', command=handler).pack()\n    mainwin.mainloop()\nPyView: An Image and Notes Slideshow\nA picture may be worth a thousand words, but it takes considerably fewer to display\none with Python. The next program, PyView, implements a simple photo slideshow\nprogram in portable Python/tkinter code. It doesn\u2019t have any image-processing abilities\nsuch as PyPhoto\u2019s resizing, but it does provide different tools, such as image note files,\nand it can be run without the optional PIL extension.\nRunning PyView\nPyView pulls together many of the topics we studied in Chapter 9: it uses after events\nto sequence a slideshow, displays image objects in an automatically sized canvas, and\nso on. Its main window displays a photo on a canvas; users can either open and view\na photo directly or start a slideshow mode that picks and displays a random photo from\na directory at regular intervals specified with a scale widget.\nBy default, PyView slideshows show images in the book\u2019s image file directory (though\nthe Open button allows you to load images in arbitrary directories). To view other sets\nof photos, either pass a directory name in as a first command-line argument or change\nthe default directory name in the script itself. I can\u2019t show you a slideshow in action\nhere, but I can show you the main window in general. Figure 11-12 shows the main\nPyView: An Image and Notes Slideshow | 727PyView window\u2019s default display on Windows 7, created by running the slideShow-\nPlus.py script we\u2019ll see in Example 11-6 ahead.\nThough it\u2019s not obvious as rendered in this book, the black-on-red label at the top gives\nthe pathname of the photo file displayed. For a good time, move the slider at the bottom\nall the way over to \u201c0\u201d to specify no delay between photo changes, and then click Start\nto begin a very fast slideshow. If your computer is at least as fast as mine, photos flip\nby much too fast to be useful for anything but subliminal advertising. Slideshow photos\nare loaded on startup to retain references to them (remember, you must hold on to\nimage objects). But the speed with which large GIFs can be thrown up in a window in\nPython is impressive, if not downright exhilarating.\nThe GUI\u2019s Start button changes to a Stop button during a slideshow (its text attribute\nis reset with the widget config method). Figure 11-13 shows the scene after pressing\nStop at an opportune moment.\nIn addition, each photo can have an associated \u201cnotes\u201d text file that is automatically\nopened along with the image. You can use this feature to record basic information about\nthe photo. Press the Note button to open an additional set of widgets that let you view\nFigure 11-12. PyView without notes\n728 | Chapter 11:\u2002Complete GUI Programsand change the note file associated with the currently displayed photo. This additional\nset of widgets should look familiar\u2014the PyEdit text editor from earlier in this chapter\nis attached to PyView in a variety of selectable modes to serve as a display and editing\nwidget for photo notes. Figure 11-14 shows PyView with the attached PyEdit note-\nediting component opened (I resized the window a bit interactively for presentation\nhere).\nEmbedding PyEdit in PyView\nThis makes for a very big window, usually best viewed maximized (taking up the entire\nscreen). The main thing to notice, though, is the lower-right corner of this display,\nabove the scale\u2014it\u2019s simply an attached PyEdit object, running the very same code\nlisted in the earlier section. Because PyEdit is implemented as a GUI class, it can be\nreused like this in any GUI that needs a text-editing interface.\nWhen embedded this way, PyEdit is a nested frame attached to a slideshow frame. Its\nmenus are based on a frame (it doesn\u2019t own the window at large), text content is stored\nand fetched directly by the enclosing program, and some standalone options are\nFigure 11-13. PyView after stopping a slideshow\nPyView: An Image and Notes Slideshow | 729omitted (e.g., the File pull down menu and Quit button are gone). On the other hand,\nyou get all of the rest of PyEdit\u2019s functionality, including cut and paste, search and\nreplace, grep to search external files, colors and fonts, undo and redo, and so on. Even\nthe Clone option works here to open a new edit window, albeit making a frame-based\nmenu without a Quit or File pull down, and which doesn\u2019t test for changes on exit\u2014\na usage mode that could be tightened up with a new PyEdit top-level component class\nif desired.\nFor variety, if you pass a third command-line argument to PyView after the image\ndirectory name, it uses it as an index into a list of PyEdit top-level mode classes. An\nargument of 0 uses the main window mode, which places the note editor below the\nimage and a window menu at top (its Frame is packed into the window\u2019s remaining\nspace, not the slide show frame); 1 pops up the note editor as a separate, independent\nToplevel window (disabled when notes are turned off); 2 and 3 run PyEdit as an em-\nbedded component nested in the slide show frame, with Frame menus (2 includes all\nmenu options which may or may not be appropriate in this role, and 3 is the default\nlimited options mode).\nFigure 11-15 captures option 0, PyEdit\u2019s main window mode; there are really two in-\ndependent frames on the window here\u2014a slideshow on top and a text editor on bot-\ntom. The disadvantage of this over nested component or pop-up window modes is that\nFigure 11-14. PyView with notes\n730 | Chapter 11:\u2002Complete GUI ProgramsPyEdit really does assume control of the program\u2019s window (including its title and\nwindow manager close button), and packing the note editor at the bottom means it\nmight not appear for tall images. Run this on your own to sample the other PyEdit\nflavors, with a command line of this form:\nC:\\...\\PP4E\\Gui\\SlideShow> slideShowPlus.py ../gifs 0\nThe note file viewer appears only if you press the Note button, and it is erased if you\npress it again\u2014PyView uses the widget pack and pack_forget methods introduced near\nthe end of Chapter 9 to show and hide the note viewer frame. The window automati-\ncally expands to accommodate the note viewer when it is packed and displayed. Note\nthat it\u2019s important that the note editor be repacked with expand=YES and fill=BOTH when\nit\u2019s unhidden, or else it won\u2019t expand in some modes; PyEdit\u2019s frame packs itself this\nway in GuiMaker when first made, but pack_forget appears to, well\u2026forget.\nIt is also possible to open the note file in a PyEdit pop-up window, but PyView embeds\nthe editor by default to retain a direct visual association and avoid issues if the pop up\nFigure 11-15. PyView other PyEdit notes\nPyView: An Image and Notes Slideshow | 731is destroyed independently. As is, this program must wrap the PyEdit classes with its\nWrapEditor in order to catch independent destroys of the PyEdit frame when it is run\nin either pop-up window or full-option component modes\u2014the note editor can no\nlonger be accessed or repacked once it\u2019s destroyed. This isn\u2019t an issue in main window\nmode (Quit ends the program) or the default minimal component mode (the editor has\nno Quit). Watch for PyEdit to show up embedded as a component like this within\nanother GUI when we meet PyMailGUI in Chapter 14.\nA caveat here: out of the box, PyView supports as many photo formats as tkinter\u2019s\nPhotoImage object does; that\u2019s why it looks for GIF files by default. You can improve\nthis by installing the PIL extension to view JPEGs (and many others). But because PIL\nis an optional extension today, it\u2019s not incorporated into this PyView release. See the\nend of Chapter 8 for more on PIL and image formats.\nPyView Source Code\nBecause the PyView program was implemented in stages, you need to study the union\nof two files and classes to understand how it truly works. One file implements a class\nthat provides core slideshow functionality; the other implements a class that extends\nthe original class, to add additional features on top of the core behavior. Let\u2019s start with\nthe extension class: Example 11-6 adds a set of features to an imported slideshow base\nclass\u2014note editing, a delay scale and file label, and so on. This is the file that is actually\nrun to start PyView.\nExample 11-6. PP4E\\Gui\\SlideShow\\slideShowPlus.py\n\"\"\"\n#############################################################################\nPyView 1.2: an image slide show with associated text notes.\nSlideShow subclass which adds note files with an attached PyEdit object,\na scale for setting the slideshow delay interval, and a label that gives\nthe name of the image file currently being displayed;\nVersion 1.2 is a Python 3.x port, but also improves repacking note for\nexpansion when it's unhidden, catches note destroys in a subclass to avoid\nexceptions when popup window or full component editor has been closed,\nand runs update() before inserting text into newly packed note so it is\npositioned correctly at line 1 (see the book's coverage of PyEdit updates).\n#############################################################################\n\"\"\"\nimport os\nfrom tkinter import *\nfrom PP4E.Gui.TextEditor.textEditor import *\nfrom slideShow import SlideShow\n#from slideShow_threads import SlideShow\nSize = (300, 550)   # 1.2: start shorter here, (h, w)\nclass SlideShowPlus(SlideShow):\n732 | Chapter 11:\u2002Complete GUI Programsdef __init__(self, parent, picdir, editclass, msecs=2000, size=Size):\n        self.msecs = msecs\n        self.editclass = editclass\n        SlideShow.__init__(self, parent, picdir, msecs, size)\n    def makeWidgets(self):\n        self.name = Label(self, text='None', bg='red', relief=RIDGE)\n        self.name.pack(fill=X)\n        SlideShow.makeWidgets(self)\n        Button(self, text='Note', command=self.onNote).pack(fill=X)\n        Button(self, text='Help', command=self.onHelp).pack(fill=X)\n        s = Scale(label='Speed: msec delay', command=self.onScale,\n                  from_=0, to=3000, resolution=50, showvalue=YES,\n                  length=400, tickinterval=250, orient='horizontal')\n        s.pack(side=BOTTOM, fill=X)\n        s.set(self.msecs)\n        # 1.2: need to know if editor destroyed, in popup or full component modes\n        self.editorGone = False\n        class WrapEditor(self.editclass):   # extend PyEdit class to catch Quit\n            def onQuit(editor):             # editor is PyEdit instance arg subject\n                self.editorGone = True      # self is slide show in enclosing scope\n                self.editorUp   = False\n                self.editclass.onQuit(editor)       # avoid recursion\n        # attach editor frame to window or slideshow frame\n        if issubclass(WrapEditor, TextEditorMain):     # make editor now\n            self.editor = WrapEditor(self.master)      # need root for menu\n        else:\n            self.editor = WrapEditor(self)             # embedded or pop-up\n        self.editor.pack_forget()                      # hide editor initially\n        self.editorUp = self.image = None\n    def onStart(self):\n        SlideShow.onStart(self)\n        self.config(cursor='watch')\n    def onStop(self):\n        SlideShow.onStop(self)\n        self.config(cursor='hand2')\n    def onOpen(self):\n        SlideShow.onOpen(self)\n        if self.image:\n            self.name.config(text=os.path.split(self.image[0])[1])\n        self.config(cursor='crosshair')\n        self.switchNote()\n    def quit(self):\n        self.saveNote()\n        SlideShow.quit(self)\n    def drawNext(self):\n        SlideShow.drawNext(self)\n        if self.image:\nPyView: An Image and Notes Slideshow | 733self.name.config(text=os.path.split(self.image[0])[1])\n        self.loadNote()\n    def onScale(self, value):\n        self.msecs = int(value)\n    def onNote(self):\n        if self.editorGone:                # 1.2: has been destroyed\n            return                         # don't rebuild: assume unwanted\n        if self.editorUp:\n            #self.saveNote()               # if editor already open\n            self.editor.pack_forget()      # save text?, hide editor\n            self.editorUp = False\n        else:\n            # 1.2: repack for expansion again, else won't expand now\n            # 1.2: update between pack and insert, else @ line 2 initially\n            self.editor.pack(side=TOP, expand=YES, fill=BOTH)\n            self.editorUp = True           # else unhide/pack editor\n            self.update()                  # see Pyedit: same as loadFirst issue\n            self.loadNote()                # and load image note text\n    def switchNote(self):\n        if self.editorUp:\n            self.saveNote()                # save current image's note\n            self.loadNote()                # load note for new image\n    def saveNote(self):\n        if self.editorUp:\n            currfile = self.editor.getFileName()     # or self.editor.onSave()\n            currtext = self.editor.getAllText()      # but text may be empty\n            if currfile and currtext:\n                try:\n                    open(currfile, 'w').write(currtext)\n                except:\n                    pass  # failure may be normal if run off a cd\n    def loadNote(self):\n        if self.image and self.editorUp:\n            root, ext = os.path.splitext(self.image[0])\n            notefile  = root + '.note'\n            self.editor.setFileName(notefile)\n            try:\n                self.editor.setAllText(open(notefile).read())\n            except:\n                self.editor.clearAllText()   # might not have a note\n    def onHelp(self):\n        showinfo('About PyView',\n                 'PyView version 1.2\\nMay, 2010\\n(1.1 July, 1999)\\n'\n                 'An image slide show\\nProgramming Python 4E')\nif __name__ == '__main__':\n    import sys\n    picdir = '../gifs'\n    if len(sys.argv) >= 2:\n734 | Chapter 11:\u2002Complete GUI Programspicdir = sys.argv[1]\n    editstyle = TextEditorComponentMinimal\n    if len(sys.argv) == 3:\n        try:\n            editstyle = [TextEditorMain,\n                         TextEditorMainPopup,\n                         TextEditorComponent,\n                         TextEditorComponentMinimal][int(sys.argv[2])]\n        except: pass\n    root = Tk()\n    root.title('PyView 1.2 - plus text notes')\n    Label(root, text=\"Slide show subclass\").pack()\n    SlideShowPlus(parent=root, picdir=picdir, editclass=editstyle)\n    root.mainloop()\nThe core functionality extended by SlideShowPlus lives in Example 11-7. This was the\ninitial slideshow implementation; it opens images, displays photos, and cycles through\na slideshow. You can run it by itself, but you won\u2019t get advanced features such as notes\nand sliders added by the SlideShowPlus subclass.\nExample 11-7. PP4E\\Gui\\SlideShow\\slideShow.py\n\"\"\"\n######################################################################\nSlideShow: a simple photo image slideshow in Python/tkinter;\nthe base feature set coded here can be extended in subclasses;\n######################################################################\n\"\"\"\nfrom tkinter import *\nfrom glob import glob\nfrom tkinter.messagebox import askyesno\nfrom tkinter.filedialog import askopenfilename\nimport random\nSize = (450, 450)  # canvas height, width at startup and slideshow start\nimageTypes = [('Gif files', '.gif'),    # for file open dialog\n              ('Ppm files', '.ppm'),    # plus jpg with a Tk patch,\n              ('Pgm files', '.pgm'),    # plus bitmaps with BitmapImage\n              ('All files', '*')]\nclass SlideShow(Frame):\n    def __init__(self, parent=None, picdir='.', msecs=3000, size=Size, **args):\n        Frame.__init__(self, parent, **args)\n        self.size = size\n        self.makeWidgets()\n        self.pack(expand=YES, fill=BOTH)\n        self.opens = picdir\n        files = []\n        for label, ext in imageTypes[:-1]:\n            files = files + glob('%s/*%s' % (picdir, ext))\n        self.images = [(x, PhotoImage(file=x)) for x in files]\n        self.msecs  = msecs\nPyView: An Image and Notes Slideshow | 735self.beep   = True\n        self.drawn  = None\n    def makeWidgets(self):\n        height, width = self.size\n        self.canvas = Canvas(self, bg='white', height=height, width=width)\n        self.canvas.pack(side=LEFT, fill=BOTH, expand=YES)\n        self.onoff = Button(self, text='Start', command=self.onStart)\n        self.onoff.pack(fill=X)\n        Button(self, text='Open',  command=self.onOpen).pack(fill=X)\n        Button(self, text='Beep',  command=self.onBeep).pack(fill=X)\n        Button(self, text='Quit',  command=self.onQuit).pack(fill=X)\n    def onStart(self):\n        self.loop = True\n        self.onoff.config(text='Stop', command=self.onStop)\n        self.canvas.config(height=self.size[0], width=self.size[1])\n        self.onTimer()\n    def onStop(self):\n        self.loop = False\n        self.onoff.config(text='Start', command=self.onStart)\n    def onOpen(self):\n        self.onStop()\n        name = askopenfilename(initialdir=self.opens, filetypes=imageTypes)\n        if name:\n            if self.drawn: self.canvas.delete(self.drawn)\n            img = PhotoImage(file=name)\n            self.canvas.config(height=img.height(), width=img.width())\n            self.drawn = self.canvas.create_image(2, 2, image=img, anchor=NW)\n            self.image = name, img\n    def onQuit(self):\n        self.onStop()\n        self.update()\n        if askyesno('PyView', 'Really quit now?'):\n            self.quit()\n    def onBeep(self):\n        self.beep = not self.beep    # toggle, or use ^ 1\n    def onTimer(self):\n        if self.loop:\n            self.drawNext()\n            self.after(self.msecs, self.onTimer)\n    def drawNext(self):\n        if self.drawn: self.canvas.delete(self.drawn)\n        name, img  = random.choice(self.images)\n        self.drawn = self.canvas.create_image(2, 2, image=img, anchor=NW)\n        self.image = name, img\n        if self.beep: self.bell()\n        self.canvas.update()\n736 | Chapter 11:\u2002Complete GUI Programsif __name__ == '__main__':\n    import sys\n    if len(sys.argv) == 2:\n        picdir = sys.argv[1]\n    else:\n        picdir = '../gifs'\n    root = Tk()\n    root.title('PyView 1.2')\n    root.iconname('PyView')\n    Label(root, text=\"Python Slide Show Viewer\").pack()\n    SlideShow(root, picdir=picdir, bd=3, relief=SUNKEN)\n    root.mainloop()\nTo give you a better idea of what this core base class implements, Figure 11-16 shows\nwhat it looks like if run by itself\u2014actually, two copies run by themselves by a script\ncalled slideShow_frames, which is in this book\u2019s examples distribution, and whose main\ncode looks like this:\nroot = Tk()\nLabel(root, text=\"Two embedded slide shows: Frames\").pack()\nSlideShow(parent=root, picdir=picdir, bd=3, relief=SUNKEN).pack(side=LEFT)\nSlideShow(parent=root, picdir=picdir, bd=3, relief=SUNKEN).pack(side=RIGHT)\nroot.mainloop()\nFigure 11-16. Two attached SlideShow objects\nThe simple slideShow_frames scripts attach two instances of SlideShow to a single win-\ndow\u2014a feat possible only because state information is recorded in class instance var-\niables, not in globals. The slideShow_toplevels script (also in the book\u2019s examples\ndistribution) attaches two SlideShows to two top-level pop-up windows instead. In both\nPyView: An Image and Notes Slideshow | 737cases, the slideshows run independently but are based on after events fired from the\nsame single event loop in a single process.\nPyDraw: Painting and Moving Graphics\nChapter 9 introduced simple tkinter animation techniques (see the tour\u2019s canvasDraw\nvariants). The PyDraw program listed here builds upon those ideas to implement a\nmore feature-rich painting program in Python. It adds new trails and scribble drawing\nmodes, object and background color fills, embedded photos, and more. In addition, it\nimplements object movement and animation techniques\u2014drawn objects may be\nmoved around the canvas by clicking and dragging, and any drawn object can be grad-\nually moved across the screen to a target location clicked with the mouse.\nRunning PyDraw\nPyDraw is essentially a tkinter canvas with keyboard and mouse event bindings to allow\nusers to perform common drawing operations. This isn\u2019t a professional-grade paint\nprogram, but it\u2019s fun to play with. In fact, you really should\u2014it is impossible to capture\nthings such as object motion in this book. Start PyDraw from the launcher bars (or run\nthe file movingpics.py from Example 11-8 directly). Press the ? key to view a help mes-\nsage giving available commands (or read the help string in the code listings).\nFigure 11-17 shows PyDraw after a few objects have been drawn on the canvas. To\nmove any object shown here, either click it with the middle mouse button and drag to\nmove it with the mouse cursor, or middle-click the object, and then right-click in the\nspot you want it to move toward. In the latter case, PyDraw performs an animated\n(gradual) movement of the object to the target spot. Try this on the picture shown near\nthe top of the figure\u2014it will slowly move across your display.\nPress \u201cp\u201d to insert photos, and use left-button drags to draw shapes. (Note to Windows\nusers: middle-click is often either both mouse buttons at once or a scroll wheel, but\nyou may need to configure this in your control panel.) In addition to mouse events,\nthere are 17 key-press commands for tailoring sketches that I won\u2019t cover here. It takes\na while to get the hang of what all the keyboard and mouse commands do, but once\nyou\u2019ve mastered the bindings, you too can begin generating senseless electronic artwork\nsuch as that in Figure 11-18.\nPyDraw Source Code\nLike PyEdit, PyDraw lives in a single file. Two extensions that customize motion im-\nplementations are listed following the main module shown in Example 11-8.\n738 | Chapter 11:\u2002Complete GUI ProgramsExample 11-8. PP4E\\Gui\\MovingPics\\movingpics.py\n\"\"\"\n##############################################################################\nPyDraw 1.1: simple canvas paint program and object mover/animator.\nUses time.sleep loops to implement object move loops, such that only\none move can be in progress at once; this is smooth and fast, but see\nthe widget.after and thread-based subclasses here for other techniques.\nVersion 1.1 has been updated to run under Python 3.X (2.X not supported)\n##############################################################################\n\"\"\"\nhelpstr = \"\"\"--PyDraw version 1.1--\nMouse commands:\n  Left        = Set target spot\n  Left+Move   = Draw new object\n  Double Left = Clear all objects\n  Right       = Move current object\n  Middle      = Select closest object\n  Middle+Move = Drag current object\nFigure 11-17. PyDraw with draw objects ready to be moved\nPyDraw: Painting and Moving Graphics | 739Keyboard commands:\n  w=Pick border width  c=Pick color\n  u=Pick move unit     s=Pick move delay\n  o=Draw ovals         r=Draw rectangles\n  l=Draw lines         a=Draw arcs\n  d=Delete object      1=Raise object\n  2=Lower object       f=Fill object\n  b=Fill background    p=Add photo\n  z=Save postscript    x=Pick pen modes\n  ?=Help               other=clear text\n\"\"\"\nimport time, sys\nfrom tkinter import *\nfrom tkinter.filedialog import *\nfrom tkinter.messagebox import *\nPicDir = '../gifs'\nif sys.platform[:3] == 'win':\n    HelpFont = ('courier', 9, 'normal')\nelse:\n    HelpFont = ('courier', 12, 'normal')\npickDelays = [0.01, 0.025, 0.05, 0.10, 0.25, 0.0, 0.001, 0.005]\npickUnits  = [1, 2, 4, 6, 8, 10, 12]\npickWidths = [1, 2, 5, 10, 20]\npickFills  = [None,'white','blue','red','black','yellow','green','purple']\nFigure 11-18. PyDraw after substantial play\n740 | Chapter 11:\u2002Complete GUI ProgramspickPens   = ['elastic', 'scribble', 'trails']\nclass MovingPics:\n    def __init__(self, parent=None):\n        canvas = Canvas(parent, width=500, height=500, bg= 'white')\n        canvas.pack(expand=YES, fill=BOTH)\n        canvas.bind('<ButtonPress-1>',  self.onStart)\n        canvas.bind('<B1-Motion>',      self.onGrow)\n        canvas.bind('<Double-1>',       self.onClear)\n        canvas.bind('<ButtonPress-3>',  self.onMove)\n        canvas.bind('<Button-2>',       self.onSelect)\n        canvas.bind('<B2-Motion>',      self.onDrag)\n        parent.bind('<KeyPress>',       self.onOptions)\n        self.createMethod = Canvas.create_oval\n        self.canvas = canvas\n        self.moving = []\n        self.images = []\n        self.object = None\n        self.where  = None\n        self.scribbleMode = 0\n        parent.title('PyDraw - Moving Pictures 1.1')\n        parent.protocol('WM_DELETE_WINDOW', self.onQuit)\n        self.realquit = parent.quit\n        self.textInfo = self.canvas.create_text(\n                                 5, 5, anchor=NW,\n                                 font=HelpFont,\n                                 text='Press ? for help')\n    def onStart(self, event):\n        self.where  = event\n        self.object = None\n    def onGrow(self, event):\n        canvas = event.widget\n        if self.object and pickPens[0] == 'elastic':\n            canvas.delete(self.object)\n        self.object = self.createMethod(canvas,\n                                self.where.x, self.where.y,    # start\n                                event.x, event.y,              # stop\n                                fill=pickFills[0], width=pickWidths[0])\n        if pickPens[0] == 'scribble':\n            self.where = event  # from here next time\n    def onClear(self, event):\n        if self.moving: return       # ok if moving but confusing\n        event.widget.delete('all')   # use all tag\n        self.images = []\n        self.textInfo = self.canvas.create_text(\n                                 5, 5, anchor=NW,\n                                 font=HelpFont,\n                                 text='Press ? for help')\n    def plotMoves(self, event):\n        diffX  = event.x - self.where.x              # plan animated moves\n        diffY  = event.y - self.where.y              # horizontal then vertical\nPyDraw: Painting and Moving Graphics | 741reptX  = abs(diffX) // pickUnits[0]          # incr per move, number moves\n        reptY  = abs(diffY) // pickUnits[0]          # from last to event click\n        incrX  = pickUnits[0] * ((diffX > 0) or \u22121)  # 3.x // trunc div required\n        incrY  = pickUnits[0] * ((diffY > 0) or \u22121)\n        return incrX, reptX, incrY, reptY\n    def onMove(self, event):\n        traceEvent('onMove', event, 0)               # move current object to click\n        object = self.object                         # ignore some ops during mv\n        if object and object not in self.moving:\n            msecs  = int(pickDelays[0] * 1000)\n            parms  = 'Delay=%d msec, Units=%d' % (msecs, pickUnits[0])\n            self.setTextInfo(parms)\n            self.moving.append(object)\n            canvas = event.widget\n            incrX, reptX, incrY, reptY = self.plotMoves(event)\n            for i in range(reptX):\n                canvas.move(object, incrX, 0)\n                canvas.update()\n                time.sleep(pickDelays[0])\n            for i in range(reptY):\n                canvas.move(object, 0, incrY)\n                canvas.update()                       # update runs other ops\n                time.sleep(pickDelays[0])             # sleep until next move\n            self.moving.remove(object)\n            if self.object == object: self.where  = event\n    def onSelect(self, event):\n        self.where  = event\n        self.object = self.canvas.find_closest(event.x, event.y)[0]   # tuple\n    def onDrag(self, event):\n        diffX = event.x - self.where.x                # OK if object in moving\n        diffY = event.y - self.where.y                # throws it off course\n        self.canvas.move(self.object, diffX, diffY)\n        self.where = event\n    def onOptions(self, event):\n        keymap = {\n            'w': lambda self: self.changeOption(pickWidths, 'Pen Width'),\n            'c': lambda self: self.changeOption(pickFills,  'Color'),\n            'u': lambda self: self.changeOption(pickUnits,  'Move Unit'),\n            's': lambda self: self.changeOption(pickDelays, 'Move Delay'),\n            'x': lambda self: self.changeOption(pickPens,   'Pen Mode'),\n            'o': lambda self: self.changeDraw(Canvas.create_oval,      'Oval'),\n            'r': lambda self: self.changeDraw(Canvas.create_rectangle, 'Rect'),\n            'l': lambda self: self.changeDraw(Canvas.create_line,      'Line'),\n            'a': lambda self: self.changeDraw(Canvas.create_arc,       'Arc'),\n            'd': MovingPics.deleteObject,\n            '1': MovingPics.raiseObject,\n            '2': MovingPics.lowerObject,        # if only 1 call pattern\n            'f': MovingPics.fillObject,         # use unbound method objects\n            'b': MovingPics.fillBackground,     # else lambda passed self\n            'p': MovingPics.addPhotoItem,\n            'z': MovingPics.savePostscript,\n742 | Chapter 11:\u2002Complete GUI Programs'?': MovingPics.help}\n        try:\n            keymap[event.char](self)\n        except KeyError:\n            self.setTextInfo('Press ? for help')\n    def changeDraw(self, method, name):\n        self.createMethod = method              # unbound Canvas method\n        self.setTextInfo('Draw Object=' + name)\n    def changeOption(self, list, name):\n        list.append(list[0])\n        del list[0]\n        self.setTextInfo('%s=%s' % (name, list[0]))\n    def deleteObject(self):\n        if self.object != self.textInfo:        # ok if object in moving\n            self.canvas.delete(self.object)     # erases but move goes on\n            self.object = None\n    def raiseObject(self):\n        if self.object:                         # ok if moving\n            self.canvas.tkraise(self.object)    # raises while moving\n    def lowerObject(self):\n        if self.object:\n            self.canvas.lower(self.object)\n    def fillObject(self):\n        if self.object:\n            type = self.canvas.type(self.object)\n            if type == 'image':\n                pass\n            elif type == 'text':\n                self.canvas.itemconfig(self.object, fill=pickFills[0])\n            else:\n                self.canvas.itemconfig(self.object,\n                               fill=pickFills[0], width=pickWidths[0])\n    def fillBackground(self):\n        self.canvas.config(bg=pickFills[0])\n    def addPhotoItem(self):\n        if not self.where: return\n        filetypes=[('Gif files', '.gif'), ('All files', '*')]\n        file = askopenfilename(initialdir=PicDir, filetypes=filetypes)\n        if file:\n            image = PhotoImage(file=file)                     # load image\n            self.images.append(image)                         # keep reference\n            self.object = self.canvas.create_image(           # add to canvas\n                                 self.where.x, self.where.y,  # at last spot\n                                 image=image, anchor=NW)\n    def savePostscript(self):\n        file = asksaveasfilename()\nPyDraw: Painting and Moving Graphics | 743if file:\n            self.canvas.postscript(file=file)  # save canvas to file\n    def help(self):\n        self.setTextInfo(helpstr)\n        #showinfo('PyDraw', helpstr)\n    def setTextInfo(self, text):\n        self.canvas.dchars(self.textInfo, 0, END)\n        self.canvas.insert(self.textInfo, 0, text)\n        self.canvas.tkraise(self.textInfo)\n    def onQuit(self):\n        if self.moving:\n            self.setTextInfo(\"Can't quit while move in progress\")\n        else:\n            self.realquit()  # std wm delete: err msg if move in progress\ndef traceEvent(label, event, fullTrace=True):\n    print(label)\n    if fullTrace:\n        for atrr in dir(event):\n            if attr[:2] != '__':\n                print(attr, '=>', getattr(event, attr))\nif __name__ == '__main__':\n    from sys import argv                        # when this file is executed\n    if len(argv) == 2: PicDir = argv[1]         # '..' fails if run elsewhere\n    root = Tk()                                 # make, run a MovingPics object\n    MovingPics(root)\n    root.mainloop()\nAs is, only one object can be in motion at a time\u2014requesting an object move while one\nis already in motion pauses the original till the new move is finished. Just as in Chap-\nter 9\u2019s canvasDraw examples, though, we can add support for moving more than one\nobject at the same time with either after scheduled callback events or threads.\nExample 11-9 shows a MovingPics subclass that codes the necessary customizations to\ndo parallel moves with after events. It allows any number of objects in the canvas,\nincluding pictures, to be moving independently at once. Run this file directly to see the\ndifference; I could try to capture the notion of multiple objects in motion with a screen-\nshot, but I would almost certainly fail.\nExample 11-9. PP4E\\Gui\\MovingPics\\movingpics_after.py\n\"\"\"\nPyDraw-after: simple canvas paint program and object mover/animator\nuse widget.after scheduled events to implement object move loops, such\nthat more than one can be in motion at once without having to use threads;\nthis does moves in parallel, but seems to be slower than time.sleep version;\nsee also canvasDraw in Tour: builds and passes the incX/incY list at once:\nhere, would be allmoves = ([(incrX, 0)] * reptX) + ([(0, incrY)] * reptY)\n\"\"\"\n744 | Chapter 11:\u2002Complete GUI Programsfrom movingpics import *\nclass MovingPicsAfter(MovingPics):\n    def doMoves(self, delay, objectId, incrX, reptX, incrY, reptY):\n        if reptX:\n            self.canvas.move(objectId, incrX, 0)\n            reptX -= 1\n        else:\n            self.canvas.move(objectId, 0, incrY)\n            reptY -= 1\n        if not (reptX or reptY):\n            self.moving.remove(objectId)\n        else:\n            self.canvas.after(delay,\n                self.doMoves, delay, objectId, incrX, reptX, incrY, reptY)\n    def onMove(self, event):\n        traceEvent('onMove', event, 0)\n        object = self.object                      # move cur obj to click spot\n        if object:\n            msecs  = int(pickDelays[0] * 1000)\n            parms  = 'Delay=%d msec, Units=%d' % (msecs, pickUnits[0])\n            self.setTextInfo(parms)\n            self.moving.append(object)\n            incrX, reptX, incrY, reptY = self.plotMoves(event)\n            self.doMoves(msecs, object, incrX, reptX, incrY, reptY)\n            self.where = event\nif __name__ == '__main__':\n    from sys import argv                          # when this file is executed\n    if len(argv) == 2:\n        import movingpics                         # not this module's global\n        movingpics.PicDir = argv[1]               # and from* doesn't link names\n    root = Tk()\n    MovingPicsAfter(root)\n    root.mainloop()\nTo appreciate its operation, open this script\u2019s window full screen and create some ob-\njects in its canvas by pressing \u201cp\u201d after an initial click to insert pictures, dragging out\nshapes, and so on. Now, while one or more moves are in progress, you can start another\nby middle-clicking on another object and right-clicking on the spot to which you want\nit to move. It starts its journey immediately, even if other objects are in motion. Each\nobject\u2019s scheduled after events are added to the same event loop queue and dispatched\nby tkinter as soon as possible after a timer expiration.\nIf you run this subclass module directly, you might notice that movement isn\u2019t quite\nas fast or as smooth as in the original (depending on your machine, and the many layers\nof software under Python), but multiple moves can overlap in time.\nExample 11-10 shows how to achieve such parallelism with threads. This process\nworks, but as we learned in Chapters 9 and 10, updating GUIs in spawned threads is\ngenerally a dangerous affair. On one of my machines, the movement that this script\nimplements with threads was a bit jerkier than the original version\u2014perhaps a\nPyDraw: Painting and Moving Graphics | 745reflection of the overhead incurred for switching the interpreter (and CPU) between\nmultiple threads\u2014but again, this can vary.\nExample 11-10. PP4E\\Gui\\MovingPics\\movingpics_threads.py\n\"\"\"\nPyDraw-threads: use threads to move objects; works okay on Windows\nprovided that canvas.update() not called by threads (else exits with\nfatal errors, some objs start moving immediately after drawn, etc.);\nat least some canvas method calls must be thread safe in tkinter;\nthis is less smooth than time.sleep, and is dangerous in general:\nthreads are best coded to update global vars, not change GUI;\n\"\"\"\nimport _thread as thread, time, sys, random\nfrom tkinter import Tk, mainloop\nfrom movingpics import MovingPics, pickUnits, pickDelays\nclass MovingPicsThreaded(MovingPics):\n    def __init__(self, parent=None):\n        MovingPics.__init__(self, parent)\n        self.mutex = thread.allocate_lock()\n        import sys\n        #sys.setcheckinterval(0) # switch after each vm op: doesn't help\n    def onMove(self, event):\n        object = self.object\n        if object and object not in self.moving:\n            msecs  = int(pickDelays[0] * 1000)\n            parms  = 'Delay=%d msec, Units=%d' % (msecs, pickUnits[0])\n            self.setTextInfo(parms)\n            #self.mutex.acquire()\n            self.moving.append(object)\n            #self.mutex.release()\n            thread.start_new_thread(self.doMove, (object, event))\n    def doMove(self, object, event):\n        canvas = event.widget\n        incrX, reptX, incrY, reptY = self.plotMoves(event)\n        for i in range(reptX):\n            canvas.move(object, incrX, 0)\n            # canvas.update()\n            time.sleep(pickDelays[0])         # this can change\n        for i in range(reptY):\n            canvas.move(object, 0, incrY)\n            # canvas.update()                 # update runs other ops\n            time.sleep(pickDelays[0])         # sleep until next move\n        #self.mutex.acquire()\n        self.moving.remove(object)\n        if self.object == object: self.where  = event\n        #self.mutex.release()\nif __name__ == '__main__':\n    root = Tk()\n746 | Chapter 11:\u2002Complete GUI ProgramsMovingPicsThreaded(root)\n    mainloop()\nPyClock: An Analog/Digital Clock Widget\nOne of the first things I always look for when exploring a new computer interface is a\nclock. Because I spend so much time glued to computers, it\u2019s essentially impossible for\nme to keep track of the time unless it is right there on the screen in front of me (and\neven then, it\u2019s iffy). The next program, PyClock, implements such a clock widget in\nPython. It\u2019s not substantially different from the clock programs that you may be used\nto seeing on the X Window System. Because it is coded in Python, though, this one is\nboth easily customized and fully portable among Windows, the X Window System,\nand Macs, like all the code in this chapter. In addition to advanced GUI techniques,\nthis example demonstrates Python math and time module tools.\nA Quick Geometry Lesson\nBefore I show you PyClock, though, let me provide a little background and a confession.\nQuick\u2014how do you plot points on a circle? This, along with time formats and events,\nturns out to be a core concept in clock widget programs. To draw an analog clock face\non a canvas widget, you essentially need to be able to sketch a circle\u2014the clock face\nitself is composed of points on a circle, and the second, minute, and hour hands of the\nclock are really just lines from a circle\u2019s center out to a point on the circle. Digital clocks\nare simpler to draw, but not much to look at.\nNow the confession: when I started writing PyClock, I couldn\u2019t answer the last para-\ngraph\u2019s opening question. I had utterly forgotten the math needed to sketch out points\non a circle (as had most of the professional software developers I queried about this\nmagic formula). It happens. After going unused for a few decades, such knowledge\ntends to be garbage collected. I finally was able to dust off a few neurons long enough\nto code the plotting math needed, but it wasn\u2019t my finest intellectual hour.\u2021\nIf you are in the same boat, I don\u2019t have space to teach geometry in depth here, but I\ncan show you one way to code the point-plotting formulas in Python in simple terms.\nBefore tackling the more complex task of implementing a clock, I wrote the plotter\nGui script shown in Example 11-11 to focus on just the circle-plotting logic.\nIts point function is where the circle logic lives\u2014it plots the (X,Y) coordinates of a point\non the circle, given the relative point number, the total number of points to be placed\non the circle, and the circle\u2019s radius (the distance from the circle\u2019s center to the points\ndrawn upon it). It first calculates the point\u2019s angle from the top by dividing 360 by the\n\u2021 Lest that make software engineers seem too doltish, I should also note that I have been called on repeatedly\nto teach Python programming to physicists, all of whom had mathematical training well in advance of my\nown, and many of whom were still happily abusing FORTRAN common blocks and go-tos. Specialization\nin modern society can make novices of us all.\nPyClock: An Analog/Digital Clock Widget | 747number of points to be plotted, and then multiplying by the point number; in case\nyou\u2019ve forgotten too, it\u2019s 360 degrees around the whole circle (e.g., if you plot 4 points\non a circle, each is 90 degrees from the last, or 360/4). Python\u2019s standard math module\ngives all the required constants and functions from that point forward\u2014pi, sine, and\ncosine. The math is really not too obscure if you study this long enough (in conjunction\nwith your old geometry text if necessary). There are alternative ways to code the number\ncrunching, but I\u2019ll skip the details here (see the examples package for hints).\nEven if you don\u2019t care about the math, though, check out Example 11-11\u2019s circle\nfunction. Given the (X,Y) coordinates of a point on the circle returned by point, it draws\na line from the circle\u2019s center out to the point and a small rectangle around the point\nitself\u2014not unlike the hands and points of an analog clock. Canvas tags are used to\nassociate drawn objects for deletion before each plot.\nExample 11-11. PP4E\\Gui\\Clock\\plotterGui.py\n# plot circles on a canvas\nimport math, sys\nfrom tkinter import *\ndef point(tick, range, radius):\n    angle = tick * (360.0 / range)\n    radiansPerDegree = math.pi / 180\n    pointX = int( round( radius * math.sin(angle * radiansPerDegree) ))\n    pointY = int( round( radius * math.cos(angle * radiansPerDegree) ))\n    return (pointX, pointY)\ndef circle(points, radius, centerX, centerY, slow=0):\n    canvas.delete('lines')\n    canvas.delete('points')\n    for i in range(points):\n        x, y = point(i+1, points, radius-4)\n        scaledX, scaledY = (x + centerX), (centerY - y)\n        canvas.create_line(centerX, centerY, scaledX, scaledY, tag='lines')\n        canvas.create_rectangle(scaledX-2, scaledY-2,\n                                scaledX+2, scaledY+2,\n                                           fill='red', tag='points')\n        if slow: canvas.update()\ndef plotter():   # 3.x // trunc div\n    circle(scaleVar.get(), (Width // 2), originX, originY, checkVar.get())\ndef makewidgets():\n    global canvas, scaleVar, checkVar\n    canvas = Canvas(width=Width, height=Width)\n    canvas.pack(side=TOP)\n    scaleVar = IntVar()\n    checkVar = IntVar()\n    scale = Scale(label='Points on circle', variable=scaleVar, from_=1, to=360)\n    scale.pack(side=LEFT)\n    Checkbutton(text='Slow mode', variable=checkVar).pack(side=LEFT)\n    Button(text='Plot', command=plotter).pack(side=LEFT, padx=50)\n748 | Chapter 11:\u2002Complete GUI Programsif __name__ == '__main__':\n    Width = 500                                       # default width, height\n    if len(sys.argv) == 2: Width = int(sys.argv[1])   # width cmdline arg?\n    originX = originY = Width // 2                    # same as circle radius\n    makewidgets()                                     # on default Tk root\n    mainloop()                                        # need 3.x // trunc div\nThe circle defaults to 500 pixels wide unless you pass a width on the command line.\nGiven a number of points on a circle, this script marks out the circle in clockwise order\nevery time you press Plot, by drawing lines out from the center to small rectangles at\npoints on the circle\u2019s shape. Move the slider to plot a different number of points and\nclick the checkbox to make the drawing happen slow enough to notice the clockwise\norder in which lines and points are drawn (this forces the script to update the display\nafter each line is drawn). Figure 11-19 shows the result for plotting 120 points with the\ncircle width set to 400 on the command line; if you ask for 60 and 12 points on the\ncircle, the relationship to clock faces and hands starts becoming clearer.\nFigure 11-19. plotterGui in action\nPyClock: An Analog/Digital Clock Widget | 749For more help, this book\u2019s examples distribution also includes text-based versions of\nthis plotting script that print circle point coordinates to the stdout stream for review,\ninstead of rendering them in a GUI. See the plotterText.py scripts in the clock\u2019s\ndirectory. Here is the sort of output they produce when plotting 4 and 12 points on a\ncircle that is 400 points wide and high; the output format is simply:\npointnumber : angle = (Xcoordinate, Ycoordinate)\nand assumes that the circle is centered at coordinate (0,0):\n----------\n1 : 90.0 = (200, 0)\n2 : 180.0 = (0, \u2212200)\n3 : 270.0 = (\u2212200, 0)\n4 : 360.0 = (0, 200)\n----------\n1 : 30.0 = (100, 173)\n2 : 60.0 = (173, 100)\n3 : 90.0 = (200, 0)\n4 : 120.0 = (173, \u2212100)\n5 : 150.0 = (100, \u2212173)\n6 : 180.0 = (0, \u2212200)\n7 : 210.0 = (\u2212100, \u2212173)\n8 : 240.0 = (\u2212173, \u2212100)\n9 : 270.0 = (\u2212200, 0)\n10 : 300.0 = (\u2212173, 100)\n11 : 330.0 = (\u2212100, 173)\n12 : 360.0 = (0, 200)\n----------\nNumeric Python Tools\nIf you do enough number crunching to have followed this section\u2019s abbreviated geom-\netry lesson, you will probably also be interested in exploring the NumPy numeric pro-\ngramming extension for Python. It adds things such as vector objects and advanced\nmathematical operations, effectively turning Python into a scientific/numeric program-\nming tool that supports efficient numerical array computations, and it has been com-\npared to MatLab. NumPy has been used effectively by many organizations, including\nLawrence Livermore and Los Alamos National Labs\u2014in many cases, allowing Python\nwith NumPy to replace legacy FORTRAN code.\nNumPy must be fetched and installed separately; see Python\u2019s website for links. On the\nweb, you\u2019ll also find related numeric tools (e.g., SciPy), as well as visualization and 3-\nD animation tools (e.g., PyOpenGL, Blender, Maya, vtk, and VPython). At this writing,\nNumPy (like the many numeric packages that depend upon it) is officially available for\nPython 2.X only, but a version that supports both versions 2.X and 3.X is in early\ndevelopment release form. Besides the math module, Python itself also has a built-in\ncomplex number type for engineering work, a fixed-precision decimal type added in\nrelease 2.4, and a rational fraction type added in 2.6 and 3.0. See the library manual\nand Python language fundamentals books such as Learning Python for details.\n750 | Chapter 11:\u2002Complete GUI ProgramsTo understand how these points are mapped to a canvas, you first need to know that\nthe width and height of a circle are always the same\u2014the radius \u00d7 2. Because tkinter\ncanvas (X,Y) coordinates start at (0,0) in the upper-left corner, the plotter GUI must\noffset the circle\u2019s center point to coordinates (width/2, width/2)\u2014the origin point from\nwhich lines are drawn. For instance, in a 400 \u00d7 400 circle, the canvas center is (200,200).\nA line to the 90-degree angle point on the right side of the circle runs from (200,200)\nto (400,200)\u2014the result of adding the (200,0) point coordinates plotted for the radius\nand angle. A line to the bottom at 180 degrees runs from (200,200) to (200,400) after\nfactoring in the (0,-200) point plotted.\nThis point-plotting algorithm used by plotterGui, along with a few scaling constants,\nis at the heart of the PyClock analog display. If this still seems a bit much, I suggest you\nfocus on the PyClock script\u2019s digital display implementation first; the analog geometry\nplots are really just extensions of underlying timing mechanisms used for both display\nmodes. In fact, the clock itself is structured as a generic Frame object that embeds digital\nand analog display objects and dispatches time change and resize events to both in the\nsame way. The analog display is an attached Canvas that knows how to draw circles,\nbut the digital object is simply an attached Frame with labels to show time components.\nRunning PyClock\nApart from the circle geometry bit, the rest of PyClock is straightforward. It simply\ndraws a clock face to represent the current time and uses widget after methods to wake\nitself up 10 times per second to check whether the system time has rolled over to the\nnext second. On second rollovers, the analog second, minute, and hour hands are re-\ndrawn to reflect the new time (or the text of the digital display\u2019s labels is changed). In\nterms of GUI construction, the analog display is etched out on a canvas, redrawn\nwhenever the window is resized, and changes to a digital format upon request.\nPyClock also puts Python\u2019s standard time module into service to fetch and convert\nsystem time information as needed for a clock. In brief, the onTimer method gets system\ntime with time.time, a built-in tool that returns a floating-point number giving seconds\nsince the epoch\u2014the point from which your computer counts time. The time.local\ntime call is then used to convert epoch time into a tuple that contains hour, minute,\nand second values; see the script and Python library manual for additional details.\nChecking the system time 10 times per second may seem intense, but it guarantees that\nthe second hand ticks when it should, without jerks or skips (after events aren\u2019t pre-\ncisely timed). It is not a significant CPU drain on systems I use. On Linux and Windows,\nPyClock uses negligible processor resources\u2014what it does use is spent largely on screen\nupdates in analog display mode, not on after events.\u00a7\n\u00a7 The PyDemos script of the preceding chapter, for instance, launches seven clocks that run in the same process,\nand all update smoothly on my (relatively slow) Windows 7 netbook laptop. They together consume a low\nsingle-digit percentage of the CPU\u2019s bandwidth, and often less than the Task Manager.\nPyClock: An Analog/Digital Clock Widget | 751To minimize screen updates, PyClock redraws only clock hands on second rollovers;\npoints on the clock\u2019s circle are redrawn only at startup and on window resizes. Fig-\nure 11-20 shows the default initial PyClock display format you get when the file\nclock.py is run directly.\nFigure 11-20. PyClock default analog display\nThe clock hand lines are given arrows at their endpoints with the canvas line object\u2019s\narrow and arrowshape options. The arrow option can be first, last, none, or both; the\narrowshape option takes a tuple giving the length of the arrow touching the line, its\noverall length, and its width.\nLike PyView, PyClock also uses the widget pack_forget and pack methods to dynami-\ncally erase and redraw portions of the display on demand (i.e., in response to bound\nevents). Clicking on the clock with a left mouse button changes its display to digital by\nerasing the analog widgets and drawing the digital interface; you get the simpler display\ncaptured in Figure 11-21.\nFigure 11-21. PyClock goes digital\nThis digital display form is useful if you want to conserve real estate on your computer\nscreen and minimize PyClock CPU utilization (it incurs very little screen update over-\nhead). Left-clicking on the clock again changes back to the analog display. The analog\n752 | Chapter 11:\u2002Complete GUI Programsand digital displays are both constructed when the script starts, but only one is ever\npacked at any given time.\nA right mouse click on the clock in either display mode shows or hides an attached\nlabel that gives the current date in simple text form. Figure 11-22 shows a PyClock\nrunning with an analog display, a clicked-on date label, and a centered photo image\nobject (this is clock style started by the PyGadgets launcher):\nFigure 11-22. PyClock extended display with an image\nThe image in the middle of Figure 11-22 is added by passing in a configuration object\nwith appropriate settings to the PyClock object constructor. In fact, almost everything\nabout this display can be customized with attributes in PyClock configuration\nobjects\u2014hand colors, clock tick colors, center photos, and initial size.\nBecause PyClock\u2019s analog display is based upon a manually sketched figure on a canvas,\nit has to process window resize events itself: whenever the window shrinks or expands,\nthe clock face has to be redrawn and scaled for the new window size. To catch screen\nresizes, the script registers for the <Configure> event with bind; surprisingly, this isn\u2019t\na top-level window manager event like the Close button. As you expand a PyClock, the\nclock face gets bigger with the window\u2014try expanding, shrinking, and maximizing the\nclock window on your computer. Because the clock face is plotted in a square coordi-\nnate system, PyClock always expands in equal horizontal and vertical proportions,\nthough; if you simply make the window only wider or taller, the clock is unchanged.\nAdded in the third edition of this book is a countdown timer feature: press the \u201cs\u201d or\n\u201cm\u201d key to pop up a simple dialog for entering the number of seconds or minutes for\nthe countdown, respectively. Once the countdown expires, the pop up in\nFigure 11-23 appears and fills the entire screen on Windows. I sometimes use this in\nPyClock: An Analog/Digital Clock Widget | 753classes I teach to remind myself and my students when it\u2019s time to move on (the effect\nis more striking when this pop up is projected onto an entire wall!).\nFinally, like PyEdit, PyClock can be run either standalone or attached to and embedded\nin other GUIs that need to display the current time. When standalone, the windows\nmodule from the preceding chapter (Example 10-16) is reused here to get a window\nicon, title, and quit pop up for free. To make it easy to start preconfigured clocks, a\nutility module called clockStyles provides a set of clock configuration objects you can\nimport, subclass to extend, and pass to the clock constructor; Figure 11-24 shows a\nfew of the preconfigured clock styles and sizes in action, ticking away in sync.\nRun clockstyles.py (or select PyClock from PyDemos, which does the same) to recreate\nthis timely scene on your computer. Each of these clocks uses after events to check for\nsystem-time rollover 10 times per second. When run as top-level windows in the same\nprocess, all receive a timer event from the same event loop. When started as independ-\nent programs, each has an event loop of its own. Either way, their second hands sweep\nin unison each second.\nPyClock Source Code\nAll of the PyClock source code lives in one file, except for the precoded configuration\nstyle objects. If you study the code at the bottom of the file shown in Example 11-12,\nyou\u2019ll notice that you can either make a clock object with a configuration object passed\nin or specify configuration options by command-line arguments such as the following\n(in which case, the script simply builds a configuration object for you):\nC:\\...\\PP4E\\Gui\\Clock> clock.py -bg gold -sh brown -size 300\nFigure 11-23. PyClock countdown timer expired\n754 | Chapter 11:\u2002Complete GUI ProgramsMore generally, you can run this file directly to start a clock with or without arguments,\nimport and make its objects with configuration objects to get a more custom display,\nor import and attach its objects to other GUIs. For instance, PyGadgets in Chap-\nter 10 runs this file with command-line options to tailor the display.\nExample 11-12. PP4E\\Gui\\Clock\\clock.py\n\"\"\"\n###############################################################################\nPyClock 2.1: a clock GUI in Python/tkinter.\nWith both analog and digital display modes, a pop-up date label, clock face\nimages, general resizing, etc.  May be run both standalone, or embedded\n(attached) in other GUIs that need a clock.\nNew in 2.0: s/m keys set seconds/minutes timer for pop-up msg; window icon.\nNew in 2.1: updated to run under Python 3.X (2.X no longer supported)\n###############################################################################\n\"\"\"\nfrom tkinter import *\nfrom tkinter.simpledialog import askinteger\nimport math, time, sys\n###############################################################################\n# Option configuration classes\n###############################################################################\nFigure 11-24. A few canned clock styles: clockstyles.py\nPyClock: An Analog/Digital Clock Widget | 755class ClockConfig:\n    # defaults--override in instance or subclass\n    size = 200                                        # width=height\n    bg, fg = 'beige', 'brown'                         # face, tick colors\n    hh, mh, sh, cog = 'black', 'navy', 'blue', 'red'  # clock hands, center\n    picture = None                                    # face photo file\nclass PhotoClockConfig(ClockConfig):\n    # sample configuration\n    size    = 320\n    picture = '../gifs/ora-pp.gif'\n    bg, hh, mh = 'white', 'blue', 'orange'\n###############################################################################\n# Digital display object\n###############################################################################\nclass DigitalDisplay(Frame):\n    def __init__(self, parent, cfg):\n        Frame.__init__(self, parent)\n        self.hour = Label(self)\n        self.mins = Label(self)\n        self.secs = Label(self)\n        self.ampm = Label(self)\n        for label in self.hour, self.mins, self.secs, self.ampm:\n            label.config(bd=4, relief=SUNKEN, bg=cfg.bg, fg=cfg.fg)\n            label.pack(side=LEFT)  # TBD: could expand, and scale font on resize\n    def onUpdate(self, hour, mins, secs, ampm, cfg):\n        mins = str(mins).zfill(2)                          # or '%02d' % x\n        self.hour.config(text=str(hour), width=4)\n        self.mins.config(text=str(mins), width=4)\n        self.secs.config(text=str(secs), width=4)\n        self.ampm.config(text=str(ampm), width=4)\n    def onResize(self, newWidth, newHeight, cfg):\n        pass  # nothing to redraw here\n###############################################################################\n# Analog display object\n###############################################################################\nclass AnalogDisplay(Canvas):\n    def __init__(self, parent, cfg):\n        Canvas.__init__(self, parent,\n                        width=cfg.size, height=cfg.size, bg=cfg.bg)\n        self.drawClockface(cfg)\n        self.hourHand = self.minsHand = self.secsHand = self.cog = None\n    def drawClockface(self, cfg):                         # on start and resize\n        if cfg.picture:                                   # draw ovals, picture\n756 | Chapter 11:\u2002Complete GUI Programstry:\n                self.image = PhotoImage(file=cfg.picture)          # bkground\n            except:\n                self.image = BitmapImage(file=cfg.picture)         # save ref\n            imgx = (cfg.size - self.image.width())  // 2           # center it\n            imgy = (cfg.size - self.image.height()) // 2           # 3.x // div\n            self.create_image(imgx+1, imgy+1,  anchor=NW, image=self.image)\n        originX = originY = radius = cfg.size // 2                 # 3.x // div\n        for i in range(60):\n            x, y = self.point(i, 60, radius-6, originX, originY)\n            self.create_rectangle(x-1, y-1, x+1, y+1, fill=cfg.fg)   # mins\n        for i in range(12):\n            x, y = self.point(i, 12, radius-6, originX, originY)\n            self.create_rectangle(x-3, y-3, x+3, y+3, fill=cfg.fg)   # hours\n        self.ampm = self.create_text(3, 3, anchor=NW, fill=cfg.fg)\n    def point(self, tick, units, radius, originX, originY):\n        angle = tick * (360.0 / units)\n        radiansPerDegree = math.pi / 180\n        pointX = int( round( radius * math.sin(angle * radiansPerDegree) ))\n        pointY = int( round( radius * math.cos(angle * radiansPerDegree) ))\n        return (pointX + originX+1), (originY+1 - pointY)\n    def onUpdate(self, hour, mins, secs, ampm, cfg):        # on timer callback\n        if self.cog:                                        # redraw hands, cog\n            self.delete(self.cog)\n            self.delete(self.hourHand)\n            self.delete(self.minsHand)\n            self.delete(self.secsHand)\n        originX = originY = radius = cfg.size // 2          # 3.x div\n        hour = hour + (mins / 60.0)\n        hx, hy = self.point(hour, 12, (radius * .80), originX, originY)\n        mx, my = self.point(mins, 60, (radius * .90), originX, originY)\n        sx, sy = self.point(secs, 60, (radius * .95), originX, originY)\n        self.hourHand = self.create_line(originX, originY, hx, hy,\n                             width=(cfg.size * .04),\n                             arrow='last', arrowshape=(25,25,15), fill=cfg.hh)\n        self.minsHand = self.create_line(originX, originY, mx, my,\n                             width=(cfg.size * .03),\n                             arrow='last', arrowshape=(20,20,10), fill=cfg.mh)\n        self.secsHand = self.create_line(originX, originY, sx, sy,\n                             width=1,\n                             arrow='last', arrowshape=(5,10,5), fill=cfg.sh)\n        cogsz = cfg.size * .01\n        self.cog = self.create_oval(originX-cogsz, originY+cogsz,\n                                    originX+cogsz, originY-cogsz, fill=cfg.cog)\n        self.dchars(self.ampm, 0, END)\n        self.insert(self.ampm, END, ampm)\n    def onResize(self, newWidth, newHeight, cfg):\n        newSize = min(newWidth, newHeight)\n        #print('analog onResize', cfg.size+4, newSize)\n        if newSize != cfg.size+4:\n            cfg.size = newSize-4\n            self.delete('all')\nPyClock: An Analog/Digital Clock Widget | 757self.drawClockface(cfg)  # onUpdate called next\n###############################################################################\n# Clock composite object\n###############################################################################\nChecksPerSec = 10  # second change timer\nclass Clock(Frame):\n    def __init__(self, config=ClockConfig, parent=None):\n        Frame.__init__(self, parent)\n        self.cfg = config\n        self.makeWidgets(parent)                     # children are packed but\n        self.labelOn = 0                             # clients pack or grid me\n        self.display = self.digitalDisplay\n        self.lastSec = self.lastMin = \u22121\n        self.countdownSeconds = 0\n        self.onSwitchMode(None)\n        self.onTimer()\n    def makeWidgets(self, parent):\n        self.digitalDisplay = DigitalDisplay(self, self.cfg)\n        self.analogDisplay  = AnalogDisplay(self,  self.cfg)\n        self.dateLabel      = Label(self, bd=3, bg='red', fg='blue')\n        parent.bind('<ButtonPress-1>', self.onSwitchMode)\n        parent.bind('<ButtonPress-3>', self.onToggleLabel)\n        parent.bind('<Configure>',     self.onResize)\n        parent.bind('<KeyPress-s>',    self.onCountdownSec)\n        parent.bind('<KeyPress-m>',    self.onCountdownMin)\n    def onSwitchMode(self, event):\n        self.display.pack_forget()\n        if self.display == self.analogDisplay:\n            self.display = self.digitalDisplay\n        else:\n            self.display = self.analogDisplay\n        self.display.pack(side=TOP, expand=YES, fill=BOTH)\n    def onToggleLabel(self, event):\n        self.labelOn += 1\n        if self.labelOn % 2:\n            self.dateLabel.pack(side=BOTTOM, fill=X)\n        else:\n            self.dateLabel.pack_forget()\n        self.update()\n    def onResize(self, event):\n        if event.widget == self.display:\n            self.display.onResize(event.width, event.height, self.cfg)\n    def onTimer(self):\n        secsSinceEpoch = time.time()\n        timeTuple      = time.localtime(secsSinceEpoch)\n        hour, min, sec = timeTuple[3:6]\n758 | Chapter 11:\u2002Complete GUI Programsif sec != self.lastSec:\n            self.lastSec = sec\n            ampm = ((hour >= 12) and 'PM') or 'AM'               # 0...23\n            hour = (hour % 12) or 12                             # 12..11\n            self.display.onUpdate(hour, min, sec, ampm, self.cfg)\n            self.dateLabel.config(text=time.ctime(secsSinceEpoch))\n            self.countdownSeconds -= 1\n            if self.countdownSeconds == 0:\n                self.onCountdownExpire()                # countdown timer\n        self.after(1000 // ChecksPerSec, self.onTimer)  # run N times per second\n                                                        # 3.x // trunc int div\n    def onCountdownSec(self, event):\n        secs = askinteger('Countdown', 'Seconds?')\n        if secs: self.countdownSeconds = secs\n    def onCountdownMin(self, event):\n        secs = askinteger('Countdown', 'Minutes')\n        if secs: self.countdownSeconds = secs * 60\n    def onCountdownExpire(self):\n        # caveat: only one active, no progress indicator\n        win = Toplevel()\n        msg = Button(win, text='Timer Expired!', command=win.destroy)\n        msg.config(font=('courier', 80, 'normal'), fg='white', bg='navy')\n        msg.config(padx=10, pady=10)\n        msg.pack(expand=YES, fill=BOTH)\n        win.lift()                             # raise above siblings\n        if sys.platform[:3] == 'win':          # full screen on Windows\n            win.state('zoomed')\n###############################################################################\n# Standalone clocks\n###############################################################################\nappname = 'PyClock 2.1'\n# use new custom Tk, Toplevel for icons, etc.\nfrom PP4E.Gui.Tools.windows import PopupWindow, MainWindow\nclass ClockPopup(PopupWindow):\n    def __init__(self, config=ClockConfig, name=''):\n        PopupWindow.__init__(self, appname, name)\n        clock = Clock(config, self)\n        clock.pack(expand=YES, fill=BOTH)\nclass ClockMain(MainWindow):\n    def __init__(self, config=ClockConfig, name=''):\n        MainWindow.__init__(self, appname, name)\n        clock = Clock(config, self)\n        clock.pack(expand=YES, fill=BOTH)\n# b/w compat: manual window borders, passed-in parent\nPyClock: An Analog/Digital Clock Widget | 759class ClockWindow(Clock):\n    def __init__(self, config=ClockConfig, parent=None, name=''):\n        Clock.__init__(self, config, parent)\n        self.pack(expand=YES, fill=BOTH)\n        title = appname\n        if name: title = appname + ' - ' + name\n        self.master.title(title)                # master=parent or default\n        self.master.protocol('WM_DELETE_WINDOW', self.quit)\n###############################################################################\n# Program run\n###############################################################################\nif __name__ == '__main__':\n    def getOptions(config, argv):\n        for attr in dir(ClockConfig):              # fill default config obj,\n            try:                                   # from \"-attr val\" cmd args\n                ix = argv.index('-' + attr)        # will skip __x__ internals\n            except:\n                continue\n            else:\n                if ix in range(1, len(argv)-1):\n                    if type(getattr(ClockConfig, attr)) == int:\n                        setattr(config, attr, int(argv[ix+1]))\n                    else:\n                        setattr(config, attr, argv[ix+1])\n   #config = PhotoClockConfig()\n    config = ClockConfig()\n    if len(sys.argv) >= 2:\n        getOptions(config, sys.argv)         # clock.py -size n -bg 'blue'...\n   #myclock = ClockWindow(config, Tk())      # parent is Tk root if standalone\n   #myclock = ClockPopup(ClockConfig(), 'popup')\n    myclock = ClockMain(config)\n    myclock.mainloop()\nAnd finally, Example 11-13 shows the module that is actually run from the PyDemos\nlauncher script\u2014it predefines a handful of clock styles and runs seven of them at once,\nattached to new top-level windows for a demo effect (though one clock per screen is\nusually enough in practice, even for me!).\nExample 11-13. PP4E\\Gui\\Clock\\clockStyles.py\n# precoded clock configuration styles\nfrom clock import *\nfrom tkinter import mainloop\ngifdir = '../gifs/'\nif __name__ == '__main__':\n    from sys import argv\n    if len(argv) > 1:\n        gifdir = argv[1] + '/'\n760 | Chapter 11:\u2002Complete GUI Programsclass PPClockBig(PhotoClockConfig):\n    picture, bg, fg = gifdir + 'ora-pp.gif', 'navy', 'green'\nclass PPClockSmall(ClockConfig):\n    size    = 175\n    picture = gifdir + 'ora-pp.gif'\n    bg, fg, hh, mh = 'white', 'red', 'blue', 'orange'\nclass GilliganClock(ClockConfig):\n    size    = 550\n    picture = gifdir + 'gilligan.gif'\n    bg, fg, hh, mh = 'black', 'white', 'green', 'yellow'\nclass LP4EClock(GilliganClock):\n    size = 700\n    picture = gifdir + 'ora-lp4e.gif'\n    bg = 'navy'\nclass LP4EClockSmall(LP4EClock):\n    size, fg = 350, 'orange'\nclass Pyref4EClock(ClockConfig):\n    size, picture = 400, gifdir + 'ora-pyref4e.gif'\n    bg, fg, hh    = 'black', 'gold', 'brown'\nclass GreyClock(ClockConfig):\n    bg, fg, hh, mh, sh = 'grey', 'black', 'black', 'black', 'white'\nclass PinkClock(ClockConfig):\n    bg, fg, hh, mh, sh = 'pink', 'yellow', 'purple', 'orange', 'yellow'\nclass PythonPoweredClock(ClockConfig):\n    bg, size, picture = 'white', 175, gifdir + 'pythonPowered.gif'\nif __name__ == '__main__':\n    root = Tk()\n    for configClass in [\n        ClockConfig,\n        PPClockBig,\n        #PPClockSmall,\n        LP4EClockSmall,\n        #GilliganClock,\n        Pyref4EClock,\n        GreyClock,\n        PinkClock,\n        PythonPoweredClock\n    ]:\n        ClockPopup(configClass, configClass.__name__)\n    Button(root, text='Quit Clocks', command=root.quit).pack()\n    root.mainloop()\nRunning this script creates the multiple clock display of Figure 11-24. Its configurations\nsupport numerous options; judging from the seven clocks on the display, though, it\u2019s\ntime to move on to our last example.\nPyClock: An Analog/Digital Clock Widget | 761PyToe: A Tic-Tac-Toe Game Widget\nFinally, a bit of fun to close out this chapter. Our last example, PyToe, implements an\nartificially intelligent tic-tac-toe (sometimes called \u201cnaughts and crosses\u201d) game-\nplaying program in Python. Most readers are probably familiar with this simple game,\nso I won\u2019t dwell on its details. In short, players take turns marking board positions, in\nan attempt to occupy an entire row, column, or diagonal. The first player to fill such a\npattern wins.\nIn PyToe, board positions are marked with mouse clicks, and one of the players is a\nPython program. The game board itself is displayed with a simple tkinter GUI; by\ndefault, PyToe builds a 3 \u00d7 3 game board (the standard tic-tac-toe setup), but it can be\nconfigured to build and play an arbitrary N \u00d7 N game.\nWhen it comes time for the computer to select a move, artificial intelligence (AI) algo-\nrithms are used to score potential moves and search a tree of candidate moves and\ncountermoves. This is a fairly simple problem as gaming programs go, and the heuristics\nused to pick moves are not perfect. Still, PyToe is usually smart enough to spot wins a\nfew moves in advance of the user.\nRunning PyToe\nPyToe\u2019s GUI is implemented as a frame of expandable packed labels, with mouse-click\nbindings on the labels to catch user moves. The label\u2019s text is configured with the\nplayer\u2019s mark after each move, computer or user. The GuiMaker class we coded earlier\nin the prior chapter (Example 10-3) is also reused here again to add a simple menu bar\nat the top (but no toolbar is drawn at the bottom, because PyToe leaves its format\ndescriptor empty). By default, the user\u2019s mark is \u201cX\u201d and PyToe\u2019s is \u201cO.\u201d Fig-\nure 11-25 shows PyToe run from PyGadgets with its status pop-up dialog, on the verge\nof beating me one of two ways.\nFigure 11-26 shows PyToe\u2019s help pop-up dialog, which lists its command-line config-\nuration options. You can specify colors and font sizes for board labels, the player who\nmoves first, the mark of the user (\u201cX\u201d or \u201cO\u201d), the board size (to override the 3 \u00d7 3\ndefault), and the move selection strategy for the computer (e.g., \u201cMinimax\u201d performs\na move tree search to spot wins and losses, and \u201cExpert1\u201d and \u201cExpert2\u201d use static\nscoring heuristics functions).\nThe AI gaming techniques used in PyToe are CPU intensive, and some computer move\nselection schemes take longer than others, but their speed varies mostly with the speed\nof your computer. Move selection delays are fractions of a second long on my machine\nfor a 3 \u00d7 3 game board, for all \u201c-mode\u201d move-selection strategy options.\nFigure 11-27 shows an alternative PyToe configuration (shown running its top-level\nscript directly with no arguments), just after it beat me. Despite the scenes captured\nfor this book, under some move selection options, I do still win once in a while. In\n762 | Chapter 11:\u2002Complete GUI Programslarger boards and more complex games, PyToe\u2019s move selection algorithms become\neven more useful.\nPyToe Source Code (External)\nPyToe is a big system that assumes some AI background knowledge and doesn\u2019t really\ndemonstrate anything new in terms of GUIs. Moreover, it was written for Python 2.X\nover a decade ago, and though ported to 3.X for this edition, some of it might be better\nrecoded from scratch today. Partly because of that, but mostly because I have a page\nlimit for this book, I\u2019m going to refer you to the book\u2019s examples distribution package\nfor its source code instead of listing it here. Please see these two files in the examples\ndistribution for PyToe implementation details:\nPP4E\\Ai\\TicTacToe\\tictactoe.py\nA top-level wrapper script\nPP4E\\Ai\\TicTacToe\\tictactoe_lists.py\nThe meat of the implementation\nFigure 11-25. PyToe thinking its way to a win\nPyToe: A Tic-Tac-Toe Game Widget | 763If you do look, though, probably the best hint I can give you is that the data structure\nused to represent board state is the crux of the matter. That is, if you understand the\nway boards are modeled, the rest of the code comes naturally.\nFor instance, the lists-based variant uses a list-of-lists to represent the board\u2019s state,\nalong with a simple dictionary of entry widgets for the GUI indexed by board coordi-\nnates. Clearing the board after a game is simply a matter of clearing the underlying data\nstructures, as shown in this code excerpt from the examples named earlier:\nFigure 11-26. PyToe help pop up with options info\n764 | Chapter 11:\u2002Complete GUI Programsdef clearBoard(self):\n    for row, col in self.label.keys():\n        self.board[row][col] = Empty\n        self.label[(row, col)].config(text=' ')\nSimilarly, picking a move, at least in random mode, is simply a matter of picking a\nnonempty slot in the board array and storing the machine\u2019s mark there and in the GUI\n(degree is the board\u2019s size):\ndef machineMove(self):\n    row, col = self.pickMove()\n    self.board[row][col] = self.machineMark\n    self.label[(row, col)].config(text=self.machineMark)\ndef pickMove(self):\n    empties = []\n    for row in self.degree:\n        for col in self.degree:\n            if self.board[row][col] == Empty:\n                empties.append((row, col))\n    return random.choice(empties)\nFinally, checking for an end-of-game state boils down to inspecting rows, columns, and\ndiagonals in the two-dimensional list-of-lists board in this scheme:\nFigure 11-27. An alternative layout\nPyToe: A Tic-Tac-Toe Game Widget | 765def checkDraw(self, board=None):\n    board = board or self.board\n    for row in board:\n        if Empty in row:\n            return 0\n    return 1 # none empty: draw or win\ndef checkWin(self, mark, board=None):\n    board = board or self.board\n    for row in board:\n        if row.count(mark) == self.degree:     # check across\n            return 1\n    for col in range(self.degree):\n        for row in board:                      # check down\n            if row[col] != mark:\n                break\n        else:\n            return 1\n    for row in range(self.degree):             # check diag1\n        col = row                              # row == col\n        if board[row][col] != mark: break\n    else:\n        return 1\n    for row in range(self.degree):             # check diag2\n        col = (self.degree-1) - row            # row+col = degree-1\n        if board[row][col] != mark: break\n    else:\n        return 1\ndef checkFinish(self):\n    if self.checkWin(self.userMark):\n        outcome = \"You've won!\"\n    elif self.checkWin(self.machineMark):\n        outcome = 'I win again :-)'\n    elif self.checkDraw():\n        outcome = 'Looks like a draw'\nOther move-selection code mostly just performs other kinds of analysis on the board\ndata structure or generates new board states to search a tree of moves and\ncountermoves.\nYou\u2019ll also find relatives of these files in the same directory that implements alternative\nsearch and move-scoring schemes, different board representations, and so on. For ad-\nditional background on game scoring and searches in general, consult an AI text. It\u2019s\nfun stuff, but it\u2019s too specialized to cover well in this book.\nWhere to Go from Here\nThis concludes the GUI section of this book, but this is not an end to the book\u2019s GUI\ncoverage. If you want to learn more about GUIs, be sure to see the tkinter examples\nthat appear later in this book and are described at the start of this chapter. PyMailGUI,\nPyCalc, and the mostly external PyForm and PyTree provide additional GUI case\n766 | Chapter 11:\u2002Complete GUI Programsstudies. In the next section of this book, we\u2019ll also learn how to build user interfaces\nthat run in web browsers\u2014a very different concept, but another option for interface\ndesign.\nKeep in mind, too, that even if you don\u2019t see a GUI example in this book that looks\nvery close to one you need to program, you\u2019ve already met all the building blocks.\nConstructing larger GUIs for your application is really just a matter of laying out hier-\narchical composites of the widgets presented in this part of the text.\nFor instance, a complex display might be composed as a collection of radio buttons,\nlistboxes, scales, text fields, menus, and so on\u2014all arranged in frames or grids to ach-\nieve the desired appearance. Pop-up top-level windows, as well as independently run\nGUI programs linked with Inter-Process Communication (IPC) mechanisms, such as\npipes, signals, and sockets, can further supplement a complex graphical interface.\nMoreover, you can implement larger GUI components as Python classes and attach or\nextend them anywhere you need a similar interface device; see PyEdit\u2019s role in PyView\nand PyMailGUI for a prime example. With a little creativity, tkinter\u2019s widget set and\nPython support a virtually unlimited number of layouts.\nBeyond this book, see the tkinter documentation overview in Chapter 7, the books\ndepartment at Python\u2019s website at http://www.python.org, and the Web at large. Finally,\nif you catch the tkinter bug, I want to again recommend downloading and experiment-\ning with the packages introduced in Chapter 7\u2014especially Pmw, PIL, Tix, and ttk (Tix\nand ttk are a standard part of Python today). Such extensions add additional tools to\nthe tkinter arsenal that can make your GUIs more sophisticated, with minimal coding.\nWhere to Go from Here | 767PART IV\nInternet Programming\nThis part of the book explores Python\u2019s role as a language for programming Internet-\nbased applications, and its library tools that support this role. Along the way, system \nand GUI tools presented earlier in the book are put to use as well. Because this is a \npopular Python domain, chapters here cover all fronts:\nChapter 12 \nThis chapter introduces Internet concepts and options, presents Python low-level \nnetwork tools such as sockets, and covers client and server basics.\nChapter 13 \nThis chapter shows you how your scripts can use Python to access common client-\nside network protocols like FTP, email, HTTP, and more.\nChapter 14 \nThis chapter uses the client-side email tools covered in the prior chapter, as well \nas the GUI techniques of the prior part, to implement a full-featured email client.\nChapter 15 \nThis chapter introduces the basics of Python server-side Common Gateway Inter-\nface (CGI) scripts\u2014a kind of program used to implement interactive websites.\nChapter 16 \nThis chapter demonstrates Python website techniques by implementing a web-\nbased email tool on a server, in part to compare and contrast with Chapter 14\u2019s \nnonweb approach.\nAlthough they are outside this book\u2019s scope, Chapter 12 also provides brief overviews \nof more advanced Python Internet tools best covered in follow-up resources, such as \nJython, Django, App Engine, Zope, PSP, pyjamas, and HTMLgen. Here, you\u2019ll learn \nthe fundamentals needed to use such tools when you\u2019re ready to step up.\nAlong the way, we\u2019ll also put general programming concepts such as object-oriented \nprogramming (OOP) and code refactoring and reuse to work here. As we\u2019ll see, Python, \nGUIs, and networking are a powerful combination.", "12": "CHAPTER 12\nNetwork Scripting\n\u201cTune In, Log On, and Drop Out\u201d\nOver the 15 years since this book was first published, the Internet has virtually exploded \nonto the mainstream stage. It has rapidly grown from a simple communication device \nused primarily by academics and researchers into a medium that is now nearly as per-\nvasive as the television and telephone. Social observers have likened the Internet\u2019s cul-\ntural impact to that of the printing press, and technical observers have suggested that \nall new software development of interest occurs only on the Internet. Naturally, time \nwill be the final arbiter for such claims, but there is little doubt that the Internet is a \nmajor force in society and one of the main application contexts for modern software \nsystems.\nThe Internet also happens to be one of the primary application domains for the Python \nprogramming language. In the decade and a half since the first edition of this book was \nwritten, the Internet\u2019s growth has strongly influenced Python\u2019s tool set and roles. Given \nPython and a computer with a socket-based Internet connection today, we can write \nPython scripts to read and send email around the world, fetch web pages from remote \nsites, transfer files by FTP, program interactive websites, parse HTML and XML files, \nand much more, simply by using the Internet modules that ship with Python as standard \ntools.\nIn fact, companies all over the world do: Google, YouTube, Walt Disney, Hewlett-\nPackard, JPL, and many others rely on Python\u2019s standard tools to power their websites. \nFor example, the Google search engine\u2014widely credited with making the Web \nusable\u2014makes extensive use of Python code. The YouTube video server site is largely \nimplemented in Python. And the BitTorrent peer-to-peer file transfer system\u2014written \nin Python and downloaded by tens of millions of users\u2014leverages Python\u2019s networking \nskills to share files among clients and remove some server bottlenecks.\nMany also build and manage their sites with larger Python-based toolkits. For instance, \nthe Zope web application server was an early entrant to the domain and is itself written \nand customizable in Python. Others build sites with the Plone content management\n771system, which is built upon Zope and delegates site content to its users. Still others use\nPython to script Java web applications with Jython (formerly known as JPython)\u2014a\nsystem that compiles Python programs to Java bytecode, exports Java libraries for use\nin Python scripts, and allows Python code to serve as web applets downloaded and run\nin a browser.\nIn more recent years, new techniques and systems have risen to prominence in the Web\nsphere. For example, XML-RPC and SOAP interfaces for Python have enabled web\nservice programming; frameworks such as Google App Engine, Django, and Turbo-\nGears have emerged as powerful tools for constructing websites; the XML package in\nPython\u2019s standard library, as well as third-party extensions, provides a suite of XML\nprocessing tools; and the IronPython implementation provides seamless .NET/Mono\nintegration for Python code in much the same way Jython leverages Java libraries.\nAs the Internet has grown, so too has Python\u2019s role as an Internet tool. Python has\nproven to be well suited to Internet scripting for some of the very same reasons that\nmake it ideal in other domains. Its modular design and rapid turnaround mix well with\nthe intense demands of Internet development. In this part of the book, we\u2019ll find that\nPython does more than simply support Internet scripting; it also fosters qualities such\nas productivity and maintainability that are essential to Internet projects of all shapes\nand sizes.\nInternet Scripting Topics\nInternet programming entails many topics, so to make the presentation easier to digest,\nI\u2019ve split this subject over the next five chapters of this book. Here\u2019s this part\u2019s chapter\nrundown:\n\u2022 This chapter introduces Internet fundamentals and explores sockets, the underly-\ning communications mechanism of the Internet. We met sockets briefly as IPC\ntools in Chapter 5 and again in a GUI use case in Chapter 10, but here we will study\nthem in the depth afforded by their broader networking roles.\n\u2022 Chapter 13 covers the fundamentals of client-side scripting and Internet protocols.\nHere, we\u2019ll explore Python\u2019s standard support for FTP, email, HTTP, NNTP, and\nmore.\n\u2022 Chapter 14 presents a larger client-side case study: PyMailGUI, a full-featured\nemail client.\n\u2022 Chapter 15 discusses the fundamentals of server-side scripting and website con-\nstruction. We\u2019ll study basic CGI scripting techniques and concepts that underlie\nmost of what happens in the Web.\n\u2022 Chapter 16 presents a larger server-side case study: PyMailCGI, a full-featured\nwebmail site.\nEach chapter assumes you\u2019ve read the previous one, but you can generally skip around,\nespecially if you have prior experience in the Internet domain. Since these chapters\n772 | Chapter 12:\u2002Network Scriptingrepresent a substantial portion of this book at large, the following sections go into a\nfew more details about what we\u2019ll be studying.\nWhat we will cover\nIn conceptual terms, the Internet can roughly be thought of as being composed of\nmultiple functional layers:\nLow-level networking layers\nMechanisms such as the TCP/IP transport mechanism, which deal with transfer-\nring bytes between machines, but don\u2019t care what they mean\nSockets\nThe programmer\u2019s interface to the network, which runs on top of physical net-\nworking layers like TCP/IP and supports flexible client/server models in both IPC\nand networked modes\nHigher-level protocols\nStructured Internet communication schemes such as FTP and email, which run on\ntop of sockets and define message formats and standard addresses\nServer-side web scripting\nApplication models such as CGI, which define the structure of communication\nbetween web browsers and web servers, also run on top of sockets, and support\nthe notion of web-based programs\nHigher-level frameworks and tools\nThird-party systems such as Django, App Engine, Jython, and pyjamas, which\nleverage sockets and communication protocols, too, but address specific techni-\nques or larger problem domains\nThis book covers the middle three tiers in this list\u2014sockets, the Internet protocols that\nrun on them, and the CGI model of web-based conversations. What we learn here will\nalso apply to more specific toolkits in the last tier above, because they are all ultimately\nbased upon the same Internet and web fundamentals.\nMore specifically, in this and the next chapter, our main focus is on programming the\nsecond and third layers: sockets and higher-level Internet protocols. We\u2019ll start this\nchapter at the bottom, learning about the socket model of network programming.\nSockets aren\u2019t strictly tied to Internet scripting, as we saw in Chapter 5\u2019s IPC examples,\nbut they are presented in full here because this is one of their primary roles. As we\u2019ll\nsee, most of what happens on the Internet happens through sockets, whether you notice\nor not.\nAfter introducing sockets, the next two chapters make their way up to Python\u2019s client-\nside interfaces to higher-level protocols\u2014things like email and FTP transfers, which\nrun on top of sockets. It turns out that a lot can be done with Python on the client alone,\nand Chapters 13 and 14 will sample the flavor of Python client-side scripting. Finally,\nthe last two chapters in this part of the book then move on to present server-side\n\u201cTune In, Log On, and Drop Out\u201d | 773scripting\u2014programs that run on a server computer and are usually invoked by a web\nbrowser.\nWhat we won\u2019t cover\nNow that I\u2019ve told you what we will cover in this book, I also want to be clear about\nwhat we won\u2019t cover. Like tkinter, the Internet is a vast topic, and this part of the book\nis mostly an introduction to its core concepts and an exploration of representative tasks.\nBecause there are so many Internet-related modules and extensions, this book does not\nattempt to serve as an exhaustive survey of the domain. Even in just Python\u2019s own tool\nset, there are simply too many Internet modules to include each in this text in any sort\nof useful fashion.\nMoreover, higher-level tools like Django, Jython, and App Engine are very large systems\nin their own right, and they are best dealt with in more focused documents. Because\ndedicated books on such topics are now available, we\u2019ll merely scratch their surfaces\nhere with a brief survey later in this chapter. This book also says almost nothing about\nlower-level networking layers such as TCP/IP. If you\u2019re curious about what happens\non the Internet at the bit-and-wire level, consult a good networking text for more\ndetails.\nIn other words, this part is not meant to be an exhaustive reference to Internet and web\nprogramming with Python\u2014a topic which has evolved between prior editions of this\nbook, and will undoubtedly continue to do so after this one is published. Instead, the\ngoal of this part of the book is to serve as a tutorial introduction to the domain to help\nyou get started, and to provide context and examples which will help you understand\nthe documentation for tools you may wish to explore after mastering the fundamentals\nhere.\nOther themes in this part of the book\nLike the prior parts of the book, this one has other agendas, too. Along the way, this\npart will also put to work many of the operating-system and GUI interfaces we studied\nin Parts II and III (e.g., processes, threads, signals, and tkinter). We\u2019ll also get to see\nthe Python language applied in realistically scaled programs, and we\u2019ll investigate some\nof the design choices and challenges that the Internet presents.\nThat last statement merits a few more words. Internet scripting, like GUIs, is one of\nthe \u201csexier\u201d application domains for Python. As in GUI work, there is an intangible but\ninstant gratification in seeing a Python Internet program ship information all over the\nworld. On the other hand, by its very nature, network programming can impose speed\noverheads and user interface limitations. Though it may not be a fashionable stance\nthese days, some applications are still better off not being deployed on the Web.\nA traditional \u201cdesktop\u201d GUI like those of Part III, for example, can combine the feature-\nrichness and responsiveness of client-side libraries with the power of network access.\nOn the other hand, web-based applications offer compelling benefits in portability and\n774 | Chapter 12:\u2002Network Scriptingadministration. In this part of the book, we will take an honest look at the Net\u2019s trade-\noffs as they arise and explore examples which illustrate the advantages of both web and\nnonweb architectures. In fact, the larger PyMailGUI and PyMailCGI examples we\u2019ll\nexplore are intended in part to serve this purpose.\nThe Internet is also considered by many to be something of an ultimate proof of concept\nfor open source tools. Indeed, much of the Net runs on top of a large number of such\ntools, such as Python, Perl, the Apache web server, the sendmail program, MySQL, and \nLinux.* Moreover, new tools and technologies for programming the Web sometimes\nseem to appear faster than developers can absorb them.\nThe good news is that Python\u2019s integration focus makes it a natural in such a hetero-\ngeneous world. Today, Python programs can be installed as client-side and server-side\ntools; used as applets and servlets in Java applications; mixed into distributed object\nsystems like CORBA, SOAP, and XML-RPC; integrated into AJAX-based applications;\nand much more. In more general terms, the rationale for using Python in the Internet\ndomain is exactly the same as in any other\u2014Python\u2019s emphasis on quality, productiv-\nity, portability, and integration makes it ideal for writing Internet programs that are\nopen, maintainable, and delivered according to the ever-shrinking schedules in this\nfield.\nRunning Examples in This Part of the Book\nInternet scripts generally imply execution contexts that earlier examples in this book\nhave not. That is, it usually takes a bit more to run programs that talk over networks.\nHere are a few pragmatic notes about this part\u2019s examples, up front:\n\u2022 You don\u2019t need to download extra packages to run examples in this part of the\nbook. All of the examples we\u2019ll see are based on the standard set of Internet-related\nmodules that come with Python and are installed in Python\u2019s library directory.\n\u2022 You don\u2019t need a state-of-the-art network link or an account on a web server to\nrun the socket and client-side examples in this part. Although some socket exam-\nples will be shown running remotely, most can be run on a single local machine.\nClient-side examples that demonstrate protocol like FTP require only basic Inter-\nnet access, and email examples expect just POP and SMTP capable servers.\n\u2022 You don\u2019t need an account on a web server machine to run the server-side scripts\nin later chapters; they can be run by any web browser. You may need such an\naccount to change these scripts if you store them remotely, but not if you use a\nlocally running web server as we will in this book.\n* There is even a common acronym for this today: LAMP, for the Linux operating system, the Apache web\nserver, the MySQL database system, and the Python, Perl, and PHP scripting languages. It\u2019s possible, and\neven very common, to put together an entire enterprise-level web server with open source tools. Python users\nwould probably also like to include systems like Zope, Django, Webware, and CherryPy in this list, but the\nresulting acronym might be a bit of a stretch.\n\u201cTune In, Log On, and Drop Out\u201d | 775We\u2019ll discuss configuration details as we move along, but in short, when a Python script\nopens an Internet connection (with the socket module or one of the Internet protocol\nmodules), Python will happily use whatever Internet link exists on your machine, be\nthat a dedicated T1 line, a DSL line, or a simple modem. For instance, opening a socket\non a Windows PC automatically initiates processing to create a connection to your\nInternet provider if needed.\nMoreover, as long as your platform supports sockets, you probably can run many of\nthe examples here even if you have no Internet connection at all. As we\u2019ll see, a machine\nname localhost or \"\" (an empty string) usually means the local computer itself. This\nallows you to test both the client and the server sides of a dialog on the same computer\nwithout connecting to the Net. For example, you can run both socket-based clients and\nservers locally on a Windows PC without ever going out to the Net. In other words,\nyou can likely run the programs here whether you have a way to connect to the Internet\nor not.\nSome later examples assume that a particular kind of server is running on a server\nmachine (e.g., FTP, POP, SMTP), but client-side scripts themselves work on any\nInternet-aware machine with Python installed. Server-side examples in Chapters 15\nand 16 require more: to develop CGI scripts, you\u2019ll need to either have a web server\naccount or run a web server program locally on your own computer (which is easier\nthan you may think\u2014we\u2019ll learn how to code a simple one in Python in Chapter 15).\nAdvanced third-party systems like Jython and Zope must be downloaded separately,\nof course; we\u2019ll peek at some of these briefly in this chapter but defer to their own\ndocumentation for more details.\nIn the Beginning There Was Grail\nBesides creating the Python language, Guido van Rossum also wrote a World Wide\nWeb browser in Python years ago, named (appropriately enough) Grail. Grail was\npartly developed as a demonstration of Python\u2019s capabilities. It allows users to browse\nthe Web much like Firefox or Internet Explorer, but it can also be programmed with\nGrail applets\u2014Python/tkinter programs downloaded from a server when accessed and\nrun on the client by the browser. Grail applets work much like Java applets in more\nwidespread browsers (more on applets in the next section).\nThough it was updated to run under recent Python releases as I was finishing this\nedition, Grail is no longer under active development today, and it is mostly used for\nresearch purposes (indeed, the Netscape browser was counted among its contempo-\nraries). Nevertheless, Python still reaps the benefits of the Grail project, in the form of\na rich set of Internet tools. To write a full-featured web browser, you need to support\na wide variety of Internet protocols, and Guido packaged support for all of these as\nstandard library modules that were eventually shipped with the Python language.\nBecause of this legacy, Python now includes standard support for Usenet news (NNTP),\nemail processing (POP, SMTP, IMAP), file transfers (FTP), web pages and interactions\n(HTTP, URLs, HTML, CGI), and other commonly used protocols such as Telnet.\n776 | Chapter 12:\u2002Network ScriptingPython scripts can connect to all of these Internet components by simply importing the\nassociated library module.\nSince Grail, additional tools have been added to Python\u2019s library for parsing XML files,\nOpenSSL secure sockets, and more. But much of Python\u2019s Internet support can be\ntraced back to the Grail browser\u2014another example of Python\u2019s support for code reuse\nat work. At this writing, you can still find the Grail by searching for \u201cGrail web browser\u201d\nat your favorite web search engine.\nPython Internet Development Options\nAlthough many are outside our scope here, there are a variety of ways that Python\nprogrammers script the Web. Just as we did for GUIs, I want to begin with a quick\noverview of some of the more popular tools in this domain before we jump into the\nfundamentals.\nNetworking tools\nAs we\u2019ll see in this chapter, Python comes with tools the support basic networking,\nas well as implementation of custom types of network servers. This includes sock-\nets, but also the select call for asynchronous servers, as well as higher-order and\npre-coded socket server classes. Standard library modules socket, select, and\nsocketserver support all these roles.\nClient-side protocol tools\nAs we\u2019ll see in the next chapter, Python\u2019s Internet arsenal also includes canned\nsupport for the client side of most standard Internet protocols\u2014scripts can easily\nmake use of FTP, email, HTTP, Telnet, and more. Especially when wedded to\ndesktop GUIs of the sort we met in the preceding part of this book, these tools\nopen the door to full-featured and highly responsive Web-aware applications.\nServer-side CGI scripting\nPerhaps the simplest way to implement interactive website behavior, CGI script-\ning is an application model for running scripts on servers to process form data, take\naction based upon it, and produce reply pages. We\u2019ll use it later in this part of the\nbook. It\u2019s supported by Python\u2019s standard library directly, is the basis for much of\nwhat happens on the Web, and suffices for simpler site development tasks. Raw\nCGI scripting doesn\u2019t by itself address issues such as cross-page state retention and\nconcurrent updates, but CGI scripts that use devices like cookies and database\nsystems often can.\nWeb frameworks and clouds\nFor more demanding Web work, frameworks can automate many of the low-level\ndetails and provide more structured and powerful techniques for dynamic site im-\nplementation. Beyond basic CGI scripts, the Python world is flush with third-party\nweb frameworks such as Django\u2014a high-level framework that encourages rapid\ndevelopment and clean, pragmatic design and includes a dynamic database access\nPython Internet Development Options | 777API and its own server-side templating language; Google App Engine\u2014a \u201ccloud\ncomputing\u201d framework that provides enterprise-level tools for use in Python scripts\nand allows sites to leverage the capacity of Google\u2019s Web infrastructure; and Turbo\nGears\u2014an integrated collection of tools including a JavaScript library, a template\nsystem, CherryPy for web interaction, and SQLObject for accessing databases us-\ning Python\u2019s class model.\nAlso in the framework category are Zope\u2014an open source web application server\nand toolkit, written in and customizable with Python, in which websites are im-\nplemented using a fundamentally object-oriented model; Plone\u2014a Zope-based\nwebsite builder which provides a workflow model (called a content management\nsystem) that allows content producers to add their content to a site; and other\npopular systems for website construction, including pylons, web2py, CherryPy, and\nWebware.\nMany of these frameworks are based upon the now widespread MVC (model-view-\ncontroller) structure, and most provide state retention solutions that wrap database\nstorage. Some make use of the ORM (object relational mapping) model we\u2019ll meet\nin the next part of the book, which superimposes Python\u2019s classes onto relational\ndatabase tables, and Zope stores objects in your site in the ZODB object-oriented\ndatabase we\u2019ll study in the next part as well.\nRich Internet Applications (revisited)\nDiscussed at the start of Chapter 7, newer and emerging \u201crich Internet application\u201d\n(RIA) systems such as Flex, Silverlight, JavaFX, and pyjamas allow user interfaces\nimplemented in web browsers to be much more dynamic and functional than\nHTML has traditionally allowed. These are client-side solutions, based generally\nupon AJAX and JavaScript, which provide widget sets that rival those of traditional\n\u201cdesktop\u201d GUIs and provide for asynchronous communication with web servers.\nAccording to some observers, such interactivity is a major component of the \u201cWeb\n2.0\u201d model.\nUltimately, the web browser is a \u201cdesktop\u201d GUI application, too, albeit one which\nis very widely available and which can be generalized with RIA techniques to serve\nas a platform for rendering other GUIs, using software layers that do not rely on a\nparticular GUI library. In effect, RIAs turn web browsers into extendable GUIs.\nAt least that\u2019s their goal today. Compared to traditional GUIs, RIAs gain some\nportability and deployment simplicity, in exchange for decreased performance and\nincreased software stack complexity. Moreover, much as in the GUI realm, there\nare already competing RIA toolkits today which may add dependencies and impact\nportability. Unless a pervasive frontrunner appears, using a RIA application may\nrequire an install step, not unlike desktop applications.\nStay tuned, though; like the Web at large, the RIA story is still a work in progress.\nThe emerging HTML5 standard, for instance, while likely not to become prevalent\nfor some years to come, may obviate the need for RIA browser plug-ins eventually.\n778 | Chapter 12:\u2002Network ScriptingWeb services: XML-RPC, SOAP\nXML-RPC is a technology that provides remote procedural calls to components \nover networks. It routes requests over the HTTP protocol and ships data back and\nforth packaged as XML text. To clients, web servers appear to be simple functions;\nwhen function calls are issued, passed data is encoded as XML and shipped to\nremote servers using the Web\u2019s HTTP transport mechanism. The net effect is to\nsimplify the interface to web servers in client-side programs.\nMore broadly, XML-RPC fosters the notion of web services\u2014reusable software\ncomponents that run on the Web\u2014and is supported by Python\u2019s xmlrpc.client\nmodule, which handles the client side of this protocol, and xmlrcp.server, which\nprovides tools for the server side. SOAP is a similar but generally heavier web serv-\nices protocol, available to Python in the third-party SOAPy and ZSI packages,\namong others.\nCORBA ORBs\nAn earlier but comparable technology, CORBA is an architecture for distributed\nprogramming, in which components communicate across a network by routing\ncalls through an Object Request Broker (ORB). Python support for CORBA is\navailable in the third-party OmniORB package, as well as the (still available though\nnot recently maintained) ILU system.\nJava and .NET: Jython and IronPython\nWe also met Jython and IronPython briefly at the start of Chapter 7, in the context\nof GUIs. By compiling Python script to Java bytecode, Jython also allows Python\nscripts to be used in any context that Java programs can. This includes web-\noriented roles, such as applets stored on the server but run on the client when\nreferenced within web pages. The IronPython system also mentioned in Chap-\nter 7 similarly offers Web-focused options, including access to the Silverlight RIA\nframework and its Moonlight implementation in the Mono system for Linux.\nScreen scraping: XML and HTML parsing tools\nThough not technically tied to the Internet, XML text often appears in such roles.\nBecause of its other roles, though, we\u2019ll study Python\u2019s basic XML parsing support,\nas well as third-party extensions to it, in the next part of this book, when we explore\nPython\u2019s text processing toolkit. As we\u2019ll see, Python\u2019s xml package comes with\nsupport for DOM, SAX, and ElementTree style XML parsing, and the open source\ndomain provides extensions for XPath and much more. Python\u2019s html.parser li-\nbrary module also provides a HTML-specific parser, with a model not unlike that\nof XML\u2019s SAX technique. Such tools can be used in screen scraping roles, to extract\ncontent of web pages fetched with urllib.request tools.\nWindows COM and DCOM\nThe PyWin32 package allows Python scripts to communicate via COM on Win-\ndows to perform feats such as editing Word documents and populating Excel\nspreadsheets (additional tools support Excel document processing). Though not\nrelated to the Internet itself (and being arguably upstaged by .NET in recent years),\nPython Internet Development Options | 779the distributed extension to COM, DCOM, offers additional options for distrib-\nuting applications over networks.\nOther tools\nOther tools serve more specific roles. Among this crowd are mod_python\u2014a system\nwhich optimizes the execution of Python server-scripts in the Apache web\nserver; Twisted\u2014an asynchronous, event-driven, networking framework written\nin Python, with support for a large number of network protocols and with precoded\nimplementations of common network servers; HTMLgen\u2014a lightweight tool that\nallows HTML code to be generated from a tree of Python objects that describes a\nweb page; and Python Server Pages (PSP)\u2014a server-side templating technology\nthat embeds Python code inside HTML, runs it with request context to render part\nof a reply page, and is strongly reminiscent of PHP, ASP, and JSP.\nAs you might expect given the prominence of the Web, there are more Internet tools\nfor Python than we have space to discuss here. For more on this front, see the PyPI\nwebsite at http://python.org/, or visit your favorite web search engine (some of which\nare implemented using Python\u2019s Internet tools themselves).\nAgain, the goal of this book is to cover the fundamentals in an in-depth way, so that\nyou\u2019ll have the context needed to use tools like some of those above well, when you\u2019re\nready to graduate to more comprehensive solutions. As we\u2019ll see, the basic model of\nCGI scripting we\u2019ll meet here illustrates the mechanisms underlying all web develop-\nment, whether it\u2019s implemented by bare-bones scripts, or advanced frameworks.\nBecause we must walk before we can run well, though, let\u2019s start at the bottom here,\nand get a handle on what the Internet really is. The Internet today rests upon a rich\nsoftware stack; while tools can hide some of its complexity, programming it skillfully\nstill requires knowledge of all its layers. As we\u2019ll see, deploying Python on the Web,\nespecially with higher-order web frameworks like those listed above, is only possible\nbecause we truly are \u201csurfing on the shoulders of giants.\u201d\nPlumbing the Internet\nUnless you\u2019ve been living in a cave for the last decade or two, you are probably already\nfamiliar with the Internet, at least from a user\u2019s perspective. Functionally, we use it as\na communication and information medium, by exchanging email, browsing web pages,\ntransferring files, and so on. Technically, the Internet consists of many layers of ab-\nstraction and devices\u2014from the actual wires used to send bits across the world to the\nweb browser that grabs and renders those bits into text, graphics, and audio on your\ncomputer.\nIn this book, we are primarily concerned with the programmer\u2019s interface to the Inter-\nnet. This, too, consists of multiple layers: sockets, which are programmable interfaces\nto the low-level connections between machines, and standard protocols, which add\n780 | Chapter 12:\u2002Network Scriptingstructure to discussions carried out over sockets. Let\u2019s briefly look at each of these layers\nin the abstract before jumping into programming details.\nThe Socket Layer\nIn simple terms, sockets are a programmable interface to connections between pro-\ngrams, possibly running on different computers of a network. They allow data format-\nted as byte strings to be passed between processes and machines. Sockets also form the\nbasis and low-level \u201cplumbing\u201d of the Internet itself: all of the familiar higher-level Net\nprotocols, like FTP, web pages, and email, ultimately occur over sockets. Sockets are\nalso sometimes called communications endpoints because they are the portals through\nwhich programs send and receive bytes during a conversation.\nAlthough often used for network conversations, sockets may also be used as a com-\nmunication mechanism between programs running on the same computer, taking the\nform of a general Inter-Process Communication (IPC) mechanism. We saw this socket\nusage mode briefly in Chapter 5. Unlike some IPC devices, sockets are bidirectional\ndata streams: programs may both send and receive data through them.\nTo programmers, sockets take the form of a handful of calls available in a library. These\nsocket calls know how to send bytes between machines, using lower-level operations\nsuch as the TCP network transmission control protocol. At the bottom, TCP knows\nhow to transfer bytes, but it doesn\u2019t care what those bytes mean. For the purposes of\nthis text, we will generally ignore how bytes sent to sockets are physically transferred.\nTo understand sockets fully, though, we need to know a bit about how computers are\nnamed.\nMachine identifiers\nSuppose for just a moment that you wish to have a telephone conversation with some-\none halfway across the world. In the real world, you would probably need either that\nperson\u2019s telephone number or a directory that you could use to look up the number\nfrom her name (e.g., a telephone book). The same is true on the Internet: before a script\ncan have a conversation with another computer somewhere in cyberspace, it must first\nknow that other computer\u2019s number or name.\nLuckily, the Internet defines standard ways to name both a remote machine and a\nservice provided by that machine. Within a script, the computer program to be con-\ntacted through a socket is identified by supplying a pair of values\u2014the machine name\nand a specific port number on that machine:\nMachine names\nA machine name may take the form of either a string of numbers separated by dots,\ncalled an IP address (e.g., 166.93.218.100), or a more legible form known as a\ndomain name (e.g., starship.python.net). Domain names are automatically mapped\ninto their dotted numeric address equivalent when used, by something called a\nPlumbing the Internet | 781domain name server\u2014a program on the Net that serves the same purpose as your\nlocal telephone directory assistance service. As a special case, the machine name\nlocalhost, and its equivalent IP address 127.0.0.1, always mean the same local\nmachine; this allows us to refer to servers running locally on the same computer\nas its clients.\nPort numbers\nA port number is an agreed-upon numeric identifier for a given conversation. Be-\ncause computers on the Net support a variety of services, port numbers are used\nto name a particular conversation on a given machine. For two machines to talk\nover the Net, both must associate sockets with the same machine name and port\nnumber when initiating network connections. As we\u2019ll see, Internet protocols such\nas email and the Web have standard reserved port numbers for their connections,\nso clients can request a service regardless of the machine providing it. Port number\n80, for example, usually provides web pages on any web server machine.\nThe combination of a machine name and a port number uniquely identifies every dialog\non the Net. For instance, an ISP\u2019s computer may provide many kinds of services for\ncustomers\u2014web pages, Telnet, FTP transfers, email, and so on. Each service on the\nmachine is assigned a unique port number to which requests may be sent. To get web\npages from a web server, programs need to specify both the web server\u2019s Internet Pro-\ntocol (IP) or domain name and the port number on which the server listens for web\npage requests.\nIf this sounds a bit strange, it may help to think of it in old-fashioned terms. To have a\ntelephone conversation with someone within a company, for example, you usually need\nto dial both the company\u2019s phone number and the extension of the person you want\nto reach. If you don\u2019t know the company\u2019s number, you can probably find it by looking\nup the company\u2019s name in a phone book. It\u2019s almost the same on the Net\u2014machine\nnames identify a collection of services (like a company), port numbers identify an in-\ndividual service within a particular machine (like an extension), and domain names are\nmapped to IP numbers by domain name servers (like a phone book).\nWhen programs use sockets to communicate in specialized ways with another machine\n(or with other processes on the same machine), they need to avoid using a port number\nreserved by a standard protocol\u2014numbers in the range of 0 to 1023\u2014but we first need\nto discuss protocols to understand why.\nThe Protocol Layer\nAlthough sockets form the backbone of the Internet, much of the activity that happens\non the Net is programmed with protocols,\u2020 which are higher-level message models that\n\u2020 Some books also use the term protocol to refer to lower-level transport schemes such as TCP. In this book,\nwe use protocol to refer to higher-level structures built on top of sockets; see a networking text if you are\ncurious about what happens at lower levels.\n782 | Chapter 12:\u2002Network Scriptingrun on top of sockets. In short, the standard Internet protocols define a structured way\nto talk over sockets. They generally standardize both message formats and socket port\nnumbers:\n\u2022 Message formats provide structure for the bytes exchanged over sockets during\nconversations.\n\u2022 Port numbers are reserved numeric identifiers for the underlying sockets over which\nmessages are exchanged.\nRaw sockets are still commonly used in many systems, but it is perhaps more common\n(and generally easier) to communicate with one of the standard higher-level Internet\nprotocols. As we\u2019ll see, Python provides support for standard protocols, which auto-\nmates most of the socket and message formatting details.\nPort number rules\nTechnically speaking, socket port numbers can be any 16-bit integer value between 0\nand 65,535. However, to make it easier for programs to locate the standard protocols,\nport numbers in the range of 0 to 1023 are reserved and preassigned to the standard\nhigher-level protocols. Table 12-1 lists the ports reserved for many of the standard\nprotocols; each gets one or more preassigned numbers from the reserved range.\nTable 12-1. Port numbers reserved for common protocols\nProtocol\nCommon function\nPort number\nPython module\nHTTP\nWeb pages\n80\nhttp.client, http.server\nNNTP\nUsenet news\n119\nnntplib\nFTP data default\nFile transfers\n20\nftplib\nFTP control\nFile transfers\n21\nftplib\nSMTP\nSending email\n25\nsmtplib\nPOP3\nFetching email\n110\npoplib\nIMAP4\nFetching email\n143\nimaplib\nFinger\nInformational\n79\nn/a\nSSH\nCommand lines\n22\nn/a: third party\nTelnet\nCommand lines\n23\ntelnetlib\nClients and servers\nTo socket programmers, the standard protocols mean that port numbers 0 to 1023 are\noff-limits to scripts, unless they really mean to use one of the higher-level protocols.\nThis is both by standard and by common sense. A Telnet program, for instance, can\nstart a dialog with any Telnet-capable machine by connecting to its port, 23; without\npreassigned port numbers, each server might install Telnet on a different port. Similarly,\nwebsites listen for page requests from browsers on port 80 by standard; if they did not,\nPlumbing the Internet | 783you might have to know and type the HTTP port number of every site you visit while\nsurfing the Net.\nBy defining standard port numbers for services, the Net naturally gives rise to a client/\nserver architecture. On one side of a conversation, machines that support standard\nprotocols perpetually run a set of programs that listen for connection requests on the\nreserved ports. On the other end of a dialog, other machines contact those programs\nto use the services they export.\nWe usually call the perpetually running listener program a server and the connecting\nprogram a client. Let\u2019s use the familiar web browsing model as an example. As shown\nin Table 12-1, the HTTP protocol used by the Web allows clients and servers to talk\nover sockets on port 80:\nServer\nA machine that hosts websites usually runs a web server program that constantly\nlistens for incoming connection requests, on a socket bound to port 80. Often, the\nserver itself does nothing but watch for requests on its port perpetually; handling\nrequests is delegated to spawned processes or threads.\nClients\nPrograms that wish to talk to this server specify the server machine\u2019s name and\nport 80 to initiate a connection. For web servers, typical clients are web browsers\nlike Firefox, Internet Explorer, or Chrome, but any script can open a client-side\nconnection on port 80 to fetch web pages from the server. The server\u2019s machine\nname can also be simply \u201clocalhost\u201d if it\u2019s the same as the client\u2019s.\nIn general, many clients may connect to a server over sockets, whether it implements\na standard protocol or something more specific to a given application. And in some\napplications, the notion of client and server is blurred\u2014programs can also pass bytes\nbetween each other more as peers than as master and subordinate. An agent in a peer-\nto-peer file transfer system, for instance, may at various times be both client and server\nfor parts of files transferred.\nFor the purposes of this book, though, we usually call programs that listen on sockets\nservers, and those that connect clients. We also sometimes call the machines that these\nprograms run on server and client (e.g., a computer on which a web server program\nruns may be called a web server machine, too), but this has more to do with the physical\nthan the functional.\nProtocol structures\nFunctionally, protocols may accomplish a familiar task, like reading email or posting\na Usenet newsgroup message, but they ultimately consist of message bytes sent over\nsockets. The structure of those message bytes varies from protocol to protocol, is hidden\nby the Python library, and is mostly beyond the scope of this book, but a few general\nwords may help demystify the protocol layer.\n784 | Chapter 12:\u2002Network ScriptingSome protocols may define the contents of messages sent over sockets; others may\nspecify the sequence of control messages exchanged during conversations. By defining\nregular patterns of communication, protocols make communication more robust. They\ncan also minimize deadlock conditions\u2014machines waiting for messages that never\narrive.\nFor example, the FTP protocol prevents deadlock by conversing over two sockets: one\nfor control messages only and one to transfer file data. An FTP server listens for control\nmessages (e.g., \u201csend me a file\u201d) on one port, and transfers file data over another. FTP\nclients open socket connections to the server machine\u2019s control port, send requests,\nand send or receive file data over a socket connected to a data port on the server ma-\nchine. FTP also defines standard message structures passed between client and server.\nThe control message used to request a file, for instance, must follow a standard format.\nPython\u2019s Internet Library Modules\nIf all of this sounds horribly complex, cheer up: Python\u2019s standard protocol modules\nhandle all the details. For example, the Python library\u2019s ftplib module manages all the\nsocket and message-level handshaking implied by the FTP protocol. Scripts that import\nftplib have access to a much higher-level interface for FTPing files and can be largely\nignorant of both the underlying FTP protocol and the sockets over which it runs.\u2021\nIn fact, each supported protocol is represented in Python\u2019s standard library by either a\nmodule package of the same name as the protocol or by a module file with a name of\nthe form xxxlib.py, where xxx is replaced by the protocol\u2019s name. The last column in\nTable 12-1 gives the module name for some standard protocol modules. For instance,\nFTP is supported by the module file ftplib.py and HTTP by package http.*. Moreover,\nwithin the protocol modules, the top-level interface object is often the name of the\nprotocol. So, for instance, to start an FTP session in a Python script, you run import\nftplib and pass appropriate parameters in a call to ftplib.FTP; for Telnet, create a\ntelnetlib.Telnet instance.\nIn addition to the protocol implementation modules in Table 12-1, Python\u2019s standard\nlibrary also contains modules for fetching replies from web servers for a web page\nrequest (urllib.request), parsing and handling data once it has been transferred over\nsockets or protocols (html.parser, the email.* and xml.* packages), and more.\nTable 12-2 lists some of the more commonly used modules in this category.\n\u2021 Since Python is an open source system, you can read the source code of the ftplib module if you are curious\nabout how the underlying protocol actually works. See the ftplib.py file in the standard source library directory\nin your machine. Its code is complex (since it must format messages and manage two sockets), but with the\nother standard Internet protocol modules, it is a good example of low-level socket programming.\nPlumbing the Internet | 785Table 12-2. Common Internet-related standard modules\nPython modules\nUtility\nsocket, ssl\nNetwork and IPC communications support (TCP/IP, UDP, etc.), plus SSL secure sockets\nwrapper\ncgi\nServer-side CGI script support: parse input stream, escape HTML text, and so on\nurllib.request\nFetch web pages from their addresses (URLs)\nurllib.parse\nParse URL string into components, escape URL text\nhttp.client, ftplib,\nnntplib\nHTTP (web), FTP (file transfer), and NNTP (news) client protocol modules\nhttp.cookies,\nhttp.cookiejar\nHTTP cookies support (data stored on clients by website request, server- and client-side\nsupport)\npoplib, imaplib, smtplib\nPOP, IMAP (mail fetch), and SMTP (mail send) protocol modules\ntelnetlib\nTelnet protocol module\nhtml.parser, xml.*\nParse web page contents (HTML and XML documents)\nxdrlib, socket\nEncode binary data portably for transmission\nstruct, pickle\nEncode Python objects as packed binary data or serialized byte strings for transmission\nemail.*\nParse and compose email messages with headers, attachments, and encodings\nmailbox\nProcess on disk mailboxes and their messages\nmimetypes\nGuess file content types from names and extensions from types\nuu, binhex, base64,\nbinascii, quopri, email.*\nEncode and decode binary (or other) data transmitted as text (automatic in email\npackage)\nsocketserver\nFramework for general Net servers\nhttp.server\nBasic HTTP server implementation, with request handlers for simple and CGI-aware servers\nWe will meet many of the modules in this table in the next few chapters of this book,\nbut not all of them. Moreover, there are additional Internet modules in Python not\nshown here. The modules demonstrated in this book will be representative, but as\nalways, be sure to see Python\u2019s standard Library Reference Manual for more complete\nand up-to-date lists and details.\nMore on Protocol Standards\nIf you want the full story on protocols and ports, at this writing you can find a com-\nprehensive list of all ports reserved for protocols or registered as used by various com-\nmon systems by searching the web pages maintained by the Internet Engineering Task\nForce (IETF) and the Internet Assigned Numbers Authority (IANA). The IETF is the\norganization responsible for maintaining web protocols and standards. The IANA is\nthe central coordinator for the assignment of unique parameter values for Internet pro-\ntocols. Another standards body, the W3 (for WWW), also maintains relevant docu-\nments. See these web pages for more details:\n786 | Chapter 12:\u2002Network Scriptinghttp://www.ietf.org\nhttp://www.iana.org/numbers.html\nhttp://www.iana.org/assignments/port-numbers\nhttp://www.w3.org\nIt\u2019s not impossible that more recent repositories for standard protocol specifications\nwill arise during this book\u2019s shelf life, but the IETF website will likely be the main\nauthority for some time to come. If you do look, though, be warned that the details are,\nwell, detailed. Because Python\u2019s protocol modules hide most of the socket and mes-\nsaging complexity documented in the protocol standards, you usually don\u2019t need to\nmemorize these documents to get web work done with Python.\nSocket Programming\nNow that we\u2019ve seen how sockets figure into the Internet picture, let\u2019s move on to\nexplore the tools that Python provides for programming sockets with Python scripts.\nThis section shows you how to use the Python socket interface to perform low-level\nnetwork communications. In later chapters, we will instead use one of the higher-level\nprotocol modules that hide underlying sockets. Python\u2019s socket interfaces can be used\ndirectly, though, to implement custom network dialogs and to access standard proto-\ncols manually.\nAs previewed in Chapter 5, the basic socket interface in Python is the standard library\u2019s\nsocket module. Like the os POSIX module, Python\u2019s socket module is just a thin wrap-\nper (interface layer) over the underlying C library\u2019s socket calls. Like Python files, it\u2019s\nalso object-based\u2014methods of a socket object implemented by this module call out to\nthe corresponding C library\u2019s operations after data conversions. For instance, the C\nlibrary\u2019s send and recv function calls become methods of socket objects in Python.\nPython\u2019s socket module supports socket programming on any machine that supports\nBSD-style sockets\u2014Windows, Macs, Linux, Unix, and so on\u2014and so provides a port-\nable socket interface. In addition, this module supports all commonly used socket\ntypes\u2014TCP/IP, UDP, datagram, and Unix domain\u2014and can be used as both a network\ninterface API and a general IPC mechanism between processes running on the same\nmachine.\nFrom a functional perspective, sockets are a programmer\u2019s device for transferring bytes\nbetween programs, possibly running on different computers. Although sockets them-\nselves transfer only byte strings, we can also transfer Python objects through them by\nusing Python\u2019s pickle module. Because this module converts Python objects such as\nlists, dictionaries, and class instances to and from byte strings, it provides the extra step\nneeded to ship higher-level objects through sockets when required.\nSocket Programming | 787Python\u2019s struct module can also be used to format Python objects as packed binary\ndata byte strings for transmission, but is generally limited in scope to objects that map\nto types in the C programming language. The pickle module supports transmission of\nlarger object, such as dictionaries and class instances. For other tasks, including most\nstandard Internet protocols, simpler formatted byte strings suffice. We\u2019ll learn more\nabout pickle later in this chapter and book.\nBeyond basic data communication tasks, the socket module also includes a variety of\nmore advanced tools. For instance, it has calls for the following and more:\n\u2022 Converting bytes to a standard network ordering (ntohl, htonl)\n\u2022 Querying machine name and address (gethostname, gethostbyname)\n\u2022 Wrapping socket objects in a file object interface (sockobj.makefile)\n\u2022 Making socket calls nonblocking (sockobj.setblocking)\n\u2022 Setting socket timeouts (sockobj.settimeout)\nProvided your Python was compiled with Secure Sockets Layer (SSL) support, the\nssl standard library module also supports encrypted transfers with its\nssl.wrap_socket call. This call wraps a socket object in SSL logic, which is used in turn\nby other standard library modules to support the HTTPS secure website protocol\n(http.client and urllib.request), secure email transfers (poplib and smtplib), and\nmore. We\u2019ll meet some of these other modules later in this part of the book, but we\nwon\u2019t study all of the socket module\u2019s advanced features in this text; see the Python\nlibrary manual for usage details omitted here.\nSocket Basics\nAlthough we won\u2019t get into advanced socket use in this chapter, basic socket transfers\nare remarkably easy to code in Python. To create a connection between machines,\nPython programs import the socket module, create a socket object, and call the object\u2019s\nmethods to establish connections and send and receive data.\nSockets are inherently bidirectional in nature, and socket object methods map directly\nto socket calls in the C library. For example, the script in Example 12-1 implements a\nprogram that simply listens for a connection on a socket and echoes back over a socket\nwhatever it receives through that socket, adding Echo=> string prefixes.\nExample 12-1. PP4E\\Internet\\Sockets\\echo-server.py\n\"\"\"\nServer side: open a TCP/IP socket on a port, listen for a message from\na client, and send an echo reply; this is a simple one-shot listen/reply\nconversation per client, but it goes into an infinite loop to listen for\nmore clients as long as this server script runs; the client may run on\na remote machine, or on same computer if it uses 'localhost' for server\n\"\"\"\n788 | Chapter 12:\u2002Network Scriptingfrom socket import *                    # get socket constructor and constants\nmyHost = ''                             # '' = all available interfaces on host\nmyPort = 50007                          # listen on a non-reserved port number\nsockobj = socket(AF_INET, SOCK_STREAM)       # make a TCP socket object\nsockobj.bind((myHost, myPort))               # bind it to server port number\nsockobj.listen(5)                            # listen, allow 5 pending connects\nwhile True:                                  # listen until process killed\n    connection, address = sockobj.accept()   # wait for next client connect\n    print('Server connected by', address)    # connection is a new socket\n    while True:\n        data = connection.recv(1024)         # read next line on client socket\n        if not data: break                   # send a reply line to the client\n        connection.send(b'Echo=>' + data)    # until eof when socket closed\n    connection.close()\nAs mentioned earlier, we usually call programs like this that listen for incoming con-\nnections servers because they provide a service that can be accessed at a given machine\nand port on the Internet. Programs that connect to such a server to access its service\nare generally called clients. Example 12-2 shows a simple client implemented in Python.\nExample 12-2. PP4E\\Internet\\Sockets\\echo-client.py\n\"\"\"\nClient side: use sockets to send data to the server, and print server's\nreply to each message line; 'localhost' means that the server is running\non the same machine as the client, which lets us test client and server\non one machine;  to test over the Internet, run a server on a remote\nmachine, and set serverHost or argv[1] to machine's domain name or IP addr;\nPython sockets are a portable BSD socket interface, with object methods\nfor the standard socket calls available in the system's C library;\n\"\"\"\nimport sys\nfrom socket import *              # portable socket interface plus constants\nserverHost = 'localhost'          # server name, or: 'starship.python.net'\nserverPort = 50007                # non-reserved port used by the server\nmessage = [b'Hello network world']          # default text to send to server\n                                            # requires bytes: b'' or str,encode()\nif len(sys.argv) > 1:\n    serverHost = sys.argv[1]                # server from cmd line arg 1\n    if len(sys.argv) > 2:                   # text from cmd line args 2..n\n        message = (x.encode() for x in sys.argv[2:])\nsockobj = socket(AF_INET, SOCK_STREAM)      # make a TCP/IP socket object\nsockobj.connect((serverHost, serverPort))   # connect to server machine + port\nfor line in message:\n    sockobj.send(line)                      # send line to server over socket\n    data = sockobj.recv(1024)               # receive line from server: up to 1k\n    print('Client received:', data)         # bytes are quoted, was `x`, repr(x)\nsockobj.close()                             # close socket to send eof to server\nSocket Programming | 789Server socket calls\nBefore we see these programs in action, let\u2019s take a minute to explain how this client\nand server do their stuff. Both are fairly simple examples of socket scripts, but they\nillustrate the common call patterns of most socket-based programs. In fact, this is boil-\nerplate code: most connected socket programs generally make the same socket calls\nthat our two scripts do, so let\u2019s step through the important points of these scripts line\nby line.\nPrograms such as Example 12-1 that provide services for other programs with sockets\ngenerally start out by following this sequence of calls:\nsockobj = socket(AF_INET, SOCK_STREAM)\nUses the Python socket module to create a TCP socket object. The names\nAF_INET and SOCK_STREAM are preassigned variables defined by and imported from\nthe socket module; using them in combination means \u201ccreate a TCP/IP socket,\u201d\nthe standard communication device for the Internet. More specifically, AF_INET\nmeans the IP address protocol, and SOCK_STREAM means the TCP transfer protocol.\nThe AF_INET/SOCK_STREAM combination is the default because it is so common, but\nit\u2019s typical to make this explicit.\nIf you use other names in this call, you can instead create things like UDP connec-\ntionless sockets (use SOCK_DGRAM second) and Unix domain sockets on the local\nmachine (use AF_UNIX first), but we won\u2019t do so in this book. See the Python library\nmanual for details on these and other socket module options. Using other socket\ntypes is mostly a matter of using different forms of boilerplate code.\nsockobj.bind((myHost, myPort))\nAssociates the socket object with an address\u2014for IP addresses, we pass a server\nmachine name and port number on that machine. This is where the server identifies\nthe machine and port associated with the socket. In server programs, the hostname\nis typically an empty string (\u201c\u201d), which means the machine that the script runs on\n(formally, all available local and remote interfaces on the machine), and the port\nis a number outside the range 0 to 1023 (which is reserved for standard protocols,\ndescribed earlier).\nNote that each unique socket dialog you support must have its own port number;\nif you try to open a socket on a port already in use, Python will raise an exception.\nAlso notice the nested parentheses in this call\u2014for the AF_INET address protocol\nsocket here, we pass the host/port socket address to bind as a two-item tuple object\n(pass a string for AF_UNIX). Technically, bind takes a tuple of values appropriate for\nthe type of socket created.\nsockobj.listen(5)\nStarts listening for incoming client connections and allows for a backlog of up to\nfive pending requests. The value passed sets the number of incoming client requests\nqueued by the operating system before new requests are denied (which happens\nonly if a server isn\u2019t fast enough to process requests before the queues fill up). A\n790 | Chapter 12:\u2002Network Scriptingvalue of 5 is usually enough for most socket-based programs; the value must be at\nleast 1.\nAt this point, the server is ready to accept connection requests from client programs\nrunning on remote machines (or the same machine) and falls into an infinite loop\u2014\nwhile True (or the equivalent while 1 for older Pythons and ex-C programmers)\u2014\nwaiting for them to arrive:\nconnection, address = sockobj.accept()\nWaits for the next client connection request to occur; when it does, the accept call\nreturns a brand-new socket object over which data can be transferred from and to\nthe connected client. Connections are accepted on sockobj, but communication\nwith a client happens on connection, the new socket. This call actually returns a\ntwo-item tuple\u2014address is the connecting client\u2019s Internet address. We can call\naccept more than one time, to service multiple client connections; that\u2019s why each\ncall returns a new, distinct socket for talking to a particular client.\nOnce we have a client connection, we fall into another loop to receive data from the\nclient in blocks of up to 1,024 bytes at a time, and echo each block back to the client:\ndata = connection.recv(1024)\nReads at most 1,024 more bytes of the next message sent from a client (i.e., coming\nacross the network or IPC connection), and returns it to the script as a byte string.\nWe get back an empty byte string when the client has finished\u2014end-of-file is trig-\ngered when the client closes its end of the socket.\nconnection.send(b'Echo=>' + data)\nSends the latest byte string data block back to the client program, prepending the\nstring 'Echo=>' to it first. The client program can then recv what we send here\u2014\nthe next reply line. Technically this call sends as much data as possible, and returns\nthe number of bytes actually sent. To be fully robust, some programs may need to\nresend unsent portions or use connection.sendall to force all bytes to be sent.\nconnection.close()\nShuts down the connection with this particular client.\nTransferring byte strings and objects\nSo far we\u2019ve seen calls used to transfer data in a server, but what is it that is actually\nshipped through a socket? As we learned in Chapter 5, sockets by themselves always\ndeal in binary byte strings, not text. To your scripts, this means you must send and will\nreceive bytes strings, not str, though you can convert to and from text as needed with\nbytes.decode and str.encode methods. In our scripts, we use b'...' bytes literals to\nsatisfy socket data requirements. In other contexts, tools such as the struct and\npickle modules return the byte strings we need automatically, so no extra steps are\nneeded.\nSocket Programming | 791For example, although the socket model is limited to transferring byte strings, you can\nsend and receive nearly arbitrary Python objects with the standard library pickle object\nserialization module. Its dumps and loads calls convert Python objects to and from byte\nstrings, ready for direct socket transfer:\n>>> import pickle\n>>> x = pickle.dumps([99, 100])        # on sending end... convert to byte strings\n>>> x                                  # string passed to send, returned by recv\nb'\\x80\\x03]q\\x00(KcKde.'\n>>> pickle.loads(x)                    # on receiving end... convert back to object\n[99, 100]\nFor simpler types that correspond to those in the C language, the struct module pro-\nvides the byte-string conversion we need as well:\n>>> import struct\n>>> x = struct.pack('>ii', 99, 100)    # convert simpler types for transmission\n>>> x\nb'\\x00\\x00\\x00c\\x00\\x00\\x00d'\n>>> struct.unpack('>ii', x)\n(99, 100)\nWhen converted this way, Python native objects become candidates for socket-based\ntransfers. See Chapter 4 for more on struct. We previewed pickle and object seriali-\nzation in Chapter 1, but we\u2019ll learn more about it and its few pickleability constraints\nwhen we explore data persistence in Chapter 17.\nIn fact there are a variety of ways to extend the basic socket transfer model. For instance,\nmuch like os.fdopen and open for the file descriptors we studied in Chapter 4, the\nsocket.makefile method allows you to wrap sockets in text-mode file objects that han-\ndle text encodings for you automatically. This call also allows you to specify nondefault\nUnicode encodings and end-line behaviors in text mode with extra arguments in 3.X\njust like the open built-in function. Because its result mimics file interfaces, the\nsocket.makefile call additionally allows the pickle module\u2019s file-based calls to transfer\nobjects over sockets implicitly. We\u2019ll see more on socket file wrappers later in this\nchapter.\nFor our simpler scripts here, hardcoded byte strings and direct socket calls do the job.\nAfter talking with a given connected client, the server in Example 12-1 goes back to its\ninfinite loop and waits for the next client connection request. Let\u2019s move on to see what\nhappened on the other side of the fence.\nClient socket calls\nThe actual socket-related calls in client programs like the one shown in Exam-\nple 12-2 are even simpler; in fact, half of that script is preparation logic. The main thing\nto keep in mind is that the client and server must specify the same port number when\nopening their sockets and the client must identify the machine on which the server is\n792 | Chapter 12:\u2002Network Scriptingrunning; in our scripts, server and client agree to use port number 50007 for their\nconversation, outside the standard protocol range. Here are the client\u2019s socket calls:\nsockobj = socket(AF_INET, SOCK_STREAM)\nCreates a Python socket object in the client program, just like the server.\nsockobj.connect((serverHost, serverPort))\nOpens a connection to the machine and port on which the server program is lis-\ntening for client connections. This is where the client specifies the string name of\nthe service to be contacted. In the client, we can either specify the name of the\nremote machine as a domain name (e.g., starship.python.net) or numeric IP ad-\ndress. We can also give the server name as localhost (or the equivalent IP address\n127.0.0.1) to specify that the server program is running on the same machine as\nthe client; that comes in handy for debugging servers without having to connect\nto the Net. And again, the client\u2019s port number must match the server\u2019s exactly.\nNote the nested parentheses again\u2014just as in server bind calls, we really pass the\nserver\u2019s host/port address to connect in a tuple object.\nOnce the client establishes a connection to the server, it falls into a loop, sending a\nmessage one line at a time and printing whatever the server sends back after each line\nis sent:\nsockobj.send(line)\nTransfers the next byte-string message line to the server over the socket. Notice\nthat the default list of lines contains bytes strings (b'...'). Just as on the server,\ndata passed through the socket must be a byte string, though it can be the result\nof a manual str.encode encoding call or an object conversion with pickle or\nstruct if desired. When lines to be sent are given as command-line arguments\ninstead, they must be converted from str to bytes; the client arranges this by en-\ncoding in a generator expression (a call map(str.encode, sys.argv[2:]) would have\nthe same effect).\ndata = sockobj.recv(1024)\nReads the next reply line sent by the server program. Technically, this reads up to\n1,024 bytes of the next reply message and returns it as a byte string.\nsockobj.close()\nCloses the connection with the server, sending it the end-of-file signal.\nAnd that\u2019s it. The server exchanges one or more lines of text with each client that\nconnects. The operating system takes care of locating remote machines, routing bytes\nsent between programs and possibly across the Internet, and (with TCP) making sure\nthat our messages arrive intact. That involves a lot of processing, too\u2014our strings may\nultimately travel around the world, crossing phone wires, satellite links, and more along\nthe way. But we can be happily ignorant of what goes on beneath the socket call layer\nwhen programming in Python.\nSocket Programming | 793Running Socket Programs Locally\nLet\u2019s put this client and server to work. There are two ways to run these scripts\u2014on\neither the same machine or two different machines. To run the client and the server on\nthe same machine, bring up two command-line consoles on your computer, start the\nserver program in one, and run the client repeatedly in the other. The server keeps\nrunning and responds to requests made each time you run the client script in the other\nwindow.\nFor instance, here is the text that shows up in the MS-DOS console window where I\u2019ve\nstarted the server script:\nC:\\...\\PP4E\\Internet\\Sockets> python echo-server.py\nServer connected by ('127.0.0.1', 57666)\nServer connected by ('127.0.0.1', 57667)\nServer connected by ('127.0.0.1', 57668)\nThe output here gives the address (machine IP name and port number) of each con-\nnecting client. Like most servers, this one runs perpetually, listening for client connec-\ntion requests. This server receives three, but I have to show you the client window\u2019s\ntext for you to understand what this means:\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py\nClient received: b'Echo=>Hello network world'\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py localhost spam Spam SPAM\nClient received: b'Echo=>spam'\nClient received: b'Echo=>Spam'\nClient received: b'Echo=>SPAM'\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py localhost Shrubbery\nClient received: b'Echo=>Shrubbery'\nHere, I ran the client script three times, while the server script kept running in the other\nwindow. Each client connected to the server, sent it a message of one or more lines of\ntext, and read back the server\u2019s reply\u2014an echo of each line of text sent from the client.\nAnd each time a client is run, a new connection message shows up in the server\u2019s\nwindow (that\u2019s why we got three). Because the server\u2019s coded as an infinite loop, you\nmay need to kill it with Task Manager on Windows when you\u2019re done testing, because\na Ctrl-C in the server\u2019s console window is ignored; other platforms may fare better.\nIt\u2019s important to notice that client and server are running on the same machine here (a\nWindows PC). The server and client agree on the port number, but they use the machine\nnames \"\" and localhost, respectively, to refer to the computer on which they are run-\nning. In fact, there is no Internet connection to speak of. This is just IPC, of the sort\nwe saw in Chapter 5: sockets also work well as cross-program communications tools\non a single machine.\n794 | Chapter 12:\u2002Network ScriptingRunning Socket Programs Remotely\nTo make these scripts talk over the Internet rather than on a single machine and sample\nthe broader scope of sockets, we have to do some extra work to run the server on a\ndifferent computer. First, upload the server\u2019s source file to a remote machine where\nyou have an account and a Python. Here\u2019s how I do it with FTP to a site that hosts a\ndomain name of my own, learning-python.com; most informational lines in the fol-\nlowing have been removed, your server name and upload interface details will vary,\nand there are other ways to copy files to a computer (e.g., FTP client GUIs, email, web\npage post forms, and so on\u2014see \u201cTips on Using Remote Servers\u201d on page 798 for\nhints on accessing remote servers):\nC:\\...\\PP4E\\Internet\\Sockets> ftp learning-python.com\nConnected to learning-python.com.\nUser (learning-python.com:(none)): xxxxxxxx\nPassword: yyyyyyyy\nftp> mkdir scripts\nftp> cd scripts\nftp> put echo-server.py\nftp> quit\nOnce you have the server program loaded on the other computer, you need to run it\nthere. Connect to that computer and start the server program. I usually Telnet or SSH\ninto my server machine and start the server program as a perpetually running process\nfrom the command line. The & syntax in Unix/Linux shells can be used to run the server\nscript in the background; we could also make the server directly executable with a #!\nline and a chmod command (see Chapter 3 for details).\nHere is the text that shows up in a window on my PC that is running a SSH session\nwith the free PuTTY client, connected to the Linux server where my account is hosted\n(again, less a few deleted informational lines):\nlogin as: xxxxxxxx\nXXXXXXXX@learning-python.com's password: yyyyyyyy\nLast login: Fri Apr 23 07:46:33 2010 from 72.236.109.185\n[...]$ cd scripts\n[...]$ python echo-server.py &\n[1] 23016\nNow that the server is listening for connections on the Net, run the client on your local\ncomputer multiple times again. This time, the client runs on a different machine than\nthe server, so we pass in the server\u2019s domain or IP name as a client command-line\nargument. The server still uses a machine name of \"\" because it always listens on what-\never machine it runs on. Here is what shows up in the remote learning-python.com\nserver\u2019s SSH window on my PC:\n[...]$ Server connected by ('72.236.109.185', 57697)\nServer connected by ('72.236.109.185', 57698)\nServer connected by ('72.236.109.185', 57699)\nServer connected by ('72.236.109.185', 57700)\nSocket Programming | 795And here is what appears in the Windows console window where I run the client. A\n\u201cconnected by\u201d message appears in the server SSH window each time the client script\nis run in the client window:\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py learning-python.com\nClient received: b'Echo=>Hello network world'\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py learning-python.com ni Ni NI\nClient received: b'Echo=>ni'\nClient received: b'Echo=>Ni'\nClient received: b'Echo=>NI'\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py learning-python.com Shrubbery\nClient received: b'Echo=>Shrubbery'\nThe ping command can be used to get an IP address for a machine\u2019s domain name;\neither machine name form can be used to connect in the client:\nC:\\...\\PP4E\\Internet\\Sockets> ping learning-python.com\nPinging learning-python.com [97.74.215.115] with 32 bytes of data:\nReply from 97.74.215.115: bytes=32 time=94ms TTL=47\nCtrl-C\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py 97.74.215.115 Brave Sir Robin\nClient received: b'Echo=>Brave'\nClient received: b'Echo=>Sir'\nClient received: b'Echo=>Robin'\nThis output is perhaps a bit understated\u2014a lot is happening under the hood. The client,\nrunning on my Windows laptop, connects with and talks to the server program running\non a Linux machine perhaps thousands of miles away. It all happens about as fast as\nwhen client and server both run on the laptop, and it uses the same library calls; only\nthe server name passed to clients differs.\nThough simple, this illustrates one of the major advantages of using sockets for cross-\nprogram communication: they naturally support running the conversing programs on\ndifferent machines, with little or no change to the scripts themselves. In the process,\nsockets make it easy to decouple and distribute parts of a system over a network when\nneeded.\nSocket pragmatics\nBefore we move on, there are three practical usage details you should know. First, you\ncan run the client and server like this on any two Internet-aware machines where Python\nis installed. Of course, to run the client and server on different computers, you need\nboth a live Internet connection and access to another machine on which to run the\nserver.\nThis need not be an expensive proposition, though; when sockets are opened, Python\nis happy to initiate and use whatever connectivity you have, be it a dedicated T1 line,\nwireless router, cable modem, or dial-up account. Moreover, if you don\u2019t have a server\n796 | Chapter 12:\u2002Network Scriptingaccount of your own like the one I\u2019m using on learning-python.com, simply run client\nand server examples on the same machine, localhost, as shown earlier; all you need\nthen is a computer that allows sockets, and most do.\nSecond, the socket module generally raises exceptions if you ask for something invalid.\nFor instance, trying to connect to a nonexistent server (or unreachable servers, if you\nhave no Internet link) fails:\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py www.nonesuch.com hello\nTraceback (most recent call last):\n  File \"echo-client.py\", line 24, in <module>\n    sockobj.connect((serverHost, serverPort))   # connect to server machine...\nsocket.error: [Errno 10060] A connection attempt failed because the connected\nparty did not properly respond after a period of time, or established connection\nfailed because connected host has failed to respond\nFinally, also be sure to kill the server process before restarting it again, or else the port\nnumber will still be in use, and you\u2019ll get another exception; on my remote server\nmachine:\n[...]$ ps -x\n  PID TTY      STAT   TIME COMMAND\n 5378 pts/0    S      0:00 python echo-server.py\n22017 pts/0    Ss     0:00 -bash\n26805 pts/0    R+     0:00 ps \u2013x\n[...]$ python echo-server.py\nTraceback (most recent call last):\n  File \"echo-server.py\", line 14, in <module>\n    sockobj.bind((myHost, myPort))               # bind it to server port number\nsocket.error: [Errno 10048] Only one usage of each socket address (protocol/\nnetwork address/port) is normally permitted\nA series of Ctrl-Cs will kill the server on Linux (be sure to type fg to bring it to the\nforeground first if started with an &):\n[...]$ fg\npython echo-server.py\nTraceback (most recent call last):\n  File \"echo-server.py\", line 18, in <module>\n    connection, address = sockobj.accept()   # wait for next client connect\nKeyboardInterrupt\nAs mentioned earlier, a Ctrl-C kill key combination won\u2019t kill the server on my Win-\ndows 7 machine, however. To kill the perpetually running server process running lo-\ncally on Windows, you may need to start Task Manager (e.g., using a Ctrl-Alt-Delete\nkey combination), and then end the Python task by selecting it in the process listbox\nthat appears. Closing the window in which the server is running will also suffice on\nWindows, but you\u2019ll lose that window\u2019s command history. You can also usually kill a\nserver on Linux with a kill \u22129 pid shell command if it is running in another window\nor in the background, but Ctrl-C requires less typing.\nSocket Programming | 797Tips on Using Remote Servers\nSome of this chapter\u2019s examples run server code on a remote computer. Though you\ncan also run the examples locally on localhost, remote execution better captures the\nflexibility and power of sockets. To run remotely, you\u2019ll need access to an Internet\naccessible computer with Python, where you can upload and run scripts. You\u2019ll also\nneed to be able to access the remote server from your PC. To help with this last step,\nhere are a few hints for readers new to using remote servers.\nTo transfer scripts to a remote machine, the FTP command is standard on Windows\nmachines and most others. On Windows, simply type it in a console window to connect\nto an FTP server or start your favorite FTP client GUI program; on Linux, type the FTP\ncommand in an xterm window. You\u2019ll need to supply your account name and password\nto connect to a nonanonymous FTP site. For anonymous FTP, use \u201canonymous\u201d for\nthe username and your email address for the password.\nTo run scripts remotely from a command line, Telnet is a standard command on some\nUnix-like machines, too. On Windows, it\u2019s often run as a client GUI. For some server\nmachines, you\u2019ll need to use SSH secure shell rather than Telnet to access a shell\nprompt. There are a variety of SSH utilities available on the Web, including PuTTY,\nused for this book. Python itself comes with a telnetlib telnet module, and a web\nsearch will reveals current SSH options for Python scripts, including ssh.py, para-\nmiko, Twisted, Pexpect, and even subprocess.Popen.\nSpawning Clients in Parallel\nSo far, we\u2019ve run a server locally and remotely, and run individual clients manually,\none after another. Realistic servers are generally intended to handle many clients, of\ncourse, and possibly at the same time. To see how our echo server handles the load,\nlet\u2019s fire up eight copies of the client script in parallel using the script in Exam-\nple 12-3; see the end of Chapter 5 for details on the launchmodes module used here to\nspawn clients and alternatives such as the multiprocessing and subprocess modules.\nExample 12-3. PP4E\\Internet\\Sockets\\testecho.py\nimport sys\nfrom PP4E.launchmodes import QuietPortableLauncher\nnumclients = 8\ndef start(cmdline):\n    QuietPortableLauncher(cmdline, cmdline)()\n# start('echo-server.py')              # spawn server locally if not yet started\nargs = ' '.join(sys.argv[1:])          # pass server name if running remotely\nfor i in range(numclients):\n    start('echo-client.py %s' % args)  # spawn 8? clients to test the server\n798 | Chapter 12:\u2002Network ScriptingTo run this script, pass no arguments to talk to a server listening on port 50007 on the\nlocal machine; pass a real machine name to talk to a server running remotely. Three\nconsole windows come into play in this scheme\u2014the client, a local server, and a remote\nserver. On Windows, the clients\u2019 output is discarded when spawned from this script,\nbut it would be similar to what we\u2019ve already seen. Here\u2019s the client window\ninteraction\u20148 clients are spawned locally to talk to both a local and a remote server:\nC:\\...\\PP4E\\Internet\\Sockets> set PYTHONPATH=C:\\...\\dev\\Examples\nC:\\...\\PP4E\\Internet\\Sockets> python testecho.py\nC:\\...\\PP4E\\Internet\\Sockets> python testecho.py learning-python.com\nIf the spawned clients connect to a server run locally (the first run of the script on the\nclient), connection messages show up in the server\u2019s window on the local machine:\nC:\\...\\PP4E\\Internet\\Sockets> python echo-server.py\nServer connected by ('127.0.0.1', 57721)\nServer connected by ('127.0.0.1', 57722)\nServer connected by ('127.0.0.1', 57723)\nServer connected by ('127.0.0.1', 57724)\nServer connected by ('127.0.0.1', 57725)\nServer connected by ('127.0.0.1', 57726)\nServer connected by ('127.0.0.1', 57727)\nServer connected by ('127.0.0.1', 57728)\nIf the server is running remotely, the client connection messages instead appear in the\nwindow displaying the SSH (or other) connection to the remote computer, here,\nlearning-python.com:\n[...]$ python echo-server.py\nServer connected by ('72.236.109.185', 57729)\nServer connected by ('72.236.109.185', 57730)\nServer connected by ('72.236.109.185', 57731)\nServer connected by ('72.236.109.185', 57732)\nServer connected by ('72.236.109.185', 57733)\nServer connected by ('72.236.109.185', 57734)\nServer connected by ('72.236.109.185', 57735)\nServer connected by ('72.236.109.185', 57736)\nPreview: Denied client connections\nThe net effect is that our echo server converses with multiple clients, whether running\nlocally or remotely. Keep in mind, however, that this works for our simple scripts only\nbecause the server doesn\u2019t take a long time to respond to each client\u2019s requests\u2014it can\nget back to the top of the server script\u2019s outer while loop in time to process the next\nincoming client. If it could not, we would probably need to change the server to handle\neach client in parallel, or some might be denied a connection.\nTechnically, client connections would fail after 5 clients are already waiting for the\nserver\u2019s attention, as specified in the server\u2019s listen call. To prove this to yourself, add\na time.sleep call somewhere inside the echo server\u2019s main loop in Example 12-1 after\nSocket Programming | 799a connection is accepted, to simulate a long-running task (this is from file echo-server-\nsleep.py in the examples package if you wish to experiment):\nwhile True:                                  # listen until process killed\n    connection, address = sockobj.accept()   # wait for next client connect\n    while True:\n        data = connection.recv(1024)         # read next line on client socket\n        time.sleep(3)                        # take time to process request\n        ...\nIf you then run this server and the testecho clients script, you\u2019ll notice that not all 8\nclients wind up receiving a connection, because the server is too busy to empty its\npending-connections queue in time. Only 6 clients are served when I run this on Win-\ndows\u2014one accepted initially, and 5 in the pending-requests listen queue. The other\ntwo clients are denied connections and fail.\nThe following shows the server and client messages produced when the server is stalled\nthis way, including the error messages that the two denied clients receive. To see the\nclients\u2019 messages on Windows, you can change testecho to use the StartArgs launcher\nwith a /B switch at the front of the command line to route messages to the persistent\nconsole window (see file testecho-messages.py in the examples package):\nC:\\...\\PP4E\\dev\\Examples\\PP4E\\Internet\\Sockets> echo-server-sleep.py\nServer connected by ('127.0.0.1', 59625)\nServer connected by ('127.0.0.1', 59626)\nServer connected by ('127.0.0.1', 59627)\nServer connected by ('127.0.0.1', 59628)\nServer connected by ('127.0.0.1', 59629)\nServer connected by ('127.0.0.1', 59630)\nC:\\...\\PP4E\\dev\\Examples\\PP4E\\Internet\\Sockets> testecho-messages.py\n/B echo-client.py\n/B echo-client.py\n/B echo-client.py\n/B echo-client.py\n/B echo-client.py\n/B echo-client.py\n/B echo-client.py\n/B echo-client.py\nClient received: b'Echo=>Hello network world'\nTraceback (most recent call last):\n  File \"C:\\...\\PP4E\\Internet\\Sockets\\echo-client.py\", line 24, in <module>\n    sockobj.connect((serverHost, serverPort))   # connect to server machine...\nsocket.error: [Errno 10061] No connection could be made because the target\nmachine actively refused it\nTraceback (most recent call last):\n  File \"C:\\...\\PP4E\\Internet\\Sockets\\echo-client.py\", line 24, in <module>\n    sockobj.connect((serverHost, serverPort))   # connect to server machine...\nsocket.error: [Errno 10061] No connection could be made because the target\nmachine actively refused it\n800 | Chapter 12:\u2002Network ScriptingClient received: b'Echo=>Hello network world'\nClient received: b'Echo=>Hello network world'\nClient received: b'Echo=>Hello network world'\nClient received: b'Echo=>Hello network world'\nClient received: b'Echo=>Hello network world'\nAs you can see, with such a sleepy server, 8 clients are spawned, but only 6 receive\nservice, and 2 fail with exceptions. Unless clients require very little of the server\u2019s at-\ntention, to handle multiple requests overlapping in time we need to somehow service\nclients in parallel. We\u2019ll see how servers can handle multiple clients more robustly in\na moment; first, though, let\u2019s experiment with some special ports.\nTalking to Reserved Ports\nIt\u2019s also important to know that this client and server engage in a proprietary sort of\ndiscussion, and so use the port number 50007 outside the range reserved for standard\nprotocols (0 to 1023). There\u2019s nothing preventing a client from opening a socket on\none of these special ports, however. For instance, the following client-side code con-\nnects to programs listening on the standard email, FTP, and HTTP web server ports\non three different server machines:\nC:\\...\\PP4E\\Internet\\Sockets> python\n>>> from socket import *\n>>> sock = socket(AF_INET, SOCK_STREAM)\n>>> sock.connect(('pop.secureserver.net', 110))    # talk to POP email server\n>>> print(sock.recv(70))\nb'+OK <14654.1272040794@p3pop01-09.prod.phx3.gdg>\\r\\n'\n>>> sock.close()\n>>> sock = socket(AF_INET, SOCK_STREAM)\n>>> sock.connect(('learning-python.com', 21))      # talk to FTP server\n>>> print(sock.recv(70))\nb'220---------- Welcome to Pure-FTPd [privsep] [TLS] ----------\\r\\n220-You'\n>>> sock.close()\n>>> sock = socket(AF_INET, SOCK_STREAM)\n>>> sock.connect(('www.python.net', 80))           # talk to Python's HTTP server\n>>> sock.send(b'GET /\\r\\n')                        # fetch root page reply\n7\n>>> sock.recv(70)\nb'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\\r\\n    \"http://'\n>>> sock.recv(70)\nb'www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\\r\\n<html xmlns=\"http://www.'\nIf we know how to interpret the output returned by these ports\u2019 servers, we could use\nraw sockets like this to fetch email, transfer files, and grab web pages and invoke server-\nside scripts. Fortunately, though, we don\u2019t have to worry about all the underlying de-\ntails\u2014Python\u2019s poplib, ftplib, and http.client and urllib.request modules provide\nhigher-level interfaces for talking to servers on these ports. Other Python protocol\nSocket Programming | 801modules do the same for other standard ports (e.g., NNTP, Telnet, and so on). We\u2019ll\nmeet some of these client-side protocol modules in the next chapter.\u00a7\nBinding reserved port servers\nSpeaking of reserved ports, it\u2019s all right to open client-side connections on reserved\nports as in the prior section, but you can\u2019t install your own server-side scripts for these\nports unless you have special permission. On the server I use to host learning-\npython.com, for instance, the web server port 80 is off limits (presumably, unless I shell\nout for a virtual or dedicated hosting account):\n[...]$ python\n>>> from socket import *\n>>> sock = socket(AF_INET, SOCK_STREAM)    # try to bind web port on general server\n>>> sock.bind(('', 80))                    # learning-python.com is a shared machine\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in\n  File \"<string>\", line 1, in bind\nsocket.error: (13, 'Permission denied')\nEven if run by a user with the required permission, you\u2019ll get the different exception\nwe saw earlier if the port is already being used by a real web server. On computers being\nused as general servers, these ports really are reserved. This is one reason we\u2019ll run a\nweb server of our own locally for testing when we start writing server-side scripts later\nin this book\u2014the above code works on a Windows PC, which allows us to experiment\nwith websites locally, on a self-contained machine:\nC:\\...\\PP4E\\Internet\\Sockets> python\n>>> from socket import *\n>>> sock = socket(AF_INET, SOCK_STREAM)      # can bind port 80 on Windows\n>>> sock.bind(('', 80))                      # allows running server on localhost\n>>>\nWe\u2019ll learn more about installing web servers later in Chapter 15. For the purposes of\nthis chapter, we need to get realistic about how our socket servers handle their clients.\nHandling Multiple Clients\nThe echo client and server programs shown previously serve to illustrate socket funda-\nmentals. But the server model used suffers from a fairly major flaw. As described earlier,\nif multiple clients try to connect to the server, and it takes a long time to process a given\nclient\u2019s request, the server will fail. More accurately, if the cost of handling a given\n\u00a7 You might be interested to know that the last part of this example, talking to port 80, is exactly what your\nweb browser does as you surf the Web: followed links direct it to download web pages over this port. In fact,\nthis lowly port is the primary basis of the Web. In Chapter 15, we will meet an entire application environment\nbased upon sending formatted data over port 80\u2014CGI server-side scripting. At the bottom, though, the Web\nis just bytes over sockets, with a user interface. The wizard behind the curtain is not as impressive as he may\nseem!\n802 | Chapter 12:\u2002Network Scriptingrequest prevents the server from returning to the code that checks for new clients in a\ntimely manner, it won\u2019t be able to keep up with all the requests, and some clients will\neventually be denied connections.\nIn real-world client/server programs, it\u2019s far more typical to code a server so as to avoid\nblocking new requests while handling a current client\u2019s request. Perhaps the easiest\nway to do so is to service each client\u2019s request in parallel\u2014in a new process, in a new\nthread, or by manually switching (multiplexing) between clients in an event loop. This\nisn\u2019t a socket issue per se, and we already learned how to start processes and threads\nin Chapter 5. But since these schemes are so typical of socket server programming, let\u2019s\nexplore all three ways to handle client requests in parallel here.\nForking Servers\nThe script in Example 12-4 works like the original echo server, but instead forks a new\nprocess to handle each new client connection. Because the handleClient function runs\nin a new process, the dispatcher function can immediately resume its main loop in\norder to detect and service a new incoming request.\nExample 12-4. PP4E\\Internet\\Sockets\\fork-server.py\n\"\"\"\nServer side: open a socket on a port, listen for a message from a client,\nand send an echo reply; forks a process to handle each client connection;\nchild processes share parent's socket descriptors; fork is less portable\nthan threads--not yet on Windows, unless Cygwin or similar installed;\n\"\"\"\nimport os, time, sys\nfrom socket import *                      # get socket constructor and constants\nmyHost = ''                               # server machine, '' means local host\nmyPort = 50007                            # listen on a non-reserved port number\nsockobj = socket(AF_INET, SOCK_STREAM)           # make a TCP socket object\nsockobj.bind((myHost, myPort))                   # bind it to server port number\nsockobj.listen(5)                                # allow 5 pending connects\ndef now():                                       # current time on server\n    return time.ctime(time.time())\nactiveChildren = []\ndef reapChildren():                              # reap any dead child processes\n    while activeChildren:                        # else may fill up system table\n        pid, stat = os.waitpid(0, os.WNOHANG)    # don't hang if no child exited\n        if not pid: break\n        activeChildren.remove(pid)\ndef handleClient(connection):                    # child process: reply, exit\n    time.sleep(5)                                # simulate a blocking activity\n    while True:                                  # read, write a client socket\n        data = connection.recv(1024)             # till eof when socket closed\n        if not data: break\nHandling Multiple Clients | 803reply = 'Echo=>%s at %s' % (data, now())\n        connection.send(reply.encode())\n    connection.close()\n    os._exit(0)\ndef dispatcher():                                # listen until process killed\n    while True:                                  # wait for next connection,\n        connection, address = sockobj.accept()   # pass to process for service\n        print('Server connected by', address, end=' ')\n        print('at', now())\n        reapChildren()                           # clean up exited children now\n        childPid = os.fork()                     # copy this process\n        if childPid == 0:                        # if in child process: handle\n            handleClient(connection)\n        else:                                    # else: go accept next connect\n            activeChildren.append(childPid)      # add to active child pid list\ndispatcher()\nRunning the forking server\nParts of this script are a bit tricky, and most of its library calls work only on Unix-like\nplatforms. Crucially, it runs on Cygwin Python on Windows, but not standard Win-\ndows Python. Before we get into too many forking details, though, let\u2019s focus on how\nthis server arranges to handle multiple client requests.\nFirst, notice that to simulate a long-running operation (e.g., database updates, other\nnetwork traffic), this server adds a five-second time.sleep delay in its client handler\nfunction, handleClient. After the delay, the original echo reply action is performed.\nThat means that when we run a server and clients this time, clients won\u2019t receive the\necho reply until five seconds after they\u2019ve sent their requests to the server.\nTo help keep track of requests and replies, the server prints its system time each time\na client connect request is received, and adds its system time to the reply. Clients print\nthe reply time sent back from the server, not their own\u2014clocks on the server and client\nmay differ radically, so to compare apples to apples, all times are server times. Because\nof the simulated delays, we also must usually start each client in its own console window\non Windows (clients will hang in a blocked state while waiting for their reply).\nBut the grander story here is that this script runs one main parent process on the server\nmachine, which does nothing but watch for connections (in dispatcher), plus one child\nprocess per active client connection, running in parallel with both the main parent\nprocess and the other client processes (in handleClient). In principle, the server can\nhandle any number of clients without bogging down.\nTo test, let\u2019s first start the server remotely in a SSH or Telnet window, and start three\nclients locally in three distinct console windows. As we\u2019ll see in a moment, this server\ncan also be run under Cygwin locally if you have Cygwin but don\u2019t have a remote server\naccount like the one on learning-python.com used here:\n804 | Chapter 12:\u2002Network Scripting[server window (SSH or Telnet)]\n[...]$ uname -p -o\ni686 GNU/Linux\n[...]$ python fork-server.py\nServer connected by ('72.236.109.185', 58395) at Sat Apr 24 06:46:45 2010\nServer connected by ('72.236.109.185', 58396) at Sat Apr 24 06:46:49 2010\nServer connected by ('72.236.109.185', 58397) at Sat Apr 24 06:46:51 2010\n[client window 1]\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py learning-python.com\nClient received: b\"Echo=>b'Hello network world' at Sat Apr 24 06:46:50 2010\"\n[client window 2]\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py learning-python.com Bruce\nClient received: b\"Echo=>b'Bruce' at Sat Apr 24 06:46:54 2010\"\n[client window 3]\nC:\\...\\Sockets> python echo-client.py learning-python.com The Meaning of Life\nClient received: b\"Echo=>b'The' at Sat Apr 24 06:46:56 2010\"\nClient received: b\"Echo=>b'Meaning' at Sat Apr 24 06:46:56 2010\"\nClient received: b\"Echo=>b'of' at Sat Apr 24 06:46:56 2010\"\nClient received: b\"Echo=>b'Life' at Sat Apr 24 06:46:57 2010\"\nAgain, all times here are on the server machine. This may be a little confusing because\nfour windows are involved. In plain English, the test proceeds as follows:\n1. The server starts running remotely.\n2. All three clients are started and connect to the server a few seconds apart.\n3. On the server, the client requests trigger three forked child processes, which all\nimmediately go to sleep for five seconds (to simulate being busy doing something\nuseful).\n4. Each client waits until the server replies, which happens five seconds after their\ninitial requests.\nIn other words, clients are serviced at the same time by forked processes, while the main\nparent process continues listening for new client requests. If clients were not handled\nin parallel like this, no client could connect until the currently connected client\u2019s five-\nsecond delay expired.\nIn a more realistic application, that delay could be fatal if many clients were trying to\nconnect at once\u2014the server would be stuck in the action we\u2019re simulating with\ntime.sleep, and not get back to the main loop to accept new client requests. With\nprocess forks per request, clients can be serviced in parallel.\nNotice that we\u2019re using the same client script here (echo-client.py, from Exam-\nple 12-2), just a different server; clients simply send and receive data to a machine and\nport and don\u2019t care how their requests are handled on the server. The result displayed\nshows a byte string within a byte string, because the client sends one to the server and\nthe server sends one back; because the server uses string formatting and manual\nHandling Multiple Clients | 805encoding instead of byte string concatenation, the client\u2019s message is shown as byte\nstring explicitly here.\nOther run modes: Local servers with Cygwin and remote clients\nAlso note that the server is running remotely on a Linux machine in the preceding\nsection. As we learned in Chapter 5, the fork call is not supported on Windows in\nstandard Python at the time this book was written. It does run on Cygwin Python,\nthough, which allows us to start this server locally on localhost, on the same machine\nas its clients:\n[Cygwin shell window]\n[C:\\...\\PP4E\\Internet\\Socekts]$ python fork-server.py\nServer connected by ('127.0.0.1', 58258) at Sat Apr 24 07:50:15 2010\nServer connected by ('127.0.0.1', 58259) at Sat Apr 24 07:50:17 2010\n[Windows console, same machine]\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py localhost bright side of life\nClient received: b\"Echo=>b'bright' at Sat Apr 24 07:50:20 2010\"\nClient received: b\"Echo=>b'side' at Sat Apr 24 07:50:20 2010\"\nClient received: b\"Echo=>b'of' at Sat Apr 24 07:50:20 2010\"\nClient received: b\"Echo=>b'life' at Sat Apr 24 07:50:20 2010\"\n[Windows console, same machine]\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py\nClient received: b\"Echo=>b'Hello network world' at Sat Apr 24 07:50:22 2010\"\nWe can also run this test on the remote Linux server entirely, with two SSH or Telnet\nwindows. It works about the same as when clients are started locally, in a DOS console\nwindow, but here \u201clocal\u201d actually means a remote machine you\u2019re using locally. Just\nfor fun, let\u2019s also contact the remote server from a locally running client to show how\nthe server is also available to the Internet at large\u2014when servers are coded with sockets\nand forks this way, clients can connect from arbitrary machines, and can overlap arbi-\ntrarily in time:\n[one SSH (or Telnet) window]\n[...]$ python fork-server.py\nServer connected by ('127.0.0.1', 55743) at Sat Apr 24 07:15:14 2010\nServer connected by ('127.0.0.1', 55854) at Sat Apr 24 07:15:26 2010\nServer connected by ('127.0.0.1', 55950) at Sat Apr 24 07:15:36 2010\nServer connected by ('72.236.109.185', 58414) at Sat Apr 24 07:19:50 2010\n[another SSH window, same machine]\n[...]$ python echo-client.py\nClient received: b\"Echo=>b'Hello network world' at Sat Apr 24 07:15:19 2010\"\n[...]$ python echo-client.py localhost niNiNI!\nClient received: b\"Echo=>b'niNiNI!' at Sat Apr 24 07:15:31 2010\"\n[...]$ python echo-client.py localhost Say no more!\nClient received: b\"Echo=>b'Say' at Sat Apr 24 07:15:41 2010\"\nClient received: b\"Echo=>b'no' at Sat Apr 24 07:15:41 2010\"\nClient received: b\"Echo=>b'more!' at Sat Apr 24 07:15:41 2010\"\n[Windows console, local machine]\n806 | Chapter 12:\u2002Network ScriptingC:\\...\\Internet\\Sockets> python echo-client.py learning-python.com Blue, no yellow!\nClient received: b\"Echo=>b'Blue,' at Sat Apr 24 07:19:55 2010\"\nClient received: b\"Echo=>b'no' at Sat Apr 24 07:19:55 2010\"\nClient received: b\"Echo=>b'yellow!' at Sat Apr 24 07:19:55 2010\"\nNow that we have a handle on the basic model, let\u2019s move on to the tricky bits. This\nserver script is fairly straightforward as forking code goes, but a few words about the\nlibrary tools it employs are in order.\nForked processes and sockets\nWe met os.fork in Chapter 5, but recall that forked processes are essentially a copy of\nthe process that forks them, and so they inherit file and socket descriptors from their\nparent process. As a result, the new child process that runs the handleClient function\nhas access to the connection socket created in the parent process. Really, this is why\nthe child process works at all\u2014when conversing on the connected socket, it\u2019s using\nthe same socket that parent\u2019s accept call returns. Programs know they are in a forked\nchild process if the fork call returns 0; otherwise, the original parent process gets back\nthe new child\u2019s ID.\nExiting from children\nIn earlier fork examples, child processes usually call one of the exec variants to start a\nnew program in the child process. Here, instead, the child process simply calls a func-\ntion in the same program and exits with os._exit. It\u2019s imperative to call os._exit here\u2014\nif we did not, each child would live on after handleClient returns, and compete for\naccepting new client requests.\nIn fact, without the exit call, we\u2019d wind up with as many perpetual server processes as\nrequests served\u2014remove the exit call and do a ps shell command after running a few\nclients, and you\u2019ll see what I mean. With the call, only the single parent process listens\nfor new requests. os._exit is like sys.exit, but it exits the calling process immediately\nwithout cleanup actions. It\u2019s normally used only in child processes, and sys.exit is\nused everywhere else.\nKilling the zombies: Don\u2019t fear the reaper!\nNote, however, that it\u2019s not quite enough to make sure that child processes exit and\ndie. On systems like Linux, though not on Cygwin, parents must also be sure to issue\na wait system call to remove the entries for dead child processes from the system\u2019s\nprocess table. If we don\u2019t do this, the child processes will no longer run, but they will\nconsume an entry in the system process table. For long-running servers, these bogus\nentries may become problematic.\nIt\u2019s common to call such dead-but-listed child processes zombies: they continue to use\nsystem resources even though they\u2019ve already passed over to the great operating system\nbeyond. To clean up after child processes are gone, this server keeps a list,\nHandling Multiple Clients | 807activeChildren, of the process IDs of all child processes it spawns. Whenever a new \nincoming client request is received, the server runs its reapChildren to issue a wait for \nany dead children by issuing the standard Python os.waitpid(0,os.WNOHANG) call.\nThe os.waitpid call attempts to wait for a child process to exit and returns its process \nID and exit status. With a 0 for its first argument, it waits for any child process. With \nthe WNOHANG parameter for its second, it does nothing if no child process has exited (i.e., \nit does not block or pause the caller). The net effect is that this call simply asks the \noperating system for the process ID of any child that has exited. If any have, the process \nID returned is removed both from the system process table and from this script\u2019s \nactiveChildren list.\nTo see why all this complexity is needed, comment out the reapChildren call in this \nscript, run it on a platform where this is an issue, and then run a few clients. On my \nLinux server, a ps -f full process listing command shows that all the dead child pro-\ncesses stay in the system process table (show as <defunct>):\n[...]$ ps \u2013f\nUID        PID  PPID  C STIME TTY          TIME CMD\n5693094   9990 30778  0 04:34 pts/0    00:00:00 python fork-server.py\n5693094  10844  9990  0 04:35 pts/0    00:00:00 [python] <defunct>\n5693094  10869  9990  0 04:35 pts/0    00:00:00 [python] <defunct>\n5693094  11130  9990  0 04:36 pts/0    00:00:00 [python] <defunct>\n5693094  11151  9990  0 04:36 pts/0    00:00:00 [python] <defunct>\n5693094  11482 30778  0 04:36 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 -bash\nWhen the reapChildren command is reactivated, dead child zombie entries are cleaned \nup each time the server gets a new client connection request, by calling the Python \nos.waitpid function. A few zombies may accumulate if the server is heavily loaded, but \nthey will remain only until the next client connection is received (you get only as many \nzombies as processes served in parallel since the last accept):\n[...]$ python fork-server.py &\n[1] 20515\n[...]$ ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\n5693094  20515 30778  0 04:43 pts/0    00:00:00 python fork-server.py\n5693094  20777 30778  0 04:43 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 -bash\n[...]$\nServer connected by ('72.236.109.185', 58672) at Sun Apr 25 04:43:51 2010\nServer connected by ('72.236.109.185', 58673) at Sun Apr 25 04:43:54 2010\n[...]$ ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\n5693094  20515 30778  0 04:43 pts/0    00:00:00 python fork-server.py\n5693094  21339 20515  0 04:43 pts/0    00:00:00 [python] <defunct>\n5693094  21398 20515  0 04:43 pts/0    00:00:00 [python] <defunct>\n5693094  21573 30778  0 04:44 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 -bash\n[...]$\nServer connected by ('72.236.109.185', 58674) at Sun Apr 25 04:44:07 2010\n808 | Chapter 12:\u2002Network Scripting[...]$ ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\n5693094  20515 30778  0 04:43 pts/0    00:00:00 python fork-server.py\n5693094  21646 20515  0 04:44 pts/0    00:00:00 [python] <defunct>\n5693094  21813 30778  0 04:44 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 -bash\nIn fact, if you type fast enough, you can actually see a child process morph from a real\nrunning program into a zombie. Here, for example, a child spawned to handle a new\nrequest changes to <defunct> on exit. Its connection cleans up lingering zombies, and\nits own process entry will be removed completely when the next request is received:\n[...]$\nServer connected by ('72.236.109.185', 58676) at Sun Apr 25 04:48:22 2010\n[...] ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\n5693094  20515 30778  0 04:43 pts/0    00:00:00 python fork-server.py\n5693094  27120 20515  0 04:48 pts/0    00:00:00 python fork-server.py\n5693094  27174 30778  0 04:48 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 -bash\n[...]$ ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\n5693094  20515 30778  0 04:43 pts/0    00:00:00 python fork-server.py\n5693094  27120 20515  0 04:48 pts/0    00:00:00 [python] <defunct>\n5693094  27234 30778  0 04:48 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 -bash\nPreventing zombies with signal handlers on Linux\nOn some systems, it\u2019s also possible to clean up zombie child processes by resetting the\nsignal handler for the SIGCHLD signal delivered to a parent process by the operating\nsystem when a child process stops or exits. If a Python script assigns the SIG_IGN (ignore)\naction as the SIGCHLD signal handler, zombies will be removed automatically and im-\nmediately by the operating system as child processes exit; the parent need not issue\nwait calls to clean up after them. Because of that, this scheme is a simpler alternative\nto manually reaping zombies on platforms where it is supported.\nIf you\u2019ve already read Chapter 5, you know that Python\u2019s standard signal module lets\nscripts install handlers for signals\u2014software-generated events. By way of review, here\nis a brief bit of background to show how this pans out for zombies. The program in\nExample 12-5 installs a Python-coded signal handler function to respond to whatever\nsignal number you type on the command line.\nExample 12-5. PP4E\\Internet\\Sockets\\signal-demo.py\n\"\"\"\nDemo Python's signal module; pass signal number as a command-line arg, and use\na \"kill -N pid\" shell command to send this process a signal; on my Linux machine,\nSIGUSR1=10, SIGUSR2=12, SIGCHLD=17, and SIGCHLD handler stays in effect even if\nnot restored: all other handlers are restored by Python after caught, but SIGCHLD\nbehavior is left to the platform's implementation; signal works on Windows too,\nbut defines only a few signal types; signals are not very portable in general;\nHandling Multiple Clients | 809\"\"\"\nimport sys, signal, time\ndef now():\n    return time.asctime()\ndef onSignal(signum, stackframe):                # Python signal handler\n    print('Got signal', signum, 'at', now())     # most handlers stay in effect\n    if signum == signal.SIGCHLD:                 # but sigchld handler is not\n        print('sigchld caught')\n        #signal.signal(signal.SIGCHLD, onSignal)\nsignum = int(sys.argv[1])\nsignal.signal(signum, onSignal)                  # install signal handler\nwhile True: signal.pause()                       # sleep waiting for signals\nTo run this script, simply put it in the background and send it signals by typing the\nkill -signal-number process-id shell command line; this is the shell\u2019s equivalent of\nPython\u2019s os.kill function available on Unix-like platforms only. Process IDs are listed\nin the PID column of ps command results. Here is this script in action catching signal\nnumbers 10 (reserved for general use) and 9 (the unavoidable terminate signal):\n[...]$ python signal-demo.py 10 &\n[1] 10141\n[...]$ ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\n5693094  10141 30778  0 05:00 pts/0    00:00:00 python signal-demo.py 10\n5693094  10228 30778  0 05:00 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 -bash\n[...]$ kill \u221210 10141\nGot signal 10 at Sun Apr 25 05:00:31 2010\n[...]$ kill \u221210 10141\nGot signal 10 at Sun Apr 25 05:00:34 2010\n[...]$ kill \u22129 10141\n[1]+  Killed                  python signal-demo.py 10\nAnd in the following the script catches signal 17, which happens to be SIGCHLD on my\nLinux server. Signal numbers vary from machine to machine, so you should normally\nuse their names, not their numbers. SIGCHLD behavior may vary per platform as well.\nOn my Cygwin install, for example, signal 10 can have different meaning, and signal\n20 is SIGCHLD\u2014on Cygwin, the script works as shown on Linux here for signal 10,\nbut generates an exception if it tries to install on handler for signal 17 (and Cygwin\ndoesn\u2019t require reaping in any event). See the signal module\u2019s library manual entry for\nmore details:\n[...]$ python signal-demo.py 17 &\n[1] 11592\n[...]$ ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\n810 | Chapter 12:\u2002Network Scripting5693094  11592 30778  0 05:00 pts/0    00:00:00 python signal-demo.py 17\n5693094  11728 30778  0 05:01 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 -bash\n[...]$ kill \u221217 11592\nGot signal 17 at Sun Apr 25 05:01:28 2010\nsigchld caught\n[...]$ kill \u221217 11592\nGot signal 17 at Sun Apr 25 05:01:35 2010\nsigchld caught\n[...]$ kill \u22129 11592\n[1]+  Killed                  python signal-demo.py 17\nNow, to apply all of this signal knowledge to killing zombies, simply set the SIGCHLD\nsignal handler to the SIG_IGN ignore handler action; on systems where this assignment\nis supported, child processes will be cleaned up when they exit. The forking server\nvariant shown in Example 12-6 uses this trick to manage its children.\nExample 12-6. PP4E\\Internet\\Sockets\\fork-server-signal.py\n\"\"\"\nSame as fork-server.py, but use the Python signal module to avoid keeping\nchild zombie processes after they terminate, instead of an explicit reaper\nloop before each new connection; SIG_IGN means ignore, and may not work with\nSIG_CHLD child exit signal on all platforms; see Linux documentation for more\nabout the restartability of a socket.accept call interrupted with a signal;\n\"\"\"\nimport os, time, sys, signal, signal\nfrom socket import *                      # get socket constructor and constants\nmyHost = ''                               # server machine, '' means local host\nmyPort = 50007                            # listen on a non-reserved port number\nsockobj = socket(AF_INET, SOCK_STREAM)           # make a TCP socket object\nsockobj.bind((myHost, myPort))                   # bind it to server port number\nsockobj.listen(5)                                # up to 5 pending connects\nsignal.signal(signal.SIGCHLD, signal.SIG_IGN)    # avoid child zombie processes\ndef now():                                       # time on server machine\n    return time.ctime(time.time())\ndef handleClient(connection):                    # child process replies, exits\n    time.sleep(5)                                # simulate a blocking activity\n    while True:                                  # read, write a client socket\n        data = connection.recv(1024)\n        if not data: break\n        reply = 'Echo=>%s at %s' % (data, now())\n        connection.send(reply.encode())\n    connection.close()\n    os._exit(0)\ndef dispatcher():                                # listen until process killed\n    while True:                                  # wait for next connection,\nHandling Multiple Clients | 811connection, address = sockobj.accept()   # pass to process for service\n        print('Server connected by', address, end=' ')\n        print('at', now())\n        childPid = os.fork()                     # copy this process\n        if childPid == 0:                        # if in child process: handle\n            handleClient(connection)             # else: go accept next connect\ndispatcher()\nWhere applicable, this technique is:\n\u2022 Much simpler; we don\u2019t need to manually track or reap child processes.\n\u2022 More accurate; it leaves no zombies temporarily between client requests.\nIn fact, only one line is dedicated to handling zombies here: the signal.signal call near\nthe top, to set the handler. Unfortunately, this version is also even less portable than\nusing os.fork in the first place, because signals may work slightly differently from plat-\nform to platform, even among Unix variants. For instance, some Unix platforms may\nnot allow SIG_IGN to be used as the SIGCHLD action at all. On Linux systems, though,\nthis simpler forking server variant works like a charm:\n[...]$ python fork-server-signal.py &\n[1] 3837\nServer connected by ('72.236.109.185', 58817) at Sun Apr 25 08:11:12 2010\n[...] ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\n5693094   3837 30778  0 08:10 pts/0    00:00:00 python fork-server-signal.py\n5693094   4378  3837  0 08:11 pts/0    00:00:00 python fork-server-signal.py\n5693094   4413 30778  0 08:11 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 -bash\n[...]$ ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\n5693094   3837 30778  0 08:10 pts/0    00:00:00 python fork-server-signal.py\n5693094   4584 30778  0 08:11 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 \u2013bash\nNotice how in this version the child process\u2019s entry goes away as soon as it exits, even\nbefore a new client request is received; no \u201cdefunct\u201d zombie ever appears. More dra-\nmatically, if we now start up the script we wrote earlier that spawns eight clients in\nparallel (testecho.py) to talk to this server remotely, all appear on the server while run-\nning, but are removed immediately as they exit:\n[client window]\nC:\\...\\PP4E\\Internet\\Sockets> testecho.py learning-python.com\n[server window]\n[...]$\nServer connected by ('72.236.109.185', 58829) at Sun Apr 25 08:16:34 2010\nServer connected by ('72.236.109.185', 58830) at Sun Apr 25 08:16:34 2010\nServer connected by ('72.236.109.185', 58831) at Sun Apr 25 08:16:34 2010\nServer connected by ('72.236.109.185', 58832) at Sun Apr 25 08:16:34 2010\n812 | Chapter 12:\u2002Network ScriptingServer connected by ('72.236.109.185', 58833) at Sun Apr 25 08:16:34 2010\nServer connected by ('72.236.109.185', 58834) at Sun Apr 25 08:16:34 2010\nServer connected by ('72.236.109.185', 58835) at Sun Apr 25 08:16:34 2010\nServer connected by ('72.236.109.185', 58836) at Sun Apr 25 08:16:34 2010\n[...]$ ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\n5693094   3837 30778  0 08:10 pts/0    00:00:00 python fork-server-signal.py\n5693094   9666  3837  0 08:16 pts/0    00:00:00 python fork-server-signal.py\n5693094   9667  3837  0 08:16 pts/0    00:00:00 python fork-server-signal.py\n5693094   9668  3837  0 08:16 pts/0    00:00:00 python fork-server-signal.py\n5693094   9670  3837  0 08:16 pts/0    00:00:00 python fork-server-signal.py\n5693094   9674  3837  0 08:16 pts/0    00:00:00 python fork-server-signal.py\n5693094   9678  3837  0 08:16 pts/0    00:00:00 python fork-server-signal.py\n5693094   9681  3837  0 08:16 pts/0    00:00:00 python fork-server-signal.py\n5693094   9682  3837  0 08:16 pts/0    00:00:00 python fork-server-signal.py\n5693094   9722 30778  0 08:16 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 -bash\n[...]$ ps -f\nUID        PID  PPID  C STIME TTY          TIME CMD\n5693094   3837 30778  0 08:10 pts/0    00:00:00 python fork-server-signal.py\n5693094  10045 30778  0 08:16 pts/0    00:00:00 ps -f\n5693094  30778 30772  0 04:23 pts/0    00:00:00 \u2013bash\nAnd now that I\u2019ve shown you how to use signal handling to reap children automatically\non Linux, I should underscore that this technique is not universally supported across\nall flavors of Unix. If you care about portability, manually reaping children as we did\nin Example 12-4 may still be desirable.\nWhy multiprocessing doesn\u2019t help with socket server portability\nIn Chapter 5, we learned about Python\u2019s new multiprocessing module. As we saw, it\nprovides a way to start function calls in new processes that is more portable than the\nos.fork call used in this section\u2019s server code, and it runs processes instead of threads\nto work around the thread GIL in some scenarios. In particular, multiprocessing works\non standard Windows Python too, unlike direct os.fork calls.\nI experimented with a server variant based upon this module to see if its portability\nmight help for socket servers. Its full source code is in the examples package in file\nmulti-server.py, but here are its important bits that differ:\n...rest unchanged from fork-server.py...\nfrom multiprocessing import Process\ndef handleClient(connection):\n    print('Child:', os.getpid())                 # child process: reply, exit\n    time.sleep(5)                                # simulate a blocking activity\n    while True:                                  # read, write a client socket\n        data = connection.recv(1024)             # till eof when socket closed\n        ...rest unchanged...\ndef dispatcher():                                # listen until process killed\nHandling Multiple Clients | 813while True:                                  # wait for next connection,\n        connection, address = sockobj.accept()   # pass to process for service\n        print('Server connected by', address, end=' ')\n        print('at', now())\n        Process(target=handleClient, args=(connection,)).start()\nif __name__ == '__main__':\n    print('Parent:', os.getpid())\n    sockobj = socket(AF_INET, SOCK_STREAM)           # make a TCP socket object\n    sockobj.bind((myHost, myPort))                   # bind it to server port number\n    sockobj.listen(5)                                # allow 5 pending connects\n    dispatcher()\nThis server variant is noticeably simpler too. Like the forking server it\u2019s derived from,\nthis server works fine under Cygwin Python on Windows running as localhost, and\nwould probably work on other Unix-like platforms as well, because multiprocessing\nforks a process on such systems, and file and socket descriptors are inherited by child\nprocesses as usual. Hence, the child process uses the same connected socket as the\nparent. Here\u2019s the scene in a Cygwin server window and two Windows client windows:\n[server window]\n[C:\\...\\PP4E\\Internet\\Sockets]$ python multi-server.py\nParent: 8388\nServer connected by ('127.0.0.1', 58271) at Sat Apr 24 08:13:27 2010\nChild: 8144\nServer connected by ('127.0.0.1', 58272) at Sat Apr 24 08:13:29 2010\nChild: 8036\n[two client windows]\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py\nClient received: b\"Echo=>b'Hello network world' at Sat Apr 24 08:13:33 2010\"\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py localhost Brave Sir Robin\nClient received: b\"Echo=>b'Brave' at Sat Apr 24 08:13:35 2010\"\nClient received: b\"Echo=>b'Sir' at Sat Apr 24 08:13:35 2010\"\nClient received: b\"Echo=>b'Robin' at Sat Apr 24 08:13:35 2010\"\nHowever, this server does not work on standard Windows Python\u2014the whole point\nof trying to use multiprocessing in this context\u2014because open sockets are not correctly\npickled when passed as arguments into the new process. Here\u2019s what occurs in the\nserver windows on Windows 7 with Python 3.1:\nC:\\...\\PP4E\\Internet\\Sockets> python multi-server.py\nParent: 9140\nServer connected by ('127.0.0.1', 58276) at Sat Apr 24 08:17:41 2010\nChild: 9628\nProcess Process-1:\nTraceback (most recent call last):\n  File \"C:\\Python31\\lib\\multiprocessing\\process.py\", line 233, in _bootstrap\n    self.run()\n  File \"C:\\Python31\\lib\\multiprocessing\\process.py\", line 88, in run\n    self._target(*self._args, **self._kwargs)\n  File \"C:\\...\\PP4E\\Internet\\Sockets\\multi-server.py\", line 38, in handleClient\n    data = connection.recv(1024)             # till eof when socket closed\n814 | Chapter 12:\u2002Network Scriptingsocket.error: [Errno 10038] An operation was attempted on something that is not\na socket\nRecall from Chapter 5 that on Windows multiprocessing passes context to a new\nPython interpreter process by pickling it, and that Process arguments must all be\npickleable for Windows. Sockets in Python 3.1 don\u2019t trigger errors when pickled thanks\nto the class they are an instance of, but they are not really pickled correctly:\n>>> from pickle import *\n>>> from socket import *\n>>> s = socket()\n>>> x = dumps(s)\n>>> s\n<socket.socket object, fd=180, family=2, type=1, proto=0>\n>>> loads(x)\n<socket.socket object, fd=-1, family=0, type=0, proto=0>\n>>> x\nb'\\x80\\x03csocket\\nsocket\\nq\\x00)\\x81q\\x01N}q\\x02(X\\x08\\x00\\x00\\x00_io_refsq\\x03\nK\\x00X\\x07\\x00\\x00\\x00_closedq\\x04\\x89u\\x86q\\x05b.'\nAs we saw in Chapter 5, multiprocessing has other IPC tools such as its own pipes and\nqueues that might be used instead of sockets to work around this issue, but clients\nwould then have to use them, too\u2014the resulting server would not be as broadly ac-\ncessible as one based upon general Internet sockets.\nEven if multiprocessing did work on Windows, though, its need to start a new Python\ninterpreter would likely make it much slower than the more traditional technique of\nspawning threads to talk to clients. Coincidentally, that brings us to our next topic.\nThreading Servers\nThe forking model just described works well on Unix-like platforms in general, but it\nsuffers from some potentially significant limitations:\nPerformance\nOn some machines, starting a new process can be fairly expensive in terms of time\nand space resources.\nPortability\nForking processes is a Unix technique; as we\u2019ve learned, the os.fork call currently\ndoesn\u2019t work on non-Unix platforms such as Windows under standard Python. As\nwe\u2019ve also learned, forks can be used in the Cygwin version of Python on Windows,\nbut they may be inefficient and not exactly the same as Unix forks. And as we just\ndiscovered, multiprocessing won\u2019t help on Windows, because connected sockets\nare not pickleable across process boundaries.\nComplexity\nIf you think that forking servers can be complicated, you\u2019re not alone. As we just\nsaw, forking also brings with it all the shenanigans of managing and reaping zom-\nbies\u2014cleaning up after child processes that live shorter lives than their parents.\nHandling Multiple Clients | 815If you read Chapter 5, you know that one solution to all of these dilemmas is to use\nthreads rather than processes. Threads run in parallel and share global (i.e., module\nand interpreter) memory.\nBecause threads all run in the same process and memory space, they automatically share\nsockets passed between them, similar in spirit to the way that child processes inherit\nsocket descriptors. Unlike processes, though, threads are usually less expensive to start,\nand work on both Unix-like machines and Windows under standard Python today.\nFurthermore, many (though not all) see threads as simpler to program\u2014child threads\ndie silently on exit, without leaving behind zombies to haunt the server.\nTo illustrate, Example 12-7 is another mutation of the echo server that handles client\nrequests in parallel by running them in threads rather than in processes.\nExample 12-7. PP4E\\Internet\\Sockets\\thread-server.py\n\"\"\"\nServer side: open a socket on a port, listen for a message from a client,\nand send an echo reply; echoes lines until eof when client closes socket;\nspawns a thread to handle each client connection; threads share global\nmemory space with main thread; this is more portable than fork: threads\nwork on standard Windows systems, but process forks do not;\n\"\"\"\nimport time, _thread as thread           # or use threading.Thread().start()\nfrom socket import *                     # get socket constructor and constants\nmyHost = ''                              # server machine, '' means local host\nmyPort = 50007                           # listen on a non-reserved port number\nsockobj = socket(AF_INET, SOCK_STREAM)           # make a TCP socket object\nsockobj.bind((myHost, myPort))                   # bind it to server port number\nsockobj.listen(5)                                # allow up to 5 pending connects\ndef now():\n    return time.ctime(time.time())               # current time on the server\ndef handleClient(connection):                    # in spawned thread: reply\n    time.sleep(5)                                # simulate a blocking activity\n    while True:                                  # read, write a client socket\n        data = connection.recv(1024)\n        if not data: break\n        reply = 'Echo=>%s at %s' % (data, now())\n        connection.send(reply.encode())\n    connection.close()\ndef dispatcher():                                # listen until process killed\n    while True:                                  # wait for next connection,\n        connection, address = sockobj.accept()   # pass to thread for service\n        print('Server connected by', address, end=' ')\n        print('at', now())\n        thread.start_new_thread(handleClient, (connection,))\ndispatcher()\n816 | Chapter 12:\u2002Network ScriptingThis dispatcher delegates each incoming client connection request to a newly spawned\nthread running the handleClient function. As a result, this server can process multiple\nclients at once, and the main dispatcher loop can get quickly back to the top to check\nfor newly arrived requests. The net effect is that new clients won\u2019t be denied service\ndue to a busy server.\nFunctionally, this version is similar to the fork solution (clients are handled in parallel),\nbut it will work on any machine that supports threads, including Windows and Linux.\nLet\u2019s test it on both. First, start the server on a Linux machine and run clients on both\nLinux and Windows:\n[window 1: thread-based server process, server keeps accepting\nclient connections while threads are servicing prior requests]\n[...]$ python thread-server.py\nServer connected by ('127.0.0.1', 37335) at Sun Apr 25 08:59:05 2010\nServer connected by ('72.236.109.185', 58866) at Sun Apr 25 08:59:54 2010\nServer connected by ('72.236.109.185', 58867) at Sun Apr 25 08:59:56 2010\nServer connected by ('72.236.109.185', 58868) at Sun Apr 25 08:59:58 2010\n[window 2: client, but on same remote server machine]\n[...]$ python echo-client.py\nClient received: b\"Echo=>b'Hello network world' at Sun Apr 25 08:59:10 2010\"\n[windows 3-5: local clients, PC]\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py learning-python.com\nClient received: b\"Echo=>b'Hello network world' at Sun Apr 25 08:59:59 2010\"\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py learning-python.com Bruce\nClient received: b\"Echo=>b'Bruce' at Sun Apr 25 09:00:01 2010\"\nC:\\...\\Sockets> python echo-client.py learning-python.com The Meaning of life\nClient received: b\"Echo=>b'The' at Sun Apr 25 09:00:03 2010\"\nClient received: b\"Echo=>b'Meaning' at Sun Apr 25 09:00:03 2010\"\nClient received: b\"Echo=>b'of' at Sun Apr 25 09:00:03 2010\"\nClient received: b\"Echo=>b'life' at Sun Apr 25 09:00:03 2010\"\nBecause this server uses threads rather than forked processes, we can run it portably\non both Linux and a Windows PC. Here it is at work again, running on the same local\nWindows PC as its clients; again, the main point to notice is that new clients are ac-\ncepted while prior clients are being processed in parallel with other clients and the main\nthread (in the five-second sleep delay):\n[window 1: server, on local PC]\nC:\\...\\PP4E\\Internet\\Sockets> python thread-server.py\nServer connected by ('127.0.0.1', 58987) at Sun Apr 25 12:41:46 2010\nServer connected by ('127.0.0.1', 58988) at Sun Apr 25 12:41:47 2010\nServer connected by ('127.0.0.1', 58989) at Sun Apr 25 12:41:49 2010\n[windows 2-4: clients, on local PC]\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py\nClient received: b\"Echo=>b'Hello network world' at Sun Apr 25 12:41:51 2010\"\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py localhost Brian\nHandling Multiple Clients | 817Client received: b\"Echo=>b'Brian' at Sun Apr 25 12:41:52 2010\"\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py localhost Bright side of life\nClient received: b\"Echo=>b'Bright' at Sun Apr 25 12:41:54 2010\"\nClient received: b\"Echo=>b'side' at Sun Apr 25 12:41:54 2010\"\nClient received: b\"Echo=>b'of' at Sun Apr 25 12:41:54 2010\"\nClient received: b\"Echo=>b'life' at Sun Apr 25 12:41:54 2010\"\nRemember that a thread silently exits when the function it is running returns; unlike\nthe process fork version, we don\u2019t call anything like os._exit in the client handler func-\ntion (and we shouldn\u2019t\u2014it may kill all threads in the process, including the main loop\nwatching for new connections!). Because of this, the thread version is not only more\nportable, but also simpler.\nStandard Library Server Classes\nNow that I\u2019ve shown you how to write forking and threading servers to process clients\nwithout blocking incoming requests, I should also tell you that there are standard tools\nin the Python standard library to make this process even easier. In particular, the\nsocketserver module defines classes that implement all flavors of forking and threading\nservers that you are likely to be interested in.\nLike the manually-coded servers we\u2019ve just studied, this module\u2019s primary classes im-\nplement servers which process clients in parallel (a.k.a. asynchronously) to avoid de-\nnying service to new requests during long-running transactions. Their net effect is to\nautomate the top-levels of common server code. To use this module, simply create the\ndesired kind of imported server object, passing in a handler object with a callback\nmethod of your own, as demonstrated in the threaded TCP server of Example 12-8.\nExample 12-8. PP4E\\Internet\\Sockets\\class-server.py\n\"\"\"\nServer side: open a socket on a port, listen for a message from a client, and\nsend an echo reply; this version uses the standard library module socketserver to\ndo its work; socketserver provides TCPServer, ThreadingTCPServer, ForkingTCPServer,\nUDP variants of these, and more, and routes each client connect request to a new\ninstance of a passed-in request handler object's handle method; socketserver also\nsupports Unix domain sockets, but only on Unixen; see the Python library manual.\n\"\"\"\nimport socketserver, time               # get socket server, handler objects\nmyHost = ''                             # server machine, '' means local host\nmyPort = 50007                          # listen on a non-reserved port number\ndef now():\n    return time.ctime(time.time())\nclass MyClientHandler(socketserver.BaseRequestHandler):\n    def handle(self):                           # on each client connect\n        print(self.client_address, now())       # show this client's address\n        time.sleep(5)                           # simulate a blocking activity\n        while True:                             # self.request is client socket\n818 | Chapter 12:\u2002Network Scriptingdata = self.request.recv(1024)      # read, write a client socket\n            if not data: break\n            reply = 'Echo=>%s at %s' % (data, now())\n            self.request.send(reply.encode())\n        self.request.close()\n# make a threaded server, listen/handle clients forever\nmyaddr = (myHost, myPort)\nserver = socketserver.ThreadingTCPServer(myaddr, MyClientHandler)\nserver.serve_forever()\nThis server works the same as the threading server we wrote by hand in the previous\nsection, but instead focuses on service implementation (the customized handle\nmethod), not on threading details. It is run the same way, too\u2014here it is processing\nthree clients started by hand, plus eight spawned by the testecho script shown we wrote\nin Example 12-3:\n[window 1: server, serverHost='localhost' in echo-client.py]\nC:\\...\\PP4E\\Internet\\Sockets> python class-server.py\n('127.0.0.1', 59036) Sun Apr 25 13:50:23 2010\n('127.0.0.1', 59037) Sun Apr 25 13:50:25 2010\n('127.0.0.1', 59038) Sun Apr 25 13:50:26 2010\n('127.0.0.1', 59039) Sun Apr 25 13:51:05 2010\n('127.0.0.1', 59040) Sun Apr 25 13:51:05 2010\n('127.0.0.1', 59041) Sun Apr 25 13:51:06 2010\n('127.0.0.1', 59042) Sun Apr 25 13:51:06 2010\n('127.0.0.1', 59043) Sun Apr 25 13:51:06 2010\n('127.0.0.1', 59044) Sun Apr 25 13:51:06 2010\n('127.0.0.1', 59045) Sun Apr 25 13:51:06 2010\n('127.0.0.1', 59046) Sun Apr 25 13:51:06 2010\n[windows 2-4: client, same machine]\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py\nClient received: b\"Echo=>b'Hello network world' at Sun Apr 25 13:50:28 2010\"\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py localhost Arthur\nClient received: b\"Echo=>b'Arthur' at Sun Apr 25 13:50:30 2010\"\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py localhost Brave Sir Robin\nClient received: b\"Echo=>b'Brave' at Sun Apr 25 13:50:31 2010\"\nClient received: b\"Echo=>b'Sir' at Sun Apr 25 13:50:31 2010\"\nClient received: b\"Echo=>b'Robin' at Sun Apr 25 13:50:31 2010\"\nC:\\...\\PP4E\\Internet\\Sockets> python testecho.py\nTo build a forking server instead, just use the class name ForkingTCPServer when cre-\nating the server object. The socketserver module has more power than shown by this\nexample; it also supports nonparallel (a.k.a. serial or synchronous) servers, UDP and\nUnix domain sockets, and Ctrl-C server interrupts on Windows. See Python\u2019s library\nmanual for more details.\nFor more advanced server needs, Python also comes with standard library tools that\nuse those shown here, and allow you to implement in just a few lines of Python code a\nHandling Multiple Clients | 819simple but fully-functional HTTP (web) server that knows how to run server-side CGI\nscripts. We\u2019ll explore those larger server tools in Chapter 15.\nMultiplexing Servers with select\nSo far we\u2019ve seen how to handle multiple clients at once with both forked processes\nand spawned threads, and we\u2019ve looked at a library class that encapsulates both\nschemes. Under both approaches, all client handlers seem to run in parallel with one\nanother and with the main dispatch loop that continues watching for new incoming\nrequests. Because all of these tasks run in parallel (i.e., at the same time), the server\ndoesn\u2019t get blocked when accepting new requests or when processing a long-running\nclient handler.\nTechnically, though, threads and processes don\u2019t really run in parallel, unless you\u2019re\nlucky enough to have a machine with many CPUs. Instead, your operating system\nperforms a juggling act\u2014it divides the computer\u2019s processing power among all active\ntasks. It runs part of one, then part of another, and so on. All the tasks appear to run\nin parallel, but only because the operating system switches focus between tasks so fast\nthat you don\u2019t usually notice. This process of switching between tasks is sometimes\ncalled time-slicing when done by an operating system; it is more generally known as\nmultiplexing.\nWhen we spawn threads and processes, we rely on the operating system to juggle the\nactive tasks so that none are starved of computing resources, especially the main server\ndispatcher loop. However, there\u2019s no reason that a Python script can\u2019t do so as well.\nFor instance, a script might divide tasks into multiple steps\u2014run a step of one task,\nthen one of another, and so on, until all are completed. The script need only know how\nto divide its attention among the multiple active tasks to multiplex on its own.\nServers can apply this technique to yield yet another way to handle multiple clients at\nonce, a way that requires neither threads nor forks. By multiplexing client connections\nand the main dispatcher with the select system call, a single event loop can process\nmultiple clients and accept new ones in parallel (or at least close enough to avoid stall-\ning). Such servers are sometimes called asynchronous, because they service clients in\nspurts, as each becomes ready to communicate. In asynchronous servers, a single main\nloop run in a single process and thread decides which clients should get a bit of attention\neach time through. Client requests and the main dispatcher loop are each given a small\nslice of the server\u2019s attention if they are ready to converse.\nMost of the magic behind this server structure is the operating system select call,\navailable in Python\u2019s standard select module on all major platforms. Roughly,\nselect is asked to monitor a list of input sources, output sources, and exceptional\ncondition sources and tells us which sources are ready for processing. It can be made\nto simply poll all the sources to see which are ready; wait for a maximum time period\nfor sources to become ready; or wait indefinitely until one or more sources are ready\nfor processing.\n820 | Chapter 12:\u2002Network ScriptingHowever used, select lets us direct attention to sockets ready to communicate, so as\nto avoid blocking on calls to ones that are not. That is, when the sources passed to\nselect are sockets, we can be sure that socket calls like accept, recv, and send will not\nblock (pause) the server when applied to objects returned by select. Because of that,\na single-loop server that uses select need not get stuck communicating with one client\nor waiting for new ones while other clients are starved for the server\u2019s attention.\nBecause this type of server does not need to start threads or processes, it can be efficient\nwhen transactions with clients are relatively short-lived. However, it also requires that\nthese transactions be quick; if they are not, it still runs the risk of becoming bogged\ndown waiting for a dialog with a particular client to end, unless augmented with threads\nor forks for long-running transactions.\u2016\nA select-based echo server\nLet\u2019s see how all of this translates into code. The script in Example 12-9 implements\nanother echo server, one that can handle multiple clients without ever starting new\nprocesses or threads.\nExample 12-9. PP4E\\Internet\\Sockets\\select-server.py\n\"\"\"\nServer: handle multiple clients in parallel with select. use the select\nmodule to manually multiplex among a set of sockets: main sockets which\naccept new client connections, and input sockets connected to accepted\nclients; select can take an optional 4th arg--0 to poll, n.m to wait n.m\nseconds, or omitted to wait till any socket is ready for processing.\n\"\"\"\nimport sys, time\nfrom select import select\nfrom socket import socket, AF_INET, SOCK_STREAM\ndef now(): return time.ctime(time.time())\nmyHost = ''                             # server machine, '' means local host\nmyPort = 50007                          # listen on a non-reserved port number\nif len(sys.argv) == 3:                  # allow host/port as cmdline args too\n    myHost, myPort = sys.argv[1:]\nnumPortSocks = 2                        # number of ports for client connects\n# make main sockets for accepting new client requests\nmainsocks, readsocks, writesocks = [], [], []\nfor i in range(numPortSocks):\n    portsock = socket(AF_INET, SOCK_STREAM)   # make a TCP/IP socket object\n\u2016 Confusingly, select-based servers are often called asynchronous, to describe their multiplexing of short-lived\ntransactions. Really, though, the classic forking and threading servers we met earlier are asynchronous, too,\nas they do not wait for completion of a given client\u2019s request. There is a clearer distinction between serial and\nparallel servers\u2014the former process one transaction at a time and the latter do not\u2014and \u201csynchronous\u201d and\n\u201casynchronous\u201d are essentially synonyms for \u201cserial\u201d and \u201cparallel.\u201d By this definition, forking, threading,\nand select loops are three alternative ways to implement parallel, asynchronous servers.\nHandling Multiple Clients | 821portsock.bind((myHost, myPort))           # bind it to server port number\n    portsock.listen(5)                        # listen, allow 5 pending connects\n    mainsocks.append(portsock)                # add to main list to identify\n    readsocks.append(portsock)                # add to select inputs list\n    myPort += 1                               # bind on consecutive ports\n# event loop: listen and multiplex until server process killed\nprint('select-server loop starting')\nwhile True:\n    #print(readsocks)\n    readables, writeables, exceptions = select(readsocks, writesocks, [])\n    for sockobj in readables:\n        if sockobj in mainsocks:                     # for ready input sockets\n            # port socket: accept new client\n            newsock, address = sockobj.accept()      # accept should not block\n            print('Connect:', address, id(newsock))  # newsock is a new socket\n            readsocks.append(newsock)                # add to select list, wait\n        else:\n            # client socket: read next line\n            data = sockobj.recv(1024)                # recv should not block\n            print('\\tgot', data, 'on', id(sockobj))\n            if not data:                             # if closed by the clients\n                sockobj.close()                      # close here and remv from\n                readsocks.remove(sockobj)            # del list else reselected\n            else:\n                # this may block: should really select for writes too\n                reply = 'Echo=>%s at %s' % (data, now())\n                sockobj.send(reply.encode())\nThe bulk of this script is its while event loop at the end that calls select to find out\nwhich sockets are ready for processing; these include both main port sockets on which\nclients can connect and open client connections. It then loops over all such ready sock-\nets, accepting connections on main port sockets and reading and echoing input on any\nclient sockets ready for input. Both the accept and recv calls in this code are guaranteed\nto not block the server process after select returns; as a result, this server can quickly\nget back to the top of the loop to process newly arrived client requests and already\nconnected clients\u2019 inputs. The net effect is that all new requests and clients are serviced\nin pseudoparallel fashion.\nTo make this process work, the server appends the connected socket for each client to\nthe readables list passed to select, and simply waits for the socket to show up in the\nselected inputs list. For illustration purposes, this server also listens for new clients on\nmore than one port\u2014on ports 50007 and 50008, in our examples. Because these main\nport sockets are also interrogated with select, connection requests on either port can\nbe accepted without blocking either already connected clients or new connection re-\nquests appearing on the other port. The select call returns whatever sockets in\nreadables are ready for processing\u2014both main port sockets and sockets connected to\nclients currently being processed.\n822 | Chapter 12:\u2002Network ScriptingRunning the select server\nLet\u2019s run this script locally to see how it does its stuff (the client and server can also be\nrun on different machines, as in prior socket examples). First, we\u2019ll assume we\u2019ve al-\nready started this server script on the local machine in one window, and run a few\nclients to talk to it. The following listing gives the interaction in two such client console\nwindows running on Windows. The first client simply runs the echo-client script twice\nto contact the server, and the second also kicks off the testecho script to spawn eight\necho-client programs running in parallel.\nAs before, the server simply echoes back whatever text that client sends, though without\na sleep pause here (more on this in a moment). Notice how the second client window\nreally runs a script called echo-client-50008 so as to connect to the second port socket\nin the server; it\u2019s the same as echo-client, with a different hardcoded port number;\nalas, the original script wasn\u2019t designed to input a port number:\n[client window 1]\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py\nClient received: b\"Echo=>b'Hello network world' at Sun Apr 25 14:51:21 2010\"\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client.py\nClient received: b\"Echo=>b'Hello network world' at Sun Apr 25 14:51:27 2010\"\n[client window 2]\nC:\\...\\PP4E\\Internet\\Sockets> python echo-client-5008.py localhost Sir Galahad\nClient received: b\"Echo=>b'Sir' at Sun Apr 25 14:51:22 2010\"\nClient received: b\"Echo=>b'Galahad' at Sun Apr 25 14:51:22 2010\"\nC:\\...\\PP4E\\Internet\\Sockets> python testecho.py\nThe next listing is the sort of output that show up in the window where the server has\nbeen started. The first three connections come from echo-client runs; the rest is the\nresult of the eight programs spawned by testecho in the second client window. We can\nrun this server on Windows, too, because select is available on this platform. Correlate\nthis output with the server\u2019s code to see how it runs.\nNotice that for testecho, new client connections and client inputs are multiplexed to-\ngether. If you study the output closely, you\u2019ll see that they overlap in time, because all\nactivity is dispatched by the single event loop in the server. In fact, the trace output on\nthe server will probably look a bit different nearly every time it runs. Clients and new\nconnections are interleaved almost at random due to timing differences on the host\nmachines. This happens in the earlier forking and treading servers, too, but the oper-\nating system automatically switches between the execution paths of the dispatcher loop\nand client transactions.\nAlso note that the server gets an empty string when the client has closed its socket. We\ntake care to close and delete these sockets at the server right away, or else they would\nbe needlessly reselected again and again, each time through the main loop:\n[server window]\nC:\\...\\PP4E\\Internet\\Sockets> python select-server.py\nHandling Multiple Clients | 823C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples\\PP4E\\Internet\\Sockets>python sele\nct-server.py\nselect-server loop starting\nConnect: ('127.0.0.1', 59080) 21339352\n        got b'Hello network world' on 21339352\n        got b'' on 21339352\nConnect: ('127.0.0.1', 59081) 21338128\n        got b'Sir' on 21338128\n        got b'Galahad' on 21338128\n        got b'' on 21338128\nConnect: ('127.0.0.1', 59082) 21339352\n        got b'Hello network world' on 21339352\n        got b'' on 21339352\n[testecho results]\nConnect: ('127.0.0.1', 59083) 21338128\n        got b'Hello network world' on 21338128\n        got b'' on 21338128\nConnect: ('127.0.0.1', 59084) 21339352\n        got b'Hello network world' on 21339352\n        got b'' on 21339352\nConnect: ('127.0.0.1', 59085) 21338128\n        got b'Hello network world' on 21338128\n        got b'' on 21338128\nConnect: ('127.0.0.1', 59086) 21339352\n        got b'Hello network world' on 21339352\n        got b'' on 21339352\nConnect: ('127.0.0.1', 59087) 21338128\n        got b'Hello network world' on 21338128\n        got b'' on 21338128\nConnect: ('127.0.0.1', 59088) 21339352\nConnect: ('127.0.0.1', 59089) 21338128\n        got b'Hello network world' on 21339352\n        got b'Hello network world' on 21338128\nConnect: ('127.0.0.1', 59090) 21338056\n        got b'' on 21339352\n        got b'' on 21338128\n        got b'Hello network world' on 21338056\n        got b'' on 21338056\nBesides this more verbose output, there\u2019s another subtle but crucial difference to\nnotice\u2014a time.sleep call to simulate a long-running task doesn\u2019t make sense in the\nserver here. Because all clients are handled by the same single loop, sleeping would\npause everything, and defeat the whole point of a multiplexing server. Again, manual\nmultiplexing servers like this one work well when transactions are short, but also gen-\nerally require them to either be so, or be handled specially.\nBefore we move on, here are a few additional notes and options:\nselect call details\nFormally, select is called with three lists of selectable objects (input sources, out-\nput sources, and exceptional condition sources), plus an optional timeout. The\ntimeout argument may be a real wait expiration value in seconds (use floating-point\n824 | Chapter 12:\u2002Network Scriptingnumbers to express fractions of a second), a zero value to mean simply poll and\nreturn immediately, or omitted to mean wait until at least one object is ready (as\ndone in our server script). The call returns a triple of ready objects\u2014subsets of the\nfirst three arguments\u2014any or all of which may be empty if the timeout expired\nbefore sources became ready.\nselect portability\nLike threading, but unlike forking, this server works in standard Windows Python,\ntoo. Technically, the select call works only for sockets on Windows, but also\nworks for things like files and pipes on Unix and Macintosh. For servers running\nover the Internet, of course, the primary devices we are interested in are sockets.\nNonblocking sockets\nselect lets us be sure that socket calls like accept and recv won\u2019t block (pause) the\ncaller, but it\u2019s also possible to make Python sockets nonblocking in general. Call\nthe setblocking method of socket objects to set the socket to blocking or non-\nblocking mode. For example, given a call like sock.setblocking(flag), the socket\nsock is set to nonblocking mode if the flag is zero and to blocking mode otherwise.\nAll sockets start out in blocking mode initially, so socket calls may always make\nthe caller wait.\nHowever, when in nonblocking mode, a socket.error exception is raised if a\nrecv socket call doesn\u2019t find any data, or if a send call can\u2019t immediately transfer\ndata. A script can catch this exception to determine whether the socket is ready for\nprocessing. In blocking mode, these calls always block until they can proceed. Of\ncourse, there may be much more to processing client requests than data transfers\n(requests may also require long-running computations), so nonblocking sockets\ndon\u2019t guarantee that servers won\u2019t stall in general. They are simply another way to\ncode multiplexing servers. Like select, they are better suited when client requests\ncan be serviced quickly.\nThe asyncore module framework\nIf you\u2019re interested in using select, you will probably also be interested in checking\nout the asyncore.py module in the standard Python library. It implements a class-\nbased callback model, where input and output callbacks are dispatched to class\nmethods by a precoded select event loop. As such, it allows servers to be con-\nstructed without threads or forks, and it is a select-based alternative to the sock\netserver module\u2019s threading and forking module we met in the prior sections. As\nfor this type of server in general, asyncore is best when transactions are short\u2014\nwhat it describes as \u201cI/O bound\u201d instead of \u201cCPU bound\u201d programs, the latter of\nwhich still require threads or forks. See the Python library manual for details and\na usage example.\nTwisted\nFor other server options, see also the open source Twisted system (http://twisted\nmatrix.com). Twisted is an asynchronous networking framework written in Python\nthat supports TCP, UDP, multicast, SSL/TLS, serial communication, and more. It\nHandling Multiple Clients | 825supports both clients and servers and includes implementations of a number of\ncommonly used network services such as a web server, an IRC chat server, a mail\nserver, a relational database interface, and an object broker.\nAlthough Twisted supports processes and threads for longer-running actions, it\nalso uses an asynchronous, event-driven model to handle clients, which is similar\nto the event loop of GUI libraries like tkinter. It abstracts an event loop, which\nmultiplexes among open socket connections, automates many of the details in-\nherent in an asynchronous server, and provides an event-driven framework for\nscripts to use to accomplish application tasks. Twisted\u2019s internal event engine is\nsimilar in spirit to our select-based server and the asyncore module, but it is re-\ngarded as much more advanced. Twisted is a third-party system, not a standard\nlibrary tool; see its website and documentation for more details.\nSummary: Choosing a Server Scheme\nSo when should you use select to build a server, instead of threads or forks? Needs\nvary per application, of course, but as mentioned, servers based on the select call\ngenerally perform very well when client transactions are relatively short and are not\nCPU-bound. If they are not short, threads or forks may be a better way to split pro-\ncessing among multiple clients. Threads and forks are especially useful if clients require\nlong-running processing above and beyond the socket calls used to pass data. However,\ncombinations are possible too\u2014nothing is stopping a select-based polling loop from\nusing threads, too.\nIt\u2019s important to remember that schemes based on select (and nonblocking sockets)\nare not completely immune to blocking. In Example 12-9, for instance, the send call\nthat echoes text back to a client might block, too, and hence stall the entire server. We\ncould work around that blocking potential by using select to make sure that the output\noperation is ready before we attempt it (e.g., use the writesocks list and add another\nloop to send replies to ready output sockets), albeit at a noticeable cost in program\nclarity.\nIn general, though, if we cannot split up the processing of a client\u2019s request in such a\nway that it can be multiplexed with other requests and not block the server\u2019s main loop,\nselect may not be the best way to construct a server by itself. While some network\nservers can satisfy this constraint, many cannot.\nMoreover, select also seems more complex than spawning either processes or threads,\nbecause we need to manually transfer control among all tasks (for instance, compare\nthe threaded and select versions of our echo server, even without write selects). As\nusual, though, the degree of that complexity varies per application. The asyncore\nstandard library module mentioned earlier simplifies some of the tasks of implementing\na select-based event-loop socket server, and Twisted offers additional hybrid \nsolutions.\n826 | Chapter 12:\u2002Network ScriptingMaking Sockets Look Like Files and Streams\nSo far in this chapter, we\u2019ve focused on the role of sockets in the classic client/server\nnetworking model. That\u2019s one of their primary roles, but they have other common use\ncases as well.\nIn Chapter 5, for instance, we saw sockets as a basic IPC device between processes and\nthreads on a single machine. And in Chapter 10\u2019s exploration of linking non-GUI scripts\nto GUIs, we wrote a utility module (Example 10-23) which connected a caller\u2019s standard\noutput stream to a socket, on which a GUI could listen for output to be displayed.\nThere, I promised that we\u2019d flesh out that module with additional transfer modes once\nwe had a chance to explore sockets in more depth. Now that we have, this section takes\na brief detour from the world of remote network servers to tell the rest of this story.\nAlthough some programs can be written or rewritten to converse over sockets explicitly,\nthis isn\u2019t always an option; it may be too expensive an effort for existing scripts, and\nmight preclude desirable nonsocket usage modes for others. In some cases, it\u2019s better\nto allow a script to use standard stream tools such as the print and input built-in\nfunctions and sys module file calls (e.g., sys.stdout.write), and connect them to sock-\nets only when needed.\nBecause such stream tools are designed to operate on text-mode files, though, probably\nthe biggest trick here is fooling them into operating on the inherently binary mode and\nvery different method interface of sockets. Luckily, sockets come with a method that\nachieves all the forgery we need.\nThe socket object makefile method comes in handy anytime you wish to process a\nsocket with normal file object methods or need to pass a socket to an existing interface\nor program that expects a file. The socket wrapper object returned allows your scripts\nto transfer data over the underlying socket with read and write calls, rather than recv\nand send. Since input and print built-in functions use the former methods set, they will\nhappily interact with sockets wrapped by this call, too.\nThe makefile method also allows us to treat normally binary socket data as text instead\nof byte strings, and has additional arguments such as encoding that let us specify non-\ndefault Unicode encodings for the transferred text\u2014much like the built-in open and\nos.fdopen calls we met in Chapter 4 do for file descriptors. Although text can always\nbe encoded and decoded with manual calls after binary mode socket transfers, make\nfile shifts the burden of text encodings from your code to the file wrapper object.\nThis equivalence to files comes in handy any time we want to use software that supports\nfile interfaces. For example, the Python pickle module\u2019s load and dump methods expect\nan object with a file-like interface (e.g., read and write methods), but they don\u2019t require\na physical file. Passing a TCP/IP socket wrapped with the makefile call to the pickler\nallows us to ship serialized Python objects over the Internet, without having to pickle\nto byte strings ourselves and call raw socket methods manually. This is an alternative\nto using the pickle module\u2019s string-based calls (dumps, loads) with socket send and\nMaking Sockets Look Like Files and Streams | 827recv calls, and might offer more flexibility for software that must support a variety of\ntransport mechanisms. See Chapter 17 for more details on object serialization\ninterfaces.\nMore generally, any component that expects a file-like method protocol will gladly\naccept a socket wrapped with a socket object makefile call. Such interfaces will also\naccept strings wrapped with the built-in io.StringIO class, and any other sort of object\nthat supports the same kinds of method calls as built-in file objects. As always in Python,\nwe code to protocols\u2014object interfaces\u2014not to specific datatypes.\nA Stream Redirection Utility\nTo illustrate the makefile method\u2019s operation, Example 12-10 implements a variety of\nredirection schemes, which redirect the caller\u2019s streams to a socket that can be used by\nanother process for communication. The first of its functions connects output, and is\nwhat we used in Chapter 10; the others connect input, and both input and output in\nthree different modes.\nNaturally, the wrapper object returned by socket.makefile can also be used with direct\nfile interface read and write method calls and independently of standard streams. This\nexample uses those methods, too, albeit in most cases indirectly and implicitly through\nthe print and input stream access built-ins, and reflects a common use case for the tool.\nExample 12-10. PP4E\\Internet\\Sockets\\socket_stream_redirect.py\n\"\"\"\n###############################################################################\nTools for connecting standard streams of non-GUI programs to sockets that\na GUI (or other) program can use to interact with the non-GUI program.\n###############################################################################\n\"\"\"\nimport sys\nfrom socket import *\nport = 50008            # pass in different port if multiple dialogs on machine\nhost = 'localhost'      # pass in different host to connect to remote listeners\ndef initListenerSocket(port=port):\n    \"\"\"\n    initialize connected socket for callers that listen in server mode\n    \"\"\"\n    sock = socket(AF_INET, SOCK_STREAM)\n    sock.bind(('', port))                     # listen on this port number\n    sock.listen(5)                            # set pending queue length\n    conn, addr = sock.accept()                # wait for client to connect\n    return conn                               # return connected socket\ndef redirectOut(port=port, host=host):\n    \"\"\"\n    connect caller's standard output stream to a socket for GUI to listen\n    start caller after listener started, else connect fails before accept\n828 | Chapter 12:\u2002Network Scripting\"\"\"\n    sock = socket(AF_INET, SOCK_STREAM)\n    sock.connect((host, port))                # caller operates in client mode\n    file = sock.makefile('w')                 # file interface: text, buffered\n    sys.stdout = file                         # make prints go to sock.send\n    return sock                               # if caller needs to access it raw\ndef redirectIn(port=port, host=host):\n    \"\"\"\n    connect caller's standard input stream to a socket for GUI to provide\n    \"\"\"\n    sock = socket(AF_INET, SOCK_STREAM)\n    sock.connect((host, port))\n    file = sock.makefile('r')                 # file interface wrapper\n    sys.stdin = file                          # make input come from sock.recv\n    return sock                               # return value can be ignored\ndef redirectBothAsClient(port=port, host=host):\n    \"\"\"\n    connect caller's standard input and output stream to same socket\n    in this mode, caller is client to a server: sends msg, receives reply\n    \"\"\"\n    sock = socket(AF_INET, SOCK_STREAM)\n    sock.connect((host, port))                # or open in 'rw' mode\n    ofile = sock.makefile('w')                # file interface: text, buffered\n    ifile = sock.makefile('r')                # two file objects wrap same socket\n    sys.stdout = ofile                        # make prints go to sock.send\n    sys.stdin  = ifile                        # make input come from sock.recv\n    return sock\ndef redirectBothAsServer(port=port, host=host):\n    \"\"\"\n    connect caller's standard input and output stream to same socket\n    in this mode, caller is server to a client: receives msg, send reply\n    \"\"\"\n    sock = socket(AF_INET, SOCK_STREAM)\n    sock.bind((host, port))                   # caller is listener here\n    sock.listen(5)\n    conn, addr = sock.accept()\n    ofile = conn.makefile('w')                # file interface wrapper\n    ifile = conn.makefile('r')                # two file objects wrap same socket\n    sys.stdout = ofile                        # make prints go to sock.send\n    sys.stdin  = ifile                        # make input come from sock.recv\n    return conn\nTo test, the script in Example 12-11 defines five sets of client/server functions. It runs\nthe client\u2019s code in process, but deploys the Python multiprocessing module we met\nin Chapter 5 to portably spawn the server function\u2019s side of the dialog in a separate\nprocess. In the end, the client and server test functions run in different processes, but\nconverse over a socket that is connected to standard streams within the test script\u2019s\nprocess.\nMaking Sockets Look Like Files and Streams | 829Example 12-11. PP4E\\Internet\\Sockets\\test-socket_stream_redirect.py\n\"\"\"\n###############################################################################\ntest the socket_stream_redirection.py modes\n###############################################################################\n\"\"\"\nimport sys, os, multiprocessing\nfrom socket_stream_redirect import *\n###############################################################################\n# redirected client output\n###############################################################################\ndef server1():\n    mypid = os.getpid()\n    conn  = initListenerSocket()                     # block till client connect\n    file  = conn.makefile('r')\n    for i in range(3):                               # read/recv client's prints\n        data = file.readline().rstrip()              # block till data ready\n        print('server %s got [%s]' % (mypid, data))  # print normally to terminal\ndef client1():\n    mypid = os.getpid()\n    redirectOut()\n    for i in range(3):\n        print('client %s: %s' % (mypid, i))          # print to socket\n        sys.stdout.flush()                           # else buffered till exits!\n###############################################################################\n# redirected client input\n###############################################################################\ndef server2():\n    mypid = os.getpid()                              # raw socket not buffered\n    conn  = initListenerSocket()                     # send to client's input\n    for i in range(3):\n        conn.send(('server %s: %s\\n' % (mypid, i)).encode())\ndef client2():\n    mypid = os.getpid()\n    redirectIn()\n    for i in range(3):\n        data = input()                               # input from socket\n        print('client %s got [%s]' % (mypid, data))  # print normally to terminal\n###############################################################################\n# redirect client input + output, client is socket client\n###############################################################################\ndef server3():\n    mypid = os.getpid()\n    conn  = initListenerSocket()                     # wait for client connect\n    file  = conn.makefile('r')                       # recv print(), send input()\n    for i in range(3):                               # readline blocks till data\n830 | Chapter 12:\u2002Network Scriptingdata = file.readline().rstrip()\n        conn.send(('server %s got [%s]\\n' % (mypid, data)).encode())\ndef client3():\n    mypid = os.getpid()\n    redirectBothAsClient()\n    for i in range(3):\n        print('client %s: %s' % (mypid, i))          # print to socket\n        data = input()                               # input from socket: flushes!\n        sys.stderr.write('client %s got [%s]\\n' % (mypid, data))  # not redirected\n###############################################################################\n# redirect client input + output, client is socket server\n###############################################################################\ndef server4():\n    mypid = os.getpid()\n    sock  = socket(AF_INET, SOCK_STREAM)\n    sock.connect((host, port))\n    file  = sock.makefile('r')\n    for i in range(3):\n        sock.send(('server %s: %s\\n' % (mypid, i)).encode())   # send to input()\n        data = file.readline().rstrip()                        # recv from print()\n        print('server %s got [%s]' % (mypid, data))            # result to terminal\ndef client4():\n    mypid = os.getpid()\n    redirectBothAsServer()         # I'm actually the socket server in this mode\n    for i in range(3):\n        data = input()                               # input from socket: flushes!\n        print('client %s got [%s]' % (mypid, data))  # print to socket\n        sys.stdout.flush()                           # else last buffered till exit!\n###############################################################################\n# redirect client input + output, client is socket client, server xfers first\n###############################################################################\ndef server5():\n    mypid = os.getpid()                              # test 4, but server accepts\n    conn  = initListenerSocket()                     # wait for client connect\n    file  = conn.makefile('r')                       # send input(), recv print()\n    for i in range(3):\n        conn.send(('server %s: %s\\n' % (mypid, i)).encode())\n        data = file.readline().rstrip()\n        print('server %s got [%s]' % (mypid, data))\ndef client5():\n    mypid = os.getpid()\n    s = redirectBothAsClient()     # I'm the socket client in this mode\n    for i in range(3):\n        data = input()                               # input from socket: flushes!\n        print('client %s got [%s]' % (mypid, data))  # print to socket\n        sys.stdout.flush()                           # else last buffered till exit!\n###############################################################################\nMaking Sockets Look Like Files and Streams | 831# test by number on command-line\n###############################################################################\nif __name__ == '__main__':\n    server = eval('server' + sys.argv[1])\n    client = eval('client' + sys.argv[1])               # client in this process\n    multiprocessing.Process(target=server).start()      # server in new process\n    client()                                            # reset streams in client\n    #import time; time.sleep(5)                         # test effect of exit flush\nRun the test script with a client and server number on the command line to test the\nmodule\u2019s tools; messages display process ID numbers, and those within square brackets\nreflect a transfer across streams connected to sockets (twice, when nested):\nC:\\...\\PP4E\\Internet\\Sockets> test-socket_stream_redirect.py 1\nserver 3844 got [client 1112: 0]\nserver 3844 got [client 1112: 1]\nserver 3844 got [client 1112: 2]\nC:\\...\\PP4E\\Internet\\Sockets> test-socket_stream_redirect.py 2\nclient 5188 got [server 2020: 0]\nclient 5188 got [server 2020: 1]\nclient 5188 got [server 2020: 2]\nC:\\...\\PP4E\\Internet\\Sockets> test-socket_stream_redirect.py 3\nclient 7796 got [server 2780 got [client 7796: 0]]\nclient 7796 got [server 2780 got [client 7796: 1]]\nclient 7796 got [server 2780 got [client 7796: 2]]\nC:\\...\\PP4E\\Internet\\Sockets> test-socket_stream_redirect.py 4\nserver 4288 got [client 3852 got [server 4288: 0]]\nserver 4288 got [client 3852 got [server 4288: 1]]\nserver 4288 got [client 3852 got [server 4288: 2]]\nC:\\...\\PP4E\\Internet\\Sockets> test-socket_stream_redirect.py 5\nserver 6040 got [client 7728 got [server 6040: 0]]\nserver 6040 got [client 7728 got [server 6040: 1]]\nserver 6040 got [client 7728 got [server 6040: 2]]\nIf you correlate this script\u2019s output with its code to see how messages are passed be-\ntween client and server, you\u2019ll find that print and input calls in client functions are\nultimately routed over sockets to another process. To the client functions, the socket\nlinkage is largely invisible.\nText-mode files and buffered output streams\nBefore we move on, there are two remarkably subtle aspects of the example\u2019s code\nworth highlighting:\nBinary to text translations\nRaw sockets transfer binary byte strings, but by opening the wrapper files in text\nmode, their content is automatically translated to text strings on input and output.\nText-mode file wrappers are required if accessed through standard stream tools\n832 | Chapter 12:\u2002Network Scriptingsuch as the print built-in that writes text strings (as we\u2019ve learned, binary mode\nfiles require byte strings instead). When dealing with the raw socket directly,\nthough, text must still be manually encoded to byte strings, as shown in most of\nExample 12-11\u2019s tests.\nBuffered streams, program output, and deadlock\nAs we learned in Chapters 5 and 10, standard streams are normally buffered, and\nprinted text may need to be flushed so that it appears on a socket connected to a\nprocess\u2019s output stream. Indeed, some of this example\u2019s tests require explicit or\nimplicit flush calls to work properly at all; otherwise their output is either incom-\nplete or absent altogether until program exit. In pathological cases, this can lead\nto deadlock, with a process waiting for output from another that never appears. In\nother configurations, we may also get socket errors in a reader if a writer exits too\nsoon, especially in two-way dialogs.\nFor example, if client1 and client4 did not flush periodically as they do, the only\nreason that they would work is because output streams are automatically flushed\nwhen their process exits. Without manual flushes, client1 transfers no data until\nprocess exit (at which point all its output is sent at once in a single message), and\nclient4\u2019s data is incomplete till exit (its last printed message is delayed).\nEven more subtly, both client3 and client4 rely on the fact that the input built-\nin first automatically flushes sys.stdout internally for its prompt option, thereby\nsending data from preceding print calls. Without this implicit flush (or the addition\nof manual flushes), client3 would experience deadlock immediately, as would\nclient4 if its manual flush call was removed (even with input\u2019s flush, removing\nclient4\u2019s manual flush causes its final print message to not be transferred until\nprocess exit). client5 has this same behavior as client4, because it simply swaps\nwhich process binds and accepts and which connects.\nIn the general case, if we wish to read a program\u2019s output as it is produced, instead\nof all at once when it exits or as its buffers fill, the program must either call\nsys.stdout.flush periodically, or be run with unbuffered streams by using\nPython\u2019s -u command-line argument of Chapter 5 if applicable.\nAlthough we can open socket wrapper files in unbuffered mode with a second\nmakefile argument of zero (like normal open), this does not allow the wrapper to\nrun in the text mode required for print and desired for input. In fact, attempting\nto make a socket wrapper file both text mode and unbuffered this way fails with\nan exception, because Python 3.X no longer supports unbuffered mode for text\nfiles (it is allowed for binary mode only today). In other words, because print\nrequires text mode, buffered mode is also implied for output stream files. More-\nover, attempting to open a socket file wrapper in line-buffered mode appears to not\nbe supported in Python 3.X (more on this ahead).\nWhile some buffering behavior may be library and platform dependent, manual\nflush calls or direct socket access might sometimes still be required. Note that\nsockets can also be made nonblocking with the setblocking(0) method, but this\nMaking Sockets Look Like Files and Streams | 833only avoids wait states for transfer calls and does not address the data producer\u2019s\nfailure to send buffered output.\nStream requirements\nTo make some of this more concrete, Example 12-12 illustrates how some of these\ncomplexities apply to redirected standard streams, by attempting to connect them to\nboth text and binary mode files produced by open and accessing them with print and\ninput built-ins much as redirected script might.\nExample 12-12. PP4E\\Internet\\Sockets\\test-stream-modes.py\n\"\"\"\ntest effect of connecting standard streams to text and binary mode files\nsame holds true for socket.makefile: print requires text mode, but text\nmode precludes unbuffered mode -- use -u or sys.stdout.flush() calls\n\"\"\"\nimport sys\ndef reader(F):\n    tmp, sys.stdin = sys.stdin, F\n    line = input()\n    print(line)\n    sys.stdin = tmp\nreader( open('test-stream-modes.py') )         # works: input() returns text\nreader( open('test-stream-modes.py', 'rb') )   # works: but input() returns bytes\ndef writer(F):\n    tmp, sys.stdout = sys.stdout, F\n    print(99, 'spam')\n    sys.stdout = tmp\nwriter( open('temp', 'w') )             # works: print() passes text str to .write()\nprint(open('temp').read())\nwriter( open('temp', 'wb') )            # FAILS on print: binary mode requires bytes\nwriter( open('temp', 'w', 0) )          # FAILS on open: text must be unbuffered\nWhen run, the last two lines in this script both fail\u2014the second to last fails because\nprint passes text strings to a binary-mode file (never allowed for files in general), and\nthe last fails because we cannot open text-mode files in unbuffered mode in Python 3.X\n(text mode implies Unicode encodings). Here are the errors we get when this script is\nrun: the first run uses the script as shown, and the second shows what happens if the\nsecond to last line is commented out (I edited the exception text slightly for\npresentation):\nC:\\...\\PP4E\\Internet\\Sockets> test-stream-modes.py\n\"\"\"\nb'\"\"\"\\r'\n99 spam\n834 | Chapter 12:\u2002Network ScriptingTraceback (most recent call last):\n  File \"C:\\...\\PP4E\\Internet\\Sockets\\test-stream-modes.py\", line 26, in <module>\n    writer( open('temp', 'wb') )            # FAILS on print: binary mode...\n  File \"C:\\...\\PP4E\\Internet\\Sockets\\test-stream-modes.py\", line 20, in writer\n    print(99, 'spam')\nTypeError: must be bytes or buffer, not str\nC:\\...\\PP4E\\Internet\\Sockets> test-streams-binary.py\n\"\"\"\nb'\"\"\"\\r'\n99 spam\nTraceback (most recent call last):\n  File \"C:\\...\\PP4E\\Internet\\Sockets\\test-stream-modes.py\", line 27, in <module>\n    writer( open('temp', 'w', 0) )          # FAILS on open: text must be...\nValueError: can't have unbuffered text I/O\nThe same rules apply to socket wrapper file objects created with a socket\u2019s makefile\nmethod\u2014they must be opened in text mode for print and should be opened in text\nmode for input if we wish to receive text strings, but text mode prevents us from using\nfully unbuffered file mode altogether:\n>>> from socket import *\n>>> s = socket()                       # defaults to tcp/ip (AF_INET, SOCK_STREAM)\n>>> s.makefile('w', 0)                 # this used to work in Python 2.X\nTraceback (most recent call last):\n  File \"C:\\Python31\\lib\\socket.py\", line 151, in makefile\nValueError: unbuffered streams must be binary\nLine buffering\nText-mode socket wrappers also accept a buffering-mode argument of 1 to specify line-\nbuffering instead of the default full buffering:\n>>> from socket import *\n>>> s = socket()\n>>> f = s.makefile('w', 1)    # same as buffering=1, but acts as fully buffered!\nThis appears to be no different than full buffering, and still requires the resulting file\nto be flushed manually to transfer lines as they are produced. Consider the simple socket\nserver and client scripts in Examples 12-13 and 12-14. The server simply reads three\nmessages using the raw socket interface.\nExample 12-13. PP4E\\Internet\\Sockets\\socket-unbuff-server.py\nfrom socket import *           # read three messages over a raw socket\nsock = socket()\nsock.bind(('', 60000))\nsock.listen(5)\nprint('accepting...')\nconn, id = sock.accept()       # blocks till client connect\nfor i in range(3):\n    print('receiving...')\nMaking Sockets Look Like Files and Streams | 835msg = conn.recv(1024)      # blocks till data received\n    print(msg)                 # gets all print lines at once unless flushed\nThe client in Example 12-14 sends three messages; the first two over a socket wrapper\nfile, and the last using the raw socket; the manual flush calls in this are commented out\nbut retained so you can experiment with turning them on, and sleep calls make the\nserver wait for data.\nExample 12-14. PP4\\Internet\\Sockets\\socket-unbuff-client.py\nimport time                            # send three msgs over wrapped and raw socket\nfrom socket import *\nsock = socket()                        # default=AF_INET, SOCK_STREAM (tcp/ip)\nsock.connect(('localhost', 60000))\nfile = sock.makefile('w', buffering=1) # default=full buff, 0=error, 1 not linebuff!\nprint('sending data1')\nfile.write('spam\\n')\ntime.sleep(5)               # must follow with flush() to truly send now\n#file.flush()               # uncomment flush lines to see the difference\nprint('sending data2')\nprint('eggs', file=file)    # adding more file prints does not flush buffer either\ntime.sleep(5)\n#file.flush()               # output appears at server recv only upon flush or exit\nprint('sending data3')\nsock.send(b'ham\\n')         # low-level byte string interface sends immediately\ntime.sleep(5)               # received first if don't flush other two!\nRun the server in one window first and the client in another (or run the server first in\nthe background in Unix-like platforms). The output in the server window follows\u2014\nthe messages sent with the socket wrapper are deferred until program exit, but the raw\nsocket call transfers data immediately:\nC:\\...\\PP4E\\Internet\\Sockets> socket-unbuff-server.py\naccepting...\nreceiving...\nb'ham\\n'\nreceiving...\nb'spam\\r\\neggs\\r\\n'\nreceiving...\nb''\nThe client window simply displays \u201csending\u201d lines 5 seconds apart; its third message\nappears at the server in 10 seconds, but the first and second messages it sends using\nthe wrapper file are deferred until exit (for 15 seconds) because the socket wrapper is\nstill fully buffered. If the manual flush calls in the client are uncommented, each of the\nthree sent messages is delivered in serial, 5 seconds apart (the third appears immediately\nafter the second):\n836 | Chapter 12:\u2002Network ScriptingC:\\...\\PP4E\\Internet\\Sockets> socket-unbuff-server.py\naccepting...\nreceiving...\nb'spam\\r\\n'\nreceiving...\nb'eggs\\r\\n'\nreceiving...\nb'ham\\n'\nIn other words, even when line buffering is requested, socket wrapper file writes (and\nby association, prints) are buffered until the program exits, manual flushes are reques-\nted, or the buffer becomes full.\nSolutions\nThe short story here is this: to avoid delayed outputs or deadlock, scripts that might\nsend data to waiting programs by printing to wrapped sockets (or for that matter, by\nusing print or sys.stdout.write in general) should do one of the following:\n\u2022 Call sys.stdout.flush periodically to flush their printed output so it becomes\navailable as produced, as shown in Example 12-11.\n\u2022 Be run with the -u Python command-line flag, if possible, to force the output stream\nto be unbuffered. This works for unmodified programs spawned by pipe tools such\nas os.popen. It will not help with the use case here, though, because we manually\nreset the stream files to buffered text socket wrappers after a process starts. To\nprove this, uncomment Example 12-11\u2019s manual flush calls and the sleep call at its\nend, and run with -u: the first test\u2019s output is still delayed for 5 seconds.\n\u2022 Use threads to read from sockets to avoid blocking, especially if the receiving pro-\ngram is a GUI and it cannot depend upon the client to flush. See Chapter 10 for\npointers. This doesn\u2019t really fix the problem\u2014the spawned reader thread may be\nblocked or deadlocked, too\u2014but at least the GUI remains active during waits.\n\u2022 Implement their own custom socket wrapper objects which intercept text write\ncalls, encode to binary, and route to a socket with send calls; socket.makefile is\nreally just a convenience tool, and we can always code a wrapper of our own for\nmore specific roles. For hints, see Chapter 10\u2019s GuiOutput class, the stream redi-\nrection class in Chapter 3, and the classes of the io standard library module (upon\nwhich Python\u2019s input/output tools are based, and which you can mix in custom\nways).\n\u2022 Skip print altogether and communicate directly with the native interfaces of IPC\ndevices, such as socket objects\u2019 raw send and recv methods\u2014these transfer data\nimmediately and do not buffer data as file methods can. We can either transfer\nsimple byte strings this way or use the pickle module\u2019s dumps and loads tools to\nconvert Python objects to and from byte strings for such direct socket transfer\n(more on pickle in Chapter 17).\nMaking Sockets Look Like Files and Streams | 837The latter option may be more direct (and the redirection utility module also returns\nthe raw socket in support of such usage), but it isn\u2019t viable in all scenarios, especially\nfor existing or multimode scripts. In many cases, it may be most straightforward to use\nmanual flush calls in shell-oriented programs whose streams might be linked to other\nprograms through sockets.\nBuffering in other contexts: Command pipes revisited\nAlso keep in mind that buffered streams and deadlock are general issues that go beyond\nsocket wrapper files. We explored this topic in Chapter 5; as a quick review, the non-\nsocket Example 12-15 does not fully buffer its output when it is connected to a terminal\n(output is only line buffered when run from a shell command prompt), but does if\nconnected to something else (including a socket or pipe).\nExample 12-15. PP4E\\Internet\\Sockets\\pipe-unbuff-writer.py\n# output line buffered (unbuffered) if stdout is a terminal, buffered by default for\n# other devices: use -u or sys.stdout.flush() to avoid delayed output on pipe/socket\nimport time, sys\nfor i in range(5):\n    print(time.asctime())                 # print transfers per stream buffering\n    sys.stdout.write('spam\\n')            # ditto for direct stream file access\n    time.sleep(2)                         # unles sys.stdout reset to other file\nAlthough text-mode files are required for Python 3.X\u2019s print in general, the -u flag still\nworks in 3.X to suppress full output stream buffering. In Example 12-16, using this flag\nmakes the spawned script\u2019s printed output appear every 2 seconds, as it is produced.\nNot using this flag defers all output for 10 seconds, until the spawned script exits, unless\nthe spawned script calls sys.stdout.flush on each iteration.\nExample 12-16. PP4E\\Internet\\Sockets\\pipe-unbuff-reader.py\n# no output for 10 seconds unless Python -u flag used or sys.stdout.flush()\n# but writer's output appears here every 2 seconds when either option is used\nimport os\nfor line in os.popen('python -u pipe-unbuff-writer.py'):    # iterator reads lines\n    print(line, end='')                                     # blocks without -u!\nFollowing is the reader script\u2019s output; unlike the socket examples, it spawns the writer\nautomatically, so we don\u2019t need separate windows to test. Recall from Chapter 5 that\nos.popen also accepts a buffering argument much like socket.makefile, but it does not\napply to the spawned program\u2019s stream, and so would not prevent output buffering in\nthis case.\nC:\\...\\PP4E\\Internet\\Sockets> pipe-unbuff-reader.py\nWed Apr 07 09:32:28 2010\nspam\nWed Apr 07 09:32:30 2010\nspam\n838 | Chapter 12:\u2002Network ScriptingWed Apr 07 09:32:32 2010\nspam\nWed Apr 07 09:32:34 2010\nspam\nWed Apr 07 09:32:36 2010\nspam\nThe net effect is that -u still works around the steam buffering issue for connected\nprograms in 3.X, as long as you don\u2019t reset the streams to other objects in the spawned\nprogram as we did for socket redirection in Example 12-11. For socket redirections,\nmanual flush calls or replacement socket wrappers may be required.\nSockets versus command pipes\nSo why use sockets in this redirection role at all? In short, for server independence and\nnetworked use cases. Notice how for command pipes it\u2019s not clear who should be called\n\u201cserver\u201d and \u201cclient,\u201d since neither script runs perpetually. In fact, this is one of the\nmajor downsides of using command pipes like this instead of sockets\u2014because the\nprograms require a direct spawning relationship, command pipes do not support longer-\nlived or remotely running servers the way that sockets do.\nWith sockets, we can start client and server independently, and the server may continue\nrunning perpetually to serve multiple clients (albeit with some changes to our utility\nmodule\u2019s listener initialization code). Moreover, passing in remote machine names to\nour socket redirection tools would allow a client to connect to a server running on a\ncompletely different machine. As we learned in Chapter 5, named pipes (fifos) accessed\nwith the open call support stronger independence of client and server, too, but unlike\nsockets, they are usually limited to the local machine, and are not supported on all\nplatforms.\nExperiment with this code on your own for more insight. Also try changing Exam-\nple 12-11 to run the client function in a spawned process instead of or in addition to\nthe server, with and without flush calls and time.sleep calls to defer exits; the spawning\nstructure might have some impact on the soundness of a given socket dialog structure\nas well, which we\u2019ll finesse here in the interest of space.\nDespite the care that must be taken with text encodings and stream buffering, the utility\nprovided by Example 12-10 is still arguably impressive\u2014prints and input calls are\nrouted over network or local-machine socket connections in a largely automatic fash-\nion, and with minimal changes to the nonsocket code that uses the module. In many\ncases, the technique can extend a script\u2019s applicability.\nIn the next section, we\u2019ll use the makefile method again to wrap the socket in a file-\nlike object, so that it can be read by lines using normal text-file method calls and tech-\nniques. This isn\u2019t strictly required in the example\u2014we could read lines as byte strings\nwith the socket recv call, too. In general, though, the makefile method comes in handy\nany time you wish to treat sockets as though they were simple files. To see this at work,\nlet\u2019s move on.\nMaking Sockets Look Like Files and Streams | 839A Simple Python File Server\nIt\u2019s time for something realistic. Let\u2019s conclude this chapter by putting some of the\nsocket ideas we\u2019ve studied to work doing something a bit more useful than echoing\ntext back and forth. Example 12-17 implements both the server-side and the client-side\nlogic needed to ship a requested file from server to client machines over a raw socket.\nIn effect, this script implements a simple file download system. One instance of the\nscript is run on the machine where downloadable files live (the server), and another on\nthe machines you wish to copy files to (the clients). Command-line arguments tell the\nscript which flavor to run and optionally name the server machine and port number\nover which conversations are to occur. A server instance can respond to any number\nof client file requests at the port on which it listens, because it serves each in a thread.\nExample 12-17. PP4E\\Internet\\Sockets\\getfile.py\n\"\"\"\n#############################################################################\nimplement client and server-side logic to transfer an arbitrary file from\nserver to client over a socket; uses a simple control-info protocol rather\nthan separate sockets for control and data (as in ftp), dispatches each\nclient request to a handler thread, and loops to transfer the entire file\nby blocks; see ftplib examples for a higher-level transport scheme;\n#############################################################################\n\"\"\"\nimport sys, os, time, _thread as thread\nfrom socket import *\nblksz = 1024\ndefaultHost = 'localhost'\ndefaultPort = 50001\nhelptext = \"\"\"\nUsage...\nserver=> getfile.py  -mode server            [-port nnn] [-host hhh|localhost]\nclient=> getfile.py [-mode client] -file fff [-port nnn] [-host hhh|localhost]\n\"\"\"\ndef now():\n    return time.asctime()\ndef parsecommandline():\n    dict = {}                        # put in dictionary for easy lookup\n    args = sys.argv[1:]              # skip program name at front of args\n    while len(args) >= 2:            # example: dict['-mode'] = 'server'\n        dict[args[0]] = args[1]\n        args = args[2:]\n    return dict\ndef client(host, port, filename):\n    sock = socket(AF_INET, SOCK_STREAM)\n    sock.connect((host, port))\n840 | Chapter 12:\u2002Network Scriptingsock.send((filename + '\\n').encode())      # send remote name with dir: bytes\n    dropdir = os.path.split(filename)[1]       # filename at end of dir path\n    file = open(dropdir, 'wb')                 # create local file in cwd\n    while True:\n        data = sock.recv(blksz)                # get up to 1K at a time\n        if not data: break                     # till closed on server side\n        file.write(data)                       # store data in local file\n    sock.close()\n    file.close()\n    print('Client got', filename, 'at', now())\ndef serverthread(clientsock):\n    sockfile = clientsock.makefile('r')        # wrap socket in dup file obj\n    filename = sockfile.readline()[:-1]        # get filename up to end-line\n    try:\n        file = open(filename, 'rb')\n        while True:\n            bytes = file.read(blksz)           # read/send 1K at a time\n            if not bytes: break                # until file totally sent\n            sent = clientsock.send(bytes)\n            assert sent == len(bytes)\n    except:\n        print('Error downloading file on server:', filename)\n    clientsock.close()\ndef server(host, port):\n    serversock = socket(AF_INET, SOCK_STREAM)     # listen on TCP/IP socket\n    serversock.bind((host, port))                 # serve clients in threads\n    serversock.listen(5)\n    while True:\n        clientsock, clientaddr = serversock.accept()\n        print('Server connected by', clientaddr, 'at', now())\n        thread.start_new_thread(serverthread, (clientsock,))\ndef main(args):\n    host = args.get('-host', defaultHost)         # use args or defaults\n    port = int(args.get('-port', defaultPort))    # is a string in argv\n    if args.get('-mode') == 'server':             # None if no -mode: client\n        if host == 'localhost': host = ''         # else fails remotely\n        server(host, port)\n    elif args.get('-file'):                       # client mode needs -file\n        client(host, port, args['-file'])\n    else:\n        print(helptext)\nif __name__ == '__main__':\n    args = parsecommandline()\n    main(args)\nThis script isn\u2019t much different from the examples we saw earlier. Depending on the\ncommand-line arguments passed, it invokes one of two functions:\n\u2022 The server function farms out each incoming client request to a thread that trans-\nfers the requested file\u2019s bytes.\nA Simple Python File Server | 841\u2022 The client function sends the server a file\u2019s name and stores all the bytes it gets\nback in a local file of the same name.\nThe most novel feature here is the protocol between client and server: the client starts\nthe conversation by shipping a filename string up to the server, terminated with an end-\nof-line character, and including the file\u2019s directory path in the server. At the server, a\nspawned thread extracts the requested file\u2019s name by reading the client socket, and\nopens and transfers the requested file back to the client, one chunk of bytes at a time.\nRunning the File Server and Clients\nSince the server uses threads to process clients, we can test both client and server on\nthe same Windows machine. First, let\u2019s start a server instance and execute two client\ninstances on the same machine while the server runs:\n[server window, localhost]\nC:\\...\\Internet\\Sockets> python getfile.py -mode server\nServer connected by ('127.0.0.1', 59134) at Sun Apr 25 16:26:50 2010\nServer connected by ('127.0.0.1', 59135) at Sun Apr 25 16:27:21 2010\n[client window, localhost]\nC:\\...\\Internet\\Sockets> dir /B *.gif *.txt\nFile Not Found\nC:\\...\\Internet\\Sockets> python getfile.py -file testdir\\ora-lp4e.gif\nClient got testdir\\ora-lp4e.gif at Sun Apr 25 16:26:50 2010\nC:\\...\\Internet\\Sockets> python getfile.py -file testdir\\textfile.txt -port 50001\nClient got testdir\\textfile.txt at Sun Apr 25 16:27:21 2010\nClients run in the directory where you want the downloaded file to appear\u2014the client\ninstance code strips the server directory path when making the local file\u2019s name. Here\nthe \u201cdownload\u201d simply copies the requested files up to the local parent directory (the\nDOS fc command compares file contents):\nC:\\...\\Internet\\Sockets> dir /B *.gif *.txt\nora-lp4e.gif\ntextfile.txt\nC:\\...\\Internet\\Sockets> fc /B ora-lp4e.gif testdir/ora-lp4e.gif\nFC: no differences encountered\nC:\\...\\Internet\\Sockets> fc textfile.txt testdir\\textfile.txt\nFC: no differences encountered\nAs usual, we can run server and clients on different machines as well. For instance, here\nare the sort of commands we would use to launch the server remotely and fetch files\nfrom it locally; run this on your own to see the client and server outputs:\n[remote server window]\n[...]$ python getfile.py -mode server\n842 | Chapter 12:\u2002Network Scripting[client window: requested file downloaded in a thread on server]\nC:\\...\\Internet\\Sockets> python getfile.py \u2013mode client\n                             -host learning-python.com\n                             -port 50001 -file python.exe\nC:\\...\\Internet\\Sockets> python getfile.py\n                             -host learning-python.com -file index.html\nOne subtle security point here: the server instance code is happy to send any server-\nside file whose pathname is sent from a client, as long as the server is run with a user-\nname that has read access to the requested file. If you care about keeping some of your\nserver-side files private, you should add logic to suppress downloads of restricted files.\nI\u2019ll leave this as a suggested exercise here, but we will implement such filename checks\nin a different getfile download tool later in this book.#\nAdding a User-Interface Frontend\nAfter all the GUI commotion in the prior part of this book, you might have noticed that\nwe have been living in the realm of the command line for this entire chapter\u2014our socket\nclients and servers have been started from simple DOS or Linux shells. Nothing is\nstopping us from adding a nice point-and-click user interface to some of these scripts,\nthough; GUI and network scripting are not mutually exclusive techniques. In fact, they\ncan be arguably \u201csexy\u201d when used together well.\nFor instance, it would be easy to implement a simple tkinter GUI frontend to the client-\nside portion of the getfile script we just met. Such a tool, run on the client machine,\nmay simply pop up a window with Entry widgets for typing the desired filename, server,\nand so on. Once download parameters have been input, the user interface could either\nimport and call the getfile.client function with appropriate option arguments, or\nbuild and run the implied getfile.py command line using tools such as os.system,\nos.popen, subprocess, and so on.\nUsing row frames and command lines\nTo help make all of this more concrete, let\u2019s very quickly explore a few simple scripts\nthat add a tkinter frontend to the getfile client-side program. All of these examples\nassume that you are running a server instance of getfile; they merely add a GUI for\nthe client side of the conversation, to fetch a file from the server. The first, in Exam-\nple 12-18, uses form construction techniques we met in Chapters 8 and 9 to create a\ndialog for inputting server, port, and filename information, and simply constructs the\n#We\u2019ll see three more getfile programs before we leave Internet scripting. The next chapter\u2019s getfile.py fetches\na file with the higher-level FTP interface instead of using raw socket calls, and its http-getfile scripts fetch files\nover the HTTP protocol. Later, Chapter 15 presents a server-side getfile.py CGI script that transfers file\ncontents over the HTTP port in response to a request made in a web browser client (files are sent as the output\nof a CGI script). All four of the download schemes presented in this text ultimately use sockets, but only the\nversion here makes that use explicit.\nA Simple Python File Server | 843corresponding getfile command line and runs it with the os.system call we studied in\nPart II.\nExample 12-18. PP4E\\Internet\\Sockets\\getfilegui-1.py\n\"\"\"\nlaunch getfile script client from simple tkinter GUI;\ncould also use os.fork+exec, os.spawnv (see Launcher);\nwindows: replace 'python' with 'start' if not on path;\n\"\"\"\nimport sys, os\nfrom tkinter import *\nfrom tkinter.messagebox import showinfo\ndef onReturnKey():\n    cmdline = ('python getfile.py -mode client -file %s -port %s -host %s' %\n                      (content['File'].get(),\n                       content['Port'].get(),\n                       content['Server'].get()))\n    os.system(cmdline)\n    showinfo('getfilegui-1', 'Download complete')\nbox = Tk()\nlabels = ['Server', 'Port', 'File']\ncontent = {}\nfor label in labels:\n    row = Frame(box)\n    row.pack(fill=X)\n    Label(row, text=label, width=6).pack(side=LEFT)\n    entry = Entry(row)\n    entry.pack(side=RIGHT, expand=YES, fill=X)\n    content[label] = entry\nbox.title('getfilegui-1')\nbox.bind('<Return>', (lambda event: onReturnKey()))\nmainloop()\nWhen run, this script creates the input form shown in Figure 12-1. Pressing the Enter\nkey (<Return>) runs a client-side instance of the getfile program; when the generated\ngetfile command line is finished, we get the verification pop up displayed in\nFigure 12-2.\nFigure 12-1. getfilegui-1 in action\n844 | Chapter 12:\u2002Network ScriptingFigure 12-2. getfilegui-1 verification pop up\nUsing grids and function calls\nThe first user-interface script (Example 12-18) uses the pack geometry manager and\nrow Frames with fixed-width labels to lay out the input form and runs the getfile client\nas a standalone program. As we learned in Chapter 9, it\u2019s arguably just as easy to use\nthe grid manager for layout and to import and call the client-side logic function instead\nof running a program. The script in Example 12-19 shows how.\nExample 12-19. PP4E\\Internet\\Sockets\\getfilegui-2.py\n\"\"\"\nsame, but with grids and import+call, not packs and cmdline;\ndirect function calls are usually faster than running files;\n\"\"\"\nimport getfile\nfrom tkinter import *\nfrom tkinter.messagebox import showinfo\ndef onSubmit():\n    getfile.client(content['Server'].get(),\n                   int(content['Port'].get()),\n                   content['File'].get())\n    showinfo('getfilegui-2', 'Download complete')\nbox    = Tk()\nlabels = ['Server', 'Port', 'File']\nrownum  = 0\ncontent = {}\nfor label in labels:\n    Label(box, text=label).grid(column=0, row=rownum)\n    entry = Entry(box)\n    entry.grid(column=1, row=rownum, sticky=E+W)\n    content[label] = entry\n    rownum += 1\nbox.columnconfigure(0, weight=0)   # make expandable\nA Simple Python File Server | 845box.columnconfigure(1, weight=1)\nButton(text='Submit', command=onSubmit).grid(row=rownum, column=0, columnspan=2)\nbox.title('getfilegui-2')\nbox.bind('<Return>', (lambda event: onSubmit()))\nmainloop()\nThis version makes a similar window (Figure 12-3), but adds a button at the bottom\nthat does the same thing as an Enter key press\u2014it runs the getfile client procedure.\nGenerally speaking, importing and calling functions (as done here) is faster than run-\nning command lines, especially if done more than once. The getfile script is set up to\nwork either way\u2014as program or function library.\nFigure 12-3. getfilegui-2 in action\nUsing a reusable form-layout class\nIf you\u2019re like me, though, writing all the GUI form layout code in those two scripts can\nseem a bit tedious, whether you use packing or grids. In fact, it became so tedious to\nme that I decided to write a general-purpose form-layout class, shown in Exam-\nple 12-20, which handles most of the GUI layout grunt work.\nExample 12-20. PP4E\\Internet\\Sockets\\form.py\n\"\"\"\n##################################################################\na reusable form class, used by getfilegui (and others)\n##################################################################\n\"\"\"\nfrom tkinter import *\nentrysize = 40\nclass Form:                                           # add non-modal form box\n    def __init__(self, labels, parent=None):          # pass field labels list\n        labelsize = max(len(x) for x in labels) + 2\n        box = Frame(parent)                           # box has rows, buttons\n        box.pack(expand=YES, fill=X)                  # rows has row frames\n        rows = Frame(box, bd=2, relief=GROOVE)        # go=button or return key\n        rows.pack(side=TOP, expand=YES, fill=X)       # runs onSubmit method\n        self.content = {}\n846 | Chapter 12:\u2002Network Scriptingfor label in labels:\n            row = Frame(rows)\n            row.pack(fill=X)\n            Label(row, text=label, width=labelsize).pack(side=LEFT)\n            entry = Entry(row, width=entrysize)\n            entry.pack(side=RIGHT, expand=YES, fill=X)\n            self.content[label] = entry\n        Button(box, text='Cancel', command=self.onCancel).pack(side=RIGHT)\n        Button(box, text='Submit', command=self.onSubmit).pack(side=RIGHT)\n        box.master.bind('<Return>', (lambda event: self.onSubmit()))\n    def onSubmit(self):                                      # override this\n        for key in self.content:                             # user inputs in\n            print(key, '\\t=>\\t', self.content[key].get())    # self.content[k]\n    def onCancel(self):                                      # override if need\n        Tk().quit()                                          # default is exit\nclass DynamicForm(Form):\n    def __init__(self, labels=None):\n        labels = input('Enter field names: ').split()\n        Form.__init__(self, labels)\n    def onSubmit(self):\n        print('Field values...')\n        Form.onSubmit(self)\n        self.onCancel()\nif __name__ == '__main__':\n    import sys\n    if len(sys.argv) == 1:\n        Form(['Name', 'Age', 'Job'])     # precoded fields, stay after submit\n    else:\n        DynamicForm()                    # input fields, go away after submit\n    mainloop()\nCompare the approach of this module with that of the form row builder function we\nwrote in Chapter 10\u2019s Example 10-9. While that example much reduced the amount\nof code required, the module here is a noticeably more complete and automatic\nscheme\u2014it builds the entire form given a set of label names, and provides a dictionary\nwith every field\u2019s entry widget ready to be fetched.\nRunning this module standalone triggers its self-test code at the bottom. Without ar-\nguments (and when double-clicked in a Windows file explorer), the self-test generates\na form with canned input fields captured in Figure 12-4, and displays the fields\u2019 values\non Enter key presses or Submit button clicks:\nC:\\...\\PP4E\\Internet\\Sockets> python form.py\nAge     =>       40\nName    =>       Bob\nJob     =>       Educator, Entertainer\nWith a command-line argument, the form class module\u2019s self-test code prompts for an\narbitrary set of field names for the form; fields can be constructed as dynamically as we\nA Simple Python File Server | 847like. Figure 12-5 shows the input form constructed in response to the following console\ninteraction. Field names could be accepted on the command line, too, but the input\nbuilt-in function works just as well for simple tests like this. In this mode, the GUI goes\naway after the first submit, because DynamicForm.onSubmit says so:\nC:\\...\\PP4E\\Internet\\Sockets> python form.py -\nEnter field names: Name Email Web Locale\nField values...\nLocale  =>       Florida\nWeb     =>       http://learning-python.com\nName    =>       Book\nEmail   =>       pp4e@learning-python.com\nFigure 12-5. Form test, dynamic fields\nAnd last but not least, Example 12-21 shows the getfile user interface again, this time\nconstructed with the reusable form layout class. We need to fill in only the form labels\nlist and provide an onSubmit callback method of our own. All of the work needed to\nconstruct the form comes \u201cfor free,\u201d from the imported and widely reusable Form\nsuperclass.\nExample 12-21. PP4E\\Internet\\Sockets\\getfilegui.py\n\"\"\"\nlaunch getfile client with a reusable GUI form class;\nos.chdir to target local dir if input (getfile stores in cwd);\nFigure 12-4. Form test, canned fields\n848 | Chapter 12:\u2002Network Scriptingto do: use threads, show download status and getfile prints;\n\"\"\"\nfrom form import Form\nfrom tkinter import Tk, mainloop\nfrom tkinter.messagebox import showinfo\nimport getfile, os\nclass GetfileForm(Form):\n    def __init__(self, oneshot=False):\n        root = Tk()\n        root.title('getfilegui')\n        labels = ['Server Name', 'Port Number', 'File Name', 'Local Dir?']\n        Form.__init__(self, labels, root)\n        self.oneshot = oneshot\n    def onSubmit(self):\n        Form.onSubmit(self)\n        localdir   = self.content['Local Dir?'].get()\n        portnumber = self.content['Port Number'].get()\n        servername = self.content['Server Name'].get()\n        filename   = self.content['File Name'].get()\n        if localdir:\n            os.chdir(localdir)\n        portnumber = int(portnumber)\n        getfile.client(servername, portnumber, filename)\n        showinfo('getfilegui', 'Download complete')\n        if self.oneshot: Tk().quit()  # else stay in last localdir\nif __name__ == '__main__':\n    GetfileForm()\n    mainloop()\nThe form layout class imported here can be used by any program that needs to input\nform-like data; when used in this script, we get a user interface like that shown in\nFigure 12-6 under Windows 7 (and similar on other versions and platforms).\nFigure 12-6. getfilegui in action\nPressing this form\u2019s Submit button or the Enter key makes the getfilegui script call\nthe imported getfile.client client-side function as before. This time, though, we also\nA Simple Python File Server | 849first change to the local directory typed into the form so that the fetched file is stored\nthere (getfile stores in the current working directory, whatever that may be when it is\ncalled). Here are the messages printed in the client\u2019s console, along with a check on the\nfile transfer; the server is still running above testdir, but the client stores the file else-\nwhere after it\u2019s fetched on the socket:\nC:\\...\\Internet\\Sockets> getfilegui.py\nLocal Dir?      =>       C:\\users\\Mark\\temp\nFile Name       =>       testdir\\ora-lp4e.gif\nServer Name     =>       localhost\nPort Number     =>       50001\nClient got testdir\\ora-lp4e.gif at Sun Apr 25 17:22:39 2010\nC:\\...\\Internet\\Sockets> fc /B C:\\Users\\mark\\temp\\ora-lp4e.gif testdir\\ora-lp4e.gif\nFC: no differences encountered\nAs usual, we can use this interface to connect to servers running locally on the same\nmachine (as done here), or remotely on a different computer. Use a different server\nname and file paths if you\u2019re running the server on a remote machine; the magic of\nsockets make this all \u201cjust work\u201d in either local or remote modes.\nOne caveat worth pointing out here: the GUI is essentially dead while the download is\nin progress (even screen redraws aren\u2019t handled\u2014try covering and uncovering the\nwindow and you\u2019ll see what I mean). We could make this better by running the down-\nload in a thread, but since we\u2019ll see how to do that in the next chapter when we explore\nthe FTP protocol, you should consider this problem a preview.\nIn closing, a few final notes: first, I should point out that the scripts in this chapter use\ntkinter techniques we\u2019ve seen before and won\u2019t go into here in the interest of space; be\nsure to see the GUI chapters in this book for implementation hints.\nKeep in mind, too, that these interfaces just add a GUI on top of the existing script to\nreuse its code; any command-line tool can be easily GUI-ified in this way to make it\nmore appealing and user friendly. In Chapter 14, for example, we\u2019ll meet a more useful\nclient-side tkinter user interface for reading and sending email over sockets (PyMail-\nGUI), which largely just adds a GUI to mail-processing tools. Generally speaking, GUIs\ncan often be added as almost an afterthought to a program. Although the degree of\nuser-interface and core logic separation varies per program, keeping the two distinct\nmakes it easier to focus on each.\nAnd finally, now that I\u2019ve shown you how to build user interfaces on top of this chap-\nter\u2019s getfile, I should also say that they aren\u2019t really as useful as they might seem. In\nparticular, getfile clients can talk only to machines that are running a getfile server.\nIn the next chapter, we\u2019ll discover another way to download files\u2014FTP\u2014which also\nruns on sockets but provides a higher-level interface and is available as a standard\nservice on many machines on the Net. We don\u2019t generally need to start up a custom\nserver to transfer files over FTP, the way we do with getfile. In fact, the user-interface\nscripts in this chapter could be easily changed to fetch the desired file with Python\u2019s\n850 | Chapter 12:\u2002Network ScriptingFTP tools, instead of the getfile module. But instead of spilling all the beans here, I\u2019ll\njust say, \u201cRead on.\u201d\nUsing Serial Ports\nSockets, the main subject of this chapter, are the programmer\u2019s interface to network\nconnections in Python scripts. As we\u2019ve seen, they let us write scripts that converse\nwith computers arbitrarily located on a network, and they form the backbone of the\nInternet and the Web.\nIf you\u2019re looking for a lower-level way to communicate with devices in general, though,\nyou may also be interested in the topic of Python\u2019s serial port interfaces. This isn\u2019t quite\nrelated to Internet scripting, but it\u2019s similar enough in spirit and is discussed often\nenough on the Net to merit a few words here.\nIn brief, scripts can use serial port interfaces to engage in low-level communication with\nthings like mice, modems, and a wide variety of serial devices and hardware. Serial port\ninterfaces are also used to communicate with devices connected over infrared ports\n(e.g., hand-held computers and remote modems). Such interfaces let scripts tap into\nraw data streams and implement device protocols of their own. Other Python tools\nsuch as the ctypes and struct modules may provide additional tools for creating and\nextracting the packed binary data these ports transfer.\nAt this writing, there are a variety of ways to send and receive data over serial ports in\nPython scripts. Notable among these options is an open source extension package\nknown as pySerial, which allows Python scripts to control serial ports on both Windows\nand Linux, as well as BSD Unix, Jython (for Java), and IronPython (for .Net and Mono).\nUnfortunately, there is not enough space to cover this or any other serial port option\nin any sort of detail in this text. As always, see your favorite web search engine for up-\nto-date details on this front.\nA Simple Python File Server | 851", "13": "CHAPTER 13\nClient-Side Scripting\n\u201cSocket to Me!\u201d\nThe preceding chapter introduced Internet fundamentals and explored sockets\u2014the \nunderlying communications mechanism over which bytes flow on the Net. In this \nchapter, we climb the encapsulation hierarchy one level and shift our focus to Python \ntools that support the client-side interfaces of common Internet protocols.\nWe talked about the Internet\u2019s higher-level protocols in the abstract at the start of the \npreceding chapter, and you should probably review that material if you skipped over \nit the first time around. In short, protocols define the structure of the conversations \nthat take place to accomplish most of the Internet tasks we\u2019re all familiar with\u2014reading \nemail, transferring files by FTP, fetching web pages, and so on.\nAt the most basic level, all of these protocol dialogs happen over sockets using fixed \nand standard message structures and ports, so in some sense this chapter builds upon \nthe last. But as we\u2019ll see, Python\u2019s protocol modules hide most of the underlying \ndetails\u2014scripts generally need to deal only with simple objects and methods, and Py-\nthon automates the socket and messaging logic required by the protocol.\nIn this chapter, we\u2019ll concentrate on the FTP and email protocol modules in Python, \nand we\u2019ll peek at a few others along the way (NNTP news, HTTP web pages, and so \non). Because it is so prevalent, we will especially focus on email in much of this chapter, \nas well as in the two to follow\u2014we\u2019ll use tools and techniques introduced here in the \nlarger PyMailGUI and PyMailCGI client and server-side programs of Chapters \n14 and 16.\nAll of the tools employed in examples here are in the standard Python library and come \nwith the Python system. All of the examples here are also designed to run on the client \nside of a network connection\u2014these scripts connect to an already running server to \nrequest interaction and can be run from a basic PC or other client device (they require \nonly a server to converse with). And as usual, all the code here is also designed to teach \nus something about Python programming in general\u2014we\u2019ll refactor FTP examples and \npackage email code to show object-oriented programming (OOP) in action.\n853In the next chapter, we\u2019ll look at a complete client-side program example before moving\non to explore scripts designed to be run on the server side instead. Python programs\ncan also produce pages on a web server, and there is support in the Python world for\nimplementing the server side of things like HTTP, email, and FTP. For now, let\u2019s focus\non the client.*\nFTP: Transferring Files over the Net\nAs we saw in the preceding chapter, sockets see plenty of action on the Net. For in-\nstance, the last chapter\u2019s getfile example allowed us to transfer entire files between\nmachines. In practice, though, higher-level protocols are behind much of what happens\non the Net. Protocols run on top of sockets, but they hide much of the complexity of\nthe network scripting examples of the prior chapter.\nFTP\u2014the File Transfer Protocol\u2014is one of the more commonly used Internet proto-\ncols. It defines a higher-level conversation model that is based on exchanging command\nstrings and file contents over sockets. By using FTP, we can accomplish the same task\nas the prior chapter\u2019s getfile script, but the interface is simpler, standard and more\ngeneral\u2014FTP lets us ask for files from any server machine that supports FTP, without\nrequiring that it run our custom getfile script. FTP also supports more advanced op-\nerations such as uploading files to the server, getting remote directory listings, and\nmore.\nReally, FTP runs on top of two sockets: one for passing control commands between\nclient and server (port 21), and another for transferring bytes. By using a two-socket\nmodel, FTP avoids the possibility of deadlocks (i.e., transfers on the data socket do not\nblock dialogs on the control socket). Ultimately, though, Python\u2019s ftplib support\nmodule allows us to upload and download files at a remote server machine by FTP,\nwithout dealing in raw socket calls or FTP protocol details.\nTransferring Files with ftplib\nBecause the Python FTP interface is so easy to use, let\u2019s jump right into a realistic\nexample. The script in Example 13-1 automatically fetches (a.k.a. \u201cdownloads\u201d) and\n* There is also support in the Python world for other technologies that some might classify as \u201cclient-side\nscripting,\u201d too, such as Jython/Java applets; XML-RPC and SOAP web services; and Rich Internet Application\ntools like Flex, Silverlight, pyjamas, and AJAX. These were all introduced early in Chapter 12. Such tools are\ngenerally bound up with the notion of web-based interactions\u2014they either extend the functionality of a web\nbrowser running on a client machine, or simplify web server access in clients. We\u2019ll study browser-based\ntechniques in Chapters 15 and 16; here, client-side scripting means the client side of common Internet\nprotocols such as FTP and email, independent of the Web or web browsers. At the bottom, web browsers\nare really just desktop GUI applications that make use of client-side protocols, including those we\u2019ll study\nhere, such as HTTP and FTP. See Chapter 12 as well as the end of this chapter for more on other client-side\ntechniques.\n854 | Chapter 13:\u2002Client-Side Scriptingopens a remote file with Python. More specifically, this Python script does the\nfollowing:\n1. Downloads an image file (by default) from a remote FTP site\n2. Opens the downloaded file with a utility we wrote in Example 6-23, in Chapter 6\nThe download portion will run on any machine with Python and an Internet connec-\ntion, though you\u2019ll probably want to change the script\u2019s settings so it accesses a server\nand file of your own. The opening part works if your playfile.py supports your platform;\nsee Chapter 6 for details, and change as needed.\nExample 13-1. PP4E\\Internet\\Ftp\\getone.py\n#!/usr/local/bin/python\n\"\"\"\nA Python script to download and play a media file by FTP.  Uses ftplib, the ftp\nprotocol handler which uses sockets.  Ftp runs on 2 sockets (one for data, one\nfor control--on ports 20 and 21) and imposes message text formats, but Python's\nftplib module hides most of this protocol's details.  Change for your site/file.\n\"\"\"\nimport os, sys\nfrom getpass import getpass                   # hidden password input\nfrom ftplib import FTP                        # socket-based FTP tools\nnonpassive  = False                           # force active mode FTP for server?\nfilename    = 'monkeys.jpg'                   # file to be downloaded\ndirname     = '.'                             # remote directory to fetch from\nsitename    = 'ftp.rmi.net'                   # FTP site to contact\nuserinfo    = ('lutz', getpass('Pswd?'))      # use () for anonymous\nif len(sys.argv) > 1: filename = sys.argv[1]  # filename on command line?\nprint('Connecting...')\nconnection = FTP(sitename)                  # connect to FTP site\nconnection.login(*userinfo)                 # default is anonymous login\nconnection.cwd(dirname)                     # xfer 1k at a time to localfile\nif nonpassive:                              # force active FTP if server requires\n    connection.set_pasv(False)\nprint('Downloading...')\nlocalfile = open(filename, 'wb')            # local file to store download\nconnection.retrbinary('RETR ' + filename, localfile.write, 1024)\nconnection.quit()\nlocalfile.close()\nif input('Open file?') in ['Y', 'y']:\n    from PP4E.System.Media.playfile import playfile\n    playfile(filename)\nMost of the FTP protocol details are encapsulated by the Python ftplib module im-\nported here. This script uses some of the simplest interfaces in ftplib (we\u2019ll see others\nlater in this chapter), but they are representative of the module in general.\nTransferring Files with ftplib | 855To open a connection to a remote (or local) FTP server, create an instance of the\nftplib.FTP object, passing in the string name (domain or IP style) of the machine you\nwish to connect to:\nconnection = FTP(sitename)                  # connect to ftp site\nAssuming this call doesn\u2019t throw an exception, the resulting FTP object exports meth-\nods that correspond to the usual FTP operations. In fact, Python scripts act much like\ntypical FTP client programs\u2014just replace commands you would normally type or select\nwith method calls:\nconnection.login(*userinfo)                 # default is anonymous login\nconnection.cwd(dirname)                     # xfer 1k at a time to localfile\nOnce connected, we log in and change to the remote directory from which we want to\nfetch a file. The login method allows us to pass in a username and password as addi-\ntional optional arguments to specify an account login; by default, it performs anony-\nmous FTP. Notice the use of the nonpassive flag in this script:\nif nonpassive:                              # force active FTP if server requires\n    connection.set_pasv(False)\nIf this flag is set to True, the script will transfer the file in active FTP mode rather than\nthe default passive mode. We\u2019ll finesse the details of the difference here (it has to do\nwith which end of the dialog chooses port numbers for the transfer), but if you have\ntrouble doing transfers with any of the FTP scripts in this chapter, try using active mode\nas a first step. In Python 2.1 and later, passive FTP mode is on by default. Now, open\na local file to receive the file\u2019s content, and fetch the file:\nlocalfile = open(filename, 'wb')\nconnection.retrbinary('RETR ' + filename, localfile.write, 1024)\nOnce we\u2019re in the target remote directory, we simply call the retrbinary method to\ndownload the target server file in binary mode. The retrbinary call will take a while to\ncomplete, since it must download a big file. It gets three arguments:\n\u2022 An FTP command string; here, the string RETR filename, which is the standard\nformat for FTP retrievals.\n\u2022 A function or method to which Python passes each chunk of the downloaded file\u2019s\nbytes; here, the write method of a newly created and opened local file.\n\u2022 A size for those chunks of bytes; here, 1,024 bytes are downloaded at a time, but\nthe default is reasonable if this argument is omitted.\nBecause this script creates a local file named localfile of the same name as the remote\nfile being fetched, and passes its write method to the FTP retrieval method, the remote\nfile\u2019s contents will automatically appear in a local, client-side file after the download is\nfinished.\nObserve how this file is opened in wb binary output mode. If this script is run on Win-\ndows we want to avoid automatically expanding any \\n bytes into \\r\\n byte sequences;\n856 | Chapter 13:\u2002Client-Side Scriptingas we saw in Chapter 4, this happens automatically on Windows when writing files\nopened in w text mode. We also want to avoid Unicode issues in Python 3.X\u2014as we\nalso saw in Chapter 4, strings are encoded when written in text mode and this isn\u2019t\nappropriate for binary data such as images. A text-mode file would also not allow for\nthe bytes strings passed to write by the FTP library\u2019s retrbinary in any event, so rb is\neffectively required here (more on output file modes later).\nFinally, we call the FTP quit method to break the connection with the server and man-\nually close the local file to force it to be complete before it is further processed (it\u2019s not\nimpossible that parts of the file are still held in buffers before the close call):\nconnection.quit()\nlocalfile.close()\nAnd that\u2019s all there is to it\u2014all the FTP, socket, and networking details are hidden\nbehind the ftplib interface module. Here is this script in action on a Windows 7 ma-\nchine; after the download, the image file pops up in a Windows picture viewer on my\nlaptop, as captured in Figure 13-1. Change the server and file assignments in this script\nto test on your own, and be sure your PYTHONPATH environment variable includes the\nPP4E root\u2019s container, as we\u2019re importing across directories on the examples tree here:\nC:\\...\\PP4E\\Internet\\Ftp> python getone.py\nPswd?\nConnecting...\nDownloading...\nOpen file?y\nNotice how the standard Python getpass.getpass is used to ask for an FTP password.\nLike the input built-in function, this call prompts for and reads a line of text from the\nconsole user; unlike input, getpass does not echo typed characters on the screen at all\n(see the moreplus stream redirection example of Chapter 3 for related tools). This is\nhandy for protecting things like passwords from potentially prying eyes. Be careful,\nthough\u2014after issuing a warning, the IDLE GUI echoes the password anyhow!\nThe main thing to notice is that this otherwise typical Python script fetches information\nfrom an arbitrarily remote FTP site and machine. Given an Internet link, any informa-\ntion published by an FTP server on the Net can be fetched by and incorporated into\nPython scripts using interfaces such as these.\nUsing urllib to Download Files\nIn fact, FTP is just one way to transfer information across the Net, and there are more\ngeneral tools in the Python library to accomplish the prior script\u2019s download. Perhaps\nthe most straightforward is the Python urllib.request module: given an Internet ad-\ndress string\u2014a URL, or Universal Resource Locator\u2014this module opens a connection\nto the specified server and returns a file-like object ready to be read with normal file\nobject method calls (e.g., read, readline).\nTransferring Files with ftplib | 857We can use such a higher-level interface to download anything with an address on the \nWeb\u2014files published by FTP sites (using URLs that start with ftp://); web pages and \noutput of scripts that live on remote servers (using http:// URLs); and even local files \n(using file:// URLs). For instance, the script in Example 13-2 does the same as the one \nin Example 13-1, but it uses the general urllib.request module to fetch the source \ndistribution file, instead of the protocol-specific ftplib.\nExample 13-2. PP4E\\Internet\\Ftp\\getone-urllib.py\n#!/usr/local/bin/python\n\"\"\"\nA Python script to download a file by FTP by its URL string; use higher-level\nurllib instead of ftplib to fetch file;  urllib supports FTP, HTTP, client-side\nHTTPS, and local files, and handles proxies, redirects, cookies, and more;\nurllib also allows downloads of html pages, images, text, etc.;  see also\nPython html/xml parsers for web pages fetched by urllib in Chapter 19;\n\"\"\"\nimport os, getpass\nfrom urllib.request import urlopen       # socket-based web tools\nFigure 13-1. Image file downloaded by FTP and opened locally\n858 | Chapter 13:\u2002Client-Side Scriptingfilename = 'monkeys.jpg'                 # remote/local filename\npassword = getpass.getpass('Pswd?')\nremoteaddr = 'ftp://lutz:%s@ftp.rmi.net/%s;type=i' % (password, filename)\nprint('Downloading', remoteaddr)\n# this works too:\n# urllib.request.urlretrieve(remoteaddr, filename)\nremotefile = urlopen(remoteaddr)                 # returns input file-like object\nlocalfile  = open(filename, 'wb')                # where to store data locally\nlocalfile.write(remotefile.read())\nlocalfile.close()\nremotefile.close()\nNote how we use a binary mode output file again; urllib fetches return byte strings,\neven for HTTP web pages. Don\u2019t sweat the details of the URL string used here; it is\nfairly complex, and we\u2019ll explain its structure and that of URLs in general in Chap-\nter 15. We\u2019ll also use urllib again in this and later chapters to fetch web pages, format\ngenerated URL strings, and get the output of remote scripts on the Web.\nTechnically speaking, urllib.request supports a variety of Internet protocols (HTTP,\nFTP, and local files). Unlike ftplib, urllib.request is generally used for reading remote\nobjects, not for writing or uploading them (though the HTTP and FTP protocols sup-\nport file uploads too). As with ftplib, retrievals must generally be run in threads if\nblocking is a concern. But the basic interface shown in this script is straightforward.\nThe call:\nremotefile = urllib.request.urlopen(remoteaddr)  # returns input file-like object\ncontacts the server named in the remoteaddr URL string and returns a file-like object\nconnected to its download stream (here, an FTP-based socket). Calling this file\u2019s\nread method pulls down the file\u2019s contents, which are written to a local client-side file.\nAn even simpler interface:\nurllib.request.urlretrieve(remoteaddr, filename)\nalso does the work of opening a local file and writing the downloaded bytes into it\u2014\nthings we do manually in the script as coded. This comes in handy if we want to down-\nload a file, but it is less useful if we want to process its data immediately.\nEither way, the end result is the same: the desired server file shows up on the client\nmachine. The output is similar to the original version, but we don\u2019t try to automatically\nopen this time (I\u2019ve changed the password in the URL here to protect the innocent):\nC:\\...\\PP4E\\Internet\\Ftp> getone-urllib.py\nPswd?\nDownloading ftp://lutz:xxxxxx@ftp.rmi.net/monkeys.jpg;type=i\nC:\\...\\PP4E\\Internet\\Ftp> fc monkeys.jpg test\\monkeys.jpg\nFC: no differences encountered\nC:\\...\\PP4E\\Internet\\Ftp> start monkeys.jpg\nTransferring Files with ftplib | 859For more urllib download examples, see the section on HTTP later in this chapter,\nand the server-side examples in Chapter 15. As we\u2019ll see in Chapter 15, in bigger terms,\ntools like the urllib.request urlopen function allow scripts to both download remote\nfiles and invoke programs that are located on a remote server machine, and so serves\nas a useful tool for testing and using web sites in Python scripts. In Chapter 15, we\u2019ll\nalso see that urllib.parse includes tools for formatting (escaping) URL strings for safe \ntransmission.\nFTP get and put Utilities\nWhen I present the ftplib interfaces in Python classes, students often ask why pro-\ngrammers need to supply the RETR string in the retrieval method. It\u2019s a good\nquestion\u2014the RETR string is the name of the download command in the FTP protocol,\nbut ftplib is supposed to encapsulate that protocol. As we\u2019ll see in a moment, we have\nto supply an arguably odd STOR string for uploads as well. It\u2019s boilerplate code that\nyou accept on faith once you see it, but that begs the question. You could propose a\npatch to ftplib, but that\u2019s not really a good answer for beginning Python students, and\nit may break existing code (the interface is as it is for a reason).\nPerhaps a better answer is that Python makes it easy to extend the standard library\nmodules with higher-level interfaces of our own\u2014with just a few lines of reusable code,\nwe can make the FTP interface look any way we want in Python. For instance, we could,\nonce and for all, write utility modules that wrap the ftplib interfaces to hide the RETR\nstring. If we place these utility modules in a directory on PYTHONPATH, they become just\nas accessible as ftplib itself, automatically reusable in any Python script we write in\nthe future. Besides removing the RETR string requirement, a wrapper module could\nalso make assumptions that simplify FTP operations into single function calls.\nFor instance, given a module that encapsulates and simplifies ftplib, our Python fetch-\nand-play script could be further reduced to the script shown in Example 13-3\u2014essen-\ntially just two function calls plus a password prompt, but with a net effect exactly like\nExample 13-1 when run.\nExample 13-3. PP4E\\Internet\\Ftp\\getone-modular.py\n#!/usr/local/bin/python\n\"\"\"\nA Python script to download and play a media file by FTP.\nUses getfile.py, a utility module which encapsulates FTP step.\n\"\"\"\nimport getfile\nfrom getpass import getpass\nfilename = 'monkeys.jpg'\n# fetch with utility\ngetfile.getfile(file=filename,\n                site='ftp.rmi.net',\n860 | Chapter 13:\u2002Client-Side Scriptingdir ='.',\n                user=('lutz', getpass('Pswd?')),\n                refetch=True)\n# rest is the same\nif input('Open file?') in ['Y', 'y']:\n    from PP4E.System.Media.playfile import playfile\n    playfile(filename)\nBesides having a much smaller line count, the meat of this script has been split off into\na file for reuse elsewhere. If you ever need to download a file again, simply import an\nexisting function instead of copying code with cut-and-paste editing. Changes in down-\nload operations would need to be made in only one file, not everywhere we\u2019ve copied\nboilerplate code; getfile.getfile could even be changed to use urllib rather than\nftplib without affecting any of its clients. It\u2019s good engineering.\nDownload utility\nSo just how would we go about writing such an FTP interface wrapper (he asks, rhet-\norically)? Given the ftplib library module, wrapping downloads of a particular file in\na particular directory is straightforward. Connected FTP objects support two download\nmethods:\nretrbinary\nThis method downloads the requested file in binary mode, sending its bytes in\nchunks to a supplied function, without line-feed mapping. Typically, the supplied\nfunction is a write method of an open local file object, such that the bytes are placed\nin the local file on the client.\nretrlines\nThis method downloads the requested file in ASCII text mode, sending each line\nof text to a supplied function with all end-of-line characters stripped. Typically,\nthe supplied function adds a \\n newline (mapped appropriately for the client ma-\nchine), and writes the line to a local file.\nWe will meet the retrlines method in a later example; the getfile utility module in\nExample 13-4 always transfers in binary mode with retrbinary. That is, files are down-\nloaded exactly as they were on the server, byte for byte, with the server\u2019s line-feed\nconventions in text files (you may need to convert line feeds after downloads if they\nlook odd in your text editor\u2014see your editor or system shell commands for pointers,\nor write a Python script that opens and writes the text as needed).\nExample 13-4. PP4E\\Internet\\Ftp\\getfile.py\n#!/usr/local/bin/python\n\"\"\"\nFetch an arbitrary file by FTP.  Anonymous FTP unless you pass a\nuser=(name, pswd) tuple. Self-test FTPs a test file and site.\n\"\"\"\nTransferring Files with ftplib | 861from ftplib  import FTP          # socket-based FTP tools\nfrom os.path import exists       # file existence test\ndef getfile(file, site, dir, user=(), *, verbose=True, refetch=False):\n    \"\"\"\n    fetch a file by ftp from a site/directory\n    anonymous or real login, binary transfer\n    \"\"\"\n    if exists(file) and not refetch:\n        if verbose: print(file, 'already fetched')\n    else:\n        if verbose: print('Downloading', file)\n        local = open(file, 'wb')                # local file of same name\n        try:\n            remote = FTP(site)                  # connect to FTP site\n            remote.login(*user)                 # anonymous=() or (name, pswd)\n            remote.cwd(dir)\n            remote.retrbinary('RETR ' + file, local.write, 1024)\n            remote.quit()\n        finally:\n            local.close()                       # close file no matter what\n        if verbose: print('Download done.')     # caller handles exceptions\nif __name__ == '__main__':\n    from getpass import getpass\n    file = 'monkeys.jpg'\n    dir  = '.'\n    site = 'ftp.rmi.net'\n    user = ('lutz', getpass('Pswd?'))\n    getfile(file, site, dir, user)\nThis module is mostly just a repackaging of the FTP code we used to fetch the image\nfile earlier, to make it simpler and reusable. Because it is a callable function, the exported\ngetfile.getfile here tries to be as robust and generally useful as possible, but even a\nfunction this small implies some design decisions. Here are a few usage notes:\nFTP mode\nThe getfile function in this script runs in anonymous FTP mode by default, but\na two-item tuple containing a username and password string may be passed to the\nuser argument in order to log in to the remote server in nonanonymous mode. To\nuse anonymous FTP, either don\u2019t pass the user argument or pass it an empty tuple,\n(). The FTP object login method allows two optional arguments to denote a user-\nname and password, and the function(*args) call syntax in Example 13-4 sends\nit whatever argument tuple you pass to user as individual arguments.\nProcessing modes\nIf passed, the last two arguments (verbose, refetch) allow us to turn off status\nmessages printed to the stdout stream (perhaps undesirable in a GUI context) and\nto force downloads to happen even if the file already exists locally (the download\noverwrites the existing local file).\n862 | Chapter 13:\u2002Client-Side ScriptingThese two arguments are coded as Python 3.X default keyword-only arguments, so\nif used they must be passed by name, not position. The user argument instead can\nbe passed either way, if it is passed at all. Keyword-only arguments here prevent\npassed verbose or refetch values from being incorrectly matched against the user\nargument if the user value is actually omitted in a call.\nException protocol\nThe caller is expected to handle exceptions; this function wraps downloads in a\ntry/finally statement to guarantee that the local output file is closed, but it lets\nexceptions propagate. If used in a GUI or run from a thread, for instance, excep-\ntions may require special handling unknown in this file.\nSelf-test\nIf run standalone, this file downloads an image file again from my website as a self-\ntest (configure for your server and file as desired), but the function will normally\nbe passed FTP filenames, site names, and directory names as well.\nFile mode\nAs in earlier examples, this script is careful to open the local output file in wb binary\nmode to suppress end-line mapping and conform to Python 3.X\u2019s Unicode string\nmodel. As we learned in Chapter 4, it\u2019s not impossible that true binary datafiles\nmay have bytes whose value is equal to a \\n line-feed character; opening in w text\nmode instead would make these bytes automatically expand to a \\r\\n two-byte\nsequence when written locally on Windows. This is only an issue when run on\nWindows; mode w doesn\u2019t change end-lines elsewhere.\nAs we also learned in Chapter 4, though, binary mode is required to suppress the\nautomatic Unicode translations performed for text in Python 3.X. Without binary\nmode, Python would attempt to encode fetched data when written per a default\nor passed Unicode encoding scheme, which might fail for some types of fetched\ntext and would normally fail for truly binary data such as images and audio.\nBecause retrbinary writes bytes strings in 3.X, we really cannot open the output\nfile in text mode anyhow, or write will raise exceptions. Recall that in 3.X text-\nmode files require str strings, and binary mode files expect bytes. Since\nretrbinary writes bytes and retrlines writes str, they implicitly require binary\nand text-mode output files, respectively. This constraint is irrespective of end-line\nor Unicode issues, but it effectively accomplishes those goals as well.\nAs we\u2019ll see in later examples, text-mode retrievals have additional encoding re-\nquirements; in fact, ftplib will turn out to be a good example of the impacts of\nPython 3.X\u2019s Unicode string model on real-world code. By always using binary\nmode in the script here, we sidestep the issue altogether.\nDirectory model\nThis function currently uses the same filename to identify both the remote file and\nthe local file where the download should be stored. As such, it should be run in\nthe directory where you want the file to show up; use os.chdir to move to direc-\ntories if needed. (We could instead assume filename is the local file\u2019s name, and\nTransferring Files with ftplib | 863strip the local directory with os.path.split to get the remote name, or accept two\ndistinct filename arguments\u2014local and remote.)\nAlso notice that, despite its name, this module is very different from the getfile.py script\nwe studied at the end of the sockets material in the preceding chapter. The socket-based\ngetfile implemented custom client and server-side logic to download a server file to a\nclient machine over raw sockets.\nThe new getfile here is a client-side tool only. Instead of raw sockets, it uses the\nstandard FTP protocol to request a file from a server; all socket-level details are hidden\nin the simpler ftplib module\u2019s implementation of the FTP client protocol. Further-\nmore, the server here is a perpetually running program on the server machine, which\nlistens for and responds to FTP requests on a socket, on the dedicated FTP port (number\n21). The net functional effect is that this script requires an FTP server to be running on\nthe machine where the desired file lives, but such a server is much more likely to be\navailable.\nUpload utility\nWhile we\u2019re at it, let\u2019s write a script to upload a single file by FTP to a remote machine.\nThe upload interfaces in the FTP module are symmetric with the download interfaces.\nGiven a connected FTP object, its:\n\u2022 storbinary method can be used to upload bytes from an open local file object\n\u2022 storlines method can be used to upload text in ASCII mode from an open local\nfile object\nUnlike the download interfaces, both of these methods are passed a file object as a\nwhole, not a file object method (or other function). We will meet the storlines method\nin a later example. The utility module in Example 13-5 uses storbinary such that the\nfile whose name is passed in is always uploaded verbatim\u2014in binary mode, without\nUnicode encodings or line-feed translations for the target machine\u2019s conventions. If\nthis script uploads a text file, it will arrive exactly as stored on the machine it came\nfrom, with client line-feed markers and existing Unicode encoding.\nExample 13-5. PP4E\\Internet\\Ftp\\putfile.py\n#!/usr/local/bin/python\n\"\"\"\nStore an arbitrary file by FTP in binary mode.  Uses anonymous\nftp unless you pass in a user=(name, pswd) tuple of arguments.\n\"\"\"\nimport ftplib                    # socket-based FTP tools\ndef putfile(file, site, dir, user=(), *, verbose=True):\n    \"\"\"\n    store a file by ftp to a site/directory\n    anonymous or real login, binary transfer\n864 | Chapter 13:\u2002Client-Side Scripting\"\"\"\n    if verbose: print('Uploading', file)\n    local  = open(file, 'rb')               # local file of same name\n    remote = ftplib.FTP(site)               # connect to FTP site\n    remote.login(*user)                     # anonymous or real login\n    remote.cwd(dir)\n    remote.storbinary('STOR ' + file, local, 1024)\n    remote.quit()\n    local.close()\n    if verbose: print('Upload done.')\nif __name__ == '__main__':\n    site = 'ftp.rmi.net'\n    dir  = '.'\n    import sys, getpass\n    pswd = getpass.getpass(site + ' pswd?')                # filename on cmdline\n    putfile(sys.argv[1], site, dir, user=('lutz', pswd))   # nonanonymous login\nNotice that for portability, the local file is opened in rb binary input mode this time to\nsuppress automatic line-feed character conversions. If this is binary information, we\ndon\u2019t want any bytes that happen to have the value of the \\r carriage-return character\nto mysteriously go away during the transfer when run on a Windows client. We also\nwant to suppress Unicode encodings for nontext files, and we want reads to produce\nthe bytes strings expected by the storbinary upload operation (more on input file\nmodes later).\nThis script uploads a file you name on the command line as a self-test, but you will\nnormally pass in real remote filename, site name, and directory name strings. Also like\nthe download utility, you may pass a (username, password) tuple to the user argument\nto trigger nonanonymous FTP mode (anonymous FTP is the default).\nPlaying the Monty Python theme song\nIt\u2019s time for a bit of fun. To test, let\u2019s use these scripts to transfer a copy of the Monty\nPython theme song audio file I have at my website. First, let\u2019s write a module that\ndownloads and plays the sample file, as shown in Example 13-6.\nExample 13-6. PP4E\\Internet\\Ftp\\sousa.py\n#!/usr/local/bin/python\n\"\"\"\nUsage: sousa.py.  Fetch and play the Monty Python theme song.\nThis will not work on your system as is: it requires a machine with Internet access\nand an FTP server account you can access, and uses audio filters on Unix and your\n.au player on Windows.  Configure this and playfile.py as needed for your platform.\n\"\"\"\nfrom getpass import getpass\nfrom PP4E.Internet.Ftp.getfile  import getfile\nfrom PP4E.System.Media.playfile import playfile\nfile = 'sousa.au'                      # default file coordinates\nTransferring Files with ftplib | 865site = 'ftp.rmi.net'                   # Monty Python theme song\ndir  = '.'\nuser = ('lutz', getpass('Pswd?'))\ngetfile(file, site, dir, user)         # fetch audio file by FTP\nplayfile(file)                         # send it to audio player\n# import os\n# os.system('getone.py sousa.au')      # equivalent command line\nThere\u2019s not much to this script, because it really just combines two tools we\u2019ve already\ncoded. We\u2019re reusing Example 13-4\u2019s getfile to download, and Chapter 6\u2019s play\nfile module (Example 6-23) to play the audio sample after it is downloaded (turn back\nto that example for more details on the player part of the task). Also notice the last two\nlines in this file\u2014we can achieve the same effect by passing in the audio filename as a\ncommand-line argument to our original script, but it\u2019s less direct.\nAs is, this script assumes my FTP server account; configure as desired (alas, this file\nused to be at the ftp.python.org anonymous FTP site, but that site went dark for security\nreasons between editions of this book). Once configured, this script will run on any\nmachine with Python, an Internet link, and a recognizable audio player; it works on\nmy Windows laptop with a broadband Internet connection, and it plays the music clip\nin Windows Media Player (and if I could insert an audio file hyperlink here to show\nwhat it sounds like, I would\u2026):\nC:\\...\\PP4E\\Internet\\Ftp> sousa.py\nPswd?\nDownloading sousa.au\nDownload done.\nC:\\...\\PP4E\\Internet\\Ftp> sousa.py\nPswd?\nsousa.au already fetched\nThe getfile and putfile modules themselves can be used to move the sample file\naround too. Both can either be imported by clients that wish to use their functions, or\nrun as top-level programs to trigger self-tests and command-line usage. For variety, let\u2019s\nrun these scripts from a command line and the interactive prompt to see how they work.\nWhen run standalone, the filename is passed in the command line to putfile and both\nuse password input and default site settings:\nC:\\...\\PP4E\\Internet\\Ftp> putfile.py sousa.py\nftp.rmi.net pswd?\nUploading sousa.py\nUpload done.\nWhen imported, parameters are passed explicitly to functions:\nC:\\...\\PP4E\\Internet\\Ftp> python\n>>> from getfile import getfile\n>>> getfile(file='sousa.au', site='ftp.rmi.net', dir='.', user=('lutz', 'XXX'))\nsousa.au already fetched\n866 | Chapter 13:\u2002Client-Side ScriptingC:\\...\\PP4E\\Internet\\Ftp> del sousa.au\nC:\\...\\PP4E\\Internet\\Ftp> python\n>>> from getfile import getfile\n>>> getfile(file='sousa.au', site='ftp.rmi.net', dir='.', user=('lutz', 'XXX'))\nDownloading sousa.au\nDownload done.\n>>> from PP4E.System.Media.playfile import playfile\n>>> playfile('sousa.au')\nAlthough Python\u2019s ftplib already automates the underlying socket and message for-\nmatting chores of FTP, tools of our own like these can make the process even simpler.\nAdding a User Interface\nIf you read the preceding chapter, you\u2019ll recall that it concluded with a quick look at\nscripts that added a user interface to a socket-based getfile script\u2014one that transferred\nfiles over a proprietary socket dialog, instead of over FTP. At the end of that presenta-\ntion, I mentioned that FTP is a much more generally useful way to move files around\nbecause FTP servers are so widely available on the Net. For illustration purposes,\nExample 13-7 shows a simple mutation of the prior chapter\u2019s user interface, imple-\nmented as a new subclass of the preceding chapter\u2019s general form builder, form.py of\nExample 12-20.\nExample 13-7. PP4E\\Internet\\Ftp\\getfilegui.py\n\"\"\"\n#################################################################################\nlaunch FTP getfile function with a reusable form GUI class;  uses os.chdir to\ngoto target local dir (getfile currently assumes that filename has no local\ndirectory path prefix);  runs getfile.getfile in thread to allow more than one\nto be running at once and avoid blocking GUI during downloads;  this differs\nfrom socket-based getfilegui, but reuses Form GUI builder tool;  supports both\nuser and anonymous FTP as currently coded;\ncaveats: the password field is not displayed as stars here, errors are printed\nto the console instead of shown in the GUI (threads can't generally update the\nGUI on Windows), this isn't 100% thread safe (there is a slight delay between\nos.chdir here and opening the local output file in getfile) and we could\ndisplay both a save-as popup for picking the local dir, and a remote directory\nlisting for picking the file to get;  suggested exercises: improve me;\n#################################################################################\n\"\"\"\nfrom tkinter import Tk, mainloop\nfrom tkinter.messagebox import showinfo\nimport getfile, os, sys, _thread                # FTP getfile here, not socket\nfrom PP4E.Internet.Sockets.form import Form     # reuse form tool in socket dir\nclass FtpForm(Form):\n    def __init__(self):\n        root = Tk()\nTransferring Files with ftplib | 867root.title(self.title)\n        labels = ['Server Name', 'Remote Dir', 'File Name',\n                  'Local Dir',   'User Name?', 'Password?']\n        Form.__init__(self, labels, root)\n        self.mutex = _thread.allocate_lock()\n        self.threads = 0\n    def transfer(self, filename, servername, remotedir, userinfo):\n        try:\n            self.do_transfer(filename, servername, remotedir, userinfo)\n            print('%s of \"%s\" successful'  % (self.mode, filename))\n        except:\n            print('%s of \"%s\" has failed:' % (self.mode, filename), end=' ')\n            print(sys.exc_info()[0], sys.exc_info()[1])\n        self.mutex.acquire()\n        self.threads -= 1\n        self.mutex.release()\n    def onSubmit(self):\n        Form.onSubmit(self)\n        localdir   = self.content['Local Dir'].get()\n        remotedir  = self.content['Remote Dir'].get()\n        servername = self.content['Server Name'].get()\n        filename   = self.content['File Name'].get()\n        username   = self.content['User Name?'].get()\n        password   = self.content['Password?'].get()\n        userinfo   = ()\n        if username and password:\n            userinfo = (username, password)\n        if localdir:\n            os.chdir(localdir)\n        self.mutex.acquire()\n        self.threads += 1\n        self.mutex.release()\n        ftpargs = (filename, servername, remotedir, userinfo)\n        _thread.start_new_thread(self.transfer, ftpargs)\n        showinfo(self.title, '%s of \"%s\" started' % (self.mode, filename))\n    def onCancel(self):\n        if self.threads == 0:\n            Tk().quit()\n        else:\n            showinfo(self.title,\n                     'Cannot exit: %d threads running' % self.threads)\nclass FtpGetfileForm(FtpForm):\n    title = 'FtpGetfileGui'\n    mode  = 'Download'\n    def do_transfer(self, filename, servername, remotedir, userinfo):\n        getfile.getfile(\n            filename, servername, remotedir, userinfo, verbose=False, refetch=True)\nif __name__ == '__main__':\n    FtpGetfileForm()\n    mainloop()\n868 | Chapter 13:\u2002Client-Side ScriptingIf you flip back to the end of the preceding chapter, you\u2019ll find that this version is similar\nin structure to its counterpart there; in fact, it has the same name (and is distinct only\nbecause it lives in a different directory). The class here, though, knows how to use the\nFTP-based getfile module from earlier in this chapter instead of the socket-based\ngetfile module we met a chapter ago. When run, this version also implements more\ninput fields, as in Figure 13-2, shown on Windows 7.\nFigure 13-2. FTP getfile input form\nNotice that a full absolute file path can be entered for the local directory here. If not,\nthe script assumes the current working directory, which changes after each download\nand can vary depending on where the GUI is launched (e.g., the current directory differs\nwhen this script is run by the PyDemos program at the top of the examples tree). When\nwe click this GUI\u2019s Submit button (or press the Enter key), the script simply passes the\nform\u2019s input field values as arguments to the getfile.getfile FTP utility function of\nExample 13-4 earlier in this section. It also posts a pop up to tell us the download has\nbegun (Figure 13-3).\nFigure 13-3. FTP getfile info pop up\nTransferring Files with ftplib | 869As currently coded, further download status messages, including any FTP error mes-\nsages, show up in the console window; here are the messages for successful downloads\nas well as one that fails (with added blank lines for readability):\nC:\\...\\PP4E\\Internet\\Ftp> getfilegui.py\nServer Name     =>       ftp.rmi.net\nUser Name?      =>       lutz\nLocal Dir       =>       test\nFile Name       =>       about-pp.html\nPassword?       =>       xxxxxxxx\nRemote Dir      =>       .\nDownload of \"about-pp.html\" successful\nServer Name     =>       ftp.rmi.net\nUser Name?      =>       lutz\nLocal Dir       =>       C:\\temp\nFile Name       =>       ora-lp4e-big.jpg\nPassword?       =>       xxxxxxxx\nRemote Dir      =>       .\nDownload of \"ora-lp4e-big.jpg\" successful\nServer Name     =>       ftp.rmi.net\nUser Name?      =>       lutz\nLocal Dir       =>       C:\\temp\nFile Name       =>       ora-lp4e.jpg\nPassword?       =>       xxxxxxxx\nRemote Dir      =>       .\nDownload of \"ora-lp4e.jpg\" has failed: <class 'ftplib.error_perm'>\n550 ora-lp4e.jpg: No such file or directory\nGiven a username and password, the downloader logs into the specified account. To\ndo anonymous FTP instead, leave the username and password fields blank.\nNow, to illustrate the threading capabilities of this GUI, start a download of a large file,\nthen start another download while this one is in progress. The GUI stays active while\ndownloads are underway, so we simply change the input fields and press Submit again.\nThis second download starts and runs in parallel with the first, because each download\nis run in a thread, and more than one Internet connection can be active at once. In fact,\nthe GUI itself stays active during downloads only because downloads are run in threads;\nif they were not, even screen redraws wouldn\u2019t happen until a download finished.\nWe discussed threads in Chapter 5, and their application to GUIs in Chapters 9 and\n10, but this script illustrates some practical thread concerns:\n\u2022 This program takes care to not do anything GUI-related in a download thread. As\nwe\u2019ve learned, only the thread that makes GUIs can generally process them.\n\u2022 To avoid killing spawned download threads on some platforms, the GUI must also\nbe careful not to exit while any downloads are in progress. It keeps track of the\nnumber of in-progress threads, and just displays a pop up if we try to kill the GUI\nby pressing the Cancel button while both of these downloads are in progress.\n870 | Chapter 13:\u2002Client-Side ScriptingWe learned about ways to work around the no-GUI rule for threads in Chapter 10, and\nwe will apply such techniques when we explore the PyMailGUI example in the next\nchapter. To be portable, though, we can\u2019t really close the GUI until the active-thread\ncount falls to zero; the exit model of the threading module of Chapter 5 can be used\nto achieve the same effect. Here is the sort of output that appears in the console window\nwhen two downloads overlap in time:\nC:\\...\\PP4E\\Internet\\Ftp> python getfilegui.py\nServer Name     =>       ftp.rmi.net\nUser Name?      =>       lutz\nLocal Dir       =>       C:\\temp\nFile Name       =>       spain08.JPG\nPassword?       =>       xxxxxxxx\nRemote Dir      =>       .\nServer Name     =>       ftp.rmi.net\nUser Name?      =>       lutz\nLocal Dir       =>       C:\\temp\nFile Name       =>       index.html\nPassword?       =>       xxxxxxxx\nRemote Dir      =>       .\nDownload of \"index.html\" successful\nDownload of \"spain08.JPG\" successful\nThis example isn\u2019t much more useful than a command line-based tool, of course, but\nit can be easily modified by changing its Python code, and it provides enough of a GUI\nto qualify as a simple, first-cut FTP user interface. Moreover, because this GUI runs\ndownloads in Python threads, more than one can be run at the same time from this\nGUI without having to start or restart a different FTP client tool.\nWhile we\u2019re in a GUI mood, let\u2019s add a simple interface to the putfile utility, too. The\nscript in Example 13-8 creates a dialog that starts uploads in threads, using core FTP\nlogic imported from Example 13-5. It\u2019s almost the same as the getfile GUI we just\nwrote, so there\u2019s not much new to say. In fact, because get and put operations are so\nsimilar from an interface perspective, most of the get form\u2019s logic was deliberately\nfactored out into a single generic class (FtpForm), so changes need be made in only a\nsingle place. That is, the put GUI here is mostly just a reuse of the get GUI, with distinct\noutput labels and transfer methods. It\u2019s in a file by itself, though, to make it easy to\nlaunch as a standalone program.\nExample 13-8. PP4E\\Internet\\Ftp\\putfilegui.py\n\"\"\"\n###############################################################\nlaunch FTP putfile function with a reusable form GUI class;\nsee getfilegui for notes: most of the same caveats apply;\nthe get and put forms have been factored into a single\nclass such that changes need be made in only one place;\n###############################################################\n\"\"\"\nTransferring Files with ftplib | 871from tkinter import mainloop\nimport putfile, getfilegui\nclass FtpPutfileForm(getfilegui.FtpForm):\n    title = 'FtpPutfileGui'\n    mode  = 'Upload'\n    def do_transfer(self, filename, servername, remotedir, userinfo):\n        putfile.putfile(filename, servername, remotedir, userinfo, verbose=False)\nif __name__ == '__main__':\n    FtpPutfileForm()\n    mainloop()\nRunning this script looks much like running the download GUI, because it\u2019s almost\nentirely the same code at work. Let\u2019s upload some files from the client machine to the\nserver; Figure 13-4 shows the state of the GUI while starting one.\nFigure 13-4. FTP putfile input form\nAnd here is the console window output we get when uploading two files in serial fash-\nion; here again, uploads run in parallel threads, so if we start a new upload before one\nin progress is finished, they overlap in time:\nC:\\...\\PP4E\\Internet\\Ftp\\test> ..\\putfilegui.py\nServer Name     =>       ftp.rmi.net\nUser Name?      =>       lutz\nLocal Dir       =>       .\nFile Name       =>       sousa.au\nPassword?       =>       xxxxxxxx\nRemote Dir      =>       .\nUpload of \"sousa.au\" successful\nServer Name     =>       ftp.rmi.net\nUser Name?      =>       lutz\nLocal Dir       =>       .\nFile Name       =>       about-pp.html\n872 | Chapter 13:\u2002Client-Side ScriptingPassword?       =>       xxxxxxxx\nRemote Dir      =>       .\nUpload of \"about-pp.html\" successful\nFinally, we can bundle up both GUIs in a single launcher script that knows how to start\nthe get and put interfaces, regardless of which directory we are in when the script is\nstarted, and independent of the platform on which it runs. Example 13-9 shows this\nprocess.\nExample 13-9. PP4E\\Internet\\Ftp\\PyFtpGui.pyw\n\"\"\"\nspawn FTP get and put GUIs no matter what directory I'm run from; os.getcwd is not\nnecessarily the place this script lives;  could also hardcode path from $PP4EHOME,\nor guessLocation;  could also do:  [from PP4E.launchmodes import PortableLauncher,\nPortableLauncher('getfilegui', '%s/getfilegui.py' % mydir)()], but need the DOS\nconsole pop up on Windows to view status messages which describe transfers made;\n\"\"\"\nimport os, sys\nprint('Running in: ', os.getcwd())\n# PP3E\n# from PP4E.Launcher import findFirst\n# mydir = os.path.split(findFirst(os.curdir, 'PyFtpGui.pyw'))[0]\n# PP4E\nfrom PP4E.Tools.find import findlist\nmydir = os.path.dirname(findlist('PyFtpGui.pyw', startdir=os.curdir)[0])\nif sys.platform[:3] == 'win':\n    os.system('start %s\\getfilegui.py' % mydir)\n    os.system('start %s\\putfilegui.py' % mydir)\nelse:\n    os.system('python %s/getfilegui.py &' % mydir)\n    os.system('python %s/putfilegui.py &' % mydir)\nNotice that we\u2019re reusing the find utility from Chapter 6\u2019s Example 6-13 again here\u2014\nthis time to locate the home directory of the script in order to build command lines.\nWhen run by launchers in the examples root directory or command lines elsewhere in\ngeneral, the current working directory may not always be this script\u2019s container. In the\nprior edition, this script used a tool in the Launcher module instead to search for its\nown directory (see the examples distribution for that equivalent).\nWhen this script is started, both the get and put GUIs appear as distinct, independently\nrun programs; alternatively, we might attach both forms to a single interface. We could\nget much fancier than these two interfaces, of course. For instance, we could pop up\nlocal file selection dialogs, and we could display widgets that give the status of down-\nloads and uploads in progress. We could even list files available at the remote site in a\nselectable listbox by requesting remote directory listings over the FTP connection. To\nlearn how to add features like that, though, we need to move on to the next section.\nTransferring Files with ftplib | 873Transferring Directories with ftplib\nOnce upon a time, I used Telnet to manage my website at my Internet Service Provider\n(ISP). I logged in to the web server in a shell window, and performed all my edits directly\non the remote machine. There was only one copy of a site\u2019s files\u2014on the machine that\nhosted it. Moreover, content updates could be performed from any machine that ran\na Telnet client\u2014ideal for people with travel-based careers.\u2020\nOf course, times have changed. Like most personal websites, today mine are maintained\non my laptop and I transfer their files to and from my ISP as needed. Often, this is a\nsimple matter of one or two files, and it can be accomplished with a command-line FTP\nclient. Sometimes, though, I need an easy way to transfer the entire site. Maybe I need\nto download to detect files that have become out of sync. Occasionally, the changes\nare so involved that it\u2019s easier to upload the entire site in a single step.\nAlthough there are a variety of ways to approach this task (including options in site-\nbuilder tools), Python can help here, too: writing Python scripts to automate the upload\nand download tasks associated with maintaining my website on my laptop provides a\nportable and mobile solution. Because Python FTP scripts will work on any machine\nwith sockets, they can be run on my laptop and on nearly any other computer where\nPython is installed. Furthermore, the same scripts used to transfer page files to and\nfrom my PC can be used to copy my site to another web server as a backup copy, should\nmy ISP experience an outage. The effect is sometimes called a mirror\u2014a copy of a\nremote site.\nDownloading Site Directories\nThe following two scripts address these needs. The first, downloadflat.py, automatically\ndownloads (i.e., copies) by FTP all the files in a directory at a remote site to a directory\non the local machine. I keep the main copy of my website files on my PC these days,\nbut I use this script in two ways:\n\u2022 To download my website to client machines where I want to make edits, I fetch\nthe contents of my web directory of my account on my ISP\u2019s machine.\n\u2022 To mirror my site to my account on another server, I run this script periodically\non the target machine if it supports Telnet or SSH secure shell; if it does not, I\nsimply download to one machine and upload from there to the target server.\n\u2020 No, really. The second edition of this book included a tale of woe here about how my ISP forced its users to\nwean themselves off Telnet access. This seems like a small issue today. Common practice on the Internet has\ncome far in a short time. One of my sites has even grown too complex for manual edits (except, of course,\nto work around bugs in the site-builder tool). Come to think of it, so has Python\u2019s presence on the Web.\nWhen I first found Python in 1992, it was a set of encoded email messages, which users decoded and\nconcatenated and hoped the result worked. Yes, yes, I know\u2014gee, Grandpa, tell us more\u2026\n874 | Chapter 13:\u2002Client-Side ScriptingMore generally, this script (shown in Example 13-10) will download a directory full of\nfiles to any machine with Python and sockets, from any machine running an FTP server.\nExample 13-10. PP4E\\Internet\\Ftp\\Mirror\\downloadflat.py\n#!/bin/env python\n\"\"\"\n###############################################################################\nuse FTP to copy (download) all files from a single directory at a remote\nsite to a directory on the local machine; run me periodically to mirror\na flat FTP site directory to your ISP account;  set user to 'anonymous'\nto do anonymous FTP;  we could use try to skip file failures, but the FTP\nconnection is likely closed if any files fail;  we could also try to\nreconnect with a new FTP instance before each transfer: connects once now;\nif failures, try setting nonpassive for active FTP, or disable firewalls;\nthis also depends on a working FTP server, and possibly its load policies.\n###############################################################################\n\"\"\"\nimport os, sys, ftplib\nfrom getpass   import getpass\nfrom mimetypes import guess_type\nnonpassive = False                        # passive FTP on by default in 2.1+\nremotesite = 'home.rmi.net'               # download from this site\nremotedir  = '.'                          # and this dir (e.g., public_html)\nremoteuser = 'lutz'\nremotepass = getpass('Password for %s on %s: ' % (remoteuser, remotesite))\nlocaldir   = (len(sys.argv) > 1 and sys.argv[1]) or '.'\ncleanall   = input('Clean local directory first? ')[:1] in ['y', 'Y']\nprint('connecting...')\nconnection = ftplib.FTP(remotesite)                 # connect to FTP site\nconnection.login(remoteuser, remotepass)            # login as user/password\nconnection.cwd(remotedir)                           # cd to directory to copy\nif nonpassive:                                      # force active mode FTP\n    connection.set_pasv(False)                      # most servers do passive\nif cleanall:\n    for localname in os.listdir(localdir):          # try to delete all locals\n        try:                                        # first, to remove old files\n            print('deleting local', localname)      # os.listdir omits . and ..\n            os.remove(os.path.join(localdir, localname))\n        except:\n            print('cannot delete local', localname)\ncount = 0                                           # download all remote files\nremotefiles = connection.nlst()                     # nlst() gives files list\n                                                    # dir()  gives full details\nfor remotename in remotefiles:\n    if remotename in ('.', '..'): continue          # some servers include . and ..\n    mimetype, encoding = guess_type(remotename)     # e.g., ('text/plain', 'gzip')\n    mimetype  = mimetype or '?/?'                   # may be (None, None)\n    maintype  = mimetype.split('/')[0]              # .jpg ('image/jpeg', None')\nTransferring Directories with ftplib | 875localpath = os.path.join(localdir, remotename)\n    print('downloading', remotename, 'to', localpath, end=' ')\n    print('as', maintype, encoding or '')\n    if maintype == 'text' and encoding == None:\n        # use ascii mode xfer and text file\n        # use encoding compatible wth ftplib's\n        localfile = open(localpath, 'w', encoding=connection.encoding)\n        callback  = lambda line: localfile.write(line + '\\n')\n        connection.retrlines('RETR ' + remotename, callback)\n    else:\n        # use binary mode xfer and bytes file\n        localfile = open(localpath, 'wb')\n        connection.retrbinary('RETR ' + remotename, localfile.write)\n    localfile.close()\n    count += 1\nconnection.quit()\nprint('Done:', count, 'files downloaded.')\nThere\u2019s not much that is new to speak of in this script, compared to other FTP examples\nwe\u2019ve seen thus far. We open a connection with the remote FTP server, log in with a\nusername and password for the desired account (this script never uses anonymous\nFTP), and go to the desired remote directory. New here, though, are loops to iterate\nover all the files in local and remote directories, text-based retrievals, and file deletions:\nDeleting all local files\nThis script has a cleanall option, enabled by an interactive prompt. If selected,\nthe script first deletes all the files in the local directory before downloading, to make\nsure there are no extra files that aren\u2019t also on the server (there may be junk here\nfrom a prior download). To delete local files, the script calls os.listdir to get a list\nof filenames in the directory, and os.remove to delete each; see Chapter 4 (or the\nPython library manual) for more details if you\u2019ve forgotten what these calls do.\nNotice the use of os.path.join to concatenate a directory path and filename ac-\ncording to the host platform\u2019s conventions; os.listdir returns filenames without\ntheir directory paths, and this script is not necessarily run in the local directory\nwhere downloads will be placed. The local directory defaults to the current direc-\ntory (\u201c.\u201d), but can be set differently with a command-line argument to the script.\nFetching all remote files\nTo grab all the files in a remote directory, we first need a list of their names. The\nFTP object\u2019s nlst method is the remote equivalent of os.listdir: nlst returns a\nlist of the string names of all files in the current remote directory. Once we have\nthis list, we simply step through it in a loop, running FTP retrieval commands for\neach filename in turn (more on this in a minute).\nThe nlst method is, more or less, like requesting a directory listing with an ls\ncommand in typical interactive FTP programs, but Python automatically splits up\n876 | Chapter 13:\u2002Client-Side Scriptingthe listing\u2019s text into a list of filenames. We can pass it a remote directory to be\nlisted; by default it lists the current server directory. A related FTP method, dir,\nreturns the list of line strings produced by an FTP LIST command; its result is like\ntyping a dir command in an FTP session, and its lines contain complete file infor-\nmation, unlike nlst. If you need to know more about all the remote files, parse the\nresult of a dir method call (we\u2019ll see how in a later example).\nNotice how we skip \u201c.\u201d and \u201c..\u201d current and parent directory indicators if present\nin remote directory listings; unlike os.listdir, some (but not all) servers include\nthese, so we need to either skip these or catch the exceptions they may trigger (more\non this later when we start using dir, too).\nSelecting transfer modes with mimetypes\nWe discussed output file modes for FTP earlier, but now that we\u2019ve started trans-\nferring text, too, I can fill in the rest of this story. To handle Unicode encodings\nand to keep line-ends in sync with the machines that my web files live on, this script\ndistinguishes between binary and text file transfers. It uses the Python mimetypes\nmodule to choose between text and binary transfer modes for each file.\nWe met mimetypes in Chapter 6 near Example 6-23, where we used it to play media\nfiles (see the examples and description there for an introduction). Here, mime\ntypes is used to decide whether a file is text or binary by guessing from its filename\nextension. For instance, HTML web pages and simple text files are transferred as\ntext with automatic line-end mappings, and images and tar archives are transferred\nin raw binary mode.\nDownloading: text versus binary\nFor binary files data is pulled down with the retrbinary method we met earlier,\nand stored in a local file with binary open mode of wb. This file open mode is\nrequired to allow for the bytes strings passed to the write method by retrbinary,\nbut it also suppresses line-end byte mapping and Unicode encodings in the process.\nAgain, text mode requires encodable text in Python 3.X, and this fails for binary\ndata like images. This script may also be run on Windows or Unix-like platforms,\nand we don\u2019t want a \\n byte embedded in an image to get expanded to \\r\\n on\nWindows. We don\u2019t use a chunk-size third argument for binary transfers here,\nthough\u2014it defaults to a reasonable size if omitted.\nFor text files, the script instead uses the retrlines method, passing in a function\nto be called for each line in the text file downloaded. The text line handler function\nreceives lines in str string form, and mostly just writes the line to a local text file.\nBut notice that the handler function created by the lambda here also adds a \\n line-\nend character to the end of the line it is passed. Python\u2019s retrlines method strips\nall line-feed characters from lines to sidestep platform differences. By adding a\n\\n, the script ensures the proper line-end marker character sequence for the local\nplatform on which this script runs when written to the file (\\n or \\r\\n).\nFor this auto-mapping of the \\n in the script to work, of course, we must also open\ntext output files in w text mode, not in wb\u2014the mapping from \\n to \\r\\n on\nTransferring Directories with ftplib | 877Windows happens when data is written to the file. As discussed earlier, text mode\nalso means that the file\u2019s write method will allow for the str string passed in by\nretrlines, and that text will be encoded per Unicode when written.\nSubtly, though, we also explicitly use the FTP connection object\u2019s Unicode encod-\ning scheme for our text output file in open, instead of the default. Without this\nencoding option, the script aborted with a UnicodeEncodeError exception for some\nfiles in my site. In retrlines, the FTP object itself reads the remote file data over a\nsocket with a text-mode file wrapper and an explicit encoding scheme for decoding;\nsince the FTP object can do no better than this encoding anyhow, we use its en-\ncoding for our output file as well.\nBy default, FTP objects use the latin1 scheme for decoding text fetched (as well\nas for encoding text sent), but this can be specialized by assigning to their\nencoding attribute. Our script\u2019s local text output file will inherit whatever encoding\nftplib uses and so be compatible with the encoded text data that it produces and\npasses.\nWe could try to also catch Unicode exceptions for files outside the Unicode en-\ncoding used by the FTP object, but exceptions leave the FTP object in an unre-\ncoverable state in tests I\u2019ve run in Python 3.1. Alternatively, we could use wb binary\nmode for the local text output file and manually encode line strings with\nline.encode, or simply use retrbinary and binary mode files in all cases, but both\nof these would fail to map end-lines portably\u2014the whole point of making text\ndistinct in this context.\nAll of this is simpler in action than in words. Here is the command I use to download\nmy entire book support website from my ISP server account to my Windows laptop\nPC, in a single step:\nC:\\...\\PP4E\\Internet\\Ftp\\Mirror> downloadflat.py test\nPassword for lutz on home.rmi.net:\nClean local directory first? y\nconnecting...\ndeleting local 2004-longmont-classes.html\ndeleting local 2005-longmont-classes.html\ndeleting local 2006-longmont-classes.html\ndeleting local about-hopl.html\ndeleting local about-lp.html\ndeleting local about-lp2e.html\ndeleting local about-pp-japan.html\n...lines omitted...\ndownloading 2004-longmont-classes.html to test\\2004-longmont-classes.html as text\ndownloading 2005-longmont-classes.html to test\\2005-longmont-classes.html as text\ndownloading 2006-longmont-classes.html to test\\2006-longmont-classes.html as text\ndownloading about-hopl.html to test\\about-hopl.html as text\ndownloading about-lp.html to test\\about-lp.html as text\ndownloading about-lp2e.html to test\\about-lp2e.html as text\ndownloading about-pp-japan.html to test\\about-pp-japan.html as text\n878 | Chapter 13:\u2002Client-Side Scripting...lines omitted...\ndownloading ora-pyref4e.gif to test\\ora-pyref4e.gif as image\ndownloading ora-lp4e-big.jpg to test\\ora-lp4e-big.jpg as image\ndownloading ora-lp4e.gif to test\\ora-lp4e.gif as image\ndownloading pyref4e-updates.html to test\\pyref4e-updates.html as text\ndownloading lp4e-updates.html to test\\lp4e-updates.html as text\ndownloading lp4e-examples.html to test\\lp4e-examples.html as text\ndownloading LP4E-examples.zip to test\\LP4E-examples.zip as application\nDone: 297 files downloaded.\nThis may take a few moments to complete, depending on your site\u2019s size and your\nconnection speed (it\u2019s bound by network speed constraints, and it usually takes roughly\ntwo to three minutes for my site on my current laptop and wireless broadband con-\nnection). It is much more accurate and easier than downloading files by hand, though.\nThe script simply iterates over all the remote files returned by the nlst method, and\ndownloads each with the FTP protocol (i.e., over sockets) in turn. It uses text transfer\nmode for names that imply text data, and binary mode for others.\nWith the script running this way, I make sure the initial assignments in it reflect the\nmachines involved, and then run the script from the local directory where I want\nthe site copy to be stored. Because the target download directory is often not where the\nscript lives, I may need to give Python the full path to the script file. When run on a\nserver in a Telnet or SSH session window, for instance, the execution and script direc-\ntory paths are different, but the script works the same way.\nIf you elect to delete local files in the download directory, you may also see a batch of\n\u201cdeleting local\u2026\u201d messages scroll by on the screen before any \u201cdownloading\u2026\u201d lines\nappear: this automatically cleans out any garbage lingering from a prior download. And\nif you botch the input of the remote site password, a Python exception is raised; I\nsometimes need to run it again (and type more slowly):\nC:\\...\\PP4E\\Internet\\Ftp\\Mirror> downloadflat.py test\nPassword for lutz on home.rmi.net:\nClean local directory first?\nconnecting...\nTraceback (most recent call last):\n  File \"C:\\...\\PP4E\\Internet\\Ftp\\Mirror\\downloadflat.py\", line 29, in <module>\n    connection.login(remoteuser, remotepass)            # login as user/password\n  File \"C:\\Python31\\lib\\ftplib.py\", line 375, in login\n    if resp[0] == '3': resp = self.sendcmd('PASS ' + passwd)\n  File \"C:\\Python31\\lib\\ftplib.py\", line 245, in sendcmd\n    return self.getresp()\n  File \"C:\\Python31\\lib\\ftplib.py\", line 220, in getresp\n    raise error_perm(resp)\nftplib.error_perm: 530 Login incorrect.\nIt\u2019s worth noting that this script is at least partially configured by assignments near the\ntop of the file. In addition, the password and deletion options are given by interactive\ninputs, and one command-line argument is allowed\u2014the local directory name to store\nTransferring Directories with ftplib | 879the downloaded files (it defaults to \u201c.\u201d, the directory where the script is run).\nCommand-line arguments could be employed to universally configure all the other\ndownload parameters and options, too, but because of Python\u2019s simplicity and lack of\ncompile/link steps, changing settings in the text of Python scripts is usually just as easy\nas typing words on a command line.\nTo check for version skew after a batch of downloads and uploads, you\ncan run the diffall script we wrote in Chapter 6, Example 6-12. For\ninstance, I find files that have diverged over time due to updates on\nmultiple platforms by comparing the download to a local copy of my\nwebsite using a shell command line such as C:\\...\\PP4E\\Internet\n\\Ftp> ..\\..\\System\\Filetools\\diffall.py Mirror\\test C:\\...\\Web\nsites\\public_html. See Chapter 6 for more details on this tool, and file\ndiffall.out.txt in the diffs subdirectory of the examples distribution for a\nsample run; its text file differences stem from either final line newline\ncharacters or newline differences reflecting binary transfers that Win-\ndows fc commands and FTP servers do not notice.\nUploading Site Directories\nUploading a full directory is symmetric to downloading: it\u2019s mostly a matter of swap-\nping the local and remote machines and operations in the program we just met. The\nscript in Example 13-11 uses FTP to copy all files in a directory on the local machine\non which it runs up to a directory on a remote machine.\nI really use this script, too, most often to upload all of the files maintained on my laptop\nPC to my ISP account in one fell swoop. I also sometimes use it to copy my site from\nmy PC to a mirror machine or from the mirror machine back to my ISP. Because this\nscript runs on any computer with Python and sockets, it happily transfers a directory\nfrom any machine on the Net to any machine running an FTP server. Simply change\nthe initial setting in this module as appropriate for the transfer you have in mind.\nExample 13-11. PP4E\\Internet\\Ftp\\Mirror\\uploadflat.py\n#!/bin/env python\n\"\"\"\n##############################################################################\nuse FTP to upload all files from one local dir to a remote site/directory;\ne.g., run me to copy a web/FTP site's files from your PC to your ISP;\nassumes a flat directory upload: uploadall.py does nested directories.\nsee downloadflat.py comments for more notes: this script is symmetric.\n##############################################################################\n\"\"\"\nimport os, sys, ftplib\nfrom getpass import getpass\nfrom mimetypes import guess_type\n880 | Chapter 13:\u2002Client-Side Scriptingnonpassive = False                                  # passive FTP by default\nremotesite = 'learning-python.com'                  # upload to this site\nremotedir  = 'books'                                # from machine running on\nremoteuser = 'lutz'\nremotepass = getpass('Password for %s on %s: ' % (remoteuser, remotesite))\nlocaldir   = (len(sys.argv) > 1 and sys.argv[1]) or '.'\ncleanall   = input('Clean remote directory first? ')[:1] in ['y', 'Y']\nprint('connecting...')\nconnection = ftplib.FTP(remotesite)                 # connect to FTP site\nconnection.login(remoteuser, remotepass)            # log in as user/password\nconnection.cwd(remotedir)                           # cd to directory to copy\nif nonpassive:                                      # force active mode FTP\n    connection.set_pasv(False)                      # most servers do passive\nif cleanall:\n    for remotename in connection.nlst():            # try to delete all remotes\n        try:                                        # first, to remove old files\n            print('deleting remote', remotename)\n            connection.delete(remotename)           # skips . and .. if attempted\n        except:\n            print('cannot delete remote', remotename)\ncount = 0                                           # upload all local files\nlocalfiles = os.listdir(localdir)                   # listdir() strips dir path\n                                                    # any failure ends script\nfor localname in localfiles:\n    mimetype, encoding = guess_type(localname)      # e.g., ('text/plain', 'gzip')\n    mimetype  = mimetype or '?/?'                   # may be (None, None)\n    maintype  = mimetype.split('/')[0]              # .jpg ('image/jpeg', None')\n    localpath = os.path.join(localdir, localname)\n    print('uploading', localpath, 'to', localname, end=' ')\n    print('as', maintype, encoding or '')\n    if maintype == 'text' and encoding == None:\n        # use ascii mode xfer and bytes file\n        # need rb mode for ftplib's crlf logic\n        localfile = open(localpath, 'rb')\n        connection.storlines('STOR ' + localname, localfile)\n    else:\n        # use binary mode xfer and bytes file\n        localfile = open(localpath, 'rb')\n        connection.storbinary('STOR ' + localname, localfile)\n    localfile.close()\n    count += 1\nconnection.quit()\nprint('Done:', count, 'files uploaded.')\nTransferring Directories with ftplib | 881Similar to the mirror download script, this program illustrates a handful of new FTP\ninterfaces and a set of FTP scripting techniques:\nDeleting all remote files\nJust like the mirror script, the upload begins by asking whether we want to delete\nall the files in the remote target directory before copying any files there. This\ncleanall option is useful if we\u2019ve deleted files in the local copy of the directory in\nthe client\u2014the deleted files would remain on the server-side copy unless we delete\nall files there first.\nTo implement the remote cleanup, this script simply gets a listing of all the files in\nthe remote directory with the FTP nlst method, and deletes each in turn with\nthe FTP delete method. Assuming we have delete permission, the directory will\nbe emptied (file permissions depend on the account we logged into when con-\nnecting to the server). We\u2019ve already moved to the target remote directory when\ndeletions occur, so no directory paths need to be prepended to filenames here. Note\nthat nlst may raise an exception for some servers if the remote directory is empty;\nwe don\u2019t catch the exception here, but you can simply not select a cleaning if one\nfails for you. We do catch deletion exceptions, because directory names like \u201c.\u201d\nand \u201c..\u201d may be returned in the listing by some servers.\nStoring all local files\nTo apply the upload operation to each file in the local directory, we get a list of\nlocal filenames with the standard os.listdir call, and take care to prepend the\nlocal source directory path to each filename with the os.path.join call. Recall that\nos.listdir returns filenames without directory paths, and the source directory may\nnot be the same as the script\u2019s execution directory if passed on the command line.\nUploading: Text versus binary\nThis script may also be run on both Windows and Unix-like clients, so we need to\nhandle text files specially. Like the mirror download, this script picks text or binary\ntransfer modes by using Python\u2019s mimetypes module to guess a file\u2019s type from its\nfilename extension; HTML and text files are moved in FTP text mode, for instance.\nWe already met the storbinary FTP object method used to upload files in binary\nmode\u2014an exact, byte-for-byte copy appears at the remote site.\nText-mode transfers work almost identically: the storlines method accepts an FTP\ncommand string and a local file (or file-like) object, and simply copies each line\nread from the local file to a same-named file on the remote machine.\nNotice, though, that the local text input file must be opened in rb binary mode in\nPython3.X. Text input files are normally opened in r text mode to perform Unicode\ndecoding and to convert any \\r\\n end-of-line sequences on Windows to the \\n\nplatform-neutral character as lines are read. However, ftplib in Python 3.1 requires\nthat the text file be opened in rb binary mode, because it converts all end-lines to\nthe \\r\\n sequence for transmission; to do so, it must read lines as raw bytes with\nreadlines and perform bytes string processing, which implies binary mode files.\n882 | Chapter 13:\u2002Client-Side ScriptingThis ftplib string processing worked with text-mode files in Python 2.X, but only\nbecause there was no separate bytes type; \\n was expanded to \\r\\n. Opening the\nlocal file in binary mode for ftplib to read also means no Unicode decoding will\noccur: the text is sent over sockets as a byte string in already encoded form. All of\nwhich is, of course, a prime lesson on the impacts of Unicode encodings; consult\nthe module ftplib.py in the Python source library directory for more details.\nFor binary mode transfers, things are simpler\u2014we open the local file in rb binary\nmode to suppress Unicode decoding and automatic mapping everywhere, and re-\nturn the bytes strings expected by ftplib on read. Binary data is not Unicode text,\nand we don\u2019t want bytes in an audio file that happen to have the same value as\n\\r to magically disappear when read on Windows.\nAs for the mirror download script, this program simply iterates over all files to be\ntransferred (files in the local directory listing this time), and transfers each in turn\u2014in\neither text or binary mode, depending on the files\u2019 names. Here is the command I use\nto upload my entire website from my laptop Windows PC to a remote Linux server at\nmy ISP, in a single step:\nC:\\...\\PP4E\\Internet\\Ftp\\Mirror> uploadflat.py test\nPassword for lutz on learning-python.com:\nClean remote directory first? y\nconnecting...\ndeleting remote .\ncannot delete remote .\ndeleting remote ..\ncannot delete remote ..\ndeleting remote 2004-longmont-classes.html\ndeleting remote 2005-longmont-classes.html\ndeleting remote 2006-longmont-classes.html\ndeleting remote about-lp1e.html\ndeleting remote about-lp2e.html\ndeleting remote about-lp3e.html\ndeleting remote about-lp4e.html\n...lines omitted...\nuploading test\\2004-longmont-classes.html to 2004-longmont-classes.html as text\nuploading test\\2005-longmont-classes.html to 2005-longmont-classes.html as text\nuploading test\\2006-longmont-classes.html to 2006-longmont-classes.html as text\nuploading test\\about-lp1e.html to about-lp1e.html as text\nuploading test\\about-lp2e.html to about-lp2e.html as text\nuploading test\\about-lp3e.html to about-lp3e.html as text\nuploading test\\about-lp4e.html to about-lp4e.html as text\nuploading test\\about-pp-japan.html to about-pp-japan.html as text\n...lines omitted...\nuploading test\\whatsnew.html to whatsnew.html as text\nuploading test\\whatsold.html to whatsold.html as text\nuploading test\\wxPython.doc.tgz to wxPython.doc.tgz as application gzip\nuploading test\\xlate-lp.html to xlate-lp.html as text\nTransferring Directories with ftplib | 883uploading test\\zaurus0.jpg to zaurus0.jpg as image\nuploading test\\zaurus1.jpg to zaurus1.jpg as image\nuploading test\\zaurus2.jpg to zaurus2.jpg as image\nuploading test\\zoo-jan-03.jpg to zoo-jan-03.jpg as image\nuploading test\\zopeoutline.htm to zopeoutline.htm as text\nDone: 297 files uploaded.\nFor my site and on my current laptop and wireless broadband connection, this process\ntypically takes six minutes, depending on server load. As with the download script, I\noften run this command from the local directory where my web files are kept, and I\npass Python the full path to the script. When I run this on a Linux server, it works in\nthe same way, but the paths to the script and my web files directory differ.\u2021\nRefactoring Uploads and Downloads for Reuse\nThe directory upload and download scripts of the prior two sections work as advertised\nand, apart from the mimetypes logic, were the only FTP examples that were included in\nthe second edition of this book. If you look at these two scripts long enough, though,\ntheir similarities will pop out at you eventually. In fact, they are largely the same\u2014they\nuse identical code to configure transfer parameters, connect to the FTP server, and\ndetermine file type. The exact details have been lost to time, but some of this code was\ncertainly copied from one file to the other.\nAlthough such redundancy isn\u2019t a cause for alarm if we never plan on changing these\nscripts, it can be a killer in software projects in general. When you have two copies of\nidentical bits of code, not only is there a danger of them becoming out of sync over time\n(you\u2019ll lose uniformity in user interface and behavior), but you also effectively double\nyour effort when it comes time to change code that appears in both places. Unless you\u2019re\na big fan of extra work, it pays to avoid redundancy wherever possible.\nThis redundancy is especially glaring when we look at the complex code that uses\nmimetypes to determine file types. Repeating magic like this in more than one place is\nalmost always a bad idea\u2014not only do we have to remember how it works every time\nwe need the same utility, but it is a recipe for errors.\nRefactoring with functions\nAs originally coded, our download and upload scripts comprise top-level script code\nthat relies on global variables. Such a structure is difficult to reuse\u2014code runs imme-\ndiately on imports, and it\u2019s difficult to generalize for varying contexts. Worse, it\u2019s dif-\nficult to maintain\u2014when you program by cut-and-paste of existing code, you increase\nthe cost of future changes every time you click the Paste button.\n\u2021 Usage note: These scripts are highly dependent on the FTP server functioning properly. For a while, the\nupload script occasionally had timeout errors when running over my current broadband connection. These\nerrors went away later, when my ISP fixed or reconfigured their server. If you have failures, try running against\na different server; connecting and disconnecting around each transfer may or may not help (some servers\nlimit their number of connections).\n884 | Chapter 13:\u2002Client-Side ScriptingTo demonstrate how we might do better, Example 13-12 shows one way to refactor\n(reorganize) the download script. By wrapping its parts in functions, they become re-\nusable in other modules, including our upload program.\nExample 13-12. PP4E\\Internet\\Ftp\\Mirror\\downloadflat_modular.py\n#!/bin/env python\n\"\"\"\n##############################################################################\nuse FTP to copy (download) all files from a remote site and directory\nto a directory on the local machine; this version works the same, but has\nbeen refactored to wrap up its code in functions that can be reused by the\nuploader, and possibly other programs in the future - else code redundancy,\nwhich may make the two diverge over time, and can double maintenance costs.\n##############################################################################\n\"\"\"\nimport os, sys, ftplib\nfrom getpass   import getpass\nfrom mimetypes import guess_type, add_type\ndefaultSite = 'home.rmi.net'\ndefaultRdir = '.'\ndefaultUser = 'lutz'\ndef configTransfer(site=defaultSite, rdir=defaultRdir, user=defaultUser):\n    \"\"\"\n    get upload or download parameters\n    uses a class due to the large number\n    \"\"\"\n    class cf: pass\n    cf.nonpassive = False                 # passive FTP on by default in 2.1+\n    cf.remotesite = site                  # transfer to/from this site\n    cf.remotedir  = rdir                  # and this dir ('.' means acct root)\n    cf.remoteuser = user\n    cf.localdir   = (len(sys.argv) > 1 and sys.argv[1]) or '.'\n    cf.cleanall   = input('Clean target directory first? ')[:1] in ['y','Y']\n    cf.remotepass = getpass(\n                    'Password for %s on %s:' % (cf.remoteuser, cf.remotesite))\n    return cf\ndef isTextKind(remotename, trace=True):\n    \"\"\"\n    use mimetype to guess if filename means text or binary\n    for 'f.html,   guess is ('text/html', None): text\n    for 'f.jpeg'   guess is ('image/jpeg', None): binary\n    for 'f.txt.gz' guess is ('text/plain', 'gzip'): binary\n    for unknowns,  guess may be (None, None): binary\n    mimetype can also guess name from type: see PyMailGUI\n    \"\"\"\n    add_type('text/x-python-win', '.pyw')                       # not in tables\n    mimetype, encoding = guess_type(remotename, strict=False)   # allow extras\n    mimetype  = mimetype or '?/?'                               # type unknown?\n    maintype  = mimetype.split('/')[0]                          # get first part\n    if trace: print(maintype, encoding or '')\nTransferring Directories with ftplib | 885return maintype == 'text' and encoding == None              # not compressed\ndef connectFtp(cf):\n    print('connecting...')\n    connection = ftplib.FTP(cf.remotesite)           # connect to FTP site\n    connection.login(cf.remoteuser, cf.remotepass)   # log in as user/password\n    connection.cwd(cf.remotedir)                     # cd to directory to xfer\n    if cf.nonpassive:                                # force active mode FTP\n        connection.set_pasv(False)                   # most servers do passive\n    return connection\ndef cleanLocals(cf):\n    \"\"\"\n    try to delete all locals files first to remove garbage\n    \"\"\"\n    if cf.cleanall:\n        for localname in os.listdir(cf.localdir):    # local dirlisting\n            try:                                     # local file delete\n                print('deleting local', localname)\n                os.remove(os.path.join(cf.localdir, localname))\n            except:\n                print('cannot delete local', localname)\ndef downloadAll(cf, connection):\n    \"\"\"\n    download all files from remote site/dir per cf config\n    ftp nlst() gives files list, dir() gives full details\n    \"\"\"\n    remotefiles = connection.nlst()                  # nlst is remote listing\n    for remotename in remotefiles:\n        if remotename in ('.', '..'): continue\n        localpath = os.path.join(cf.localdir, remotename)\n        print('downloading', remotename, 'to', localpath, 'as', end=' ')\n        if isTextKind(remotename):\n            # use text mode xfer\n            localfile = open(localpath, 'w', encoding=connection.encoding)\n            def callback(line): localfile.write(line + '\\n')\n            connection.retrlines('RETR ' + remotename, callback)\n        else:\n            # use binary mode xfer\n            localfile = open(localpath, 'wb')\n            connection.retrbinary('RETR ' + remotename, localfile.write)\n        localfile.close()\n    connection.quit()\n    print('Done:', len(remotefiles), 'files downloaded.')\nif __name__ == '__main__':\n    cf = configTransfer()\n    conn = connectFtp(cf)\n    cleanLocals(cf)          # don't delete if can't connect\n    downloadAll(cf, conn)\nCompare this version with the original. This script, and every other in this section, runs\nthe same as the original flat download and upload programs. Although we haven\u2019t\n886 | Chapter 13:\u2002Client-Side Scriptingchanged its behavior, though, we\u2019ve modified the script\u2019s software structure radically\u2014\nits code is now a set of tools that can be imported and reused in other programs.\nThe refactored upload program in Example 13-13, for instance, is now noticeably sim-\npler, and the code it shares with the download script only needs to be changed in one\nplace if it ever requires improvement.\nExample 13-13. PP4E\\Internet\\Ftp\\Mirror\\uploadflat_modular.py\n#!/bin/env python\n\"\"\"\n##############################################################################\nuse FTP to upload all files from a local dir to a remote site/directory;\nthis version reuses downloader's functions, to avoid code redundancy;\n##############################################################################\n\"\"\"\nimport os\nfrom downloadflat_modular import configTransfer, connectFtp, isTextKind\ndef cleanRemotes(cf, connection):\n    \"\"\"\n    try to delete all remote files first to remove garbage\n    \"\"\"\n    if cf.cleanall:\n        for remotename in connection.nlst():            # remote dir listing\n            try:                                        # remote file delete\n                print('deleting remote', remotename)    # skips . and .. exc\n                connection.delete(remotename)\n            except:\n                print('cannot delete remote', remotename)\ndef uploadAll(cf, connection):\n    \"\"\"\n    upload all files to remote site/dir per cf config\n    listdir() strips dir path, any failure ends script\n    \"\"\"\n    localfiles = os.listdir(cf.localdir)            # listdir is local listing\n    for localname in localfiles:\n        localpath = os.path.join(cf.localdir, localname)\n        print('uploading', localpath, 'to', localname, 'as', end=' ')\n        if isTextKind(localname):\n            # use text mode xfer\n            localfile = open(localpath, 'rb')\n            connection.storlines('STOR ' + localname, localfile)\n        else:\n            # use binary mode xfer\n            localfile = open(localpath, 'rb')\n            connection.storbinary('STOR ' + localname, localfile)\n        localfile.close()\n    connection.quit()\n    print('Done:', len(localfiles), 'files uploaded.')\nif __name__ == '__main__':\n    cf = configTransfer(site='learning-python.com', rdir='books', user='lutz')\nTransferring Directories with ftplib | 887conn = connectFtp(cf)\n    cleanRemotes(cf, conn)\n    uploadAll(cf, conn)\nNot only is the upload script simpler now because it reuses common code, but it will\nalso inherit any changes made in the download module. For instance, the isTextKind\nfunction was later augmented with code that adds the .pyw extension to mimetypes\ntables (this file type is not recognized by default); because it is a shared function, the\nchange is automatically picked up in the upload program, too.\nThis script and the one it imports achieve the same goals as the originals, but changing\nthem for easier code maintenance is a big deal in the real world of software development.\nThe following, for example, downloads the site from one server and uploads to another:\nC:\\...\\PP4E\\Internet\\Ftp\\Mirror> python downloadflat_modular.py test\nClean target directory first?\nPassword for lutz on home.rmi.net:\nconnecting...\ndownloading 2004-longmont-classes.html to test\\2004-longmont-classes.html as text\n...lines omitted...\ndownloading relo-feb010-index.html to test\\relo-feb010-index.html as text\nDone: 297 files downloaded.\nC:\\...\\PP4E\\Internet\\Ftp\\Mirror> python uploadflat_modular.py test\nClean target directory first?\nPassword for lutz on learning-python.com:\nconnecting...\nuploading test\\2004-longmont-classes.html to 2004-longmont-classes.html as text\n...lines omitted...\nuploading test\\zopeoutline.htm to zopeoutline.htm as text\nDone: 297 files uploaded.\nRefactoring with classes\nThe function-based approach of the last two examples addresses the redundancy issue,\nbut they are perhaps clumsier than they need to be. For instance, their cf configuration\noptions object provides a namespace that replaces global variables and breaks cross-\nfile dependencies. Once we start making objects to model namespaces, though, Py-\nthon\u2019s OOP support tends to be a more natural structure for our code. As one last twist,\nExample 13-14 refactors the FTP code one more time in order to leverage Python\u2019s class\nfeature.\nExample 13-14. PP4E\\Internet\\Ftp\\Mirror\\ftptools.py\n#!/bin/env python\n\"\"\"\n##############################################################################\nuse FTP to download or upload all files in a single directory from/to a\nremote site and directory;  this version has been refactored to use classes\nand OOP for namespace and a natural structure;  we could also structure this\nas a download superclass, and an upload subclass which redefines the clean\nand transfer methods, but then there is no easy way for another client to\n888 | Chapter 13:\u2002Client-Side Scriptinginvoke both an upload and download;  for the uploadall variant and possibly\nothers, also make single file upload/download code in orig loops methods;\n##############################################################################\n\"\"\"\nimport os, sys, ftplib\nfrom getpass   import getpass\nfrom mimetypes import guess_type, add_type\n# defaults for all clients\ndfltSite = 'home.rmi.net'\ndfltRdir = '.'\ndfltUser = 'lutz'\nclass FtpTools:\n    # allow these 3 to be redefined\n    def getlocaldir(self):\n        return (len(sys.argv) > 1 and sys.argv[1]) or '.'\n    def getcleanall(self):\n        return input('Clean target dir first?')[:1] in ['y','Y']\n    def getpassword(self):\n        return getpass(\n               'Password for %s on %s:' % (self.remoteuser, self.remotesite))\n    def configTransfer(self, site=dfltSite, rdir=dfltRdir, user=dfltUser):\n        \"\"\"\n        get upload or download parameters\n        from module defaults, args, inputs, cmdline\n        anonymous ftp: user='anonymous' pass=emailaddr\n        \"\"\"\n        self.nonpassive = False             # passive FTP on by default in 2.1+\n        self.remotesite = site              # transfer to/from this site\n        self.remotedir  = rdir              # and this dir ('.' means acct root)\n        self.remoteuser = user\n        self.localdir   = self.getlocaldir()\n        self.cleanall   = self.getcleanall()\n        self.remotepass = self.getpassword()\n    def isTextKind(self, remotename, trace=True):\n        \"\"\"\n        use mimetypes to guess if filename means text or binary\n        for 'f.html,   guess is ('text/html', None): text\n        for 'f.jpeg'   guess is ('image/jpeg', None): binary\n        for 'f.txt.gz' guess is ('text/plain', 'gzip'): binary\n        for unknowns,  guess may be (None, None): binary\n        mimetypes can also guess name from type: see PyMailGUI\n        \"\"\"\n        add_type('text/x-python-win', '.pyw')                    # not in tables\n        mimetype, encoding = guess_type(remotename, strict=False)# allow extras\n        mimetype  = mimetype or '?/?'                            # type unknown?\n        maintype  = mimetype.split('/')[0]                       # get 1st part\n        if trace: print(maintype, encoding or '')\nTransferring Directories with ftplib | 889return maintype == 'text' and encoding == None           # not compressed\n    def connectFtp(self):\n        print('connecting...')\n        connection = ftplib.FTP(self.remotesite)           # connect to FTP site\n        connection.login(self.remoteuser, self.remotepass) # log in as user/pswd\n        connection.cwd(self.remotedir)                     # cd to dir to xfer\n        if self.nonpassive:                                # force active mode\n            connection.set_pasv(False)                     # most do passive\n        self.connection = connection\n    def cleanLocals(self):\n        \"\"\"\n        try to delete all local files first to remove garbage\n        \"\"\"\n        if self.cleanall:\n            for localname in os.listdir(self.localdir):    # local dirlisting\n                try:                                       # local file delete\n                    print('deleting local', localname)\n                    os.remove(os.path.join(self.localdir, localname))\n                except:\n                    print('cannot delete local', localname)\n    def cleanRemotes(self):\n        \"\"\"\n        try to delete all remote files first to remove garbage\n        \"\"\"\n        if self.cleanall:\n            for remotename in self.connection.nlst():       # remote dir listing\n                try:                                        # remote file delete\n                    print('deleting remote', remotename)\n                    self.connection.delete(remotename)\n                except:\n                    print('cannot delete remote', remotename)\n    def downloadOne(self, remotename, localpath):\n        \"\"\"\n        download one file by FTP in text or binary mode\n        local name need not be same as remote name\n        \"\"\"\n        if self.isTextKind(remotename):\n            localfile = open(localpath, 'w', encoding=self.connection.encoding)\n            def callback(line): localfile.write(line + '\\n')\n            self.connection.retrlines('RETR ' + remotename, callback)\n        else:\n            localfile = open(localpath, 'wb')\n            self.connection.retrbinary('RETR ' + remotename, localfile.write)\n        localfile.close()\n    def uploadOne(self, localname, localpath, remotename):\n        \"\"\"\n        upload one file by FTP in text or binary mode\n        remote name need not be same as local name\n        \"\"\"\n        if self.isTextKind(localname):\n890 | Chapter 13:\u2002Client-Side Scriptinglocalfile = open(localpath, 'rb')\n            self.connection.storlines('STOR ' + remotename, localfile)\n        else:\n            localfile = open(localpath, 'rb')\n            self.connection.storbinary('STOR ' + remotename, localfile)\n        localfile.close()\n    def downloadDir(self):\n        \"\"\"\n        download all files from remote site/dir per config\n        ftp nlst() gives files list, dir() gives full details\n        \"\"\"\n        remotefiles = self.connection.nlst()         # nlst is remote listing\n        for remotename in remotefiles:\n            if remotename in ('.', '..'): continue\n            localpath = os.path.join(self.localdir, remotename)\n            print('downloading', remotename, 'to', localpath, 'as', end=' ')\n            self.downloadOne(remotename, localpath)\n        print('Done:', len(remotefiles), 'files downloaded.')\n    def uploadDir(self):\n        \"\"\"\n        upload all files to remote site/dir per config\n        listdir() strips dir path, any failure ends script\n        \"\"\"\n        localfiles = os.listdir(self.localdir)       # listdir is local listing\n        for localname in localfiles:\n            localpath = os.path.join(self.localdir, localname)\n            print('uploading', localpath, 'to', localname, 'as', end=' ')\n            self.uploadOne(localname, localpath, localname)\n        print('Done:', len(localfiles), 'files uploaded.')\n    def run(self, cleanTarget=lambda:None, transferAct=lambda:None):\n        \"\"\"\n        run a complete FTP session\n        default clean and transfer are no-ops\n        don't delete if can't connect to server\n        \"\"\"\n        self.connectFtp()\n        cleanTarget()\n        transferAct()\n        self.connection.quit()\nif __name__ == '__main__':\n    ftp = FtpTools()\n    xfermode = 'download'\n    if len(sys.argv) > 1:\n        xfermode = sys.argv.pop(1)   # get+del 2nd arg\n    if xfermode == 'download':\n        ftp.configTransfer()\n        ftp.run(cleanTarget=ftp.cleanLocals,  transferAct=ftp.downloadDir)\n    elif xfermode == 'upload':\n        ftp.configTransfer(site='learning-python.com', rdir='books', user='lutz')\n        ftp.run(cleanTarget=ftp.cleanRemotes, transferAct=ftp.uploadDir)\nTransferring Directories with ftplib | 891else:\n        print('Usage: ftptools.py [\"download\" | \"upload\"] [localdir]')\nIn fact, this last mutation combines uploads and downloads into a single file, because\nthey are so closely related. As before, common code is factored into methods to avoid\nredundancy. New here, the instance object itself becomes a natural namespace for\nstoring configuration options (they become self attributes). Study this example\u2019s code\nfor more details of the restructuring applied.\nAgain, this revision runs the same as our original site download and upload scripts; see\nits self-test code at the end for usage details, and pass in a command-line argument to\nspecify \u201cdownload\u201d or \u201cupload.\u201d We haven\u2019t changed what it does, we\u2019ve refactored\nit for maintainability and reuse:\nC:\\...\\PP4E\\Internet\\Ftp\\Mirror> ftptools.py download test\nClean target dir first?\nPassword for lutz on home.rmi.net:\nconnecting...\ndownloading 2004-longmont-classes.html to test\\2004-longmont-classes.html as text\n...lines omitted...\ndownloading relo-feb010-index.html to test\\relo-feb010-index.html as text\nDone: 297 files downloaded.\nC:\\...\\PP4E\\Internet\\Ftp\\Mirror> ftptools.py upload test\nClean target dir first?\nPassword for lutz on learning-python.com:\nconnecting...\nuploading test\\2004-longmont-classes.html to 2004-longmont-classes.html as text\n...lines omitted...\nuploading test\\zopeoutline.htm to zopeoutline.htm as text\nDone: 297 files uploaded.\nAlthough this file can still be run as a command-line script like this, its class is really\nnow a package of FTP tools that can be mixed into other programs and reused. By\nwrapping its code in a class, it can be easily customized by redefining its methods\u2014its\nconfiguration calls, such as getlocaldir, for example, may be redefined in subclasses\nfor custom scenarios.\nPerhaps most importantly, using classes optimizes code reusability. Clients of this file\ncan both upload and download directories by simply subclassing or embedding an\ninstance of this class and calling its methods. To see one example of how, let\u2019s move\non to the next section.\nTransferring Directory Trees with ftplib\nPerhaps the biggest limitation of the website download and upload scripts we just met\nis that they assume the site directory is flat (hence their names). That is, the preceding\nscripts transfer simple files only, and none of them handle nested subdirectories within\nthe web directory to be transferred.\n892 | Chapter 13:\u2002Client-Side ScriptingFor my purposes, that\u2019s often a reasonable constraint. I avoid nested subdirectories to\nkeep things simple, and I store my book support home website as a simple directory of\nfiles. For other sites, though, including one I keep at another machine, site transfer\nscripts are easier to use if they also automatically transfer subdirectories along the way.\nUploading Local Trees\nIt turns out that supporting directories on uploads is fairly simple\u2014we need to add\nonly a bit of recursion and remote directory creation calls. The upload script in Exam-\nple 13-15 extends the class-based version we just saw in Example 13-14, to handle\nuploading all subdirectories nested within the transferred directory. Furthermore, it\nrecursively transfers subdirectories within subdirectories\u2014the entire directory tree\ncontained within the top-level transfer directory is uploaded to the target directory at\nthe remote server.\nIn terms of its code structure, Example 13-15 is just a customization of the FtpTools\nclass of the prior section\u2014really, we\u2019re just adding a method for recursive uploads, by \nsubclassing. As one consequence, we get tools such as parameter configuration, content\ntype testing, and connection and upload code for free here; with OOP, some of the\nwork is done before we start.\nExample 13-15. PP4E\\Internet\\Ftp\\Mirror\\uploadall.py\n#!/bin/env python\n\"\"\"\n############################################################################\nextend the FtpTools class to upload all files and subdirectories from a\nlocal dir tree to a remote site/dir; supports nested dirs too, but not\nthe cleanall option (that requires parsing FTP listings to detect remote\ndirs: see cleanall.py); to upload subdirectories, uses os.path.isdir(path)\nto see if a local file is really a directory, FTP().mkd(path) to make dirs\non the remote machine (wrapped in a try in case it already exists there),\nand recursion to upload all files/dirs inside the nested subdirectory.\n############################################################################\n\"\"\"\nimport os, ftptools\nclass UploadAll(ftptools.FtpTools):\n    \"\"\"\n    upload an entire tree of subdirectories\n    assumes top remote directory exists\n    \"\"\"\n    def __init__(self):\n        self.fcount = self.dcount = 0\n    def getcleanall(self):\n        return False  # don't even ask\n    def uploadDir(self, localdir):\n        \"\"\"\nTransferring Directory Trees with ftplib | 893for each directory in an entire tree\n        upload simple files, recur into subdirectories\n        \"\"\"\n        localfiles = os.listdir(localdir)\n        for localname in localfiles:\n            localpath = os.path.join(localdir, localname)\n            print('uploading', localpath, 'to', localname, end=' ')\n            if not os.path.isdir(localpath):\n                self.uploadOne(localname, localpath, localname)\n                self.fcount += 1\n            else:\n                try:\n                    self.connection.mkd(localname)\n                    print('directory created')\n                except:\n                    print('directory not created')\n                self.connection.cwd(localname)             # change remote dir\n                self.uploadDir(localpath)                  # upload local subdir\n                self.connection.cwd('..')                  # change back up\n                self.dcount += 1\n                print('directory exited')\nif __name__ == '__main__':\n    ftp = UploadAll()\n    ftp.configTransfer(site='learning-python.com', rdir='training', user='lutz')\n    ftp.run(transferAct = lambda: ftp.uploadDir(ftp.localdir))\n    print('Done:', ftp.fcount, 'files and', ftp.dcount, 'directories uploaded.')\nLike the flat upload script, this one can be run on any machine with Python and sockets\nand upload to any machine running an FTP server; I run it both on my laptop PC and\non other servers by Telnet or SSH to upload sites to my ISP.\nThe crux of the matter in this script is the os.path.isdir test near the top; if this test\ndetects a directory in the current local directory, we create an identically named direc-\ntory on the remote machine with connection.mkd and descend into it with\nconnection.cwd, and recur into the subdirectory on the local machine (we have to use\nrecursive calls here, because the shape and depth of the tree are arbitrary). Like all FTP\nobject methods, mkd and cwd methods issue FTP commands to the remote server. When\nwe exit a local subdirectory, we run a remote cwd('..') to climb to the remote parent\ndirectory and continue; the recursive call level\u2019s return restores the prior directory on\nthe local machine. The rest of the script is roughly the same as the original.\nIn the interest of space, I\u2019ll leave studying this variant in more depth as a suggested\nexercise. For more context, try changing this script so as not to assume that the top-\nlevel remote directory already exists. As usual in software, there are a variety of imple-\nmentation and operation options here.\nHere is the sort of output displayed on the console when the upload-all script is run,\nuploading a site with multiple subdirectory levels which I maintain with site builder\ntools. It\u2019s similar to the flat upload (which you might expect, given that it is reusing\n894 | Chapter 13:\u2002Client-Side Scriptingmuch of the same code by inheritance), but notice that it traverses and uploads nested\nsubdirectories along the way:\nC:\\...\\PP4E\\Internet\\Ftp\\Mirror> uploadall.py Website-Training\nPassword for lutz on learning-python.com:\nconnecting...\nuploading Website-Training\\2009-public-classes.htm to 2009-public-classes.htm text\nuploading Website-Training\\2010-public-classes.html to 2010-public-classes.html text\nuploading Website-Training\\about.html to about.html text\nuploading Website-Training\\books to books directory created\nuploading Website-Training\\books\\index.htm to index.htm text\nuploading Website-Training\\books\\index.html to index.html text\nuploading Website-Training\\books\\_vti_cnf to _vti_cnf directory created\nuploading Website-Training\\books\\_vti_cnf\\index.htm to index.htm text\nuploading Website-Training\\books\\_vti_cnf\\index.html to index.html text\ndirectory exited\ndirectory exited\nuploading Website-Training\\calendar.html to calendar.html text\nuploading Website-Training\\contacts.html to contacts.html text\nuploading Website-Training\\estes-nov06.htm to estes-nov06.htm text\nuploading Website-Training\\formalbio.html to formalbio.html text\nuploading Website-Training\\fulloutline.html to fulloutline.html text\n...lines omitted...\nuploading Website-Training\\_vti_pvt\\writeto.cnf to writeto.cnf ?\nuploading Website-Training\\_vti_pvt\\_vti_cnf to _vti_cnf directory created\nuploading Website-Training\\_vti_pvt\\_vti_cnf\\_x_todo.htm to _x_todo.htm text\nuploading Website-Training\\_vti_pvt\\_vti_cnf\\_x_todoh.htm to _x_todoh.htm text\ndirectory exited\nuploading Website-Training\\_vti_pvt\\_x_todo.htm to _x_todo.htm text\nuploading Website-Training\\_vti_pvt\\_x_todoh.htm to _x_todoh.htm text\ndirectory exited\nDone: 366 files and 18 directories uploaded.\nAs is, the script of Example 13-15 handles only directory tree uploads; recursive uploads\nare generally more useful than recursive downloads if you maintain your websites on\nyour local PC and upload to a server periodically, as I do. To also download (mirror) a\nwebsite that has subdirectories, a script must parse the output of a remote listing com-\nmand to detect remote directories. For the same reason, the recursive upload script was\nnot coded to support the remote directory tree cleanup option of the original\u2014such a\nfeature would require parsing remote listings as well. The next section shows how.\nDeleting Remote Trees\nOne last example of code reuse at work: when I initially tested the prior section\u2019s\nupload-all script, it contained a bug that caused it to fall into an infinite recursion loop,\nand keep copying the full site into new subdirectories, over and over, until the FTP\nserver kicked me off (not an intended feature of the program!). In fact, the upload got\n13 levels deep before being killed by the server; it effectively locked my site until the\nmess could be repaired.\nTransferring Directory Trees with ftplib | 895To get rid of all the files accidentally uploaded, I quickly wrote the script in Exam-\nple 13-16 in emergency (really, panic) mode; it deletes all files and nested subdirectories\nin an entire remote tree. Luckily, this was very easy to do given all the reuse that\nExample 13-16 inherits from the FtpTools superclass. Here, we just have to define the\nextension for recursive remote deletions. Even in tactical mode like this, OOP can be\na decided advantage.\nExample 13-16. PP4E\\Internet\\Ftp\\Mirror\\cleanall.py\n#!/bin/env python\n\"\"\"\n##############################################################################\nextend the FtpTools class to delete files and subdirectories from a remote\ndirectory tree; supports nested directories too;  depends on the dir()\ncommand output format, which may vary on some servers! - see Python's\nTools\\Scripts\\ftpmirror.py for hints;  extend me for remote tree downloads;\n##############################################################################\n\"\"\"\nfrom ftptools import FtpTools\nclass CleanAll(FtpTools):\n    \"\"\"\n    delete an entire remote tree of subdirectories\n    \"\"\"\n    def __init__(self):\n        self.fcount = self.dcount = 0\n    def getlocaldir(self):\n        return None  # irrelevent here\n    def getcleanall(self):\n        return True  # implied here\n    def cleanDir(self):\n        \"\"\"\n        for each item in current remote directory,\n        del simple files, recur into and then del subdirectories\n        the dir() ftp call passes each line to a func or method\n        \"\"\"\n        lines = []                                   # each level has own lines\n        self.connection.dir(lines.append)            # list current remote dir\n        for line in lines:\n            parsed  = line.split()                   # split on whitespace\n            permiss = parsed[0]                      # assume 'drw... ... filename'\n            fname   = parsed[-1]\n            if fname in ('.', '..'):                 # some include cwd and parent\n                continue\n            elif permiss[0] != 'd':                  # simple file: delete\n                print('file', fname)\n                self.connection.delete(fname)\n                self.fcount += 1\n            else:                                    # directory: recur, del\n                print('directory', fname)\n896 | Chapter 13:\u2002Client-Side Scriptingself.connection.cwd(fname)           # chdir into remote dir\n                self.cleanDir()                      # clean subdirectory\n                self.connection.cwd('..')            # chdir remote back up\n                self.connection.rmd(fname)           # delete empty remote dir\n                self.dcount += 1\n                print('directory exited')\nif __name__ == '__main__':\n    ftp = CleanAll()\n    ftp.configTransfer(site='learning-python.com', rdir='training', user='lutz')\n    ftp.run(cleanTarget=ftp.cleanDir)\n    print('Done:', ftp.fcount, 'files and', ftp.dcount, 'directories cleaned.')\nBesides again being recursive in order to handle arbitrarily shaped trees, the main trick\nemployed here is to parse the output of a remote directory listing. The FTP nlst call\nused earlier gives us a simple list of filenames; here, we use dir to also get file detail\nlines like these:\nC:\\...\\PP4E\\Internet\\Ftp> ftp learning-python.com\nftp> cd training\nftp> dir\ndrwxr-xr-x   11 5693094  450          4096 May  4 11:06 .\ndrwx---r-x   19 5693094  450          8192 May  4 10:59 ..\n-rw----r--    1 5693094  450         15825 May  4 11:02 2009-public-classes.htm\n-rw----r--    1 5693094  450         18084 May  4 11:02 2010-public-classes.html\ndrwx---r-x    3 5693094  450          4096 May  4 11:02 books\n-rw----r--    1 5693094  450          3783 May  4 11:02 calendar-save-aug09.html\n-rw----r--    1 5693094  450          3923 May  4 11:02 calendar.html\ndrwx---r-x    2 5693094  450          4096 May  4 11:02 images\n-rw----r--    1 5693094  450          6143 May  4 11:02 index.html\n...lines omitted...\nThis output format is potentially server-specific, so check this on your own server before\nrelying on this script. For this Unix ISP, if the first character of the first item on the line\nis character \u201cd\u201d, the filename at the end of the line names a remote directory. To parse,\nthe script simply splits on whitespace to extract parts of a line.\nNotice how this script, like others before it, must skip the symbolic \u201c.\u201d and \u201c..\u201d current\nand parent directory names in listings to work properly for this server. Oddly this can\nvary per server as well; one of the servers I used for this book\u2019s examples, for instance,\ndoes not include these special names in listings. We can verify by running ftplib at the\ninteractive prompt, as though it were a portable FTP client interface:\nC:\\...\\PP4E\\Internet\\Ftp> python\n>>> from ftplib import FTP\n>>> f = FTP('ftp.rmi.net')\n>>> f.login('lutz', 'xxxxxxxx')         # output lines omitted\n>>> for x in f.nlst()[:3]: print(x)     # no . or .. in listings\n...\n2004-longmont-classes.html\n2005-longmont-classes.html\n2006-longmont-classes.html\n>>> L = []\nTransferring Directory Trees with ftplib | 897>>> f.dir(L.append)                     # ditto for detailed list\n>>> for x in L[:3]: print(x)\n...\n-rw-r--r--   1 ftp      ftp          8173 Mar 19  2006 2004-longmont-classes.html\n-rw-r--r--   1 ftp      ftp          9739 Mar 19  2006 2005-longmont-classes.html\n-rw-r--r--   1 ftp      ftp           805 Jul  8  2006 2006-longmont-classes.html\nOn the other hand, the server I\u2019m using in this section does include the special dot\nnames; to be robust, our scripts must skip over these names in remote directory listings\njust in case they\u2019re run against a server that includes them (here, the test is required to\navoid falling into an infinite recursive loop!). We don\u2019t need to care about local directory\nlistings because Python\u2019s os.listdir never includes \u201c.\u201d or \u201c..\u201d in its result, but things\nare not quite so consistent in the \u201cWild West\u201d that is the Internet today:\n>>> f = FTP('learning-python.com')\n>>> f.login('lutz', 'xxxxxxxx')         # output lines omitted\n>>> for x in f.nlst()[:5]: print(x)     # includes . and .. here\n...\n.\n..\n.hcc.thumbs\n2009-public-classes.htm\n2010-public-classes.html\n>>> L = []\n>>> f.dir(L.append)                     # ditto for detailed list\n>>> for x in L[:5]: print(x)\n...\ndrwx---r-x   19 5693094  450          8192 May  4 10:59 .\ndrwx---r-x   19 5693094  450          8192 May  4 10:59 ..\ndrwx------    2 5693094  450          4096 Feb 18 05:38 .hcc.thumbs\n-rw----r--    1 5693094  450         15824 May  1 14:39 2009-public-classes.htm\n-rw----r--    1 5693094  450         18083 May  4 09:05 2010-public-classes.html\nThe output of our clean-all script in action follows; it shows up in the system console\nwindow where the script is run. You might be able to achieve the same effect with a\n\u201crm \u2013rf\u201d Unix shell command in a SSH or Telnet window on some servers, but the\nPython script runs on the client and requires no other remote access than basic FTP on\nthe client:\nC:\\PP4E\\Internet\\Ftp\\Mirror> cleanall.py\nPassword for lutz on learning-python.com:\nconnecting...\nfile 2009-public-classes.htm\nfile 2010-public-classes.html\nfile Learning-Python-interview.doc\nfile Python-registration-form-010.pdf\nfile PythonPoweredSmall.gif\ndirectory _derived\nfile 2009-public-classes.htm_cmp_DeepBlue100_vbtn.gif\nfile 2009-public-classes.htm_cmp_DeepBlue100_vbtn_p.gif\nfile 2010-public-classes.html_cmp_DeepBlue100_vbtn_p.gif\nfile 2010-public-classes.html_cmp_deepblue100_vbtn.gif\ndirectory _vti_cnf\n898 | Chapter 13:\u2002Client-Side Scriptingfile 2009-public-classes.htm_cmp_DeepBlue100_vbtn.gif\nfile 2009-public-classes.htm_cmp_DeepBlue100_vbtn_p.gif\nfile 2010-public-classes.html_cmp_DeepBlue100_vbtn_p.gif\nfile 2010-public-classes.html_cmp_deepblue100_vbtn.gif\ndirectory exited\ndirectory exited\n...lines omitted...\nfile priorclients.html\nfile public_classes.htm\nfile python_conf_ora.gif\nfile topics.html\nDone: 366 files and 18 directories cleaned.\nDownloading Remote Trees\nIt is possible to extend this remote tree-cleaner to also download a remote tree with\nsubdirectories: rather than deleting, as you walk the remote tree simply create a local\ndirectory to match a remote one, and download nondirectory files. We\u2019ll leave this final\nstep as a suggested exercise, though, partly because its dependence on the format pro-\nduced by server directory listings makes it complex to be robust and partly because this\nuse case is less common for me\u2014in practice, I am more likely to maintain a site on my\nPC and upload to the server than to download a tree.\nIf you do wish to experiment with a recursive download, though, be sure to consult the\nscript Tools\\Scripts\\ftpmirror.py in Python\u2019s install or source tree for hints. That script\nattempts to download a remote directory tree by FTP, and allows for various directory\nlisting formats which we\u2019ll skip here in the interest of space. For our purposes, it\u2019s time\nto move on to the next protocol on our tour\u2014Internet email.\nProcessing Internet Email\nSome of the other most common, higher-level Internet protocols have to do with read-\ning and sending email messages: POP and IMAP for fetching email from servers, SMTP\nfor sending new messages, and other formalisms such as RFC822 for specifying email\nmessage content and format. You don\u2019t normally need to know about such acronyms\nwhen using common email tools, but internally, programs like Microsoft Outlook and\nwebmail systems generally talk to POP and SMTP servers to do your bidding.\nLike FTP, email ultimately consists of formatted commands and byte streams shipped\nover sockets and ports (port 110 for POP; 25 for SMTP). Regardless of the nature of its\ncontent and attachments, an email message is little more than a string of bytes sent and\nreceived through sockets. But also like FTP, Python has standard library modules to\nsimplify all aspects of email processing:\nProcessing Internet Email | 899\u2022 poplib and imaplib for fetching email\n\u2022 smtplib for sending email\n\u2022 The email module package for parsing email and constructing email\nThese modules are related: for nontrivial messages, we typically use email to parse mail\ntext which has been fetched with poplib and use email to compose mail text to be sent\nwith smtplib. The email package also handles tasks such as address parsing, date and\ntime formatting, attachment formatting and extraction, and encoding and decoding of\nemail content (e,g, uuencode, Base64). Additional modules handle more specific tasks\n(e.g., mimetypes to map filenames to and from content types).\nIn the next few sections, we explore the POP and SMTP interfaces for fetching and\nsending email from and to servers, and the email package interfaces for parsing and\ncomposing email message text. Other email interfaces in Python are analogous and are\ndocumented in the Python library reference manual.\u00a7\nUnicode in Python 3.X and Email Tools\nIn the prior sections of this chapter, we studied how Unicode encodings can impact\nscripts using Python\u2019s ftplib FTP tools in some depth, because it illustrates the impli-\ncations of Python 3.X\u2019s Unicode string model for real-world programming. In short:\n\u2022 All binary mode transfers should open local output and input files in binary mode\n(modes wb and rb).\n\u2022 Text-mode downloads should open local output files in text mode with explicit\nencoding names (mode w, with an encoding argument that defaults to latin1 within\nftplib itself).\n\u2022 Text-mode uploads should open local input files in binary mode (mode rb).\nThe prior sections describe why these rules are in force. The last two points here differ\nfor scripts written originally for Python 2.X. As you might expect, given that the un-\nderlying sockets transfer byte strings today, the email story is somewhat convoluted for\nUnicode in Python 3.X as well. As a brief preview:\nFetching\nThe poplib module returns fetched email text in bytes string form. Command text\nsent to the server is encoded per UTF8 internally, but replies are returned as raw\nbinary bytes and not decoded into str text.\n\u00a7 IMAP, or Internet Message Access Protocol, was designed as an alternative to POP, but it is still not as widely\navailable today, and so it is not presented in this text. For instance, major commercial providers used for this\nbook\u2019s examples provide only POP (or web-based) access to email. See the Python library manual for IMAP\nserver interface details. Python used to have a RFC822 module as well, but it\u2019s been subsumed by the\nemail package in 3.X.\n900 | Chapter 13:\u2002Client-Side ScriptingSending\nThe smtplib module accepts email content to send as str strings. Internally, mes-\nsage text passed in str form is encoded to binary bytes for transmission using the\nascii encoding scheme. Passing an already encoded bytes string to the send call\nmay allow more explicit control.\nComposing\nThe email package produces Unicode str strings containing plain text when gen-\nerating full email text for sending with smtplib and accepts optional encoding\nspecifications for messages and their parts, which it applies according to email\nstandard rules. Message headers may also be encoded per email, MIME, and Uni-\ncode conventions.\nParsing\nThe email package in 3.1 currently requires raw email byte strings of the type\nfetched with poplib to be decoded into Unicode str strings as appropriate before\nit can be passed in to be parsed into a message object. This pre-parse decoding\nmight be done by a default, user preference, mail headers inspection, or intelligent\nguess. Because this requirement raises difficult issues for package clients, it may be\ndropped in a future version of email and Python.\nNavigating\nThe email package returns most message components as str strings, though parts\ncontent decoded by Base64 and other email encoding schemes may be returned as\nbytes strings, parts fetched without such decoding may be str or bytes, and some\nstr string parts are internally encoded to bytes with scheme raw-unicode-escape\nbefore processing. Message headers may be decoded by the package on request as\nwell.\nIf you\u2019re migrating email scripts (or your mindset) from 2.X, you\u2019ll need to treat email\ntext fetched from a server as byte strings, and encode it before passing it along for\nparsing; scripts that send or compose email are generally unaffected (and this may be\nthe majority of Python email-aware scripts), though content may have to be treated\nspecially if it may be returned as byte strings.\nThis is the story in Python 3.1, which is of course prone to change over time. We\u2019ll see\nhow these email constraints translate into code as we move along in this section. Suffice\nit to say, the text on the Internet is not as simple as it used to be, though it probably\nshouldn\u2019t have been anyhow.\nPOP: Fetching Email\nI confess: up until just before 2000, I took a lowest-common-denominator approach\nto email. I preferred to check my messages by Telnetting to my ISP and using a simple\ncommand-line email interface. Of course, that\u2019s not ideal for mail with attachments,\npictures, and the like, but its portability was staggering\u2014because Telnet runs on almost\nPOP: Fetching Email | 901any machine with a network link, I was able to check my mail quickly and easily from\nanywhere on the planet. Given that I make my living traveling around the world teach-\ning Python classes, this wild accessibility was a big win.\nAs with website maintenance, times have changed on this front. Somewhere along the\nway, most ISPs began offering web-based email access with similar portability and\ndropped Telnet altogether. When my ISP took away Telnet access, however, they also\ntook away one of my main email access methods. Luckily, Python came to the rescue\nagain\u2014by writing email access scripts in Python, I could still read and send email from\nany machine in the world that has Python and an Internet connection. Python can be\nas portable a solution as Telnet, but much more powerful.\nMoreover, I can still use these scripts as an alternative to tools suggested by the ISP.\nBesides my not being fond of delegating control to commercial products of large com-\npanies, closed email tools impose choices on users that are not always ideal and may\nsometimes fail altogether. In many ways, the motivation for coding Python email scripts\nis the same as it was for the larger GUIs in Chapter 11: the scriptability of Python\nprograms can be a decided advantage.\nFor example, Microsoft Outlook historically and by default has preferred to download\nmail to your PC and delete it from the mail server as soon as you access it. This keeps\nyour email box small (and your ISP happy), but it isn\u2019t exactly friendly to people who\ntravel and use multiple machines along the way\u2014once accessed, you cannot get to a\nprior email from any machine except the one to which it was initially downloaded.\nWorse, the web-based email interfaces offered by my ISPs have at times gone offline\ncompletely, leaving me cut off from email (and usually at the worst possible time).\nThe next two scripts represent one first-cut solution to such portability and reliability\nconstraints (we\u2019ll see others in this and later chapters). The first, popmail.py, is a simple \nmail reader tool, which downloads and prints the contents of each email in an email\naccount. This script is admittedly primitive, but it lets you read your email on any\nmachine with Python and sockets; moreover, it leaves your email intact on the server,\nand isn\u2019t susceptible to webmail outages. The second, smtpmail.py, is a one-shot script\nfor writing and sending a new email message that is as portable as Python itself.\nLater in this chapter, we\u2019ll implement an interactive console-based email client (py-\nmail), and later in this book we\u2019ll code a full-blown GUI email tool (PyMailGUI) and\na web-based email program of our own (PyMailCGI). For now, we\u2019ll start with the\nbasics.\nMail Configuration Module\nBefore we get to the scripts, let\u2019s first take a look at a common module they import and\nuse. The module in Example 13-17 is used to configure email parameters appropriately\nfor a particular user. It\u2019s simply a collection of assignments to variables used by mail\nprograms that appear in this book; each major mail client has its own version, to allow\n902 | Chapter 13:\u2002Client-Side Scriptingcontent to vary. Isolating these configuration settings in this single module makes it\neasy to configure the book\u2019s email programs for a particular user, without having to\nedit actual program logic code.\nIf you want to use any of this book\u2019s email programs to do mail processing of your own,\nbe sure to change its assignments to reflect your servers, account usernames, and so on\n(as shown, they refer to email accounts used for developing this book). Not all scripts\nuse all of these settings; we\u2019ll revisit this module in later examples to explain more of\nthem.\nNote that some ISPs may require that you be connected directly to their systems in\norder to use their SMTP servers to send mail. For example, when connected directly\nby dial-up in the past, I could use my ISP\u2019s server directly, but when connected via\nbroadband, I had to route requests through a cable Internet provider. You may need\nto adjust these settings to match your configuration; see your ISP to obtain the required\nPOP and SMTP servers. Also, some SMTP servers check domain name validity in ad-\ndresses, and may require an authenticating login step\u2014see the SMTP section later in\nthis chapter for interface details.\nExample 13-17. PP4E\\Internet\\Email\\mailconfig.py\n\"\"\"\nuser configuration settings for various email programs (pymail/mailtools version);\nemail scripts get their server names and other email config options from this\nmodule: change me to reflect your server names and mail preferences;\n\"\"\"\n#------------------------------------------------------------------------------\n# (required for load, delete: all) POP3 email server machine, user\n#------------------------------------------------------------------------------\npopservername = 'pop.secureserver.net'\npopusername   = 'PP4E@learning-python.com'\n#------------------------------------------------------------------------------\n# (required for send: all) SMTP email server machine name\n# see Python smtpd module for a SMTP server class to run locally;\n#------------------------------------------------------------------------------\nsmtpservername = 'smtpout.secureserver.net'\n#------------------------------------------------------------------------------\n# (optional: all) personal information used by clients to fill in mail if set;\n# signature  -- can be a triple-quoted block, ignored if empty string;\n# address -- used for initial value of \"From\" field if not empty,\n# no longer tries to guess From for replies: this had varying success;\n#------------------------------------------------------------------------------\nmyaddress   = 'PP4E@learning-python.com'\nmysignature = ('Thanks,\\n'\n               '--Mark Lutz  (http://learning-python.com, http://rmi.net/~lutz)')\nPOP: Fetching Email | 903#------------------------------------------------------------------------------\n# (optional: mailtools) may be required for send; SMTP user/password if\n# authenticated; set user to None or '' if no login/authentication is\n# required; set pswd to name of a file holding your SMTP password, or\n# an empty string to force programs to ask (in a console, or GUI);\n#------------------------------------------------------------------------------\nsmtpuser  = None                           # per your ISP\nsmtppasswdfile  = ''                       # set to '' to be asked\n#------------------------------------------------------------------------------\n# (optional: mailtools) name of local one-line text file with your pop\n# password; if empty or file cannot be read, pswd is requested when first\n# connecting; pswd not encrypted: leave this empty on shared machines;\n#------------------------------------------------------------------------------\npoppasswdfile  = r'c:\\temp\\pymailgui.txt'      # set to '' to be asked\n#------------------------------------------------------------------------------\n# (required: mailtools) local file where sent messages are saved by some clients;\n#------------------------------------------------------------------------------\nsentmailfile   = r'.\\sentmail.txt'             # . means in current working dir\n#------------------------------------------------------------------------------\n# (required: pymail, pymail2) local file where pymail saves pop mail on request;\n#------------------------------------------------------------------------------\nsavemailfile   = r'c:\\temp\\savemail.txt'       # not used in PyMailGUI: dialog\n#------------------------------------------------------------------------------\n# (required: pymail, mailtools) fetchEncoding is the Unicode encoding used to\n# decode fetched full message bytes, and to encode and decode message text if\n# stored in text-mode save files; see Chapter 13 for details: this is a limited\n# and temporary approach to Unicode encodings until a new bytes-friendly email\n# package is developed; headersEncodeTo is for sent headers: see chapter13;\n#------------------------------------------------------------------------------\nfetchEncoding = 'utf8'      # 4E: how to decode and store message text (or latin1?)\nheadersEncodeTo = None      # 4E: how to encode non-ASCII headers sent (None=utf8)\n#------------------------------------------------------------------------------\n# (optional: mailtools) the maximum number of mail headers or messages to\n# download on each load request; given this setting N, mailtools fetches at\n# most N of the most recently arrived mails; older mails outside this set are\n# not fetched from the server, but are returned as empty/dummy emails; if this\n# is assigned to None (or 0), loads will have no such limit; use this if you\n# have very many mails in your inbox, and your Internet or mail server speed\n# makes full loads too slow to be practical;  some clients also load only\n# newly-arrived emails, but this setting is independent of that feature;\n#------------------------------------------------------------------------------\nfetchlimit = 25             # 4E: maximum number headers/emails to fetch on loads\n904 | Chapter 13:\u2002Client-Side ScriptingPOP Mail Reader Script\nOn to reading email in Python: the script in Example 13-18 employs Python\u2019s standard\npoplib module, an implementation of the client-side interface to POP\u2014the Post Office\nProtocol. POP is a well-defined and widely available way to fetch email from servers\nover sockets. This script connects to a POP server to implement a simple yet portable\nemail download and display tool.\nExample 13-18. PP4E\\Internet\\Email\\popmail.py\n#!/usr/local/bin/python\n\"\"\"\n##############################################################################\nuse the Python POP3 mail interface module to view your POP email account\nmessages;  this is just a simple listing--see pymail.py for a client with\nmore user interaction features, and smtpmail.py for a script which sends\nmail;  POP is used to retrieve mail, and runs on a socket using port number\n110 on the server machine, but Python's poplib hides all protocol details;\nto send mail, use the smtplib module (or os.popen('mail...')).  see also:\nimaplib module for IMAP alternative, PyMailGUI/PyMailCGI for more features;\n##############################################################################\n\"\"\"\nimport poplib, getpass, sys, mailconfig\nmailserver = mailconfig.popservername      # ex: 'pop.rmi.net'\nmailuser   = mailconfig.popusername        # ex: 'lutz'\nmailpasswd = getpass.getpass('Password for %s?' % mailserver)\nprint('Connecting...')\nserver = poplib.POP3(mailserver)\nserver.user(mailuser)                      # connect, log in to mail server\nserver.pass_(mailpasswd)                   # pass is a reserved word\ntry:\n    print(server.getwelcome())             # print returned greeting message\n    msgCount, msgBytes = server.stat()\n    print('There are', msgCount, 'mail messages in', msgBytes, 'bytes')\n    print(server.list())\n    print('-' * 80)\n    input('[Press Enter key]')\n    for i in range(msgCount):\n        hdr, message, octets = server.retr(i+1)    # octets is byte count\n        for line in message: print(line.decode())  # retrieve, print all mail\n        print('-' * 80)                            # mail text is bytes in 3.x\n        if i < msgCount - 1:\n           input('[Press Enter key]')              # mail box locked till quit\nfinally:                                           # make sure we unlock mbox\n    server.quit()                                  # else locked till timeout\nprint('Bye.')\nPOP: Fetching Email | 905Though primitive, this script illustrates the basics of reading email in Python. To es-\ntablish a connection to an email server, we start by making an instance of the pop\nlib.POP3 object, passing in the email server machine\u2019s name as a string:\nserver = poplib.POP3(mailserver)\nIf this call doesn\u2019t raise an exception, we\u2019re connected (by socket) to the POP server\nlistening on POP port number 110 at the machine where our email account lives.\nThe next thing we need to do before fetching messages is tell the server our username\nand password; notice that the password method is called pass_. Without the trailing\nunderscore, pass would name a reserved word and trigger a syntax error:\nserver.user(mailuser)                      # connect, log in to mail server\nserver.pass_(mailpasswd)                   # pass is a reserved word\nTo keep things simple and relatively secure, this script always asks for the account\npassword interactively; the getpass module we met in the FTP section of this chapter\nis used to input but not display a password string typed by the user.\nOnce we\u2019ve told the server our username and password, we\u2019re free to fetch mailbox\ninformation with the stat method (number messages, total bytes among all messages)\nand fetch the full text of a particular message with the retr method (pass the message\nnumber\u2014they start at 1). The full text includes all headers, followed by a blank line,\nfollowed by the mail\u2019s text and any attached parts. The retr call sends back a tuple that\nincludes a list of line strings representing the content of the mail:\nmsgCount, msgBytes = server.stat()\nhdr, message, octets = server.retr(i+1)    # octets is byte count\nWe close the email server connection by calling the POP object\u2019s quit method:\nserver.quit()                              # else locked till timeout\nNotice that this call appears inside the finally clause of a try statement that wraps the\nbulk of the script. To minimize complications associated with changes, POP servers\nlock your email inbox between the time you first connect and the time you close your\nconnection (or until an arbitrary, system-defined timeout expires). Because the POP\nquit method also unlocks the mailbox, it\u2019s crucial that we do this before exiting,\nwhether an exception is raised during email processing or not. By wrapping the action\nin a try/finally statement, we guarantee that the script calls quit on exit to unlock the\nmailbox to make it accessible to other processes (e.g., delivery of incoming email).\nFetching Messages\nHere is the popmail script of Example 13-18 in action, displaying two messages in my\naccount\u2019s mailbox on machine pop.secureserver.net\u2014the domain name of the mail\nserver machine used by the ISP hosting my learning-python.com domain name, as\nconfigured in the module mailconfig. To keep this output reasonably sized, I\u2019ve omitted\nor truncated a few irrelevant message header lines here, including most of the\n906 | Chapter 13:\u2002Client-Side ScriptingReceived: headers that chronicle an email\u2019s journey; run this on your own to see all the\ngory details of raw email text:\nC:\\...\\PP4E\\Internet\\Email> popmail.py\nPassword for pop.secureserver.net?\nConnecting...\nb'+OK <1314.1273085900@p3pop01-02.prod.phx3.gdg>'\nThere are 2 mail messages in 3268 bytes\n(b'+OK ', [b'1 1860', b'2 1408'], 16)\n--------------------------------------------------------------------------------\n[Press Enter key]\nReceived: (qmail 7690 invoked from network); 5 May 2010 15:29:43 \u22120000\nX-IronPort-Anti-Spam-Result: AskCAG4r4UvRVllAlGdsb2JhbACDF44FjCkVAQEBAQkLCAkRAx+\nReceived: from 72.236.109.185 by webmail.earthlink.net with HTTP; Wed, 5 May 201\nMessage-ID: <27293081.1273073376592.JavaMail.root@mswamui-thinleaf.atl.sa.earthl\nDate: Wed, 5 May 2010 11:29:36 \u22120400 (EDT)\nFrom: lutz@rmi.net\nReply-To: lutz@rmi.net\nTo: pp4e@learning-python.com\nSubject: I'm a Lumberjack, and I'm Okay\nMime-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 7bit\nX-Mailer: EarthLink Zoo Mail 1.0\nX-ELNK-Trace: 309f369105a89a174e761f5d55cab8bca866e5da7af650083cf64d888edc8b5a35\nX-Originating-IP: 209.86.224.51\nX-Nonspam: None\nI cut down trees, I skip and jump,\nI like to press wild flowers...\n--------------------------------------------------------------------------------\n[Press Enter key]\nReceived: (qmail 17482 invoked from network); 5 May 2010 15:33:47 \u22120000\nX-IronPort-Anti-Spam-Result: AlIBAIss4UthSoc7mWdsb2JhbACDF44FjD4BAQEBAQYNCgcRIq1\nReceived: (qmail 4009 invoked by uid 99); 5 May 2010 15:33:47 \u22120000\nContent-Transfer-Encoding: quoted-printable\nContent-Type: text/plain; charset=\"utf-8\"\nX-Originating-IP: 72.236.109.185\nUser-Agent: Web-Based Email 5.2.13\nMessage-Id: <20100505083347.deec9532fd532622acfef00cad639f45.0371a89d29.wbe@emai\nFrom: lutz@learning-python.com\nTo: PP4E@learning-python.com\nCc: lutz@learning-python.com\nSubject: testing\nDate: Wed, 05 May 2010 08:33:47 \u22120700\nMime-Version: 1.0\nX-Nonspam: None\nTesting Python mail tools.\n--------------------------------------------------------------------------------\nBye.\nPOP: Fetching Email | 907This user interface is about as simple as it could be\u2014after connecting to the server, it \nprints the complete and raw full text of one message at a time, pausing between each \nuntil you press the Enter key. The input built-in is called to wait for the key press \nbetween message displays. The pause keeps messages from scrolling off the screen too \nfast; to make them visually distinct, emails are also separated by lines of dashes.\nWe could make the display fancier (e.g., we can use the email package to parse headers, \nbodies, and attachments\u2014watch for examples in this and later chapters), but here we \nsimply display the whole message that was sent. This works well for simple mails like \nthese two, but it can be inconvenient for larger messages with attachments; we\u2019ll im-\nprove on this in later clients.\nThis book won\u2019t cover the full of set of headers that may appear in emails, but we\u2019ll \nmake use of some along the way. For example, the X-Mailer header line, if present, \ntypically identifies the sending program; we\u2019ll use it later to identify Python-coded email \nsenders we write. The more common headers such as From and Subject are more crucial \nto a message. In fact, a variety of extra header lines can be sent in a message\u2019s text. The \nReceived headers, for example, trace the machines that a message passed through on \nits way to the target mailbox.\nBecause popmail prints the entire raw text of a message, you see all headers here, but \nyou usually see only a few by default in end-user-oriented mail GUIs such as Outlook \nand webmail pages. The raw text here also makes apparent the email structure we noted \nearlier: an email in general consists of a set of headers like those here, followed by a \nblank line, which is followed by the mail\u2019s main text, though as we\u2019ll see later, they can \nbe more complex if there are alternative parts or attachments.\nThe script in Example 13-18 never deletes mail from the server. Mail is simply retrieved \nand printed and will be shown again the next time you run the script (barring deletion \nin another tool, of course). To really remove mail permanently, we need to call other \nmethods (e.g., server.dele(msgnum)), but such a capability is best deferred until we \ndevelop more interactive mail tools.\nNotice how the reader script decodes each mail content line with line.decode into a \nstr string for display; as mentioned earlier, poplib returns content as bytes strings in\n3.X. In fact, if we change the script to not decode, this becomes more obvious in its \noutput:\n[Press Enter key]\n...assorted lines omitted...\nb'Date: Wed, 5 May 2010 11:29:36 \u22120400 (EDT)'\nb'From: lutz@rmi.net'\nb'Reply-To: lutz@rmi.net'\nb'To: pp4e@learning-python.com'\nb\"Subject: I'm a Lumberjack, and I'm Okay\"\nb'Mime-Version: 1.0'\nb'Content-Type: text/plain; charset=UTF-8'\nb'Content-Transfer-Encoding: 7bit'\nb'X-Mailer: EarthLink Zoo Mail 1.0'\n908 | Chapter 13:\u2002Client-Side Scriptingb''\nb'I cut down trees, I skip and jump,'\nb'I like to press wild flowers...'\nb''\nAs we\u2019ll see later, we\u2019ll need to decode similarly in order to parse this text with email\ntools. The next section exposes the bytes-based interface as well.\nFetching Email at the Interactive Prompt\nIf you don\u2019t mind typing code and reading POP server messages, it\u2019s possible to use the\nPython interactive prompt as a simple email client, too. The following session uses two\nadditional interfaces we\u2019ll apply in later examples:\nconn.list()\nReturns a list of \u201cmessage-number message-size\u201d strings.\nconn.top( N , 0)\nRetrieves just the header text portion of message number N.\nThe top call also returns a tuple that includes the list of line strings sent back; its second\nargument tells the server how many additional lines after the headers to send, if any. If\nall you need are header details, top can be much quicker than the full text fetch of\nretr, provided your mail server implements the TOP command (most do):\nC:\\...\\PP4E\\Internet\\Email> python\n>>> from poplib import POP3\n>>> conn = POP3('pop.secureserver.net')         # connect to server\n>>> conn.user('PP4E@learning-python.com')       # log in to account\nb'+OK '\n>>> conn.pass_('xxxxxxxx')\nb'+OK '\n>>> conn.stat()      # num mails, num bytes\n(2, 3268)\n>>> conn.list()\n(b'+OK ', [b'1 1860', b'2 1408'], 16)\n>>> conn.top(1, 0)\n(b'+OK 1860 octets ', [b'Received: (qmail 7690 invoked from network); 5 May 2010\n...lines omitted...\nb'X-Originating-IP: 209.86.224.51', b'X-Nonspam: None', b'', b''], 1827)\n>>> conn.retr(1)\n(b'+OK 1860 octets ', [b'Received: (qmail 7690 invoked from network); 5 May 2010\n...lines omitted...\nb'X-Originating-IP: 209.86.224.51', b'X-Nonspam: None', b'',\nb'I cut down trees, I skip and jump,', b'I like to press wild flowers...',\nb'', b''], 1898)\n>>> conn.quit()\nb'+OK '\nPOP: Fetching Email | 909Printing the full text of a message at the interactive prompt is easy once it\u2019s fetched:\nsimply decode each line to a normal string as it is printed, like our pop mail script did,\nor concatenate the line strings returned by retr or top adding a newline between; any\nof the following will suffice for an open POP server object:\n>>> info, msg, oct = connection.retr(1)       # fetch first email in mailbox\n>>> for x in msg: print(x.decode())           # four ways to display message lines\n>>> print(b'\\n'.join(msg).decode())\n>>> x = [print(x.decode()) for x in msg]\n>>> x = list(map(print, map(bytes.decode, msg)))\nParsing email text to extract headers and components is more complex, especially for\nmails with attached and possibly encoded parts, such as images. As we\u2019ll see later in\nthis chapter, the standard library\u2019s email package can parse the mail\u2019s full or headers\ntext after it has been fetched with poplib (or imaplib).\nSee the Python library manual for details on other POP module tools. As of Python 2.4,\nthere is also a POP3_SSL class in the poplib module that connects to the server over an\nSSL-encrypted socket on port 995 by default (the standard port for POP over SSL). It\nprovides an identical interface, but it uses secure sockets for the conversation where\nsupported by servers.\nSMTP: Sending Email\nThere is a proverb in hackerdom that states that every useful computer program even-\ntually grows complex enough to send email. Whether such wisdom rings true or not\nin practice, the ability to automatically initiate email from within a program is a pow-\nerful tool.\nFor instance, test systems can automatically email failure reports, user interface pro-\ngrams can ship purchase orders to suppliers by email, and so on. Moreover, a portable\nPython mail script could be used to send messages from any computer in the world\nwith Python and an Internet connection that supports standard email protocols. Free-\ndom from dependence on mail programs like Outlook is an attractive feature if you\nhappen to make your living traveling around teaching Python on all sorts of computers.\nLuckily, sending email from within a Python script is just as easy as reading it. In fact,\nthere are at least four ways to do so:\nCalling os.popen to launch a command-line mail program\nOn some systems, you can send email from a script with a call of the form:\nos.popen('mail -s \"xxx\" a@b.c', 'w').write(text)\nAs we saw earlier in the book, the popen tool runs the command-line string passed\nto its first argument, and returns a file-like object connected to it. If we use an open\nmode of w, we are connected to the command\u2019s standard input stream\u2014here, we\nwrite the text of the new mail message to the standard Unix mail command-line\n910 | Chapter 13:\u2002Client-Side Scriptingprogram. The net effect is as if we had run mail interactively, but it happens inside\na running Python script.\nRunning the sendmail program\nThe open source sendmail program offers another way to initiate mail from a pro-\ngram. Assuming it is installed and configured on your system, you can launch it\nusing Python tools like the os.popen call of the previous paragraph.\nUsing the standard smtplib Python module\nPython\u2019s standard library comes with support for the client-side interface to\nSMTP\u2014the Simple Mail Transfer Protocol\u2014a higher-level Internet standard for\nsending mail over sockets. Like the poplib module we met in the previous section,\nsmtplib hides all the socket and protocol details and can be used to send mail on\nany machine with Python and a suitable socket-based Internet link.\nFetching and using third-party packages and tools\nOther tools in the open source library provide higher-level mail handling packages\nfor Python; most build upon one of the prior three techniques.\nOf these four options, smtplib is by far the most portable and direct. Using os.popen\nto spawn a mail program usually works on Unix-like platforms only, not on Windows\n(it assumes a command-line mail program), and requires spawning one or more pro-\ncesses along the way. And although the sendmail program is powerful, it is also some-\nwhat Unix-biased, complex, and may not be installed even on all Unix-like machines.\nBy contrast, the smtplib module works on any machine that has Python and an Internet\nlink that supports SMTP access, including Unix, Linux, Mac, and Windows. It sends\nmail over sockets in-process, instead of starting other programs to do the work. More-\nover, SMTP affords us much control over the formatting and routing of email.\nSMTP Mail Sender Script\nSince SMTP is arguably the best option for sending mail from a Python script, let\u2019s\nexplore a simple mailing program that illustrates its interfaces. The Python script shown\nin Example 13-19 is intended to be used from an interactive command line; it reads a\nnew mail message from the user and sends the new mail by SMTP using Python\u2019s\nsmtplib module.\nExample 13-19. PP4E\\Internet\\Email\\smtpmail.py\n#!/usr/local/bin/python\n\"\"\"\n###########################################################################\nuse the Python SMTP mail interface module to send email messages; this\nis just a simple one-shot send script--see pymail, PyMailGUI, and\nPyMailCGI for clients with more user interaction features; also see\npopmail.py for a script that retrieves mail, and the mailtools pkg\nfor attachments and formatting with the standard library email package;\n###########################################################################\n\"\"\"\nSMTP: Sending Email | 911import smtplib, sys, email.utils, mailconfig\nmailserver = mailconfig.smtpservername         # ex: smtp.rmi.net\nFrom = input('From? ').strip()                 # or import from mailconfig\nTo   = input('To?   ').strip()                 # ex: python-list@python.org\nTos  = To.split(';')                           # allow a list of recipients\nSubj = input('Subj? ').strip()\nDate = email.utils.formatdate()                # curr datetime, rfc2822\n# standard headers, followed by blank line, followed by text\ntext = ('From: %s\\nTo: %s\\nDate: %s\\nSubject: %s\\n\\n' % (From, To, Date, Subj))\nprint('Type message text, end with line=[Ctrl+d (Unix), Ctrl+z (Windows)]')\nwhile True:\n    line = sys.stdin.readline()\n    if not line:\n        break                        # exit on ctrl-d/z\n   #if line[:4] == 'From':\n   #    line = '>' + line            # servers may escape\n    text += line\nprint('Connecting...')\nserver = smtplib.SMTP(mailserver)              # connect, no log-in step\nfailed = server.sendmail(From, Tos, text)\nserver.quit()\nif failed:                                     # smtplib may raise exceptions\n    print('Failed recipients:', failed)        # too, but let them pass here\nelse:\n    print('No errors.')\nprint('Bye.')\nMost of this script is user interface\u2014it inputs the sender\u2019s address (From), one or more\nrecipient addresses (To, separated by \u201c;\u201d if more than one), and a subject line. The\nsending date is picked up from Python\u2019s standard time module, standard header lines\nare formatted, and the while loop reads message lines until the user types the end-of-\nfile character (Ctrl-Z on Windows, Ctrl-D on Linux).\nTo be robust, be sure to add a blank line between the header lines and the body in the\nmessage\u2019s text; it\u2019s required by the SMTP protocol and some SMTP servers enforce\nthis. Our script conforms by inserting an empty line with \\n\\n at the end of the string\nformat expression\u2014one \\n to terminate the current line and another for a blank line;\nsmtplib expands \\n to Internet-style \\r\\n internally prior to transmission, so the short\nform is fine here. Later in this chapter, we\u2019ll format our messages with the Python\nemail package, which handles such details for us automatically.\nThe rest of the script is where all the SMTP magic occurs: to send a mail by SMTP,\nsimply run these two sorts of calls:\nserver = smtplib.SMTP(mailserver)\nMake an instance of the SMTP object, passing in the name of the SMTP server that\nwill dispatch the message first. If this doesn\u2019t throw an exception, you\u2019re connected\n912 | Chapter 13:\u2002Client-Side Scriptingto the SMTP server via a socket when the call returns. Technically, the connect\nmethod establishes connection to a server, but the SMTP object calls this method\nautomatically if the mail server name is passed in this way.\nfailed = server.sendmail(From, Tos, text)\nCall the SMTP object\u2019s sendmail method, passing in the sender address, one or\nmore recipient addresses, and the raw text of the message itself with as many\nstandard mail header lines as you care to provide.\nWhen you\u2019re done, be sure to call the object\u2019s quit method to disconnect from the\nserver and finalize the transaction. Notice that, on failure, the sendmail method may\neither raise an exception or return a list of the recipient addresses that failed; the script\nhandles the latter case itself but lets exceptions kill the script with a Python error\nmessage.\nSubtly, calling the server object\u2019s quit method after sendmail raises an exception may\nor may not work as expected\u2014quit can actually hang until a server timeout if the send\nfails internally and leaves the interface in an unexpected state. For instance, this can\noccur on Unicode encoding errors when translating the outgoing mail to bytes per the\nASCII scheme (the rset reset request hangs in this case, too). An alternative close\nmethod simply closes the client\u2019s sockets without attempting to send a quit command\nto the server; quit calls close internally as a last step (assuming the quit command can\nbe sent!).\nFor advanced usage, SMTP objects provide additional calls not used in this example:\n\u2022 server.login(user, password) provides an interface to SMTP servers that require\nand support authentication; watch for this call to appear as an option in the mail\ntools package example later in this chapter.\n\u2022 server.starttls([keyfile[, certfile]]) puts the SMTP connection in Transport\nLayer Security (TLS) mode; all commands will be encrypted using the Python\nssl module\u2019s socket wrapper SSL support, and they assume the server supports\nthis mode.\nSee the Python library manual for more on these and other calls not covered here.\nSending Messages\nLet\u2019s ship a few messages across the world. The smtpmail script is a one-shot tool: each\nrun allows you to send a single new mail message. Like most of the client-side tools in\nthis chapter, it can be run from any computer with Python and an Internet link that\nsupports SMTP (most do, though some public access machines may restrict users to\nHTTP [Web] access only or require special server SMTP configuration). Here it is run-\nning on Windows:\nC:\\...\\PP4E\\Internet\\Email> smtpmail.py\nFrom? Eric.the.Half.a.Bee@yahoo.com\nTo?   PP4E@learning-python.com\nSMTP: Sending Email | 913Subj? A B C D E F G\nType message text, end with line=[Ctrl+d (Unix), Ctrl+z (Windows)]\nFiddle de dum, Fiddle de dee,\nEric the half a bee.\n^Z\nConnecting...\nNo errors.\nBye.\nThis mail is sent to the book\u2019s email account address (PP4E@learning-python.com), so\nit ultimately shows up in the inbox at my ISP, but only after being routed through an\narbitrary number of machines on the Net, and across arbitrarily distant network links.\nIt\u2019s complex at the bottom, but usually, the Internet \u201cjust works.\u201d\nNotice the From address, though\u2014it\u2019s completely fictitious (as far as I know, at least).\nIt turns out that we can usually provide any From address we like because SMTP doesn\u2019t\ncheck its validity (only its general format is checked). Furthermore, unlike POP, there\nis usually no notion of a username or password in SMTP, so the sender is more difficult\nto determine. We need only pass email to any machine with a server listening on the\nSMTP port, and we don\u2019t need an account or login on that machine. Here,\nthe name Eric.the.Half.a.Bee@yahoo.com works just fine as the sender;\nMarketing.Geek.From.Hell@spam.com might work just as well.\nIn fact, I didn\u2019t import a From email address from the mailconfig.py module on purpose,\nbecause I wanted to be able to demonstrate this behavior; it\u2019s the basis of some of those\nannoying junk emails that show up in your mailbox without a real sender\u2019s address.\u2016\nMarketers infected with e-millionaire mania will email advertising to all addresses on\na list without providing a real From address, to cover their tracks.\nNormally, of course, you should use the same To address in the message and the SMTP\ncall and provide your real email address as the From value (that\u2019s the only way people\nwill be able to reply to your message). Moreover, apart from teasing your significant\nother, sending phony addresses is often just plain bad Internet citizenship. Let\u2019s run\nthe script again to ship off another mail with more politically correct coordinates:\nC:\\...\\PP4E\\Internet\\Email> smtpmail.py\nFrom? PP4E@learning-python.com\nTo?   PP4E@learning-python.com\nSubj? testing smtpmail\nType message text, end with line=[Ctrl+d (Unix), Ctrl+z (Windows)]\nLovely Spam! Wonderful Spam!\n^Z\nConnecting...\nNo errors.\nBye.\n\u2016 We all know by now that such junk mail is usually referred to as spam, but not everyone knows that this\nname is a reference to a Monty Python skit in which a restaurant\u2019s customers find it difficult to hear the\nreading of menu options over a group of Vikings singing an increasingly loud chorus of \u201cspam, spam, spam\u2026\u201d.\nHence the tie-in to junk email. Spam is used in Python program examples as a sort of generic variable name,\nthough it also pays homage to the skit.\n914 | Chapter 13:\u2002Client-Side ScriptingVerifying receipt\nAt this point, we could run whatever email tool we normally use to access our mailbox\nto verify the results of these two send operations; the two new emails should show up\nin our mailbox regardless of which mail client is used to view them. Since we\u2019ve already\nwritten a Python script for reading mail, though, let\u2019s put it to use as a verification\ntool\u2014running the popmail script from the last section reveals our two new messages at\nthe end of the mail list (again parts of the output have been trimmed to conserve space\nand protect the innocent here):\nC:\\...\\PP4E\\Internet\\Email> popmail.py\nPassword for pop.secureserver.net?\nConnecting...\nb'+OK <29464.1273155506@pop08.mesa1.secureserver.net>'\nThere are 4 mail messages in 5326 bytes\n(b'+OK ', [b'1 1860', b'2 1408', b'3 1049', b'4 1009'], 32)\n--------------------------------------------------------------------------------\n[Press Enter key]\n...first two mails omitted...\nReceived: (qmail 25683 invoked from network); 6 May 2010 14:12:07 \u22120000\nReceived: from unknown (HELO p3pismtp01-018.prod.phx3.secureserver.net) ([10.6.1\n          (envelope-sender <Eric.the.Half.a.Bee@yahoo.com>)\n          by p3plsmtp06-04.prod.phx3.secureserver.net (qmail-1.03) with SMTP\n          for <PP4E@learning-python.com>; 6 May 2010 14:12:07 \u22120000\n...more deleted...\nReceived: from [66.194.109.3] by smtp.mailmt.com (ArGoSoft Mail Server .NET v.1.\n        for <PP4E@learning-python.com>; Thu, 06 May 2010 10:12:12 \u22120400\nFrom: Eric.the.Half.a.Bee@yahoo.com\nTo: PP4E@learning-python.com\nDate: Thu, 06 May 2010 14:11:07 \u22120000\nSubject: A B C D E F G\nMessage-ID: <jdlohzf0j8dp8z4x06052010101212@SMTP>\nX-FromIP: 66.194.109.3\nX-Nonspam: None\nFiddle de dum, Fiddle de dee,\nEric the half a bee.\n--------------------------------------------------------------------------------\n[Press Enter key]\nReceived: (qmail 4634 invoked from network); 6 May 2010 14:16:57 \u22120000\nReceived: from unknown (HELO p3pismtp01-025.prod.phx3.secureserver.net) ([10.6.1\n          (envelope-sender <PP4E@learning-python.com>)\n          by p3plsmtp06-05.prod.phx3.secureserver.net (qmail-1.03) with SMTP\n          for <PP4E@learning-python.com>; 6 May 2010 14:16:57 \u22120000\n...more deleted...\nReceived: from [66.194.109.3] by smtp.mailmt.com (ArGoSoft Mail Server .NET v.1.\n        for <PP4E@learning-python.com>; Thu, 06 May 2010 10:17:03 \u22120400\nFrom: PP4E@learning-python.com\nTo: PP4E@learning-python.com\nDate: Thu, 06 May 2010 14:16:31 \u22120000\nSMTP: Sending Email | 915Subject: testing smtpmail\nMessage-ID: <8fad1n462667fik006052010101703@SMTP>\nX-FromIP: 66.194.109.3\nX-Nonspam: None\nLovely Spam! Wonderful Spam!\n--------------------------------------------------------------------------------\nBye.\nNotice how the fields we input to our script show up as headers and text in the email\u2019s\nraw text delivered to the recipient. Technically, some ISPs test to make sure that at least\nthe domain of the email sender\u2019s address (the part after \u201c@\u201d) is a real, valid domain\nname, and disallow delivery if not. As mentioned earlier, some servers also require that\nSMTP senders have a direct connection to their network and may require an authen-\ntication call with username and password (described near the end of the preceding\nsection). In the second edition of the book, I used an ISP that let me get away with more\nnonsense, but this may vary per server; the rules have tightened since then to limit spam.\nManipulating both From and To\nThe first mail listed at the end of the preceding section was the one we sent with a\nfictitious sender address; the second was the more legitimate message. Like sender\naddresses, header lines are a bit arbitrary under SMTP. Our smtpmail script automati-\ncally adds From and To header lines in the message\u2019s text with the same addresses that\nare passed to the SMTP interface, but only as a polite convention. Sometimes, though,\nyou can\u2019t tell who a mail was sent to, either\u2014to obscure the target audience or to\nsupport legitimate email lists, senders may manipulate the contents of both these head-\ners in the message\u2019s text.\nFor example, if we change smtpmail to not automatically generate a \u201cTo:\u201d header line\nwith the same address(es) sent to the SMTP interface call:\ntext = ('From: %s\\nDate: %s\\nSubject: %s\\n' % (From, Date, Subj))\nwe can then manually type a \u201cTo:\u201d header that differs from the address we\u2019re really\nsending to\u2014the \u201cTo\u201d address list passed into the smtplib send call gives the true re-\ncipients, but the \u201cTo:\u201d header line in the text of the message is what most mail clients\nwill display (see smtpmail-noTo.py in the examples package for the code needed to\nsupport such anonymous behavior, and be sure to type a blank line after \u201cTo:\u201d):\nC:\\...\\PP4E\\Internet\\Email> smtpmail-noTo.py\nFrom? Eric.the.Half.a.Bee@aol.com\nTo?   PP4E@learning-python.com\nSubj? a b c d e f g\nType message text, end with line=(ctrl + D or Z)\nTo: nobody.in.particular@marketing.com\nSpam; Spam and eggs; Spam, spam, and spam.\n^Z\n916 | Chapter 13:\u2002Client-Side ScriptingConnecting...\nNo errors.\nBye.\nIn some ways, the From and To addresses in send method calls and message header\nlines are similar to addresses on envelopes and letters in envelopes, respectively. The\nformer is used for routing, but the latter is what the reader sees. Here, From is fictitious\nin both places. Moreover, I gave the real To address for the account on the server, but\nthen gave a fictitious name in the manually typed \u201cTo:\u201d header line\u2014the first address\nis where it really goes and the second appears in mail clients. If your mail tool picks out\nthe \u201cTo:\u201d line, such mails will look odd when viewed.\nFor instance, when the mail we just sent shows up in my mailbox at learning-\npython.com, it\u2019s difficult to tell much about its origin or destination in the webmail\ninterface my ISP provides, as captured in Figure 13-5.\nFigure 13-5. Anonymous mail in a web-mail client (see also ahead: PyMailGUI)\nFurthermore, this email\u2019s raw text won\u2019t help unless we look closely at the \u201cReceived:\u201d\nheaders added by the machines it has been routed through:\nC:\\...\\PP4E\\Internet\\Email> popmail.py\nPassword for pop.secureserver.net?\nConnecting...\nb'+OK <4802.1273156821@p3plpop03-03.prod.phx3.secureserver.net>'\nThere are 5 mail messages in 6364 bytes\n(b'+OK ', [b'1 1860', b'2 1408', b'3 1049', b'4 1009', b'5 1038'], 40)\nSMTP: Sending Email | 917--------------------------------------------------------------------------------\n[Press Enter key]\n...first three mails omitted...\nReceived: (qmail 30325 invoked from network); 6 May 2010 14:33:45 \u22120000\nReceived: from unknown (HELO p3pismtp01-004.prod.phx3.secureserver.net) ([10.6.1\n          (envelope-sender <Eric.the.Half.a.Bee@aol.com>)\n          by p3plsmtp06-03.prod.phx3.secureserver.net (qmail-1.03) with SMTP\n          for <PP4E@learning-python.com>; 6 May 2010 14:33:45 \u22120000\n...more deleted...\nReceived: from [66.194.109.3] by smtp.mailmt.com (ArGoSoft Mail Server .NET v.1.\n        for <PP4E@learning-python.com>; Thu, 06 May 2010 10:33:16 \u22120400\nFrom: Eric.the.Half.a.Bee@aol.com\nDate: Thu, 06 May 2010 14:32:32 \u22120000\nSubject: a b c d e f g\nTo: nobody.in.particular@marketing.com\nMessage-ID: <66koqg66e0q1c8hl06052010103316@SMTP>\nX-FromIP: 66.194.109.3\nX-Nonspam: None\nSpam; Spam and eggs; Spam, spam, and spam.\n--------------------------------------------------------------------------------\nBye.\nOnce again, though, don\u2019t do this unless you have good cause. This demonstration is\nintended only to help you understand how mail headers factor into email processing.\nTo write an automatic spam filter that deletes incoming junk mail, for instance, you\nneed to know some of the telltale signs to look for in a message\u2019s text. Spamming\ntechniques have grown much more sophisticated than simply forging sender and re-\ncipient names, of course (you\u2019ll find much more on the subject on the Web at large and\nin the SpamBayes mail filter written in Python), but it\u2019s one common trick.\nOn the other hand, such To address juggling may also be useful in the context of le-\ngitimate mailing lists\u2014the name of the list appears in the \u201cTo:\u201d header when the mes-\nsage is viewed, not the potentially many individual recipients named in the send-mail\ncall. As the next section\u2019s example demonstrates, a mail client can simply send a mail\nto all on the list but insert the general list name in the \u201cTo:\u201d header.\nBut in other contexts, sending email with bogus \u201cFrom:\u201d and \u201cTo:\u201d lines is equivalent\nto making anonymous phone calls. Most mailers won\u2019t even let you change the From\nline, and they don\u2019t distinguish between the To address and header line. When you\nprogram mail scripts of your own, though, SMTP is wide open in this regard. So be\ngood out there, OK?\n918 | Chapter 13:\u2002Client-Side ScriptingDoes Anybody Really Know What Time It Is?\nIn the prior version of the smtpmail script of Example 13-19, a simple date format was\nused for the Date email header that didn\u2019t quite follow the SMTP date formatting\nstandard:\n>>> import time\n>>> time.asctime()\n'Wed May 05 17:52:05 2010'\nMost servers don\u2019t care and will let any sort of date text appear in date header lines, or\neven add one if needed. Clients are often similarly forgiving, but not always; one of my\nISP webmail programs shows dates correctly anyhow, but another leaves such ill-\nformed dates blank in mail displays. If you want to be more in line with the standard,\nyou could format the date header with code like this (the result can be parsed with\nstandard tools such as the time.strptime call):\nimport time\ngmt = time.gmtime(time.time())\nfmt = '%a, %d %b %Y %H:%M:%S GMT'\nstr = time.strftime(fmt, gmt)\nhdr = 'Date: ' + str\nprint(hdr)\nThe hdr variable\u2019s value looks like this when this code is run:\nDate: Wed, 05 May 2010 21:49:32 GMT\nThe time.strftime call allows arbitrary date and time formatting; time.asctime is just\none standard format. Better yet, do what smtpmail does now\u2014in the newer email pack-\nage (described in this chapter), an email.utils call can be used to properly format date\nand time automatically. The smtpmail script uses the first of the following format\nalternatives:\n>>> import email.utils\n>>> email.utils.formatdate()\n'Wed, 05 May 2010 21:54:28 \u22120000'\n>>> email.utils.formatdate(localtime=True)\n'Wed, 05 May 2010 17:54:52 \u22120400'\n>>> email.utils.formatdate(usegmt=True)\n'Wed, 05 May 2010 21:55:22 GMT'\nSee the pymail and mailtools examples in this chapter for additional usage examples;\nthe latter is reused by the larger PyMailGUI and PyMailCGI email clients later in this\nbook.\nSending Email at the Interactive Prompt\nSo where are we in the Internet abstraction model now? With all this email fetching\nand sending going on, it\u2019s easy to lose the forest for the trees. Keep in mind that because\nmail is transferred over sockets (remember sockets?), they are at the root of all this\nactivity. All email read and written ultimately consists of formatted bytes shipped over\nSMTP: Sending Email | 919sockets between computers on the Net. As we\u2019ve seen, though, the POP and SMTP\ninterfaces in Python hide all the details. Moreover, the scripts we\u2019ve begun writing even\nhide the Python interfaces and provide higher-level interactive tools.\nBoth the popmail and smtpmail scripts provide portable email tools but aren\u2019t quite what\nwe\u2019d expect in terms of usability these days. Later in this chapter, we\u2019ll use what we\u2019ve\nseen thus far to implement a more interactive, console-based mail tool. In the next\nchapter, we\u2019ll also code a tkinter email GUI, and then we\u2019ll go on to build a web-based\ninterface in a later chapter. All of these tools, though, vary primarily in terms of user\ninterface only; each ultimately employs the Python mail transfer modules we\u2019ve met\nhere to transfer mail message text over the Internet with sockets.\nBefore we move on, one more SMTP note: just as for reading mail, we can use the\nPython interactive prompt as our email sending client, too, if we type calls manually.\nThe following, for example, sends a message through my ISP\u2019s SMTP server to two\nrecipient addresses assumed to be part of a mail list:\nC:\\...\\PP4E\\Internet\\Email> python\n>>> from smtplib import SMTP\n>>> conn = SMTP('smtpout.secureserver.net')\n>>> conn.sendmail(\n... 'PP4E@learning-python.com',                           # true sender\n... ['lutz@rmi.net', 'PP4E@learning-python.com'],         # true recipients\n... \"\"\"From: PP4E@learning-python.com\n... To: maillist\n... Subject: test interactive smtplib\n...\n... testing 1 2 3...\n... \"\"\")\n{}\n>>> conn.quit()                                # quit() required, Date added\n(221, b'Closing connection. Good bye.')\nWe\u2019ll verify receipt of this message in a later email client program; the \u201cTo\u201d recipient\nshows up as \u201cmaillist\u201d in email clients\u2014a completely valid use case for header manip-\nulation. In fact, you can achieve the same effect with the smtpmail-noTo script by sep-\narating recipient addresses at the \u201cTo?\u201d prompt with a semicolon (e.g. lutz@rmi.net;\nPP4E@learning-python.com) and typing the email list\u2019s name in the \u201cTo:\u201d header line.\nMail clients that support mailing lists automate such steps.\nSending mail interactively this way is a bit tricky to get right, though\u2014header lines are\ngoverned by standards: the blank line after the subject line is required and significant,\nfor instance, and Date is omitted altogether (one is added for us). Furthermore, mail\nformatting gets much more complex as we start writing messages with attachments. In\npractice, the email package in the standard library is generally used to construct emails,\nbefore shipping them off with smtplib. The package lets us build mails by assigning\nheaders and attaching and possibly encoding parts, and creates a correctly formatted\nmail text. To learn how, let\u2019s move on to the next section.\n920 | Chapter 13:\u2002Client-Side Scriptingemail: Parsing and Composing Mail Content\nThe second edition of this book used a handful of standard library modules (rfc822,\nStringIO, and more) to parse the contents of messages, and simple text processing to\ncompose them. Additionally, that edition included a section on extracting and decoding\nattached parts of a message using modules such as mhlib, mimetools, and base64.\nIn the third edition, those tools were still available, but were, frankly, a bit clumsy and\nerror-prone. Parsing attachments from messages, for example, was tricky, and com-\nposing even basic messages was tedious (in fact, an early printing of the prior edition\ncontained a potential bug, because it omitted one \\n character in a string formatting\noperation). Adding attachments to sent messages wasn\u2019t even attempted, due to the\ncomplexity of the formatting involved. Most of these tools are gone completely in Py-\nthon 3.X as I write this fourth edition, partly because of their complexity, and partly\nbecause they\u2019ve been made obsolete.\nLuckily, things are much simpler today. After the second edition, Python sprouted a\nnew email package\u2014a powerful collection of tools that automate most of the work\nbehind parsing and composing email messages. This module gives us an object-based\nmessage interface and handles all the textual message structure details, both analyzing\nand creating it. Not only does this eliminate a whole class of potential bugs, it also\npromotes more advanced mail processing.\nThings like attachments, for instance, become accessible to mere mortals (and authors\nwith limited book real estate). In fact, an entire original section on manual attachment\nparsing and decoding was deleted in the third edition\u2014it\u2019s essentially automatic with\nemail. The new package parses and constructs headers and attachments; generates\ncorrect email text; decodes and encodes Base64, quoted-printable, and uuencoded\ndata; and much more.\nWe won\u2019t cover the email package in its entirety in this book; it is well documented in\nPython\u2019s library manual. Our goal here is to explore some example usage code, which\nyou can study in conjunction with the manuals. But to help get you started, let\u2019s begin\nwith a quick overview. In a nutshell, the email package is based around the Message\nobject it provides:\nParsing mail\nA mail\u2019s full text, fetched from poplib or imaplib, is parsed into a new Message\nobject, with an API for accessing its components. In the object, mail headers be-\ncome dictionary-like keys, and components become a \u201cpayload\u201d that can be\nwalked with a generator interface (more on payloads in a moment).\nCreating mail\nNew mails are composed by creating a new Message object, using an API to attach\nheaders and parts, and asking the object for its print representation\u2014a correctly\nformatted mail message text, ready to be passed to the smtplib module for delivery.\nHeaders are added by key assignment and attachments by method calls.\nemail: Parsing and Composing Mail Content | 921In other words, the Message object is used both for accessing existing messages and for\ncreating new ones from scratch. In both cases, email can automatically handle details\nlike content encodings (e.g., attached binary images can be treated as text with Base64\nencoding and decoding), content types, and more.\nMessage Objects\nSince the email module\u2019s Message object is at the heart of its API, you need a cursory\nunderstanding of its form to get started. In short, it is designed to reflect the structure\nof a formatted email message. Each Message consists of three main pieces of\ninformation:\nType\nA content type (plain text, HTML text, JPEG image, and so on), encoded as a\nMIME main type and a subtype. For instance, \u201ctext/html\u201d means the main type is\ntext and the subtype is HTML (a web page); \u201cimage/jpeg\u201d means a JPEG photo.\nA \u201cmultipart/mixed\u201d type means there are nested parts within the message.\nHeaders\nA dictionary-like mapping interface, with one key per mail header (From, To, and\nso on). This interface supports almost all of the usual dictionary operations, and\nheaders may be fetched or set by normal key indexing.\nContent\nA \u201cpayload,\u201d which represents the mail\u2019s content. This can be either a string\n(bytes or str) for simple messages, or a list of additional Message objects for\nmultipart container messages with attached or alternative parts. For some oddball\ntypes, the payload may be a Python None object.\nThe MIME type of a Message is key to understanding its content. For example, mails\nwith attached images may have a main top-level Message (type multipart/mixed), with\nthree more Message objects in its payload\u2014one for its main text (type text/plain),\nfollowed by two of type image for the photos (type image/jpeg). The photo parts may\nbe encoded for transmission as text with Base64 or another scheme; the encoding type,\nas well as the original image filename, are specified in the part\u2019s headers.\nSimilarly, mails that include both simple text and an HTML alternative will have two\nnested Message objects in their payload, of type plain text (text/plain) and HTML text\n(text/html), along with a main root Message of type multipart/alternative. Your mail\nclient decides which part to display, often based on your preferences.\nSimpler messages may have just a root Message of type text/plain or text/html, repre-\nsenting the entire message body. The payload for such mails is a simple string. They\nmay also have no explicitly given type at all, which generally defaults to text/plain.\nSome single-part messages are text/html, with no text/plain alternative\u2014they require\na web browser or other HTML viewer (or a very keen-eyed user).\n922 | Chapter 13:\u2002Client-Side ScriptingOther combinations are possible, including some types that are not commonly seen in\npractice, such as message/delivery status. Most messages have a main text part, though\nit is not required, and may be nested in a multipart or other construct.\nIn all cases, an email message is a simple, linear string, but these message structures are\nautomatically detected when mail text is parsed and are created by your method calls\nwhen new messages are composed. For instance, when creating messages, the message\nattach method adds parts for multipart mails, and set_payload sets the entire payload\nto a string for simple mails.\nMessage objects also have assorted properties (e.g., the filename of an attachment), and\nthey provide a convenient walk generator method, which returns the next Message in\nthe payload each time through in a for loop or other iteration context. Because the\nwalker yields the root Message object first (i.e., self), single-part messages don\u2019t have\nto be handled as a special case; a nonmultipart message is effectively a Message with a\nsingle item in its payload\u2014itself.\nUltimately, the Message object structure closely mirrors the way mails are formatted as\ntext. Special header lines in the mail\u2019s text give its type (e.g., plain text or multipart),\nas well as the separator used between the content of nested parts. Since the underlying\ntextual details are automated by the email package\u2014both when parsing and when\ncomposing\u2014we won\u2019t go into further formatting details here.\nIf you are interested in seeing how this translates to real emails, a great way to learn\nmail structure is by inspecting the full raw text of messages displayed by email clients\nyou already use, as we\u2019ll see with some we meet in this book. In fact, we\u2019ve already seen\na few\u2014see the raw text printed by our earlier POP email scripts for simple mail text\nexamples. For more on the Message object, and email in general, consult the email\npackage\u2019s entry in Python\u2019s library manual. We\u2019re skipping details such as its available\nencoders and MIME object classes here in the interest of space.\nBeyond the email package, the Python library includes other tools for mail-related pro-\ncessing. For instance, mimetypes maps a filename to and from a MIME type:\nmimetypes.guess_type(filename)\nMaps a filename to a MIME type. Name spam.txt maps to text/plan.\nmimetypes.guess_extension(contype)\nMaps a MIME type to a filename extension. Type text/html maps to .html.\nWe also used the mimetypes module earlier in this chapter to guess FTP transfer modes\nfrom filenames (see Example 13-10), as well as in Chapter 6, where we used it to guess\na media player for a filename (see the examples there, including playfile.py, Exam-\nple 6-23). For email, these can come in handy when attaching files to a new message\n(guess_type) and saving parsed attachments that do not provide a filename\n(guess_extension). In fact, this module\u2019s source code is a fairly complete reference to\nMIME types. See the library manual for more on these tools.\nemail: Parsing and Composing Mail Content | 923Basic email Package Interfaces in Action\nAlthough we can\u2019t provide an exhaustive reference here, let\u2019s step through a simple\ninteractive session to illustrate the fundamentals of email processing. To compose the\nfull text of a message\u2014to be delivered with smtplib, for instance\u2014make a Message,\nassign headers to its keys, and set its payload to the message body. Converting to a\nstring yields the mail text. This process is substantially simpler and less error-prone\nthan the manual text operations we used earlier in Example 13-19 to build mail as\nstrings:\n>>> from email.message import Message\n>>> m = Message()\n>>> m['from'] = 'Jane Doe <jane@doe.com>'\n>>> m['to']   = 'PP4E@learning-python.com'\n>>> m.set_payload('The owls are not what they seem...')\n>>>\n>>> s = str(m)\n>>> print(s)\nfrom: Jane Doe <jane@doe.com>\nto: PP4E@learning-python.com\nThe owls are not what they seem...\nParsing a message\u2019s text\u2014like the kind you obtain with poplib\u2014is similarly simple,\nand essentially the inverse: we get back a Message object from the text, with keys for\nheaders and a payload for the body:\n>>> s    # same as in prior interaction\n'from: Jane Doe <jane@doe.com>\\nto: PP4E@learning-python.com\\n\\nThe owls are not...'\n>>> from email.parser import Parser\n>>> x = Parser().parsestr(s)\n>>> x\n<email.message.Message object at 0x015EA9F0>\n>>>\n>>> x['From']\n'Jane Doe <jane@doe.com>'\n>>> x.get_payload()\n'The owls are not what they seem...'\n>>> x.items()\n[('from', 'Jane Doe <jane@doe.com>'), ('to', 'PP4E@learning-python.com')]\nSo far this isn\u2019t much different from the older and now-defunct rfc822 module, but as\nwe\u2019ll see in a moment, things get more interesting when there is more than one part.\nFor simple messages like this one, the message walk generator treats it as a single-part\nmail, of type plain text:\n>>> for part in x.walk():\n...     print(x.get_content_type())\n...     print(x.get_payload())\n...\ntext/plain\nThe owls are not what they seem...\n924 | Chapter 13:\u2002Client-Side ScriptingHandling multipart messages\nMaking a mail with attachments is a little more work, but not much: we just make a\nroot Message and attach nested Message objects created from the MIME type object that\ncorresponds to the type of data we\u2019re attaching. The MIMEText class, for instance, is a\nsubclass of Message, which is tailored for text parts, and knows how to generate the\nright types of header information when printed. MIMEImage and MIMEAudio similarly cus-\ntomize Message for images and audio, and also know how to apply Base64 and other\nMIME encodings to binary data. The root message is where we store the main headers\nof the mail, and we attach parts here, instead of setting the entire payload\u2014the payload\nis a list now, not a string. MIMEMultipart is a Message that provides the extra header\nprotocol we need for the root:\n>>> from email.mime.multipart import MIMEMultipart      # Message subclasses\n>>> from email.mime.text import MIMEText                # with extra headers+logic\n>>>\n>>> top = MIMEMultipart()                               # root Message object\n>>> top['from'] = 'Art <arthur@camelot.org>'            # subtype default=mixed\n>>> top['to']   = 'PP4E@learning-python.com'\n>>>\n>>> sub1 = MIMEText('nice red uniforms...\\n')           # part Message attachments\n>>> sub2 = MIMEText(open('data.txt').read())\n>>> sub2.add_header('Content-Disposition', 'attachment', filename='data.txt')\n>>> top.attach(sub1)\n>>> top.attach(sub2)\nWhen we ask for the text, a correctly formatted full mail text is returned, separators\nand all, ready to be sent with smtplib\u2014quite a trick, if you\u2019ve ever tried this by hand:\n>>> text = top.as_string()    # or do: str(top) or print(top)\n>>> print(text)\nContent-Type: multipart/mixed; boundary=\"===============1574823535==\"\nMIME-Version: 1.0\nfrom: Art <arthur@camelot.org>\nto: PP4E@learning-python.com\n--===============1574823535==\nContent-Type: text/plain; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nnice red uniforms...\n--===============1574823535==\nContent-Type: text/plain; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nContent-Disposition: attachment; filename=\"data.txt\"\nline1\nline2\nline3\n--===============1574823535==--\nemail: Parsing and Composing Mail Content | 925If we are sent this message and retrieve it via poplib, parsing its full text yields a\nMessage object just like the one we built to send. The message walk generator allows us\nto step through each part, fetching their types and payloads:\n>>> text    # same as in prior interaction\n'Content-Type: multipart/mixed; boundary=\"===============1574823535==\"\\nMIME-Ver...'\n>>> from email.parser import Parser\n>>> msg = Parser().parsestr(text)\n>>> msg['from']\n'Art <arthur@camelot.org>'\n>>> for part in msg.walk():\n...     print(part.get_content_type())\n...     print(part.get_payload())\n...     print()\n...\n multipart/mixed\n[<email.message.Message object at 0x015EC610>,\n<email.message.Message object at0x015EC630>]\ntext/plain\nnice red uniforms...\ntext/plain\nline1\nline2\nline3\nMultipart alternative messages (with text and HTML renditions of the same message)\ncan be composed and parsed in similar fashion. Because email clients are able to parse\nand compose messages with a simple object-based API, they are freed to focus on user-\ninterface instead of text processing.\nUnicode, Internationalization, and the Python 3.1 email Package\nNow that I\u2019ve shown you how \u201ccool\u201d the email package is, I unfortunately need to let\nyou know that it\u2019s not completely operational in Python 3.1. The email package works\nas shown for simple messages, but is severely impacted by Python 3.X\u2019s Unicode/bytes\nstring dichotomy in a number of ways.\nIn short, the email package in Python 3.1 is still somewhat coded to operate in the realm\nof 2.X str text strings. Because these have become Unicode in 3.X, and because some\ntools that email uses are now oriented toward bytes strings, which do not mix freely\nwith str, a variety of conflicts crop up and cause issues for programs that depend upon\nthis module.\nAt this writing, a new version of email is being developed which will handle bytes and\nUnicode encodings better, but the going consensus is that it won\u2019t be folded back into\nPython until release 3.3 or later, long after this book\u2019s release. Although a few patches\n926 | Chapter 13:\u2002Client-Side Scriptingmight make their way into 3.2, the current sense is that fully addressing the package\u2019s\nproblems appears to require a full redesign.\nTo be fair, it\u2019s a substantial problem. Email has historically been oriented toward single-\nbyte ASCII text, and generalizing it for Unicode is difficult to do well. In fact, the same\nholds true for most of the Internet today\u2014as discussed elsewhere in this chapter, FTP,\nPOP, SMTP, and even webpage bytes fetched over HTTP pose the same sorts of issues.\nInterpreting the bytes shipped over networks as text is easy if the mapping is one-to-\none, but allowing for arbitrary Unicode encoding in that text opens a Pandora\u2019s box of\ndilemmas. The extra complexity is necessary today, but, as email attests, can be a\ndaunting task.\nFrankly, I considered not releasing this edition of this book until this package\u2019s issues\ncould be resolved, but I decided to go forward because a new email package may be\nyears away (two Python releases, by all accounts). Moreover, the issues serve as a case\nstudy of the types of problems you\u2019ll run into in the real world of large-scale software\ndevelopment. Things change over time, and program code is no exception.\nInstead, this book\u2019s examples provide new Unicode and Internationalization support\nbut adopt policies to work around issues where possible. Programs in books are meant\nto be educational, after all, not commercially viable. Given the state of the email package\nthat the examples depend on, though, the solutions used here might not be completely\nuniversal, and there may be additional Unicode issues lurking. To address the future,\nwatch this book\u2019s website (described in the Preface) for updated notes and code ex-\namples if/when the anticipated new email package appears. Here, we\u2019ll work with what\nwe have.\nThe good news is that we\u2019ll be able to make use of email in its current form to build\nfairly sophisticated and full-featured email clients in this book anyhow. It still offers an\namazing number of tools, including MIME encoding and decoding, message formatting\nand parsing, Internationalized headers extraction and construction, and more. The bad\nnews is that this will require a handful of obscure workarounds and may need to be\nchanged in the future, though few software projects are exempt from such realities.\nBecause email\u2019s limitations have implications for later email code in this book, I\u2019m\ngoing to quickly run through them in this section. Some of this can be safely saved for\nlater reference, but parts of later examples may be difficult to understand if you don\u2019t\nhave this background. The upside is that exploring the package\u2019s limitations here also\nserves as a vehicle for digging a bit deeper into the email package\u2019s interfaces in general.\nParser decoding requirement\nThe first Unicode issue in Python3.1\u2019s email package is nearly a showstopper in some\ncontexts: the bytes strings of the sort produced by poplib for mail fetches must be\ndecoded to str prior to parsing with email. Unfortunately, because there may not be\nenough information to know how to decode the message bytes per Unicode, some\nclients of this package may need to be generalized to detect whole-message encodings\nemail: Parsing and Composing Mail Content | 927prior to parsing; in worst cases other than email that may mandate mixed data types,\nthe current package cannot be used at all. Here\u2019s the issue live:\n>>> text    # from prior example in his section\n'Content-Type: multipart/mixed; boundary=\"===============1574823535==\"\\nMIME-Ver...'\n>>> btext = text.encode()\n>>> btext\nb'Content-Type: multipart/mixed; boundary=\"===============1574823535==\"\\nMIME-Ve...'\n>>> msg = Parser().parsestr(text)           # email parser expects Unicode str\n>>> msg = Parser().parsestr(btext)          # but poplib fetches email as bytes!\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"C:\\Python31\\lib\\email\\parser.py\", line 82, in parsestr\n    return self.parse(StringIO(text), headersonly=headersonly)\nTypeError: initial_value must be str or None, not bytes\n>>> msg = Parser().parsestr(btext.decode())               # okay per default\n>>> msg = Parser().parsestr(btext.decode('utf8'))         # ascii encoded (default)\n>>> msg = Parser().parsestr(btext.decode('latin1'))       # ascii is same in all 3\n>>> msg = Parser().parsestr(btext.decode('ascii'))\nThis is less than ideal, as a bytes-based email would be able to handle message encod-\nings more directly. As mentioned, though, the email package is not really fully func-\ntional in Python 3.1, because of its legacy str focus, and the sharp distinction that\nPython 3.X makes between Unicode text and byte strings. In this case, its parser should\naccept bytes and not expect clients to know how to decode.\nBecause of that, this book\u2019s email clients take simplistic approaches to decoding fetched\nmessage bytes to be parsed by email. Specifically, full-text decoding will try a user-\nconfigurable encoding name, then fall back on trying common types as a heuristic, and\nfinally attempt to decode just message headers.\nThis will suffice for the examples shown but may need to be enhanced for broader\napplicability. In some cases, encoding may have to be determined by other schemes\nsuch as inspecting email headers (if present at all), guessing from bytes structure\nanalysis, or dynamic user feedback. Adding such enhancements in a robust fashion is\nlikely too complex to attempt in a book\u2019s example code, and it is better performed in\ncommon standard library tools in any event.\nReally, robust decoding of mail text may not be possible today at all, if it requires\nheaders inspections\u2014we can\u2019t inspect a message\u2019s encoding information headers un-\nless we parse the message, but we can\u2019t parse a message with 3.1\u2019s email package unless\nwe already know the encoding. That is, scripts may need to parse in order to decode,\nbut they need to decode in order to parse! The byte strings of poplib and Unicode strings\nof email in 3.1 are fundamentally at odds. Even within its own libraries, Python 3.X\u2019s\nchanges have created a chicken-and-egg dependency problem that still exists nearly\ntwo years after 3.0\u2019s release.\n928 | Chapter 13:\u2002Client-Side ScriptingShort of writing our own email parser, or pursuing other similarly complex approaches,\nthe best bet today for fetched messages seems to be decoding per user preferences and\ndefaults, and that\u2019s how we\u2019ll proceed in this edition. The PyMailGUI client of Chap-\nter 14, for instance, will allow Unicode encodings for full mail text to be set on a per-\nsession basis.\nThe real issue, of course, is that email in general is inherently complicated by the pres-\nence of arbitrary text encodings. Besides full mail text, we also must consider Unicode\nencoding issues for the text components of a message once it\u2019s parsed\u2014both its text\nparts and its message headers. To see why, let\u2019s move on.\nRelated Issue for CGI scripts: I should also note that the full text decoding\nissue may not be as large a factor for email as it is for some other\nemail package clients. Because the original email standards call for\nASCII text and require binary data to be MIME encoded, most emails\nare likely to decode properly according to a 7- or 8-bit encoding such as\nLatin-1.\nAs we\u2019ll see in Chapter 15, though, a more insurmountable and related\nissue looms for server-side scripts that support CGI file uploads on the\nWeb\u2014because Python\u2019s CGI module also uses the email package to\nparse multipart form data; because this package requires data to be de-\ncoded to str for parsing; and because such data might have mixed text\nand binary data (included raw binary data that is not MIME-encoded,\ntext of any encoding, and even arbitrary combinations of these), these\nuploads fail in Python 3.1 if any binary or incompatible text files are\nincluded. The cgi module triggers Unicode decoding or type errors in-\nternally, before the Python script has a chance to intervene.\nCGI uploads worked in Python 2.X, because the str type represented\nboth possibly encoded text and binary data. Saving this type\u2019s content\nto a binary mode file as a string of bytes in 2.X sufficed for both arbitrary\ntext and binary data such as images. Email parsing worked in 2.X for\nthe same reason. For better or worse, the 3.X str/bytes dichotomy\nmakes this generality impossible.\nIn other words, although we can generally work around the email\nparser\u2019s str requirement for fetched emails by decoding per an 8-bit\nencoding, it\u2019s much more malignant for web scripting today. Watch for\nmore details on this in Chapter 15, and stay tuned for a future fix, which\nmay have materialized by the time you read these words.\nText payload encodings: Handling mixed type results\nOur next email Unicode issue seems to fly in the face of Python\u2019s generic programming\nmodel: the data types of message payload objects may differ, depending on how they\nare fetched. Especially for programs that walk and process payloads of mail parts\ngenerically, this complicates code.\nemail: Parsing and Composing Mail Content | 929Specifically, the Message object\u2019s get_payload method we used earlier accepts an op-\ntional decode argument to control automatic email-style MIME decoding (e.g., Base64,\nuuencode, quoted-printable). If this argument is passed in as 1 (or equivalently, True),\nthe payload\u2019s data is MIME-decoded when fetched, if required. Because this argument\nis so useful for complex messages with arbitrary parts, it will normally be passed as true\nin all cases. Binary parts are normally MIME-encoded, but even text parts might also\nbe present in Base64 or another MIME form if their bytes fall outside email standards.\nSome types of Unicode text, for example, require MIME encoding.\nThe upshot is that get_payload normally returns str strings for str text parts, but re-\nturns bytes strings if its decode argument is true\u2014even if the message part is known to\nbe text by nature. If this argument is not used, the payload\u2019s type depends upon how\nit was set: str or bytes. Because Python 3.X does not allow str and bytes to be mixed\nfreely, clients that need to use the result in text processing or store it in files need to\naccommodate the difference. Let\u2019s run some code to illustrate:\n>>> from email.message import Message\n>>> m = Message()\n>>> m['From'] = 'Lancelot'\n>>> m.set_payload('Line?...')\n>>> m['From']\n'Lancelot'\n>>> m.get_payload()                 # str, if payload is str\n'Line?...'\n>>> m.get_payload(decode=1)         # bytes, if MIME decode (same as decode=True)\nb'Line?...'\nThe combination of these different return types and Python 3.X\u2019s strict str/bytes di-\nchotomy can cause problems in code that processes the result unless they decode\ncarefully:\n>>> m.get_payload(decode=True) + 'spam'                        # can't mix in 3.X!\nTypeError: can't concat bytes to str\n>>> m.get_payload(decode=True).decode() + 'spam'               # convert if required\n'Line?...spam'\nTo make sense of these examples, it may help to remember that there are two different\nconcepts of \u201cencoding\u201d for email text:\n\u2022 Email-style MIME encodings such as Base64, uuencode, and quoted-printable,\nwhich are applied to binary and otherwise unusual content to make them accept-\nable for transmission in email text\n\u2022 Unicode text encodings for strings in general, which apply to message text as well\nas its parts, and may be required after MIME encoding for text message parts\nThe email package handles email-style MIME encodings automatically when we pass\ndecode=1 to fetch parsed payloads, or generate text for messages that have nonprintable\nparts, but scripts still need to take Unicode encodings into consideration because of\n930 | Chapter 13:\u2002Client-Side ScriptingPython 3.X\u2019s sharp string types differentiation. For example, the first decode in the\nfollowing refers to MIME, and the second to Unicode:\nm.get_payload(decode=True).decode()  # to bytes via MIME, then to str via Unicode\nEven without the MIME decode argument, the payload type may also differ if it is stored\nin different forms:\n>>> m = Message(); m.set_payload('spam'); m.get_payload()      # fetched as stored\n'spam'\n>>> m = Message(); m.set_payload(b'spam'); m.get_payload()\nb'spam'\nMoreover, the same hold true for the text-specific MIME subclass (though as we\u2019ll see\nlater in this section, we cannot pass a bytes to its constructor to force a binary payload):\n>>> from email.mime.text import MIMEText\n>>> m = MIMEText('Line...?')\n>>> m['From'] = 'Lancelot'\n>>> m['From']\n'Lancelot'\n>>> m.get_payload()\n'Line...?'\n>>> m.get_payload(decode=1)\nb'Line...?'\nUnfortunately, the fact that payloads might be either str or bytes today not only flies\nin the face of Python\u2019s type-neutral mindset, it can complicate your code\u2014scripts may\nneed to convert in contexts that require one or the other type. For instance, GUI libraries\nmight allow both, but file saves and web page content generation may be less flexible.\nIn our example programs, we\u2019ll process payloads as bytes whenever possible, but de-\ncode to str text in cases where required using the encoding information available in\nthe header API described in the next section.\nText payload encodings: Using header information to decode\nMore profoundly, text in email can be even richer than implied so far\u2014in principle,\ntext payloads of a single message may be encoded in a variety of different Unicode\nschemes (e.g., three HTML webpage file attachments, all in different Unicode encod-\nings, and possibly different than the full message text\u2019s encoding). Although treating\nsuch text as binary byte strings can sometimes finesse encoding issues, saving such parts\nin text-mode files for opening must respect the original encoding types. Further, any\ntext processing performed on such parts will be similarly type-specific.\nLuckily, the email package both adds character-set headers when generating message\ntext and retains character-set information for parts if it is present when parsing message\ntext. For instance, adding non-ASCII text attachments simply requires passing in an\nencoding name\u2014the appropriate message headers are added automatically on text\ngeneration, and the character set is available directly via the get_content_charset\nmethod:\nemail: Parsing and Composing Mail Content | 931>>> s = b'A\\xe4B'\n>>> s.decode('latin1')\n'A\u00e4B'\n>>> from email.message import Message\n>>> m = Message()\n>>> m.set_payload(b'A\\xe4B', charset='latin1')       # or 'latin-1': see ahead\n>>> t = m.as_string()\n>>> print(t)\nMIME-Version: 1.0\nContent-Type: text/plain; charset=\"latin1\"\nContent-Transfer-Encoding: base64\nQeRC\n>>> m.get_content_charset()\n'latin1'\nNotice how email automatically applies Base64 MIME encoding to non-ASCII text\nparts on generation, to conform to email standards. The same is true for the more\nspecific MIME text subclass of Message:\n>>> from email.mime.text import MIMEText\n>>> m = MIMEText(b'A\\xe4B', _charset='latin1')\n>>> t = m.as_string()\n>>> print(t)\nContent-Type: text/plain; charset=\"latin1\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: base64\nQeRC\n>>> m.get_content_charset()\n'latin1'\nNow, if we parse this message\u2019s text string with email, we get back a new Message whose\ntext payload is the Base64 MIME-encoded text used to represent the non-ASCII Uni-\ncode string. Requesting MIME decoding for the payload with decode=1 returns the byte\nstring we originally attached:\n>>> from email.parser import Parser\n>>> q = Parser().parsestr(t)\n>>> q\n<email.message.Message object at 0x019ECA50>\n>>> q.get_content_type()\n'text/plain'\n>>> q._payload\n'QeRC\\n'\n>>> q.get_payload()\n'QeRC\\n'\n>>> q.get_payload(decode=1)\nb'A\\xe4B'\nHowever, running Unicode decoding on this byte string to convert to text fails if we\nattempt to use the platform default on Windows (UTF8). To be more accurate, and\n932 | Chapter 13:\u2002Client-Side Scriptingsupport a wide variety of text types, we need to use the character-set information saved\nby the parser and attached to the Message object. This is especially important if we need\nto save the data to a file\u2014we either have to store as bytes in binary mode files, or specify\nthe correct (or at least a compatible) Unicode encoding in order to use such strings for\ntext-mode files. Decoding manually works the same way:\n>>> q.get_payload(decode=1).decode()\nUnicodeDecodeError: 'utf8' codec can't decode bytes in position 1-2: unexpected\n>>> q.get_content_charset()\n'latin1'\n>>> q.get_payload(decode=1).decode('latin1')                    # known type\n'A\u00e4B'\n>>> q.get_payload(decode=1).decode(q.get_content_charset())     # allow any type\n'A\u00e4B'\nIn fact, all the header details are available on Message objects, if we know where to look.\nThe character set can also be absent entirely, in which case it\u2019s returned as None; clients\nneed to define policies for such ambiguous text (they might try common types, guess,\nor treat the data as a raw byte string):\n>>> q['content-type']                                     # mapping interface\n'text/plain; charset=\"latin1\"'\n>>> q.items()\n[('Content-Type', 'text/plain; charset=\"latin1\"'), ('MIME-Version', '1.0'),\n('Content-Transfer-Encoding', 'base64')]\n>> q.get_params(header='Content-Type')                    # param interface\n[('text/plain', ''), ('charset', 'latin1')]\n>>> q.get_param('charset', header='Content-Type')\n'latin1'\n>>> charset = q.get_content_charset()                     # might be missing\n>>> if charset:\n...    print(q.get_payload(decode=1).decode(charset))\n...\nA\u00e4B\nThis handles encodings for message text parts in parsed emails. For composing new\nemails, we still must apply session-wide user settings or allow the user to specify an\nencoding for each part interactively. In some of this book\u2019s email clients, payload con-\nversions are performed as needed\u2014using encoding information in message headers\nafter parsing and provided by users during mail composition.\nMessage header encodings: email package support\nOn a related note, the email package also provides support for encoding and decoding\nmessage headers themselves (e.g., From, Subject) per email standards when they are\nnot simple text. Such headers are often called Internationalized (or i18n) headers, be-\ncause they support inclusion of non-ASCII character set text in emails. This term is also\nsometimes used to refer to encoded text of message payloads; unlike message headers,\nemail: Parsing and Composing Mail Content | 933though, message payload encoding is used for both international Unicode text and truly\nbinary data such as images (as we\u2019ll see in the next section).\nLike mail payload parts, i18n headers are encoded specially for email, and may also be\nencoded per Unicode. For instance, here\u2019s how to decode an encoded subject line from\nan arguably spammish email that just showed up in my inbox; its =?UTF-8?Q? preamble\ndeclares that the data following it is UTF-8 encoded Unicode text, which is also MIME-\nencoded per quoted-printable for transmission in email (in short, unlike the prior sec-\ntion\u2019s part payloads, which declare their encodings in separate header lines, headers\nthemselves may declare their Unicode and MIME encodings by embedding them in\ntheir own content this way):\n>>> rawheader = '=?UTF-8?Q?Introducing=20Top=20Values=3A=20A=20Special=20Selecti\non=20of=20Great=20Money=20Savers?='\n>>> from email.header import decode_header        # decode per email+MIME\n>>> decode_header(rawheader)\n[(b'Introducing Top Values: A Special Selection of Great Money Savers', 'utf-8')]\n>>> bin, enc = decode_header(rawheader)[0]        # and decode per Unicode\n>>> bin, enc\n(b'Introducing Top Values: A Special Selection of Great Money Savers', 'utf-8')\n>>> bin.decode(enc)\n'Introducing Top Values: A Special Selection of Great Money Savers'\nSubtly, the email package can return multiple parts if there are encoded substrings in\nthe header, and each must be decoded individually and joined to produce decoded\nheader text. Even more subtly, in 3.1, this package returns all bytes when any substring\n(or the entire header) is encoded but returns str for a fully unencoded header, and\nuncoded substrings returned as bytes are encoded per \u201craw-unicode-escape\u201d in the\npackage\u2014an encoding scheme useful to convert str to bytes when no encoding type\napplies:\n>>> from email.header import decode_header\n>>> S1 = 'Man where did you get that assistant?'\n>>> S2 = '=?utf-8?q?Man_where_did_you_get_that_assistant=3F?='\n>>> S3 = 'Man where did you get that =?UTF-8?Q?assistant=3F?='\n# str: don't decode()\n>>> decode_header(S1)\n[('Man where did you get that assistant?', None)]\n# bytes: do decode()\n>>> decode_header(S2)\n[(b'Man where did you get that assistant?', 'utf-8')]\n# bytes: do decode() using raw-unicode-escape applied in package\n>>> decode_header(S3)\n[(b'Man where did you get that', None), (b'assistant?', 'utf-8')]\n# join decoded parts if more than one\n934 | Chapter 13:\u2002Client-Side Scripting>>> parts = decode_header(S3)\n>>> ' '.join(abytes.decode('raw-unicode-escape' if enc == None else enc)\n...          for (abytes, enc) in parts)\n'Man where did you get that assistant?'\nWe\u2019ll use logic similar to the last step here in the mailtools package ahead, but also\nretain str substrings intact without attempting to decode.\nLate-breaking news: As I write this in mid-2010, it seems possible that\nthis mixed type, nonpolymorphic, and frankly, non-Pythonic API be-\nhavior may be addressed in a future Python release. In response to a rant\nposted on the Python developers list by a book author whose work you\nmight be familiar with, there is presently a vigorous discussion of the\ntopic there. Among other ideas is a proposal for a bytes-like type which\ncarries with it an explicit Unicode encoding; this may make it possible\nto treat some text cases in a more generic fashion. While it\u2019s impossible\nto foresee the outcome of such proposals, it\u2019s good to see that the issues\nare being actively explored. Stay tuned to this book\u2019s website for further\ndevelopments in the Python 3.X library API and Unicode stories.\nMessage address header encodings and parsing, and header creation\nOne wrinkle pertaining to the prior section: for message headers that contain email\naddresses (e.g., From), the name component of the name/address pair might be encoded\nthis way as well. Because the email package\u2019s header parser expects encoded substrings\nto be followed by whitespace or the end of string, we cannot ask it to decode a complete\naddress-related header\u2014quotes around name components will fail.\nTo support such Internationalized address headers, we must also parse out the first\npart of the email address and then decode. First of all, we need to extract the name and\naddress parts of an email address using email package tools:\n>>> from email.utils import parseaddr, formataddr\n>>> p = parseaddr('\"Smith, Bob\" <bob@bob.com>')      # split into name/addr pair\n>>> p                                                # unencoded addr\n('Smith, Bob', 'bob@bob.com')\n>>> formataddr(p)\n'\"Smith, Bob\" <bob@bob.com>'\n>>> parseaddr('Bob Smith <bob@bob.com>')             # unquoted name part\n('Bob Smith', 'bob@bob.com')\n>>> formataddr(parseaddr('Bob Smith <bob@bob.com>'))\n'Bob Smith <bob@bob.com>'\n>>> parseaddr('bob@bob.com')                          # simple, no name\n('', 'bob@bob.com')\n>>> formataddr(parseaddr('bob@bob.com'))\n'bob@bob.com'\nFields with multiple addresses (e.g., To) separate individual addresses by commas.\nSince email names might embed commas, too, blindly splitting on commas to run each\nemail: Parsing and Composing Mail Content | 935though parsing won\u2019t always work. Instead, another utility can be used to parse each\naddress individually: getaddresses ignores commas in names when spitting apart sep-\narate addresses, and parseaddr does, too, because it simply returns the first pair in the\ngetaddresses result (some line breaks were added to the following for legibility):\n>>> from email.utils import getaddresses\n>>> multi = '\"Smith, Bob\" <bob@bob.com>, Bob Smith <bob@bob.com>, bob@bob.com,\n\"Bob\" <bob@bob.com>'\n>>> getaddresses([multi])\n[('Smith, Bob', 'bob@bob.com'), ('Bob Smith', 'bob@bob.com'), ('', 'bob@bob.com'),\n('Bob', 'bob@bob.com')]\n>>> [formataddr(pair) for pair in getaddresses([multi])]\n['\"Smith, Bob\" <bob@bob.com>', 'Bob Smith <bob@bob.com>', 'bob@bob.com',\n'Bob <bob@bob.com>']\n>>> ', '.join([formataddr(pair) for pair in getaddresses([multi])])\n'\"Smith, Bob\" <bob@bob.com>, Bob Smith <bob@bob.com>, bob@bob.com,\nBob <bob@bob.com>'\n>>> getaddresses(['bob@bob.com'])     # handles single address cases too\n('', 'bob@bob.com')]\nNow, decoding email addresses is really just an extra step before and after the normal\nheader decoding logic we saw earlier:\n>>> rawfromheader = '\"=?UTF-8?Q?Walmart?=\" <newsletters@walmart.com>'\n>>> from email.utils import parseaddr, formataddr\n>>> from email.header import decode_header\n>>> name, addr = parseaddr(rawfromheader)             # split into name/addr parts\n>>> name, addr\n('=?UTF-8?Q?Walmart?=', 'newsletters@walmart.com')\n>>> abytes, aenc = decode_header(name)[0]             # do email+MIME decoding\n>>> abytes, aenc\n(b'Walmart', 'utf-8')\n>>> name = abytes.decode(aenc)                        # do Unicode decoding\n>>> name\n'Walmart'\n>>> formataddr((name, addr))                          # put parts back together\n'Walmart <newsletters@walmart.com>'\nAlthough From headers will typically have just one address, to be fully robust we need\nto apply this to every address in headers, such as To, Cc, and Bcc. Again, the multiad-\ndress getaddresses utility avoids comma clashes between names and address separa-\ntors; since it also handles the single address case, it suffices for From headers as well:\n>>> rawfromheader = '\"=?UTF-8?Q?Walmart?=\" <newsletters@walmart.com>'\n>>> rawtoheader = rawfromheader + ', ' + rawfromheader\n>>> rawtoheader\n936 | Chapter 13:\u2002Client-Side Scripting'\"=?UTF-8?Q?Walmart?=\" <newsletters@walmart.com>, \"=?UTF-8?Q?Walmart?=\" <newslet\nters@walmart.com>'\n>>> pairs = getaddresses([rawtoheader])\n>>> pairs\n[('=?UTF-8?Q?Walmart?=', 'newsletters@walmart.com'), ('=?UTF-8?Q?Walmart?=', 'ne\nwsletters@walmart.com')]\n>>> addrs = []\n>>> for name, addr in pairs:\n...     abytes, aenc = decode_header(name)[0]      # email+MIME\n...     name = abytes.decode(aenc)                 # Unicode\n...     addrs.append(formataddr((name, addr)))     # one or more addrs\n...\n>>> ', '.join(addrs)\n'Walmart <newsletters@walmart.com>, Walmart <newsletters@walmart.com>'\nThese tools are generally forgiving for unencoded content and return them intact. To\nbe robust, though, the last portion of code here should also allow for multiple parts\nreturned by decode_header (for encoded substrings), None encoding values for parts (for\nunencoded substrings), and str substring values instead of bytes (for fully unencoded\nnames).\nDecoding this way applies both MIME and Unicode decoding steps to fetched mails.\nCreating properly encoded headers for inclusion in new mails composed and sent is\nsimilarly straightforward:\n>>> from email.header import make_header\n>>> hdr = make_header([(b'A\\xc4B\\xe4C', 'latin-1')])\n>>> print(hdr)\nA\u00c4B\u00e4C\n>>> print(hdr.encode())\n=?iso-8859-1?q?A=C4B=E4C?=\n>>> decode_header(hdr.encode())\n[(b'A\\xc4B\\xe4C', 'iso-8859-1')]\nThis can be applied to entire headers such as Subject, as well as the name component\nof each email address in an address-related header line such as From and To (use\ngetaddresses to split into individual addresses first if needed). The header object pro-\nvides an alternative interface; both techniques handle additional details, such as line\nlengths, for which we\u2019ll defer to Python manuals:\n>>> from email.header import Header\n>>> h = Header(b'A\\xe4B\\xc4X', charset='latin-1')\n>>> h.encode()\n'=?iso-8859-1?q?A=E4B=C4X?='\n>>>\n>>> h = Header('spam', charset='ascii')       # same as Header('spam')\n>>> h.encode()\n'spam'\nThe mailtools package ahead and its PyMailGUI client of Chapter 14 will use these\ninterfaces to automatically decode message headers in fetched mails per their content\nfor display, and to encode headers sent that are not in ASCII format. That latter also\nemail: Parsing and Composing Mail Content | 937applies to the name component of email addresses, and assumes that SMTP servers will\nallow these to pass. This may encroach on some SMTP server issues which we don\u2019t\nhave space to address in this book. See the Web for more on SMTP headers handling.\nFor more on headers decoding, see also file _test-i18n-headers.py in the examples pack-\nage; it decodes additional subject and address-related headers using mailtools\nmethods, and displays them in a tkinter Text widget\u2014a foretaste of how these will be\ndisplayed in PyMailGUI.\nWorkaround: Message text generation for binary attachment payloads is broken\nOur last two email Unicode issues are outright bugs which we must work around today,\nthough they will almost certainly be fixed in a future Python release. The first breaks\nmessage text generation for all but trivial messages\u2014the email package today no longer\nsupports generation of full mail text for messages that contain any binary parts, such\nas images or audio files. Without coding workarounds, only simple emails that consist\nentirely of text parts can be composed and generated in Python 3.1\u2019s email package;\nany MIME-encoded binary part causes mail text generation to fail.\nThis is a bit tricky to understand without poring over email\u2019s source code (which,\nthankfully, we can in the land of open source), but to demonstrate the issue, first notice\nhow simple text payloads are rendered as full message text when printed as we\u2019ve\nalready seen:\nC:\\...\\PP4E\\Internet\\Email> python\n>>> from email.message import Message            # generic message object\n>>> m = Message()\n>>> m['From'] = 'bob@bob.com'\n>>> m.set_payload(open('text.txt').read())       # payload is str text\n>>> print(m)                                     # print uses as_string()\nFrom: bob@bob.com\nspam\nSpam\nSPAM!\nAs we\u2019ve also seen, for convenience, the email package also provides subclasses of the\nMessage object, tailored to add message headers that provide the extra descriptive details\nused by email clients to know how to process the data:\n>>> from email.mime.text import MIMEText         # Message subclass with headers\n>>> text = open('text.txt').read()\n>>> m = MIMEText(text)                           # payload is str text\n>>> m['From'] = 'bob@bob.com'\n>>> print(m)\nContent-Type: text/plain; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nFrom: bob@bob.com\n938 | Chapter 13:\u2002Client-Side Scriptingspam\nSpam\nSPAM!\nThis works for text, but watch what happens when we try to render a message part\nwith truly binary data, such as an image that could not be decoded as Unicode text:\n>>> from email.message import Message            # generic Message object\n>>> m = Message()\n>>> m['From'] = 'bob@bob.com'\n>>> bytes = open('monkeys.jpg', 'rb').read()     # read binary bytes (not Unicode)\n>>> m.set_payload(bytes)                         # we set the payload to bytes\n>>> print(m)\nTraceback (most recent call last):\n  ...lines omitted...\n  File \"C:\\Python31\\lib\\email\\generator.py\", line 155, in _handle_text\n    raise TypeError('string payload expected: %s' % type(payload))\nTypeError: string payload expected: <class 'bytes'>\n>>> m.get_payload()[:20]\nb'\\xff\\xd8\\xff\\xe0\\x00\\x10JFIF\\x00\\x01\\x01\\x01\\x00x\\x00x\\x00\\x00'\nThe problem here is that the email package\u2019s text generator assumes that the message\u2019s\npayload data is a Base64 (or similar) encoded str text string by generation time, not\nbytes. Really, the error is probably our fault in this case, because we set the payload to\nraw bytes manually. We should use the MIMEImage MIME subclass tailored for images;\nif we do, the email package internally performs Base64 MIME email encoding on the\ndata when the message object is created. Unfortunately, it still leaves it as bytes, not\nstr, despite the fact the whole point of Base64 is to change binary data to text (though\nthe exact Unicode flavor this text should take may be unclear). This leads to additional\nfailures in Python 3.1:\n>>> from email.mime.image import MIMEImage       # Message sublcass with hdrs+base64\n>>> bytes = open('monkeys.jpg', 'rb').read()     # read binary bytes again\n>>> m = MIMEImage(bytes)                         # MIME class does Base64 on data\n>>> print(m)\nTraceback (most recent call last):\n  ...lines omitted...\n  File \"C:\\Python31\\lib\\email\\generator.py\", line 155, in _handle_text\n    raise TypeError('string payload expected: %s' % type(payload))\nTypeError: string payload expected: <class 'bytes'>\n>>> m.get_payload()[:40]                         # this is already Base64 text\nb'/9j/4AAQSkZJRgABAQEAeAB4AAD/2wBDAAIBAQIB'\n>>> m.get_payload()[:40].decode('ascii')         # but it's still bytes internally!\n'/9j/4AAQSkZJRgABAQEAeAB4AAD/2wBDAAIBAQIB'\nIn other words, not only does the Python 3.1 email package not fully support the Python\n3.X Unicode/bytes dichotomy, it was actually broken by it. Luckily, there\u2019s a work-\naround for this case.\nTo address this specific issue, I opted to create a custom encoding function for binary\nMIME attachments, and pass it in to the email package\u2019s MIME message object\nemail: Parsing and Composing Mail Content | 939subclasses for all binary data types. This custom function is coded in the upcoming\nmailtools package of this chapter (Example 13-23). Because it is used by email to en-\ncode from bytes to text at initialization time, it is able to decode to ASCII text per\nUnicode as an extra step, after running the original call to perform Base64 encoding\nand arrange content-encoding headers. The fact that email does not do this extra Uni-\ncode decoding step itself is a genuine bug in that package (albeit, one introduced by\nchanges elsewhere in Python standard libraries), but the workaround does its job:\n# in mailtools.mailSender module ahead in this chapter...\ndef fix_encode_base64(msgobj):\n     from email.encoders import encode_base64\n     encode_base64(msgobj)                # what email does normally: leaves bytes\n     bytes = msgobj.get_payload()         # bytes fails in email pkg on text gen\n     text  = bytes.decode('ascii')        # decode to unicode str so text gen works\n     ...line splitting logic omitted...\n     msgobj.set_payload('\\n'.join(lines))\n>>> from email.mime.image import MIMEImage\n>>> from mailtools.mailSender import fix_encode_base64      # use custom workaround\n>>> bytes = open('monkeys.jpg', 'rb').read()\n>>> m = MIMEImage(bytes, _encoder=fix_encode_base64)        # convert to ascii str\n>>> print(m.as_string()[:500])\nContent-Type: image/jpeg\nMIME-Version: 1.0\nContent-Transfer-Encoding: base64\n/9j/4AAQSkZJRgABAQEAeAB4AAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcG\nBwcICQsJCAgKCAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwM\nDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCAHoAvQDASIA\nAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQA\nAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3\nODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc\n>>> print(m)   # to print the entire message: very long\nAnother possible workaround involves defining a custom MIMEImage class that is like\nthe original but does not attempt to perform Base64 ending on creation; that way, we\ncould encode and translate to str before message object creation, but still make use of\nthe original class\u2019s header-generation logic. If you take this route, though, you\u2019ll find\nthat it requires repeating (really, cutting and pasting) far too much of the original logic\nto be reasonable\u2014this repeated code would have to mirror any future email changes:\n>>> from email.mime.nonmultipart import MIMENonMultipart\n>>> class MyImage(MIMENonMultipart):\n...     def __init__(self, imagedata, subtype):\n...         MIMENonMultipart.__init__(self, 'image', subtype)\n...         self.set_payload(_imagedata)\n...repeat all the base64 logic here, with an extra ASCII Unicode decode...\n>>> m = MyImage(text_from_bytes)\nInterestingly, this regression in email actually reflects an unrelated change in Python\u2019s\nbase64 module made in 2007, which was completely benign until the Python 3.X bytes/\n940 | Chapter 13:\u2002Client-Side Scriptingstr differentiation came online. Prior to that, the email encoder worked in Python 2.X,\nbecause bytes was really str. In 3.X, though, because base64 returns bytes, the normal\nmail encoder in email also leaves the payload as bytes, even though it\u2019s been encoded\nto Base64 text form. This in turn breaks email text generation, because it assumes the\npayload is text in this case, and requires it to be str. As is common in large-scale\nsoftware systems, the effects of some 3.X changes may have been difficult to anticipate\nor accommodate in full.\nBy contrast, parsing binary attachments (as opposed to generating text for them) works\nfine in 3.X, because the parsed message payload is saved in message objects as a Base64-\nencoded str string, not bytes, and is converted to bytes only when fetched. This bug\nseems likely to also go away in a future Python and email package (perhaps even as a\nsimple patch in Python 3.2), but it\u2019s more serious than the other Unicode decoding\nissues described here, because it prevents mail composition for all but trivial mails.\nThe flexibility afforded by the package and the Python language allows such a work-\naround to be developed external to the package, rather than hacking the package\u2019s code\ndirectly. With open source and forgiving APIs, you rarely are truly stuck.\nLate-breaking news: This section\u2019s bug is scheduled to be fixed in Python\n3.2, making our workaround here unnecessary in this and later Python\nreleases. This is per communications with members of Python\u2019s email\nspecial interest group (on the \u201cemail-sig\u201d mailing list).\nRegrettably, this fix didn\u2019t appear until after this chapter and its exam-\nples had been written. I\u2019d like to remove the workaround and its de-\nscription entirely, but this book is based on Python 3.1, both before and\nafter the fix was incorporated.\nSo that it works under Python 3.2 alpha, too, though, the workaround\ncode ahead was specialized just before publication to check for bytes\nprior to decoding. Moreover, the workaround still must manually split\nlines in Base64 data, because 3.2 still does not.\nWorkaround: Message composition for non-ASCII text parts is broken\nOur final email Unicode issue is as severe as the prior one: changes like that of the prior\nsection introduced yet another regression for mail composition. In short, it\u2019s impossible\nto make text message parts today without specializing for different Unicode encodings.\nSome types of text are automatically MIME-encoded for transmission. Unfortunately,\nbecause of the str/bytes split, the MIME text message class in email now requires\ndifferent string object types for different Unicode encodings. The net effect is that you\nnow have to know how the email package will process your text data when making a\ntext message object, or repeat most of its logic redundantly.\nFor example, to properly generate Unicode encoding headers and apply required MIME\nencodings, here\u2019s how we must proceed today for common Unicode text types:\nemail: Parsing and Composing Mail Content | 941>>> m = MIMEText('abc', _charset='ascii')             # pass text for ascii\n>>> print(m)\nMIME-Version: 1.0\nContent-Type: text/plain; charset=\"us-ascii\"\nContent-Transfer-Encoding: 7bit\nabc\n>>> m = MIMEText('abc', _charset='latin-1')           # pass text for latin-1\n>>> print(m)                                          # but not for 'latin1': ahead\nMIME-Version: 1.0\nContent-Type: text/plain; charset=\"iso-8859-1\"\nContent-Transfer-Encoding: quoted-printable\nabc\n>>> m = MIMEText(b'abc', _charset='utf-8')            # pass bytes for utf8\n>>> print(m)\nContent-Type: text/plain; charset=\"utf-8\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: base64\nYWJj\nThis works, but if you look closely, you\u2019ll notice that we must pass str to the first two,\nbut bytes to the third. That requires that we special-case code for Unicode types based\nupon the package\u2019s internal operation. Types other than those expected for a Unicode\nencoding don\u2019t work at all, because of newly invalid str/bytes combinations that occur\ninside the email package in 3.1:\n>>> m = MIMEText('abc', _charset='ascii')\n>>> m = MIMEText(b'abc', _charset='ascii')            # bug: assumes 2.X str\nTraceback (most recent call last):\n  ...lines omitted...\n  File \"C:\\Python31\\lib\\email\\encoders.py\", line 60, in encode_7or8bit\n    orig.encode('ascii')\nAttributeError: 'bytes' object has no attribute 'encode'\n>>> m = MIMEText('abc', _charset='latin-1')\n>>> m = MIMEText(b'abc', _charset='latin-1')          # bug: qp uses str\nTraceback (most recent call last):\n  ...lines omitted...\n  File \"C:\\Python31\\lib\\email\\quoprimime.py\", line 176, in body_encode\n    if line.endswith(CRLF):\nTypeError: expected an object with the buffer interface\n>>> m = MIMEText(b'abc', _charset='utf-8')\n>>> m = MIMEText('abc', _charset='utf-8')             # bug: base64 uses bytes\nTraceback (most recent call last):\n  ...lines omitted...\n  File \"C:\\Python31\\lib\\email\\base64mime.py\", line 94, in body_encode\n    enc = b2a_base64(s[i:i + max_unencoded]).decode(\"ascii\")\nTypeError: must be bytes or buffer, not str\nMoreover, the email package is pickier about encoding name synonyms than Python\nand most other tools are: \u201clatin-1\u201d is detected as a quoted-printable MIME type, but\n942 | Chapter 13:\u2002Client-Side Scripting\u201clatin1\u201d is unknown and so defaults to Base64 MIME. In fact, this is why Base64 was\nused for the \u201clatin1\u201d Unicode type earlier in this section\u2014an encoding choice that is\nirrelevant to any recipient that understands the \u201clatin1\u201d synonym, including Python\nitself. Unfortunately, that means that we also need to pass in a different string type if\nwe use a synonym the package doesn\u2019t understand today:\n>>> m = MIMEText('abc', _charset='latin-1')            # str for 'latin-1'\n>>> print(m)\nMIME-Version: 1.0\nContent-Type: text/plain; charset=\"iso-8859-1\"\nContent-Transfer-Encoding: quoted-printable\nabc\n>>> m = MIMEText('abc', _charset='latin1')\nTraceback (most recent call last):\n  ...lines omitted...\n  File \"C:\\Python31\\lib\\email\\base64mime.py\", line 94, in body_encode\n    enc = b2a_base64(s[i:i + max_unencoded]).decode(\"ascii\")\nTypeError: must be bytes or buffer, not str\n>>> m = MIMEText(b'abc', _charset='latin1')            # bytes for 'latin1'!\n>>> print(m)\nContent-Type: text/plain; charset=\"latin1\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: base64\nYWJj\nThere are ways to add aliases and new encoding types in the email package, but they\u2019re\nnot supported out of the box. Programs that care about being robust would have to\ncross-check the user\u2019s spelling, which may be valid for Python itself, against that ex-\npected by email. This also holds true if your data is not ASCII in general\u2014you\u2019ll have\nto first decode to text in order to use the expected \u201clatin-1\u201d name because its quoted-\nprintable MIME encoding expects str, even though bytes are required if \u201clatin1\u201d\ntriggers the default Base64 MIME:\n>>> m = MIMEText(b'A\\xe4B', _charset='latin1')\n>>> print(m)\nContent-Type: text/plain; charset=\"latin1\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: base64\nQeRC\n>>> m = MIMEText(b'A\\xe4B', _charset='latin-1')\nTraceback (most recent call last):\n  ...lines omitted...\n  File \"C:\\Python31\\lib\\email\\quoprimime.py\", line 176, in body_encode\n    if line.endswith(CRLF):\nTypeError: expected an object with the buffer interface\n>>> m = MIMEText(b'A\\xe4B'.decode('latin1'), _charset='latin-1')\n>>> print(m)\nemail: Parsing and Composing Mail Content | 943MIME-Version: 1.0\nContent-Type: text/plain; charset=\"iso-8859-1\"\nContent-Transfer-Encoding: quoted-printable\nA=E4B\nIn fact, the text message object doesn\u2019t check to see that the data you\u2019re MIME-\nencoding is valid per Unicode in general\u2014we can send invalid UTF text but the receiver\nmay have trouble decoding it:\n>>> m = MIMEText(b'A\\xe4B', _charset='utf-8')\n>>> print(m)\nContent-Type: text/plain; charset=\"utf-8\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: base64\nQeRC\n>>> b'A\\xe4B'.decode('utf8')\nUnicodeDecodeError: 'utf8' codec can't decode bytes in position 1-2: unexpected...\n>>> import base64\n>>> base64.b64decode(b'QeRC')\nb'A\\xe4B'\n>>> base64.b64decode(b'QeRC').decode('utf')\nUnicodeDecodeError: 'utf8' codec can't decode bytes in position 1-2: unexpected...\nSo what to do if we need to attach message text to composed messages if the text\u2019s\ndatatype requirement is indirectly dictated by its Unicode encoding name? The generic\nMessage superclass doesn\u2019t help here directly if we specify an encoding, as it exhibits\nthe same encoding-specific behavior:\n>>> m = Message()\n>>> m.set_payload('spam', charset='us-ascii')\n>>> print(m)\nMIME-Version: 1.0\nContent-Type: text/plain; charset=\"us-ascii\"\nContent-Transfer-Encoding: 7bit\nspam\n>>> m = Message()\n>>> m.set_payload(b'spam', charset='us-ascii')\nAttributeError: 'bytes' object has no attribute 'encode'\n>>> m.set_payload('spam', charset='utf-8')\nTypeError: must be bytes or buffer, not str\nAlthough we could try to work around these issues by repeating much of the code that\nemail runs, the redundancy would make us hopelessly tied to its current implementa-\ntion and dependent upon its future changes. The following, for example, parrots the\nsteps that email runs internally to create a text message object for ASCII encoding text;\nunlike the MIMEText class, this approach allows all data to be read from files as binary\nbyte strings, even if it\u2019s simple ASCII:\n944 | Chapter 13:\u2002Client-Side Scripting>>> m = Message()\n>>> m.add_header('Content-Type', 'text/plain')\n>>> m['MIME-Version'] = '1.0'\n>>> m.set_param('charset', 'us-ascii')\n>>> m.add_header('Content-Transfer-Encoding', '7bit')\n>>> data = b'spam'\n>>> m.set_payload(data.decode('ascii'))           # data read as bytes here\n>>> print(m)\nMIME-Version: 1.0\nContent-Type: text/plain; charset=\"us-ascii\"\nContent-Transfer-Encoding: 7bit\nspam\n>>> print(MIMEText('spam', _charset='ascii'))     # same, but type-specific\nMIME-Version: 1.0\nContent-Type: text/plain; charset=\"us-ascii\"\nContent-Transfer-Encoding: 7bit\nspam\nTo do the same for other kinds of text that require MIME encoding, just insert an extra\nencoding step; although we\u2019re concerned with text parts here, a similar imitative ap-\nproach could address the binary parts text generation bug we met earlier:\n>>> m = Message()\n>>> m.add_header('Content-Type', 'text/plain')\n>>> m['MIME-Version'] = '1.0'\n>>> m.set_param('charset', 'utf-8')\n>>> m.add_header('Content-Transfer-Encoding', 'base64')\n>>> data = b'spam'\n>>> from binascii import b2a_base64               # add MIME encode if needed\n>>> data = b2a_base64(data)                       # data read as bytes here too\n>>> m.set_payload(data.decode('ascii'))\n>>> print(m)\nMIME-Version: 1.0\nContent-Type: text/plain; charset=\"utf-8\"\nContent-Transfer-Encoding: base64\nc3BhbQ==\n>>> print(MIMEText(b'spam', _charset='utf-8'))    # same, but type-specific\nContent-Type: text/plain; charset=\"utf-8\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: base64\nc3BhbQ==\nThis works, but besides the redundancy and dependency it creates, to use this approach\nbroadly we\u2019d also have to generalize to account for all the various kinds of Unicode\nencodings and MIME encodings possible, like the email package already does inter-\nnally. We might also have to support encoding name synonyms to be flexible, adding\nfurther redundancy. In other words, this requires additional work, and in the end, we\u2019d\nstill have to specialize our code for different Unicode types.\nemail: Parsing and Composing Mail Content | 945Any way we go, some dependence on the current implementation seems unavoidable\ntoday. It seems the best we can do here, apart from hoping for an improved email\npackage in a few years\u2019 time, is to specialize text message construction calls by Unicode\ntype, and assume both that encoding names match those expected by the package and\nthat message data is valid for the Unicode type selected. Here is the sort of arguably\nmagic code that the upcoming mailtools package (again in Example 13-23) will apply\nto choose text types:\n>>> from email.charset import Charset, BASE64, QP\n>>> for e in ('us-ascii', 'latin-1', 'utf8', 'latin1', 'ascii'):\n...     cset = Charset(e)\n...     benc = cset.body_encoding\n...     if benc in (None, QP):\n...         print(e, benc, 'text')              # read/fetch data as str\n...     else:\n...         print(e, benc, 'binary')            # read/fetch data as bytes\n...\nus-ascii None text\nlatin-1 1 text\nutf8 2 binary\nlatin1 2 binary\nascii None text\nWe\u2019ll proceed this way in this book, with the major caveat that this is almost certainly\nlikely to require changes in the future because of its strong coupling with the current\nemail implementation.\nLate-breaking news: Like the prior section, it now appears that this sec-\ntion\u2019s bug will also be fixed in Python 3.2, making the workaround here\nunnecessary in this and later Python releases. The nature of the fix is\nunknown, though, and we still need the fix for the version of Python\ncurrent when this chapter was written. As of just before publication, the\nalpha release of 3.2 is still somewhat type specific on this issue, but now\naccepts either str or bytes for text that triggers Base64 encodings, in-\nstead of just bytes.\nSummary: Solutions and workarounds\nThe email package in Python 3.1 provides powerful tools for parsing and composing\nmails, and can be used as the basis for full-featured mail clients like those in this book\nwith just a few workarounds. As you can see, though, it is less than fully functional\ntoday. Because of that, further specializing code to its current API is perhaps a tempo-\nrary solution. Short of writing our own email parser and composer (not a practical\noption in a finitely-sized book!), some compromises are in order here. Moreover, the\ninherent complexity of Unicode support in email places some limits on how much we\ncan pursue this thread in this book.\n946 | Chapter 13:\u2002Client-Side ScriptingIn this edition, we will support Unicode encodings of text parts and headers in messages\ncomposed, and respect the Unicode encodings in text parts and mail headers of mes-\nsages fetched. To make this work with the partially crippled email package in\nPython 3.1, though, we\u2019ll apply the following Unicode policies in various email clients\nin this book:\n\u2022 Use user preferences and defaults for the preparse decoding of full mail text fetched\nand encoding of text payloads sent.\n\u2022 Use header information, if available, to decode the bytes payloads returned by\nget_payload when text parts must be treated as str text, but use binary mode files\nto finesse the issue in other contexts.\n\u2022 Use formats prescribed by email standard to decode and encode message headers\nsuch as From and Subject if they are not simple text.\n\u2022 Apply the fix described to work around the message text generation issue for binary\nparts.\n\u2022 Special-case construction of text message objects according to Unicode types and\nemail behavior.\nThese are not necessarily complete solutions. For example, some of this edition\u2019s email\nclients allow for Unicode encodings for both text attachments and mail headers, but\nthey do nothing about encoding the full text of messages sent beyond the policies in-\nherited from smtplib and implement policies that might be inconvenient in some use\ncases. But as we\u2019ll see, despite their limitations, our email clients will still be able to\nhandle complex email tasks and a very large set of emails.\nAgain, since this story is in flux in Python today, watch this book\u2019s website for updates\nthat may improve or be required of code that uses email in the future. A future email\nmay handle Unicode encodings more accurately. Like Python 3.X, though, backward\ncompatibility may be sacrificed in the process and require updates to this book\u2019s code.\nFor more on this issue, see the Web as well as up-to-date Python release notes.\nAlthough this quick tour captures the basic flavor of the interface, we need to step up\nto larger examples to see more of the email package\u2019s power. The next section takes us\non the first of those steps.\nA Console-Based Email Client\nLet\u2019s put together what we\u2019ve learned about fetching, sending, parsing, and composing\nemail in a simple but functional command-line console email tool. The script in Ex-\nample 13-20 implements an interactive email session\u2014users may type commands to\nread, send, and delete email messages. It uses poplib and smtplib to fetch and send,\nand uses the email package directly to parse and compose.\nA Console-Based Email Client | 947Example 13-20. PP4E\\Internet\\Email\\pymail.py\n#!/usr/local/bin/python\n\"\"\"\n##########################################################################\npymail - a simple console email interface client in Python; uses Python\npoplib module to view POP email messages, smtplib to send new mails, and\nthe email package to extract mail headers and payload and compose mails;\n##########################################################################\n\"\"\"\nimport poplib, smtplib, email.utils, mailconfig\nfrom email.parser  import Parser\nfrom email.message import Message\nfetchEncoding = mailconfig.fetchEncoding\ndef decodeToUnicode(messageBytes, fetchEncoding=fetchEncoding):\n    \"\"\"\n    4E, Py3.1: decode fetched bytes to str Unicode string for display or parsing;\n    use global setting (or by platform default, hdrs inspection, intelligent guess);\n    in Python 3.2/3.3, this step may not be required: if so, return message intact;\n    \"\"\"\n    return [line.decode(fetchEncoding) for line in messageBytes]\ndef splitaddrs(field):\n    \"\"\"\n    4E: split address list on commas, allowing for commas in name parts\n    \"\"\"\n    pairs = email.utils.getaddresses([field])                 # [(name,addr)]\n    return [email.utils.formataddr(pair) for pair in pairs]   # [name <addr>]\ndef inputmessage():\n    import sys\n    From = input('From? ').strip()\n    To   = input('To?   ').strip()           # datetime hdr may be set auto\n    To   = splitaddrs(To)                    # possible many, name+<addr> okay\n    Subj = input('Subj? ').strip()           # don't split blindly on ',' or ';'\n    print('Type message text, end with line=\".\"')\n    text = ''\n    while True:\n        line = sys.stdin.readline()\n        if line == '.\\n': break\n        text += line\n    return From, To, Subj, text\ndef sendmessage():\n    From, To, Subj, text = inputmessage()\n    msg = Message()\n    msg['From']    = From\n    msg['To']      = ', '.join(To)                     # join for hdr, not send\n    msg['Subject'] = Subj\n    msg['Date']    = email.utils.formatdate()          # curr datetime, rfc2822\n    msg.set_payload(text)\n    server = smtplib.SMTP(mailconfig.smtpservername)\n    try:\n        failed = server.sendmail(From, To, str(msg))   # may also raise exc\n948 | Chapter 13:\u2002Client-Side Scriptingexcept:\n        print('Error - send failed')\n    else:\n        if failed: print('Failed:', failed)\ndef connect(servername, user, passwd):\n    print('Connecting...')\n    server = poplib.POP3(servername)\n    server.user(user)                     # connect, log in to mail server\n    server.pass_(passwd)                  # pass is a reserved word\n    print(server.getwelcome())            # print returned greeting message\n    return server\ndef loadmessages(servername, user, passwd, loadfrom=1):\n    server = connect(servername, user, passwd)\n    try:\n        print(server.list())\n        (msgCount, msgBytes) = server.stat()\n        print('There are', msgCount, 'mail messages in', msgBytes, 'bytes')\n        print('Retrieving...')\n        msgList = []                                     # fetch mail now\n        for i in range(loadfrom, msgCount+1):            # empty if low >= high\n            (hdr, message, octets) = server.retr(i)      # save text on list\n            message = decodeToUnicode(message)           # 4E, Py3.1: bytes to str\n            msgList.append('\\n'.join(message))           # leave mail on server\n    finally:\n        server.quit()                                    # unlock the mail box\n    assert len(msgList) == (msgCount - loadfrom) + 1     # msg nums start at 1\n    return msgList\ndef deletemessages(servername, user, passwd, toDelete, verify=True):\n    print('To be deleted:', toDelete)\n    if verify and input('Delete?')[:1] not in ['y', 'Y']:\n        print('Delete cancelled.')\n    else:\n        server = connect(servername, user, passwd)\n        try:\n            print('Deleting messages from server...')\n            for msgnum in toDelete:                 # reconnect to delete mail\n                server.dele(msgnum)                 # mbox locked until quit()\n        finally:\n            server.quit()\ndef showindex(msgList):\n    count = 0                                       # show some mail headers\n    for msgtext in msgList:\n        msghdrs = Parser().parsestr(msgtext, headersonly=True)  # expects str in 3.1\n        count += 1\n        print('%d:\\t%d bytes' % (count, len(msgtext)))\n        for hdr in ('From', 'To', 'Date', 'Subject'):\n            try:\n                print('\\t%-8s=>%s' % (hdr, msghdrs[hdr]))\n            except KeyError:\n                print('\\t%-8s=>(unknown)' % hdr)\n        if count % 5 == 0:\nA Console-Based Email Client | 949input('[Press Enter key]')  # pause after each 5\ndef showmessage(i, msgList):\n    if 1 <= i <= len(msgList):\n       #print(msgList[i-1])             # old: prints entire mail--hdrs+text\n        print('-' * 79)\n        msg = Parser().parsestr(msgList[i-1])      # expects str in 3.1\n        content = msg.get_payload()     # prints payload: string, or [Messages]\n        if isinstance(content, str):    # keep just one end-line at end\n            content = content.rstrip() + '\\n'\n        print(content)\n        print('-' * 79)                 # to get text only, see email.parsers\n    else:\n        print('Bad message number')\ndef savemessage(i, mailfile, msgList):\n    if 1 <= i <= len(msgList):\n        savefile = open(mailfile, 'a', encoding=mailconfig.fetchEncoding)  # 4E\n        savefile.write('\\n' + msgList[i-1] + '-'*80 + '\\n')\n    else:\n        print('Bad message number')\ndef msgnum(command):\n    try:\n        return int(command.split()[1])\n    except:\n        return \u22121   # assume this is bad\nhelptext = \"\"\"\nAvailable commands:\ni     - index display\nl n?  - list all messages (or just message n)\nd n?  - mark all messages for deletion (or just message n)\ns n?  - save all messages to a file (or just message n)\nm     - compose and send a new mail message\nq     - quit pymail\n?     - display this help text\n\"\"\"\ndef interact(msgList, mailfile):\n    showindex(msgList)\n    toDelete = []\n    while True:\n        try:\n            command = input('[Pymail] Action? (i, l, d, s, m, q, ?) ')\n        except EOFError:\n            command = 'q'\n        if not command: command = '*'\n        # quit\n        if command == 'q':\n            break\n        # index\n        elif command[0] == 'i':\n950 | Chapter 13:\u2002Client-Side Scriptingshowindex(msgList)\n        # list\n        elif command[0] == 'l':\n            if len(command) == 1:\n                for i in range(1, len(msgList)+1):\n                    showmessage(i, msgList)\n            else:\n                showmessage(msgnum(command), msgList)\n        # save\n        elif command[0] == 's':\n            if len(command) == 1:\n                for i in range(1, len(msgList)+1):\n                    savemessage(i, mailfile, msgList)\n            else:\n                savemessage(msgnum(command), mailfile, msgList)\n        # delete\n        elif command[0] == 'd':\n            if len(command) == 1:                          # delete all later\n                toDelete = list(range(1, len(msgList)+1))  # 3.x requires list\n            else:\n                delnum = msgnum(command)\n                if (1 <= delnum <= len(msgList)) and (delnum not in toDelete):\n                    toDelete.append(delnum)\n                else:\n                    print('Bad message number')\n        # mail\n        elif command[0] == 'm':                # send a new mail via SMTP\n            sendmessage()\n            #execfile('smtpmail.py', {})       # alt: run file in own namespace\n        elif command[0] == '?':\n            print(helptext)\n        else:\n            print('What? -- type \"?\" for commands help')\n    return toDelete\nif __name__ == '__main__':\n    import getpass, mailconfig\n    mailserver = mailconfig.popservername        # ex: 'pop.rmi.net'\n    mailuser   = mailconfig.popusername          # ex: 'lutz'\n    mailfile   = mailconfig.savemailfile         # ex:  r'c:\\stuff\\savemail'\n    mailpswd   = getpass.getpass('Password for %s?' % mailserver)\n    print('[Pymail email client]')\n    msgList    = loadmessages(mailserver, mailuser, mailpswd)     # load all\n    toDelete   = interact(msgList, mailfile)\n    if toDelete: deletemessages(mailserver, mailuser, mailpswd, toDelete)\n    print('Bye.')\nA Console-Based Email Client | 951There isn\u2019t much new here\u2014just a combination of user-interface logic and tools we\u2019ve\nalready met, plus a handful of new techniques:\nLoads\nThis client loads all email from the server into an in-memory Python list only once,\non startup; you must exit and restart to reload newly arrived email.\nSaves\nOn demand, pymail saves the raw text of a selected message into a local file, whose\nname you place in the mailconfig module of Example 13-17.\nDeletions\nWe finally support on-request deletion of mail from the server here: in pymail, mails\nare selected for deletion by number, but are still only physically removed from your\nserver on exit, and then only if you verify the operation. By deleting only on exit,\nwe avoid changing mail message numbers during a session\u2014under POP, deleting\na mail not at the end of the list decrements the number assigned to all mails fol-\nlowing the one deleted. Since mail is cached in memory by pymail, future operations\non the numbered messages in memory can be applied to the wrong mail if deletions\nwere done immediately.#\nParsing and composing messages\npymail now displays just the payload of a message on listing commands, not the\nentire raw text, and the mail index listing only displays selected headers parsed out\nof each message. Python\u2019s email package is used to extract headers and content\nfrom a message, as shown in the prior section. Similarly, we use email to compose\na message and ask for its string to ship as a mail.\nBy now, I expect that you know enough to read this script for a deeper look, so instead\nof saying more about its design here, let\u2019s jump into an interactive pymail session to see\nhow it works.\nRunning the pymail Console Client\nLet\u2019s start up pymail to read and delete email at our mail server and send new messages.\npymail runs on any machine with Python and sockets, fetches mail from any email server\nwith a POP interface on which you have an account, and sends mail via the SMTP server\nyou\u2019ve named in the mailconfig module we wrote earlier (Example 13-17).\nHere it is in action running on my Windows laptop machine; its operation is identical\non other machines thanks to the portability of both Python and its standard library.\n#There will be more on POP message numbers when we study mailtools later in this chapter. Interestingly,\nthe list of message numbers to be deleted need not be sorted; they remain valid for the duration of the delete\nconnection, so deletions earlier in the list don\u2019t change numbers of messages later in the list while you are\nstill connected to the POP server. We\u2019ll also see that some subtle issues may arise if mails in the server inbox\nare deleted without pymail\u2019s knowledge (e.g., by your ISP or another email client); although very rare, suffice\nit to say for now that deletions in this script are not guaranteed to be accurate.\n952 | Chapter 13:\u2002Client-Side ScriptingFirst, we start the script, supply a POP password (remember, SMTP servers usually\nrequire no password), and wait for the pymail email list index to appear; as is, this\nversion loads the full text of all mails in the inbox on startup:\nC:\\...\\PP4E\\Internet\\Email> pymail.py\nPassword for pop.secureserver.net?\n[Pymail email client]\nConnecting...\nb'+OK <8927.1273263898@p3pop01-10.prod.phx3.gdg>'\n(b'+OK ', [b'1 1860', b'2 1408', b'3 1049', b'4 1009', b'5 1038', b'6 957'], 47)\nThere are 6 mail messages in 7321 bytes\nRetrieving...\n1:      1861 bytes\n        From    =>lutz@rmi.net\n        To      =>pp4e@learning-python.com\n        Date    =>Wed, 5 May 2010 11:29:36 \u22120400 (EDT)\n        Subject =>I'm a Lumberjack, and I'm Okay\n2:      1409 bytes\n        From    =>lutz@learning-python.com\n        To      =>PP4E@learning-python.com\n        Date    =>Wed, 05 May 2010 08:33:47 \u22120700\n        Subject =>testing\n3:      1050 bytes\n        From    =>Eric.the.Half.a.Bee@yahoo.com\n        To      =>PP4E@learning-python.com\n        Date    =>Thu, 06 May 2010 14:11:07 \u22120000\n        Subject =>A B C D E F G\n4:      1010 bytes\n        From    =>PP4E@learning-python.com\n        To      =>PP4E@learning-python.com\n        Date    =>Thu, 06 May 2010 14:16:31 \u22120000\n        Subject =>testing smtpmail\n5:      1039 bytes\n        From    =>Eric.the.Half.a.Bee@aol.com\n        To      =>nobody.in.particular@marketing.com\n        Date    =>Thu, 06 May 2010 14:32:32 \u22120000\n        Subject =>a b c d e f g\n[Press Enter key]\n6:      958 bytes\n        From    =>PP4E@learning-python.com\n        To      =>maillist\n        Date    =>Thu, 06 May 2010 10:58:40 \u22120400\n        Subject =>test interactive smtplib\n[Pymail] Action? (i, l, d, s, m, q, ?) l 6\n-------------------------------------------------------------------------------\ntesting 1 2 3...\n-------------------------------------------------------------------------------\n[Pymail] Action? (i, l, d, s, m, q, ?) l 3\n-------------------------------------------------------------------------------\nFiddle de dum, Fiddle de dee,\nEric the half a bee.\n-------------------------------------------------------------------------------\n[Pymail] Action? (i, l, d, s, m, q, ?)\nA Console-Based Email Client | 953Once pymail downloads your email to a Python list on the local client machine, you\ntype command letters to process it. The l command lists (prints) the contents of a given\nmail number; here, we just used it to list two emails we sent in the preceding section,\nwith the smtpmail script, and interactively.\npymail also lets us get command help, delete messages (deletions actually occur at the\nserver on exit from the program), and save messages away in a local text file whose\nname is listed in the mailconfig module we saw earlier:\n[Pymail] Action? (i, l, d, s, m, q, ?) ?\nAvailable commands:\ni     - index display\nl n?  - list all messages (or just message n)\nd n?  - mark all messages for deletion (or just message n)\ns n?  - save all messages to a file (or just message n)\nm     - compose and send a new mail message\nq     - quit pymail\n?     - display this help text\n[Pymail] Action? (i, l, d, s, m, q, ?) s 4\n[Pymail] Action? (i, l, d, s, m, q, ?) d 4\nNow, let\u2019s pick the m mail compose option\u2014pymail inputs the mail parts, builds mail\ntext with email, and ships it off with smtplib. You can separate recipients with a comma,\nand use either simple \u201caddr\u201d or full \u201cname <addr>\u201d address pairs if desired. Because\nthe mail is sent by SMTP, you can use arbitrary From addresses here; but again, you\ngenerally shouldn\u2019t do that (unless, of course, you\u2019re trying to come up with interesting\nexamples for a book):\n[Pymail] Action? (i, l, d, s, m, q, ?) m\nFrom? Cardinal@hotmail.com\nTo?   PP4E@learning-python.com\nSubj? Among our weapons are these\nType message text, end with line=\".\"\nNobody Expects the Spanish Inquisition!\n.\n[Pymail] Action? (i, l, d, s, m, q, ?) q\nTo be deleted: [4]\nDelete?y\nConnecting...\nb'+OK <16872.1273264370@p3pop01-17.prod.phx3.secureserver.net>'\nDeleting messages from server...\nBye.\nAs mentioned, deletions really happen only on exit. When we quit pymail with the q\ncommand, it tells us which messages are queued for deletion, and verifies the request.\nOnce verified, pymail finally contacts the mail server again and issues POP calls to delete\nthe selected mail messages. Because deletions change message numbers in the server\u2019s\ninbox, postponing deletion until exit simplifies the handling of already loaded email\n(we\u2019ll improve on this in the PyMailGUI client of the next chapter).\n954 | Chapter 13:\u2002Client-Side ScriptingBecause pymail downloads mail from your server into a local Python list only once at\nstartup, though, we need to start pymail again to refetch mail from the server if we want\nto see the result of the mail we sent and the deletion we made. Here, our new mail\nshows up at the end as new number 6, and the original mail assigned number 4 in the\nprior session is gone:\nC:\\...\\PP4E\\Internet\\Email> pymail.py\nPassword for pop.secureserver.net?\n[Pymail email client]\nConnecting...\nb'+OK <11563.1273264637@p3pop01-26.prod.phx3.secureserver.net>'\n(b'+OK ', [b'1 1860', b'2 1408', b'3 1049', b'4 1038', b'5 957', b'6 1037'], 47)\nThere are 6 mail messages in 7349 bytes\nRetrieving...\n1:      1861 bytes\n        From    =>lutz@rmi.net\n        To      =>pp4e@learning-python.com\n        Date    =>Wed, 5 May 2010 11:29:36 \u22120400 (EDT)\n        Subject =>I'm a Lumberjack, and I'm Okay\n2:      1409 bytes\n        From    =>lutz@learning-python.com\n        To      =>PP4E@learning-python.com\n        Date    =>Wed, 05 May 2010 08:33:47 \u22120700\n        Subject =>testing\n3:      1050 bytes\n        From    =>Eric.the.Half.a.Bee@yahoo.com\n        To      =>PP4E@learning-python.com\n        Date    =>Thu, 06 May 2010 14:11:07 \u22120000\n        Subject =>A B C D E F G\n4:      1039 bytes\n        From    =>Eric.the.Half.a.Bee@aol.com\n        To      =>nobody.in.particular@marketing.com\n        Date    =>Thu, 06 May 2010 14:32:32 \u22120000\n        Subject =>a b c d e f g\n5:      958 bytes\n        From    =>PP4E@learning-python.com\n        To      =>maillist\n        Date    =>Thu, 06 May 2010 10:58:40 \u22120400\n        Subject =>test interactive smtplib\n[Press Enter key]\n6:      1038 bytes\n        From    =>Cardinal@hotmail.com\n        To      =>PP4E@learning-python.com\n        Date    =>Fri, 07 May 2010 20:32:38 \u22120000\n        Subject =>Among our weapons are these\n[Pymail] Action? (i, l, d, s, m, q, ?) l 6\n-------------------------------------------------------------------------------\nNobody Expects the Spanish Inquisition!\n-------------------------------------------------------------------------------\n[Pymail] Action? (i, l, d, s, m, q, ?) q\nBye.\nA Console-Based Email Client | 955Though not shown in this session, you can also send to multiple recipients, and include\nfull name and address pairs in your email addresses. This works just because the script\nemploys email utilities described earlier to split up addresses and fully parse to allow\ncommas as both separators and name characters. The following, for example, would\nsend to two and three recipients, respectively, using mostly full address formats:\n[Pymail] Action? (i, l, d, s, m, q, ?) m\nFrom? \"moi 1\" <pp4e@learning-python.com>\nTo?   \"pp 4e\" <pp4e@learning-python.com>, \"lu,tz\" <lutz@learning-python.com>\n[Pymail] Action? (i, l, d, s, m, q, ?) m\nFrom? The Book <pp4e@learning-python.com>\nTo?   \"pp 4e\" <pp4e@learning-python.com>, \"lu,tz\" <lutz@learning-python.com>,\nlutz@rmi.net\nFinally, if you are running this live, you will also find the mail save file on your machine,\ncontaining the one message we asked to be saved in the prior session; it\u2019s simply the\nraw text of saved emails, with separator lines. This is both human and machine-\nreadable\u2014in principle, another script could load saved mail from this file into a Python\nlist by calling the string object\u2019s split method on the file\u2019s text with the separator line\nas a delimiter. As shown in this book, it shows up in file C:\\temp\\savemail.txt, but you\ncan configure this as you like in the mailconfig module.\nThe mailtools Utility Package\nThe email package used by the pymail example of the prior section is a collection of\npowerful tools\u2014in fact, perhaps too powerful to remember completely. At the mini-\nmum, some reusable boilerplate code for common use cases can help insulate you from\nsome of its details; by isolating module usage, such code can also ease the migration to\npossible future email changes. To simplify email interfacing for more complex mail\nclients, and to further demonstrate the use of standard library email tools, I developed\nthe custom utility modules listed in this section\u2014a package called mailtools.\nmailtools is a Python modules package: a directory of code, with one module per tool\nclass, and an initialization module run when the directory is first imported. This pack-\nage\u2019s modules are essentially just a wrapper layer above the standard library\u2019s email\npackage, as well as its poplib and smtplib modules. They make some assumptions about\nthe way email is to be used, but they are reasonable and allow us to forget some of the\nunderlying complexity of the standard library tools employed.\nIn a nutshell, the mailtools package provides three classes\u2014to fetch, send, and parse\nemail messages. These classes can be used as superclasses in order to mix in their meth-\nods to an application-specific class, or as standalone or embedded objects that export\ntheir methods for direct calls. We\u2019ll see these classes deployed both ways in this text.\nAs a simple example of this package\u2019s tools in action, its selftest.py module serves as\na self-test script. When run, it sends a message from you, to you, which includes the\nselftest.py file as an attachment. It also fetches and displays some mail headers and\n956 | Chapter 13:\u2002Client-Side Scriptingparsed and unparsed content. These interfaces, along with some user-interface magic,\nwill lead us to full-blown email clients and websites in later chapters.\nTwo design notes worth mentioning up front: First, none of the code in this package\nknows anything about the user interface it will be used in (console, GUI, web, or other)\nor does anything about things like threads; it is just a toolkit. As we\u2019ll see, its clients\nare responsible for deciding how it will be deployed. By focusing on just email pro-\ncessing here, we simplify the code, as well as the programs that will use it.\nSecond, each of the main modules in this package illustrate Unicode issues that con-\nfront Python 3.X code, especially when using the 3.1 Python email package:\n\u2022 The sender must address encodings for the main message text, attachment input\nfiles, saved-mail output files, and message headers.\n\u2022 The fetcher must resolve full mail text encodings when new mails are fetched.\n\u2022 The parser must deal with encodings in text part payloads of parsed messages, as\nwell as those in message headers.\nIn addition, the sender must provide workarounds for the binary parts generation and\ntext part creation issues in email described earlier in this chapter. Since these highlight\nUnicode factors in general, and might not be solved as broadly as they might be due to\nlimitations of the current Python email package, I\u2019ll elaborate on each of these choices\nalong the way.\nThe next few sections list mailtools source code. Together, its files consist of roughly\n1,050 lines of code, including whitespace and comments. We won\u2019t cover all of this\npackage\u2019s code in depth\u2014study its listings for more details, and see its self-test module\nfor a usage example. Also, for more context and examples, watch for the three clients\nthat will use this package\u2014the modified pymail2.py following this listing, the\nPyMailGUI client in Chapter 14, and the PyMailCGI server in Chapter 16. By sharing\nand reusing this module, all three systems inherit all its utility, as well as any future\nenhancements.\nInitialization File\nThe module in Example 13-21 implements the initialization logic of the mailtools\npackage; as usual, its code is run automatically the first time a script imports through\nthe package\u2019s directory. Notice how this file collects the contents of all the nested\nmodules into the directory\u2019s namespace with from * statements\u2014because mailtools\nbegan life as a single .py file, this provides backward compatibility for existing clients.\nWe also must use package-relative import syntax here (from .module), because Python\n3.X no longer includes the package\u2019s own directory on the module import search path\n(only the package\u2019s container is on the path). Since this is the root module, global\ncomments appear here as well.\nThe mailtools Utility Package | 957Example 13-21. PP4E\\Internet\\Email\\mailtools\\__init__.py \n\"\"\"\n##################################################################################\nmailtools package: interface to mail server transfers, used by pymail2, PyMailGUI,\nand PyMailCGI;  does loads, sends, parsing, composing, and deleting, with part\nattachments, encodings (of both the email and Unicdode kind), etc.;  the parser,\nfetcher, and sender classes here are designed to be mixed-in to subclasses which\nuse their methods, or used as embedded or standalone objects;\nthis package also includes convenience subclasses for silent mode, and more;\nloads all mail text if pop server doesn't do top;  doesn't handle threads or UI\nhere, and allows askPassword to differ per subclass;  progress callback funcs get\nstatus;  all calls raise exceptions on error--client must handle in GUI/other;\nthis changed from file to package: nested modules imported here for bw compat;\n4E: need to use package-relative import syntax throughout, because in Py 3.X\npackage dir in no longer on module import search path if package is imported\nelsewhere (from another directory which uses this package);  also performs\nUnicode decoding on mail text when fetched (see mailFetcher), as well as for\nsome text part payloads which might have been email-encoded (see mailParser);\nTBD: in saveparts, should file be opened in text mode for text/ contypes?\nTBD: in walkNamedParts, should we skip oddballs like message/delivery-status?\nTBD: Unicode support has not been tested exhaustively: see Chapter 13 for more\non the Py3.1 email package and its limitations, and the policies used here;\n##################################################################################\n\"\"\"\n# collect contents of all modules here, when package dir imported directly\nfrom .mailFetcher import *\nfrom .mailSender  import *                 # 4E: package-relative\nfrom .mailParser  import *\n# export nested modules here, when from mailtools import *\n__all__ = 'mailFetcher', 'mailSender', 'mailParser'\n# self-test code is in selftest.py to allow mailconfig's path\n# to be set before running thr nested module imports above\nMailTool Class\nExample 13-22 contains common superclasses for the other classes in the package. This \nis in part meant for future expansion. At present, these are used only to enable or disable \ntrace message output (some clients, such as web-based programs, may not want text \nto be printed to the output stream). Subclasses mix in the silent variant to turn off \noutput.\n958 | Chapter 13:\u2002Client-Side ScriptingExample 13-22. PP4E\\Internet\\Email\\mailtools\\mailTool.py\n\"\"\"\n###############################################################################\ncommon superclasses: used to turn trace massages on/off\n###############################################################################\n\"\"\"\nclass MailTool:                    # superclass for all mail tools\n    def trace(self, message):      # redef me to disable or log to file\n        print(message)\nclass SilentMailTool:              # to mixin instead of subclassing\n    def trace(self, message):\n        pass\nMailSender Class\nThe class used to compose and send messages is coded in Example 13-23. This module\nprovides a convenient interface that combines standard library tools we\u2019ve already met\nin this chapter\u2014the email package to compose messages with attachments and en-\ncodings, and the smtplib module to send the resulting email text. Attachments are\npassed in as a list of filenames\u2014MIME types and any required encodings are deter-\nmined automatically with the module mimetypes. Moreover, date and time strings are\nautomated with an email.utils call, and non-ASCII headers are encoded per email,\nMIME, and Unicode standards. Study this file\u2019s code and comments for more on its\noperation.\nUnicode issues for attachments, save files, and headers\nThis is also where we open and add attachment files, generate message text, and save\nsent messages to a local file. Most attachment files are opened in binary mode, but as\nwe\u2019ve seen, some text attachments must be opened in text mode because the current\nemail package requires them to be str strings when message objects are created. As we\nalso saw earlier, the email package requires attachments to be str text when mail text\nis later generated, possibly as the result of MIME encoding.\nTo satisfy these constraints with the Python 3.1 email package, we must apply the two\nfixes described earlier\u2014 part file open calls select between text or binary mode (and\nthus read str or bytes) based upon the way email will process the data, and MIME\nencoding calls for binary data are augmented to decode the result to ASCII text. The\nlatter of these also splits the Base64 text into lines here for binary parts (unlike email),\nbecause it is otherwise sent as one long line, which may work in some contexts, but\ncauses problems in some text editors if the raw text is viewed.\nBeyond these fixes, clients may optionally provide the names of the Unicode encoding\nscheme associated with the main text part and each text attachment part. In Chap-\nter 14\u2019s PyMailGUI, this is controlled in the mailconfig user settings module, with\nUTF-8 used as a fallback default whenever user settings fail to encode a text part. We\nThe mailtools Utility Package | 959could in principle also catch part file decoding errors and return an error indicator string\n(as we do for received mails in the mail fetcher ahead), but sending an invalid attach-\nment is much more grievous than displaying one. Instead, the send request fails entirely\non errors.\nFinally, there is also new support for encoding non-ASCII headers (both full headers\nand names of email addresses) per a client-selectable encoding that defaults to UTF-8,\nand the sent message save file is opened in the same mailconfig Unicode encoding mode\nused to decode messages when they are fetched.\nThe latter policy for sent mail saves is used because the sent file may be opened to fetch\nfull mail text in this encoding later by clients which apply this encoding scheme. This\nis intended to mirror the way that clients such as PyMailGUI save full message text in\nlocal files to be opened and parsed later. It might fail if the mail fetcher resorted to\nguessing a different and incompatible encoding, and it assumes that no message gives\nrise to incompatibly encoded data in the file across multiple sessions. We could instead\nkeep one save file per encoding, but encodings for full message text probably will not\nvary; ASCII was the original standard for full mail text, so 7- or 8-bit text is likely.\nExample 13-23. PP4E\\Internet\\Email\\mailtools\\mailSender.py\n\"\"\"\n###############################################################################\nsend messages, add attachments (see __init__ for docs, test)\n###############################################################################\n\"\"\"\nimport mailconfig                                      # client's mailconfig\nimport smtplib, os, mimetypes                          # mime: name to type\nimport email.utils, email.encoders                     # date string, base64\nfrom .mailTool import MailTool, SilentMailTool         # 4E: package-relative\nfrom email.message          import Message             # general message, obj->text\nfrom email.mime.multipart   import MIMEMultipart       # type-specific messages\nfrom email.mime.audio       import MIMEAudio           # format/encode attachments\nfrom email.mime.image       import MIMEImage\nfrom email.mime.text        import MIMEText\nfrom email.mime.base        import MIMEBase\nfrom email.mime.application import MIMEApplication     # 4E: use new app class\ndef fix_encode_base64(msgobj):\n    \"\"\"\n    4E: workaround for a genuine bug in Python 3.1 email package that prevents\n    mail text generation for binary parts encoded with base64 or other email\n    encodings;  the normal email.encoder run by the constructor leaves payload\n    as bytes, even though it's encoded to base64 text form;  this breaks email\n    text generation which assumes this is text and requires it to be str;  net\n    effect is that only simple text part emails can be composed in Py 3.1 email\n    package as is - any MIME-encoded binary part cause mail text generation to\n    fail;  this bug seems likely to go away in a future Python and email package,\n    in which case this should become a no-op;  see Chapter 13 for more details;\n960 | Chapter 13:\u2002Client-Side Scripting\"\"\"\n    linelen = 76  # per MIME standards\n    from email.encoders import encode_base64\n    encode_base64(msgobj)                # what email does normally: leaves bytes\n    text = msgobj.get_payload()          # bytes fails in email pkg on text gen\n    if isinstance(text, bytes):          # payload is bytes in 3.1, str in 3.2 alpha\n        text = text.decode('ascii')      # decode to unicode str so text gen works\n    lines = []                           # split into lines, else 1 massive line\n    text  = text.replace('\\n', '')       # no \\n present in 3.1, but futureproof me!\n    while text:\n        line, text = text[:linelen], text[linelen:]\n        lines.append(line)\n    msgobj.set_payload('\\n'.join(lines))\ndef fix_text_required(encodingname):\n    \"\"\"\n    4E: workaround for str/bytes combination errors in email package;  MIMEText\n    requires different types for different Unicode encodings in Python 3.1, due\n    to the different ways it MIME-encodes some types of text;  see Chapter 13;\n    the only other alternative is using generic Message and repeating much code;\n    \"\"\"\n    from email.charset import Charset, BASE64, QP\n    charset = Charset(encodingname)   # how email knows what to do for encoding\n    bodyenc = charset.body_encoding   # utf8, others require bytes input data\n    return bodyenc in (None, QP)      # ascii, latin1, others require str\nclass MailSender(MailTool):\n    \"\"\"\n    send mail: format a message, interface with an SMTP server;\n    works on any machine with Python+Inet, doesn't use cmdline mail;\n    a nonauthenticating client: see MailSenderAuth if login required;\n    4E: tracesize is num chars of msg text traced: 0=none, big=all;\n    4E: supports Unicode encodings for main text and text parts;\n    4E: supports header encoding, both full headers and email names;\n    \"\"\"\n    def __init__(self, smtpserver=None, tracesize=256):\n        self.smtpServerName = smtpserver or mailconfig.smtpservername\n        self.tracesize = tracesize\n    def sendMessage(self, From, To, Subj, extrahdrs, bodytext, attaches,\n                                      saveMailSeparator=(('=' * 80) + 'PY\\n'),\n                                      bodytextEncoding='us-ascii',\n                                      attachesEncodings=None):\n        \"\"\"\n        format and send mail: blocks caller, thread me in a GUI;\n        bodytext is main text part, attaches is list of filenames,\n        extrahdrs is list of (name, value) tuples to be added;\n        raises uncaught exception if send fails for any reason;\n        saves sent message text in a local file if successful;\nThe mailtools Utility Package | 961assumes that To, Cc, Bcc hdr values are lists of 1 or more already\n        decoded addresses (possibly in full name+<addr> format); client\n        must parse to split these on delimiters, or use multiline input;\n        note that SMTP allows full name+<addr> format in recipients;\n        4E: Bcc addrs now used for send/envelope, but header is dropped;\n        4E: duplicate recipients removed, else will get >1 copies of mail;\n        caveat: no support for multipart/alternative mails, just /mixed;\n        \"\"\"\n        # 4E: assume main body text is already in desired encoding;\n        # clients can decode to user pick, default, or utf8 fallback;\n        # either way, email needs either str xor bytes specifically;\n        if fix_text_required(bodytextEncoding):\n            if not isinstance(bodytext, str):\n                bodytext = bodytext.decode(bodytextEncoding)\n        else:\n            if not isinstance(bodytext, bytes):\n                bodytext = bodytext.encode(bodytextEncoding)\n        # make message root\n        if not attaches:\n            msg = Message()\n            msg.set_payload(bodytext, charset=bodytextEncoding)\n        else:\n            msg = MIMEMultipart()\n            self.addAttachments(msg, bodytext, attaches,\n                                     bodytextEncoding, attachesEncodings)\n        # 4E: non-ASCII hdrs encoded on sends; encode just name in address,\n        # else smtp may drop the message completely; encodes all envelope\n        # To names (but not addr) also, and assumes servers will allow;\n        # msg.as_string retains any line breaks added by encoding headers;\n        hdrenc = mailconfig.headersEncodeTo or 'utf-8'        # default=utf8\n        Subj = self.encodeHeader(Subj, hdrenc)                # full header\n        From = self.encodeAddrHeader(From, hdrenc)            # email names\n        To   = [self.encodeAddrHeader(T, hdrenc) for T in To] # each recip\n        Tos  = ', '.join(To)                                  # hdr+envelope\n        # add headers to root\n        msg['From']    = From\n        msg['To']      = Tos                        # poss many: addr list\n        msg['Subject'] = Subj                       # servers reject ';' sept\n        msg['Date']    = email.utils.formatdate()   # curr datetime, rfc2822 utc\n        recip = To\n        for name, value in extrahdrs:               # Cc, Bcc, X-Mailer, etc.\n            if value:\n                if name.lower() not in ['cc', 'bcc']:\n                    value = self.encodeHeader(value, hdrenc)\n                    msg[name] = value\n                else:\n                    value = [self.encodeAddrHeader(V, hdrenc) for V in value]\n                    recip += value                     # some servers reject ['']\n962 | Chapter 13:\u2002Client-Side Scriptingif name.lower() != 'bcc':          # 4E: bcc gets mail, no hdr\n                        msg[name] = ', '.join(value)   # add commas between cc\n        recip = list(set(recip))                       # 4E: remove duplicates\n        fullText = msg.as_string()                     # generate formatted msg\n        # sendmail call raises except if all Tos failed,\n        # or returns failed Tos dict for any that failed\n        self.trace('Sending to...' + str(recip))\n        self.trace(fullText[:self.tracesize])                # SMTP calls connect\n        server = smtplib.SMTP(self.smtpServerName)           # this may fail too\n        self.getPassword()                                   # if srvr requires\n        self.authenticateServer(server)                      # login in subclass\n        try:\n            failed = server.sendmail(From, recip, fullText)  # except or dict\n        except:\n            server.close()                                   # 4E: quit may hang!\n            raise                                            # reraise except\n        else:\n            server.quit()                                    # connect + send OK\n        self.saveSentMessage(fullText, saveMailSeparator)    # 4E: do this first\n        if failed:\n            class SomeAddrsFailed(Exception): pass\n            raise SomeAddrsFailed('Failed addrs:%s\\n' % failed)\n        self.trace('Send exit')\n    def addAttachments(self, mainmsg, bodytext, attaches,\n                                      bodytextEncoding, attachesEncodings):\n        \"\"\"\n        format a multipart message with attachments;\n        use Unicode encodings for text parts if passed;\n        \"\"\"\n        # add main text/plain part\n        msg = MIMEText(bodytext, _charset=bodytextEncoding)\n        mainmsg.attach(msg)\n        # add attachment parts\n        encodings = attachesEncodings or (['us-ascii'] * len(attaches))\n        for (filename, fileencode) in zip(attaches, encodings):\n            # filename may be absolute or relative\n            if not os.path.isfile(filename):             # skip dirs, etc.\n                continue\n            # guess content type from file extension, ignore encoding\n            contype, encoding = mimetypes.guess_type(filename)\n            if contype is None or encoding is not None:  # no guess, compressed?\n                contype = 'application/octet-stream'     # use generic default\n            self.trace('Adding ' + contype)\n            # build sub-Message of appropriate kind\n            maintype, subtype = contype.split('/', 1)\n            if maintype == 'text':                       # 4E: text needs encoding\n                if fix_text_required(fileencode):        # requires str or bytes\n                    data = open(filename, 'r', encoding=fileencode)\nThe mailtools Utility Package | 963else:\n                    data = open(filename, 'rb')\n                msg = MIMEText(data.read(), _subtype=subtype, _charset=fileencode)\n                data.close()\n            elif maintype == 'image':\n                data = open(filename, 'rb')              # 4E: use fix for binaries\n                msg  = MIMEImage(\n                       data.read(), _subtype=subtype, _encoder=fix_encode_base64)\n                data.close()\n            elif maintype == 'audio':\n                data = open(filename, 'rb')\n                msg  = MIMEAudio(\n                       data.read(), _subtype=subtype, _encoder=fix_encode_base64)\n                data.close()\n            elif maintype == 'application':              # new  in 4E\n                data = open(filename, 'rb')\n                msg  = MIMEApplication(\n                       data.read(), _subtype=subtype, _encoder=fix_encode_base64)\n                data.close()\n            else:\n                data = open(filename, 'rb')              # application/* could\n                msg  = MIMEBase(maintype, subtype)       # use this code too\n                msg.set_payload(data.read())\n                data.close()                             # make generic type\n                fix_encode_base64(msg)                   # was broken here too!\n               #email.encoders.encode_base64(msg)        # encode using base64\n            # set filename and attach to container\n            basename = os.path.basename(filename)\n            msg.add_header('Content-Disposition',\n                           'attachment', filename=basename)\n            mainmsg.attach(msg)\n        # text outside mime structure, seen by non-MIME mail readers\n        mainmsg.preamble = 'A multi-part MIME format message.\\n'\n        mainmsg.epilogue = ''  # make sure message ends with a newline\n    def saveSentMessage(self, fullText, saveMailSeparator):\n        \"\"\"\n        append sent message to local file if send worked for any;\n        client: pass separator used for your application, splits;\n        caveat: user may change the file at same time (unlikely);\n        \"\"\"\n        try:\n            sentfile = open(mailconfig.sentmailfile, 'a',\n                                  encoding=mailconfig.fetchEncoding)    # 4E\n            if fullText[-1] != '\\n': fullText += '\\n'\n            sentfile.write(saveMailSeparator)\n            sentfile.write(fullText)\n            sentfile.close()\n        except:\n964 | Chapter 13:\u2002Client-Side Scriptingself.trace('Could not save sent message')    # not a show-stopper\n    def encodeHeader(self, headertext, unicodeencoding='utf-8'):\n        \"\"\"\n        4E: encode composed non-ascii message headers content per both email\n        and Unicode standards, according to an optional user setting or UTF-8;\n        header.encode adds line breaks in header string automatically if needed;\n        \"\"\"\n        try:\n            headertext.encode('ascii')\n        except:\n            try:\n                hdrobj = email.header.make_header([(headertext, unicodeencoding)])\n                headertext = hdrobj.encode()\n            except:\n                pass         # auto splits into multiple cont lines if needed\n        return headertext    # smtplib may fail if it won't encode to ascii\n    def encodeAddrHeader(self, headertext, unicodeencoding='utf-8'):\n        \"\"\"\n        4E: try to encode non-ASCII names in email addresess per email, MIME,\n        and Unicode standards; if this fails drop name and use just addr part;\n        if cannot even get addresses, try to decode as a whole, else smtplib\n        may run into errors when it tries to encode the entire mail as ASCII;\n        utf-8 default should work for most, as it formats code points broadly;\n        inserts newlines if too long or hdr.encode split names to multiple lines,\n        but this may not catch some lines longer than the cutoff (improve me);\n        as used, Message.as_string formatter won't try to break lines further;\n        see also decodeAddrHeader in mailParser module for the inverse of this;\n        \"\"\"\n        try:\n            pairs = email.utils.getaddresses([headertext])   # split addrs + parts\n            encoded = []\n            for name, addr in pairs:\n                try:\n                    name.encode('ascii')         # use as is if okay as ascii\n                except UnicodeError:             # else try to encode name part\n                    try:\n                        uni  = name.encode(unicodeencoding)\n                        hdr  = email.header.make_header([(uni, unicodeencoding)])\n                        name = hdr.encode()\n                    except:\n                        name = None              # drop name, use address part only\n                joined = email.utils.formataddr((name, addr))  # quote name if need\n                encoded.append(joined)\n            fullhdr = ', '.join(encoded)\n            if len(fullhdr) > 72 or '\\n' in fullhdr:      # not one short line?\n                fullhdr = ',\\n '.join(encoded)            # try multiple lines\n            return fullhdr\n        except:\n            return self.encodeHeader(headertext)\n    def authenticateServer(self, server):\nThe mailtools Utility Package | 965pass  # no login required for this server/class\n    def getPassword(self):\n        pass  # no login required for this server/class\n################################################################################\n# specialized subclasses\n################################################################################\nclass MailSenderAuth(MailSender):\n    \"\"\"\n    use for servers that require login authorization;\n    client: choose MailSender or MailSenderAuth super\n    class based on mailconfig.smtpuser setting (None?)\n    \"\"\"\n    smtpPassword = None    # 4E: on class, not self, shared by poss N instances\n    \n    def __init__(self, smtpserver=None, smtpuser=None):\n        MailSender.__init__(self, smtpserver)\n        self.smtpUser = smtpuser or mailconfig.smtpuser\n        #self.smtpPassword = None # 4E: makes PyMailGUI ask for each send!\n    def authenticateServer(self, server):\n        server.login(self.smtpUser, self.smtpPassword)\n    def getPassword(self):\n        \"\"\"\n        get SMTP auth password if not yet known;\n        may be called by superclass auto, or client manual:\n        not needed until send, but don't run in GUI thread;\n        get from client-side file or subclass method\n        \"\"\"\n        if not self.smtpPassword:\n            try:\n                localfile = open(mailconfig.smtppasswdfile)\n                MailSenderAuth.smtpPassword = localfile.readline()[:-1] # 4E\n                self.trace('local file password' + repr(self.smtpPassword))\n            except:\n                MailSenderAuth.smtpPassword = self.askSmtpPassword()    # 4E\n    def askSmtpPassword(self):\n        assert False, 'Subclass must define method'\nclass MailSenderAuthConsole(MailSenderAuth):\n    def askSmtpPassword(self):\n        import getpass\n        prompt = 'Password for %s on %s?' % (self.smtpUser, self.smtpServerName)\n        return getpass.getpass(prompt)\nclass SilentMailSender(SilentMailTool, MailSender):\n    pass   # replaces trace\n966 | Chapter 13:\u2002Client-Side ScriptingMailFetcher Class\nThe class defined in Example 13-24 does the work of interfacing with a POP email\nserver\u2014loading, deleting, and synchronizing. This class merits a few additional words\nof explanation.\nGeneral usage\nThis module deals strictly in email text; parsing email after it has been fetched is dele-\ngated to a different module in the package. Moreover, this module doesn\u2019t cache already\nloaded information; clients must add their own mail-retention tools if desired. Clients\nmust also provide password input methods or pass one in, if they cannot use the console\ninput subclass here (e.g., GUIs and web-based programs).\nThe loading and deleting tasks use the standard library poplib module in ways we saw\nearlier in this chapter, but notice that there are interfaces for fetching just message\nheader text with the TOP action in POP if the mail server supports it. This can save\nsubstantial time if clients need to fetch only basic details for an email index. In addition,\nthe header and full-text fetchers are equipped to load just mails newer than a particular\nnumber (useful once an initial load is run), and to restrict fetches to a fixed-sized set of\nthe mostly recently arrived emails (useful for large inboxes with slow Internet access\nor servers).\nThis module also supports the notion of progress indicators\u2014for methods that perform\nmultiple downloads or deletions, callers may pass in a function that will be called as\neach mail is processed. This function will receive the current and total step numbers.\nIt\u2019s left up to the caller to render this in a GUI, console, or other user interface.\nUnicode decoding for full mail text on fetches\nAdditionally, this module is where we apply the session-wide message bytes Unicode\ndecoding policy required for parsing, as discussed earlier in this chapter. This decoding\nuses an encoding name user setting in the mailconfig module, followed by heuristics.\nBecause this decoding is performed immediately when a mail is fetched, all clients of\nthis package can assume message text is str Unicode strings\u2014including any later pars-\ning, display, or save operations. In addition to the mailconfig setting, we also apply a\nfew guesses with common encoding types, though it\u2019s not impossible that this may lead\nto problems if mails decoded by guessing cannot be written to mail save fails using the\nmailconfig setting.\nAs described, this session-wide approach to encodings is not ideal, but it can be adjusted\nper client session and reflects the current limitations of email in Python 3.1\u2014its parser\nrequires already decoded Unicode strings, but fetches return bytes. If this decoding\nfails, as a last resort we attempt to decode headers only, as either ASCII (or other com-\nmon format) text or the platform default, and insert an error message in the email\nbody\u2014a heuristic that attempts to avoid killing clients with exceptions if possible (see\nThe mailtools Utility Package | 967file _test-decoding.py in the examples package for a test of this logic). In practice, an 8-\nbit Unicode encoding such as Latin-1 will probably suffice in most cases, because ASCII\nwas the original requirement of email standards.\nIn principle, we could try to search for encoding information in message headers if it\u2019s\npresent, by parsing mails partially ourselves. We might then take a per-message instead\nof per-session approach to decoding full text, and associate an encoding type with each\nmail for later processing such as saves, though this raises further complications, as a\nsave file can have just one (compatible) encoding, not one per message. Moreover,\ncharacter sets in email headers may refer to individual components, not the entire\nemail\u2019s text. Since most mails will conform to 7- or 8-bit standards, and since a future\nemail release will likely address this issue, extra complexity is probably not warranted\nfor this case in this book.\nAlso keep in mind that the Unicode decoding performed here is for the entire mail text\nfetched from a server. Really, this is just one part of the email encoding story in the\nUnicode-aware world of today. In addition:\n\u2022 Payloads of parsed message parts may still be returned as bytes and require special\nhandling or further Unicode decoding (see the parser module ahead).\n\u2022 Text parts and attachments in composed mails impose encoding choices as well\n(see the sender module earlier).\n\u2022 Message headers have their own encoding conventions, and may be both MIME\nand Unicode encoded if Internationalized (see both the parser and sender\nmodules).\nInbox synchronization tools\nWhen you start studying this example, you\u2019ll also notice that Example 13-24 devotes\nsubstantial code to detecting synchronization errors between an email list held by a\nclient and the current state of the inbox at the POP email server. Normally, POP assigns\nrelative message numbers to email in the inbox, and only adds newly arrived emails to\nthe end of the inbox. As a result, relative message numbers from an earlier fetch may\nusually be used to delete and fetch in the future.\nHowever, although rare, it is not impossible for the server\u2019s inbox to change in ways\nthat invalidate previously fetched message numbers. For instance, emails may be de-\nleted in another client, and the server itself may move mails from the inbox to an un-\ndeliverable state on download errors (this may vary per ISP). In both cases, email may\nbe removed from the middle of the inbox, throwing some prior relative message num-\nbers out of sync with the server.\nThis situation can result in fetching the wrong message in an email client\u2014users receive\na different message than the one they thought they had selected. Worse, this can make\ndeletions inaccurate\u2014if a mail client uses a relative message number in a delete request,\nthe wrong mail may be deleted if the inbox has changed since the index was fetched.\n968 | Chapter 13:\u2002Client-Side ScriptingTo assist clients, Example 13-24 includes tools, which match message headers on de-\nletions to ensure accuracy and perform general inbox synchronization tests on demand.\nThese tools are useful only to clients that retain the fetched email list as state informa-\ntion. We\u2019ll use these in the PyMailGUI client in Chapter 14. There, deletions use the\nsafe interface, and loads run the on-demand synchronization test; on detection of syn-\nchronization errors, the inbox index is automatically reloaded. For now, see Exam-\nple 13-24 source code and comments for more details.\nNote that the synchronization tests try a variety of matching techniques, but require\nthe complete headers text and, in the worst case, must parse headers and match many\nheader fields. In many cases, the single previously fetched message-id header field\nwould be sufficient for matching against messages in the server\u2019s inbox. However, be-\ncause this field is optional and can be forged to have any value, it might not always be\na reliable way to identify messages. In other words, a same-valued message-id may not\nsuffice to guarantee a match, although it can be used to identify a mismatch; in Exam-\nple 13-24, the message-id is used to rule out a match if either message has one, and they\ndiffer in value. This test is performed before falling back on slower parsing and multiple\nheader matches.\nExample 13-24. PP4E\\Internet\\Email\\mailtools\\mailFetcher.py\n\"\"\"\n###############################################################################\nretrieve, delete, match mail from a POP server (see __init__ for docs, test)\n###############################################################################\n\"\"\"\nimport poplib, mailconfig, sys               # client's mailconfig on sys.path\nprint('user:', mailconfig.popusername)       # script dir, pythonpath, changes\nfrom .mailParser import MailParser                 # for headers matching (4E: .)\nfrom .mailTool   import MailTool, SilentMailTool   # trace control supers (4E: .)\n# index/server msgnum out of synch tests\nclass DeleteSynchError(Exception): pass            # msg out of synch in del\nclass TopNotSupported(Exception): pass             # can't run synch test\nclass MessageSynchError(Exception): pass           # index list out of sync\nclass MailFetcher(MailTool):\n    \"\"\"\n    fetch mail: connect, fetch headers+mails, delete mails\n    works on any machine with Python+Inet; subclass me to cache\n    implemented with the POP protocol; IMAP requires new class;\n    4E: handles decoding of full mail text on fetch for parser;\n    \"\"\"\n    def __init__(self, popserver=None, popuser=None, poppswd=None, hastop=True):\n        self.popServer   = popserver or mailconfig.popservername\n        self.popUser     = popuser   or mailconfig.popusername\n        self.srvrHasTop  = hastop\n        self.popPassword = poppswd  # ask later if None\nThe mailtools Utility Package | 969def connect(self):\n        self.trace('Connecting...')\n        self.getPassword()                          # file, GUI, or console\n        server = poplib.POP3(self.popServer)\n        server.user(self.popUser)                   # connect,login POP server\n        server.pass_(self.popPassword)              # pass is a reserved word\n        self.trace(server.getwelcome())             # print returned greeting\n        return server\n    # use setting in client's mailconfig on import search path;\n    # to tailor, this can be changed in class or per instance;\n    fetchEncoding = mailconfig.fetchEncoding\n    def decodeFullText(self, messageBytes):\n        \"\"\"\n        4E, Py3.1: decode full fetched mail text bytes to str Unicode string;\n        done at fetch, for later display or parsing (full mail text is always\n        Unicode thereafter);  decode with per-class or per-instance setting, or\n        common types;  could also try headers inspection, or intelligent guess\n        from structure; in Python 3.2/3.3, this step may not be required: if so,\n        change to return message line list intact; for more details see Chapter 13;\n        an 8-bit encoding such as latin-1 will likely suffice for most emails, as\n        ASCII is the original standard;  this method applies to entire/full message\n        text, which is really just one part of the email encoding story: Message\n        payloads and Message headers may also be encoded per email, MIME, and\n        Unicode standards; see Chapter 13 and mailParser and mailSender for more;\n        \"\"\"\n        text = None\n        kinds =  [self.fetchEncoding]             # try user setting first\n        kinds += ['ascii', 'latin1', 'utf8']      # then try common types\n        kinds += [sys.getdefaultencoding()]       # and platform dflt (may differ)\n        for kind in kinds:                        # may cause mail saves to fail\n            try:\n                text = [line.decode(kind) for line in messageBytes]\n                break\n            except (UnicodeError, LookupError):   # LookupError: bad name\n                pass\n        if text == None:\n            # try returning headers + error msg, else except may kill client;\n            # still try to decode headers per ascii, other, platform default;\n            blankline = messageBytes.index(b'')\n            hdrsonly  = messageBytes[:blankline]\n            commons   = ['ascii', 'latin1', 'utf8']\n            for common in commons:\n                try:\n                    text = [line.decode(common) for line in hdrsonly]\n                    break\n                except UnicodeError:\n                    pass\n            else:                                                  # none worked\n                try:\n                    text = [line.decode() for line in hdrsonly]    # platform dflt?\n970 | Chapter 13:\u2002Client-Side Scriptingexcept UnicodeError:\n                    text = ['From: (sender of unknown Unicode format headers)']\n            text += ['', '--Sorry: mailtools cannot decode this mail content!--']\n        return text\n    def downloadMessage(self, msgnum):\n        \"\"\"\n        load full raw text of one mail msg, given its\n        POP relative msgnum; caller must parse content\n        \"\"\"\n        self.trace('load ' + str(msgnum))\n        server = self.connect()\n        try:\n            resp, msglines, respsz = server.retr(msgnum)\n        finally:\n            server.quit()\n        msglines = self.decodeFullText(msglines)   # raw bytes to Unicode str\n        return '\\n'.join(msglines)                 # concat lines for parsing\n    def downloadAllHeaders(self, progress=None, loadfrom=1):\n        \"\"\"\n        get sizes, raw header text only, for all or new msgs\n        begins loading headers from message number loadfrom\n        use loadfrom to load newly arrived mails only\n        use downloadMessage to get a full msg text later\n        progress is a function called with (count, total);\n        returns: [headers text], [mail sizes], loadedfull?\n        4E: add mailconfig.fetchlimit to support large email\n        inboxes: if not None, only fetches that many headers,\n        and returns others as dummy/empty mail; else inboxes\n        like one of mine (4K emails) are not practical to use;\n        4E: pass loadfrom along to downloadAllMsgs (a buglet);\n        \"\"\"\n        if not self.srvrHasTop:                    # not all servers support TOP\n            # naively load full msg text\n            return self.downloadAllMsgs(progress, loadfrom)\n        else:\n            self.trace('loading headers')\n            fetchlimit = mailconfig.fetchlimit\n            server = self.connect()                # mbox now locked until quit\n            try:\n                resp, msginfos, respsz = server.list()   # 'num size' lines list\n                msgCount = len(msginfos)                 # alt to srvr.stat[0]\n                msginfos = msginfos[loadfrom-1:]         # drop already loadeds\n                allsizes = [int(x.split()[1]) for x in msginfos]\n                allhdrs  = []\n                for msgnum in range(loadfrom, msgCount+1):          # poss empty\n                    if progress: progress(msgnum, msgCount)         # run callback\n                    if fetchlimit and (msgnum <= msgCount - fetchlimit):\n                        # skip, add dummy hdrs\n                        hdrtext = 'Subject: --mail skipped--\\n\\n'\n                        allhdrs.append(hdrtext)\n                    else:\n                        # fetch, retr hdrs only\nThe mailtools Utility Package | 971resp, hdrlines, respsz = server.top(msgnum, 0)\n                        hdrlines = self.decodeFullText(hdrlines)\n                        allhdrs.append('\\n'.join(hdrlines))\n            finally:\n                server.quit()                          # make sure unlock mbox\n            assert len(allhdrs) == len(allsizes)\n            self.trace('load headers exit')\n            return allhdrs, allsizes, False\n    def downloadAllMessages(self, progress=None, loadfrom=1):\n        \"\"\"\n        load full message text for all msgs from loadfrom..N,\n        despite any caching that may be being done in the caller;\n        much slower than downloadAllHeaders, if just need hdrs;\n        4E: support mailconfig.fetchlimit: see downloadAllHeaders;\n        could use server.list() to get sizes of skipped emails here\n        too, but clients probably don't care about these anyhow;\n        \"\"\"\n        self.trace('loading full messages')\n        fetchlimit = mailconfig.fetchlimit\n        server = self.connect()\n        try:\n            (msgCount, msgBytes) = server.stat()          # inbox on server\n            allmsgs  = []\n            allsizes = []\n            for i in range(loadfrom, msgCount+1):         # empty if low >= high\n                if progress: progress(i, msgCount)\n                if fetchlimit and (i <= msgCount - fetchlimit):\n                    # skip, add dummy mail\n                    mailtext = 'Subject: --mail skipped--\\n\\nMail skipped.\\n'\n                    allmsgs.append(mailtext)\n                    allsizes.append(len(mailtext))\n                else:\n                    # fetch, retr full mail\n                    (resp, message, respsz) = server.retr(i)  # save text on list\n                    message = self.decodeFullText(message)\n                    allmsgs.append('\\n'.join(message))        # leave mail on server\n                    allsizes.append(respsz)                   # diff from len(msg)\n        finally:\n            server.quit()                                     # unlock the mail box\n        assert len(allmsgs) == (msgCount - loadfrom) + 1      # msg nums start at 1\n       #assert sum(allsizes) == msgBytes                      # not if loadfrom > 1\n        return allmsgs, allsizes, True                        # not if fetchlimit\n    def deleteMessages(self, msgnums, progress=None):\n        \"\"\"\n        delete multiple msgs off server; assumes email inbox\n        unchanged since msgnums were last determined/loaded;\n        use if msg headers not available as state information;\n        fast, but poss dangerous: see deleteMessagesSafely\n        \"\"\"\n        self.trace('deleting mails')\n        server = self.connect()\n        try:\n972 | Chapter 13:\u2002Client-Side Scriptingfor (ix, msgnum) in enumerate(msgnums):   # don't reconnect for each\n                if progress: progress(ix+1, len(msgnums))\n                server.dele(msgnum)\n        finally:                                      # changes msgnums: reload\n            server.quit()\n    def deleteMessagesSafely(self, msgnums, synchHeaders, progress=None):\n        \"\"\"\n        delete multiple msgs off server, but use TOP fetches to\n        check for a match on each msg's header part before deleting;\n        assumes the email server supports the TOP interface of POP,\n        else raises TopNotSupported - client may call deleteMessages;\n        use if the mail server might change the inbox since the email\n        index was last fetched, thereby changing POP relative message\n        numbers;  this can happen if email is deleted in a different\n        client;  some ISPs may also move a mail from inbox to the\n        undeliverable box in response to a failed download;\n        synchHeaders must be a list of already loaded mail hdrs text,\n        corresponding to selected msgnums (requires state);  raises\n        exception if any out of synch with the email server;  inbox is\n        locked until quit, so it should not change between TOP check\n        and actual delete: synch check must occur here, not in caller;\n        may be enough to call checkSynchError+deleteMessages, but check\n        each msg here in case deletes and inserts in middle of inbox;\n        \"\"\"\n        if not self.srvrHasTop:\n            raise TopNotSupported('Safe delete cancelled')\n        self.trace('deleting mails safely')\n        errmsg  = 'Message %s out of synch with server.\\n'\n        errmsg += 'Delete terminated at this message.\\n'\n        errmsg += 'Mail client may require restart or reload.'\n        server = self.connect()                       # locks inbox till quit\n        try:                                          # don't reconnect for each\n            (msgCount, msgBytes) = server.stat()      # inbox size on server\n            for (ix, msgnum) in enumerate(msgnums):\n                if progress: progress(ix+1, len(msgnums))\n                if msgnum > msgCount:                            # msgs deleted\n                    raise DeleteSynchError(errmsg % msgnum)\n                resp, hdrlines, respsz = server.top(msgnum, 0)   # hdrs only\n                hdrlines = self.decodeFullText(hdrlines)\n                msghdrs = '\\n'.join(hdrlines)\n                if not self.headersMatch(msghdrs, synchHeaders[msgnum-1]):\n                    raise DeleteSynchError(errmsg % msgnum)\n                else:\n                    server.dele(msgnum)               # safe to delete this msg\n        finally:                                      # changes msgnums: reload\n            server.quit()                             # unlock inbox on way out\n    def checkSynchError(self, synchHeaders):\n        \"\"\"\n        check to see if already loaded hdrs text in synchHeaders\nThe mailtools Utility Package | 973list matches what is on the server, using the TOP command in\n        POP to fetch headers text; use if inbox can change due to\n        deletes in other client, or automatic action by email server;\n        raises except if out of synch, or error while talking to server;\n        for speed, only checks last in last: this catches inbox deletes,\n        but assumes server won't insert before last (true for incoming\n        mails); check inbox size first: smaller if just deletes;  else\n        top will differ if deletes and newly arrived messages added at\n        end;  result valid only when run: inbox may change after return;\n        \"\"\"\n        self.trace('synch check')\n        errormsg  = 'Message index out of synch with mail server.\\n'\n        errormsg += 'Mail client may require restart or reload.'\n        server = self.connect()\n        try:\n            lastmsgnum = len(synchHeaders)                      # 1..N\n            (msgCount, msgBytes) = server.stat()                # inbox size\n            if lastmsgnum > msgCount:                           # fewer now?\n                raise MessageSynchError(errormsg)               # none to cmp\n            if self.srvrHasTop:\n                resp, hdrlines, respsz = server.top(lastmsgnum, 0)  # hdrs only\n                hdrlines = self.decodeFullText(hdrlines)\n                lastmsghdrs = '\\n'.join(hdrlines)\n                if not self.headersMatch(lastmsghdrs, synchHeaders[-1]):\n                    raise MessageSynchError(errormsg)\n        finally:\n            server.quit()\n    def headersMatch(self, hdrtext1, hdrtext2):\n        \"\"\"\"\n        may not be as simple as a string compare: some servers add\n        a \"Status:\" header that changes over time; on one ISP, it\n        begins as \"Status: U\" (unread), and changes to \"Status: RO\"\n        (read, old) after fetched once - throws off synch tests if\n        new when index fetched, but have been fetched once before\n        delete or last-message check;  \"Message-id:\" line is unique\n        per message in theory, but optional, and can be anything if\n        forged; match more common: try first; parsing costly: try last\n        \"\"\"\n        # try match by simple string compare\n        if hdrtext1 == hdrtext2:\n            self.trace('Same headers text')\n            return True\n        # try match without status lines\n        split1 = hdrtext1.splitlines()       # s.split('\\n'), but no final ''\n        split2 = hdrtext2.splitlines()\n        strip1 = [line for line in split1 if not line.startswith('Status:')]\n        strip2 = [line for line in split2 if not line.startswith('Status:')]\n        if strip1 == strip2:\n            self.trace('Same without Status')\n            return True\n        # try mismatch by message-id headers if either has one\n974 | Chapter 13:\u2002Client-Side Scriptingmsgid1 = [line for line in split1 if line[:11].lower() == 'message-id:']\n        msgid2 = [line for line in split2 if line[:11].lower() == 'message-id:']\n        if (msgid1 or msgid2) and (msgid1 != msgid2):\n            self.trace('Different Message-Id')\n            return False\n        # try full hdr parse and common headers if msgid missing or trash\n        tryheaders  = ('From', 'To', 'Subject', 'Date')\n        tryheaders += ('Cc', 'Return-Path', 'Received')\n        msg1 = MailParser().parseHeaders(hdrtext1)\n        msg2 = MailParser().parseHeaders(hdrtext2)\n        for hdr in tryheaders:                          # poss multiple Received\n            if msg1.get_all(hdr) != msg2.get_all(hdr):  # case insens, dflt None\n                self.trace('Diff common headers')\n                return False\n        # all common hdrs match and don't have a diff message-id\n        self.trace('Same common headers')\n        return True\n    def getPassword(self):\n        \"\"\"\n        get POP password if not yet known\n        not required until go to server\n        from client-side file or subclass method\n        \"\"\"\n        if not self.popPassword:\n            try:\n                localfile = open(mailconfig.poppasswdfile)\n                self.popPassword = localfile.readline()[:-1]\n                self.trace('local file password' + repr(self.popPassword))\n            except:\n                self.popPassword = self.askPopPassword()\n    def askPopPassword(self):\n        assert False, 'Subclass must define method'\n################################################################################\n# specialized subclasses\n################################################################################\nclass MailFetcherConsole(MailFetcher):\n    def askPopPassword(self):\n        import getpass\n        prompt = 'Password for %s on %s?' % (self.popUser, self.popServer)\n        return getpass.getpass(prompt)\nclass SilentMailFetcher(SilentMailTool, MailFetcher):\n    pass   # replaces trace\nThe mailtools Utility Package | 975MailParser Class\nExample 13-25 implements the last major class in the mailtools package\u2014given the\n(already decoded) text of an email message, its tools parse the mail\u2019s content into a\nmessage object, with headers and decoded parts. This module is largely just a wrapper\naround the standard library\u2019s email package, but it adds convenience tools\u2014finding\nthe main text part of a message, filename generation for message parts, saving attached\nparts to files, decoding headers, splitting address lists, and so on. See the code for more\ninformation. Also notice the parts walker here: by coding its search logic in one place\nas a generator function, we guarantee that all its three clients here, as well as any others\nelsewhere, implement the same traversal.\nUnicode decoding for text part payloads and message headers\nThis module also provides support for decoding message headers per email standards\n(both full headers and names in address headers), and handles decoding per text part\nencodings. Headers are decoded according to their content, using tools in the email\npackage; the headers themselves give their MIME and Unicode encodings, so no user\nintervention is required. For client convenience, we also perform Unicode decoding for\nmain text parts to convert them from bytes to str here if needed.\nThe latter main-text decoding merits elaboration. As discussed earlier in this chapter,\nMessage objects (main or attached) may return their payloads as bytes if we fetch with\na decode=1 argument, or if they are bytes to begin with; in other cases, payloads may\nbe returned as str. We generally need to decode bytes in order to treat payloads as text.\nIn mailtools itself, str text part payloads are automatically encoded to bytes by\ndecode=1 and then saved to binary-mode files to finesse encoding issues, but main-text\npayloads are decoded to str if they are bytes. This main-text decoding is performed\nper the encoding name in the part\u2019s message header (if present and correct), the plat-\nform default, or a guess. As we learned in Chapter 9, while GUIs may allow bytes for\ndisplay, str text generally provides broader Unicode support; furthermore, str is\nsometimes needed for later processing such as line wrapping and webpage generation.\nSince this package can\u2019t predict the role of other part payloads besides the main text,\nclients are responsible for decoding and encoding as necessary. For instance, other text\nparts which are saved in binary mode here may require that message headers be\nconsulted later to extract Unicode encoding names for better display. For example,\nChapter 14\u2019s PyMailGUI will proceed this way to open text parts on demand, passing\nmessage header encoding information on to PyEdit for decoding as text is loaded.\nSome of the to-text conversions performed here are potentially partial solutions (some\nparts may lack the required headers and fail per the platform defaults) and may need\nto be improved; since this seems likely to be addressed in a future release of Python\u2019s\nemail package, we\u2019ll settle for our assumptions here.\n976 | Chapter 13:\u2002Client-Side ScriptingExample 13-25. PP4E\\Internet\\Email\\mailtools\\mailParser.py\n\"\"\"\n###############################################################################\nparsing and attachment extract, analyse, save (see __init__ for docs, test)\n###############################################################################\n\"\"\"\nimport os, mimetypes, sys                       # mime: map type to name\nimport email.parser                             # parse text to Message object\nimport email.header                             # 4E: headers decode/encode\nimport email.utils                              # 4E: addr header parse/decode\nfrom email.message import Message               # Message may be traversed\nfrom .mailTool import MailTool                  # 4E: package-relative\nclass MailParser(MailTool):\n    \"\"\"\n    methods for parsing message text, attachments\n    subtle thing: Message object payloads are either a simple\n    string for non-multipart messages, or a list of Message\n    objects if multipart (possibly nested); we don't need to\n    distinguish between the two cases here, because the Message\n    walk generator always returns self first, and so works fine\n    on non-multipart messages too (a single object is walked);\n    for simple messages, the message body is always considered\n    here to be the sole part of the mail;  for multipart messages,\n    the parts list includes the main message text, as well as all\n    attachments;  this allows simple messages not of type text to\n    be handled like attachments in a UI (e.g., saved, opened);\n    Message payload may also be None for some oddball part types;\n    4E note: in Py 3.1, text part payloads are returned as bytes\n    for decode=1, and might be str otherwise; in mailtools, text\n    is stored as bytes for file saves, but main-text bytes payloads\n    are decoded to Unicode str per mail header info or platform\n    default+guess; clients may need to convert other payloads:\n    PyMailGUI uses headers to decode parts saved to binary files;\n    4E supports fetched message header auto-decoding per its own\n    content, both for general headers such as Subject, as well as\n    for names in address header such as From and To; client must\n    request this after parse, before display: parser doesn't decode;\n    \"\"\"\n    def walkNamedParts(self, message):\n        \"\"\"\n        generator to avoid repeating part naming logic;\n        skips multipart headers, makes part filenames;\n        message is already parsed email.message.Message object;\n        doesn't skip oddball types: payload may be None, must\n        handle in part saves; some others may warrant skips too;\n        \"\"\"\n        for (ix, part) in enumerate(message.walk()):    # walk includes message\n            fulltype = part.get_content_type()          # ix includes parts skipped\nThe mailtools Utility Package | 977maintype = part.get_content_maintype()\n            if maintype == 'multipart':                 # multipart/*: container\n                continue\n            elif fulltype == 'message/rfc822':          # 4E: skip message/rfc822\n                continue                                # skip all message/* too?\n            else:\n                filename, contype = self.partName(part, ix)\n                yield (filename, contype, part)\n    def partName(self, part, ix):\n        \"\"\"\n        extract filename and content type from message part;\n        filename: tries Content-Disposition, then Content-Type\n        name param, or generates one based on mimetype guess;\n        \"\"\"\n        filename = part.get_filename()                # filename in msg hdrs?\n        contype  = part.get_content_type()            # lowercase maintype/subtype\n        if not filename:\n            filename = part.get_param('name')         # try content-type name\n        if not filename:\n            if contype == 'text/plain':               # hardcode plain text ext\n                ext = '.txt'                          # else guesses .ksh!\n            else:\n                ext = mimetypes.guess_extension(contype)\n                if not ext: ext = '.bin'              # use a generic default\n            filename = 'part-%03d%s' % (ix, ext)\n        return (filename, contype)\n    def saveParts(self, savedir, message):\n        \"\"\"\n        store all parts of a message as files in a local directory;\n        returns [('maintype/subtype', 'filename')] list for use by\n        callers, but does not open any parts or attachments here;\n        get_payload decodes base64, quoted-printable, uuencoded data;\n        mail parser may give us a None payload for oddball types we\n        probably should skip over: convert to str here to be safe;\n        \"\"\"\n        if not os.path.exists(savedir):\n            os.mkdir(savedir)\n        partfiles = []\n        for (filename, contype, part) in self.walkNamedParts(message):\n            fullname = os.path.join(savedir, filename)\n            fileobj  = open(fullname, 'wb')             # use binary mode\n            content  = part.get_payload(decode=1)       # decode base64,qp,uu\n            if not isinstance(content, bytes):          # 4E: need bytes for rb\n                content = b'(no content)'               # decode=1 returns bytes,\n            fileobj.write(content)                      # but some payloads None\n            fileobj.close()                             # 4E: not str(content)\n            partfiles.append((contype, fullname))       # for caller to open\n        return partfiles\n    def saveOnePart(self, savedir, partname, message):\n        \"\"\"\n        ditto, but find and save just one part by name\n        \"\"\"\n978 | Chapter 13:\u2002Client-Side Scriptingif not os.path.exists(savedir):\n            os.mkdir(savedir)\n        fullname = os.path.join(savedir, partname)\n        (contype, content) = self.findOnePart(partname, message)\n        if not isinstance(content, bytes):          # 4E: need bytes for rb\n            content = b'(no content)'               # decode=1 returns bytes,\n        open(fullname, 'wb').write(content)         # but some payloads None\n        return (contype, fullname)                  # 4E: not str(content)\n    def partsList(self, message):\n        \"\"\"\"\n        return a list of filenames for all parts of an\n        already parsed message, using same filename logic\n        as saveParts, but do not store the part files here\n        \"\"\"\n        validParts = self.walkNamedParts(message)\n        return [filename for (filename, contype, part) in validParts]\n    def findOnePart(self, partname, message):\n        \"\"\"\n        find and return part's content, given its name;\n        intended to be used in conjunction with partsList;\n        we could also mimetypes.guess_type(partname) here;\n        we could also avoid this search by saving in dict;\n        4E: content may be str or bytes--convert as needed;\n        \"\"\"\n        for (filename, contype, part) in self.walkNamedParts(message):\n            if filename == partname:\n                content = part.get_payload(decode=1)          # does base64,qp,uu\n                return (contype, content)                     # may be bytes text\n    def decodedPayload(self, part, asStr=True):\n        \"\"\"\n        4E: decode text part bytes to Unicode str for display, line wrap,\n        etc.; part is a Message; (decode=1) undoes MIME email encodings\n        (base64, uuencode, qp), bytes.decode() performs additional Unicode\n        text string decodings; tries charset encoding name in message\n        headers first (if present, and accurate), then tries platform\n        defaults and a few guesses before giving up with error string;\n        \"\"\"\n        payload = part.get_payload(decode=1)           # payload may be bytes\n        if asStr and isinstance(payload, bytes):       # decode=1 returns bytes\n            tries = []\n            enchdr = part.get_content_charset()        # try msg headers first!\n            if enchdr:\n                tries += [enchdr]                      # try headers first\n            tries += [sys.getdefaultencoding()]        # same as bytes.decode()\n            tries += ['latin1', 'utf8']                # try 8-bit, incl ascii\n            for trie in tries:                         # try utf8 (windows dflt)\n                try:\n                    payload = payload.decode(trie)     # give it a shot, eh?\n                    break\n                except (UnicodeError, LookupError):    # lookuperr: bad name\n                    pass\n            else:\nThe mailtools Utility Package | 979payload = '--Sorry: cannot decode Unicode text--'\n        return payload\n    def findMainText(self, message, asStr=True):\n        \"\"\"\n        for text-oriented clients, return first text part's str;\n        for the payload of a simple message, or all parts of\n        a multipart message, looks for text/plain, then text/html,\n        then text/*, before deducing that there is no text to\n        display;  this is a heuristic, but covers most simple,\n        multipart/alternative, and multipart/mixed messages;\n        content-type defaults to text/plain if not in simple msg;\n        handles message nesting at top level by walking instead\n        of list scans;  if non-multipart but type is text/html,\n        returns the HTML as the text with an HTML type: caller\n        may open in web browser, extract plain text, etc;  if\n        nonmultipart and not text, there is  no text to display:\n        save/open message content in UI; caveat: does not try\n        to concatenate multiple inline text/plain parts if any;\n        4E: text payloads may be bytes--decodes to str here;\n        4E: asStr=False to get raw bytes for HTML file saves;\n        \"\"\"\n        # try to find a plain text\n        for part in message.walk():                            # walk visits message\n            type = part.get_content_type()                     # if nonmultipart\n            if type == 'text/plain':                           # may be base64,qp,uu\n                return type, self.decodedPayload(part, asStr)  # bytes to str too?\n        # try to find an HTML part\n        for part in message.walk():\n            type = part.get_content_type()                     # caller renders html\n            if type == 'text/html':\n                return type, self.decodedPayload(part, asStr)\n        # try any other text type, including XML\n        for part in message.walk():\n            if part.get_content_maintype() == 'text':\n                return part.get_content_type(), self.decodedPayload(part, asStr)\n        # punt: could use first part, but it's not marked as text\n        failtext = '[No text to display]' if asStr else b'[No text to display]'\n        return 'text/plain', failtext\n    def decodeHeader(self, rawheader):\n        \"\"\"\n        4E: decode existing i18n message header text per both email and Unicode\n        standards, according to its content; return as is if unencoded or fails;\n        client must call this to display: parsed Message object does not decode;\n        i18n header example: '=?UTF-8?Q?Introducing=20Top=20Values=20..Savers?=';\n        i18n header example: 'Man where did you get that =?UTF-8?Q?assistant=3F?=';\n        decode_header handles any line breaks in header string automatically, may\n        return multiple parts if any substrings of hdr are encoded, and returns all\n980 | Chapter 13:\u2002Client-Side Scriptingbytes in parts list if any encodings found (with unencoded parts encoded as\n        raw-unicode-escape and enc=None) but returns a single part with enc=None\n        that is str instead of bytes in Py3.1 if the entire header is unencoded\n        (must handle mixed types here); see Chapter 13 for more details/examples;\n        the following first attempt code was okay unless any encoded substrings, or\n        enc was returned as None (raised except which returned rawheader unchanged):\n        hdr, enc = email.header.decode_header(rawheader)[0]\n        return hdr.decode(enc) # fails if enc=None: no encoding or encoded substrs\n        \"\"\"\n        try:\n            parts = email.header.decode_header(rawheader)\n            decoded = []\n            for (part, enc) in parts:                      # for all substrings\n                if enc == None:                            # part unencoded?\n                    if not isinstance(part, bytes):        # str: full hdr unencoded\n                        decoded += [part]                  # else do unicode decode\n                    else:\n                        decoded += [part.decode('raw-unicode-escape')]\n                else:\n                    decoded += [part.decode(enc)]\n            return ' '.join(decoded)\n        except:\n            return rawheader         # punt!\n    def decodeAddrHeader(self, rawheader):\n        \"\"\"\n        4E: decode existing i18n address header text per email and Unicode,\n        according to its content; must parse out first part of email address\n        to get i18n part: '\"=?UTF-8?Q?Walmart?=\" <newsletters@walmart.com>';\n        From will probably have just 1 addr, but To, Cc, Bcc may have many;\n        decodeHeader handles nested encoded substrings within an entire hdr,\n        but we can't simply call it for entire hdr here because it fails if\n        encoded name substring ends in \" quote instead of whitespace or endstr;\n        see also encodeAddrHeader in mailSender module for the inverse of this;\n        the following first attempt code failed to handle encoded substrings in\n        name, and raised exc for unencoded bytes parts if any encoded substrings;\n        namebytes, nameenc = email.header.decode_header(name)[0]  (do email+MIME)\n        if nameenc: name = namebytes.decode(nameenc)              (do Unicode?)\n        \"\"\"\n        try:\n            pairs = email.utils.getaddresses([rawheader])  # split addrs and parts\n            decoded = []                                   # handles name commas\n            for (name, addr) in pairs:\n                try:\n                    name = self.decodeHeader(name)                # email+MIME+Uni\n                except:\n                    name = None   # but uses encooded name if exc in decodeHeader\n                joined = email.utils.formataddr((name, addr))     # join parts\n                decoded.append(joined)\n            return ', '.join(decoded)                             # >= 1 addrs\n        except:\n            return self.decodeHeader(rawheader)    # try decoding entire string\nThe mailtools Utility Package | 981def splitAddresses(self, field):\n        \"\"\"\n        4E: use comma separator for multiple addrs in the UI, and\n        getaddresses to split correctly and allow for comma in the\n        name parts of addresses; used by PyMailGUI to split To, Cc,\n        Bcc as needed for user inputs and copied headers;  returns\n        empty list if field is empty, or any exception occurs;\n        \"\"\"\n        try:\n            pairs = email.utils.getaddresses([field])                # [(name,addr)]\n            return [email.utils.formataddr(pair) for pair in pairs]  # [name <addr>]\n        except:\n            return ''   # syntax error in user-entered field?, etc.\n    # returned when parses fail\n    errorMessage = Message()\n    errorMessage.set_payload('[Unable to parse message - format error]')\n    def parseHeaders(self, mailtext):\n        \"\"\"\n        parse headers only, return root email.message.Message object\n        stops after headers parsed, even if nothing else follows (top)\n        email.message.Message object is a mapping for mail header fields\n        payload of message object is None, not raw body text\n        \"\"\"\n        try:\n            return email.parser.Parser().parsestr(mailtext, headersonly=True)\n        except:\n            return self.errorMessage\n    def parseMessage(self, fulltext):\n        \"\"\"\n        parse entire message, return root email.message.Message object\n        payload of message object is a string if not is_multipart()\n        payload of message object is more Messages if multiple parts\n        the call here same as calling email.message_from_string()\n        \"\"\"\n        try:\n            return email.parser.Parser().parsestr(fulltext)       # may fail!\n        except:\n            return self.errorMessage     # or let call handle? can check return\n    def parseMessageRaw(self, fulltext):\n        \"\"\"\n        parse headers only, return root email.message.Message object\n        stops after headers parsed, for efficiency (not yet used here)\n        payload of message object is raw text of mail after headers\n        \"\"\"\n        try:\n            return email.parser.HeaderParser().parsestr(fulltext)\n        except:\n            return self.errorMessage\n982 | Chapter 13:\u2002Client-Side ScriptingSelf-Test Script\nThe last file in the mailtools package, Example 13-26, lists the self-test code for the\npackage. This code is a separate script file, in order to allow for import search path\nmanipulation\u2014it emulates a real client, which is assumed to have a mailconfig.py\nmodule in its own source directory (this module can vary per client).\nExample 13-26. PP4E\\Internet\\Email\\mailtools\\selftest.py\n\"\"\"\n###############################################################################\nself-test when this file is run as a program\n###############################################################################\n\"\"\"\n#\n# mailconfig normally comes from the client's source directory or\n# sys.path; for testing, get it from Email directory one level up\n#\nimport sys\nsys.path.append('..')\nimport mailconfig\nprint('config:', mailconfig.__file__)\n# get these from __init__\nfrom mailtools import (MailFetcherConsole,\n                       MailSender, MailSenderAuthConsole,\n                       MailParser)\nif not mailconfig.smtpuser:\n    sender = MailSender(tracesize=5000)\nelse:\n    sender = MailSenderAuthConsole(tracesize=5000)\nsender.sendMessage(From      = mailconfig.myaddress,\n                   To        = [mailconfig.myaddress],\n                   Subj      = 'testing mailtools package',\n                   extrahdrs = [('X-Mailer', 'mailtools')],\n                   bodytext  = 'Here is my source code\\n',\n                   attaches  = ['selftest.py'],\n                  )\n                   # bodytextEncoding='utf-8',          # other tests to try\n                   # attachesEncodings=['latin-1'],     # inspect text headers\n                   # attaches=['monkeys.jpg'])          # verify Base64 encoded\n                   # to='i18n adddr list...',           # test mime/unicode headers\n# change mailconfig to test fetchlimit\nfetcher = MailFetcherConsole()\ndef status(*args): print(args)\nhdrs, sizes, loadedall = fetcher.downloadAllHeaders(status)\nfor num, hdr in enumerate(hdrs[:5]):\n    print(hdr)\nThe mailtools Utility Package | 983if input('load mail?') in ['y', 'Y']:\n        print(fetcher.downloadMessage(num+1).rstrip(), '\\n', '-'*70)\nlast5 = len(hdrs)-4\nmsgs, sizes, loadedall = fetcher.downloadAllMessages(status, loadfrom=last5)\nfor msg in msgs:\n    print(msg[:200], '\\n', '-'*70)\nparser = MailParser()\nfor i in [0]:                  # try [0 , len(msgs)]\n    fulltext = msgs[i]\n    message  = parser.parseMessage(fulltext)\n    ctype, maintext = parser.findMainText(message)\n    print('Parsed:', message['Subject'])\n    print(maintext)\ninput('Press Enter to exit')   # pause if clicked on Windows\nRunning the self-test\nHere\u2019s a run of the self-test script; it generates a lot of output, most of which has been\ndeleted here for presentation in this book\u2014as usual, run this on your own for further\ndetails:\nC:\\...\\PP4E\\Internet\\Email\\mailtools> selftest.py\nconfig: ..\\mailconfig.py\nuser: PP4E@learning-python.com\nAdding text/x-python\nSending to...['PP4E@learning-python.com']\nContent-Type: multipart/mixed; boundary=\"===============0085314748==\"\nMIME-Version: 1.0\nFrom: PP4E@learning-python.com\nTo: PP4E@learning-python.com\nSubject: testing mailtools package\nDate: Sat, 08 May 2010 19:26:22 \u22120000\nX-Mailer: mailtools\nA multi-part MIME format message.\n--===============0085314748==\nContent-Type: text/plain; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nHere is my source code\n--===============0085314748==\nContent-Type: text/x-python; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nContent-Disposition: attachment; filename=\"selftest.py\"\n\"\"\"\n###############################################################################\nself-test when this file is run as a program\n###############################################################################\n984 | Chapter 13:\u2002Client-Side Scripting\"\"\"\n...more lines omitted...\nprint(maintext)\ninput('Press Enter to exit')   # pause if clicked on Windows\n--===============0085314748==--\nSend exit\nloading headers\nConnecting...\nPassword for PP4E@learning-python.com on pop.secureserver.net?\nb'+OK <28121.1273346862@p3pop01-07.prod.phx3.gdg>'\n(1, 7)\n(2, 7)\n(3, 7)\n(4, 7)\n(5, 7)\n(6, 7)\n(7, 7)\nload headers exit\nReceived: (qmail 7690 invoked from network); 5 May 2010 15:29:43 \u22120000\nReceived: from unknown (HELO p3pismtp01-026.prod.phx3.secureserver.net) ([10.6.1\n...more lines omitted...\nload mail?y\nload 1\nConnecting...\nb'+OK <29205.1273346957@p3pop01-10.prod.phx3.gdg>'\nReceived: (qmail 7690 invoked from network); 5 May 2010 15:29:43 \u22120000\nReceived: from unknown (HELO p3pismtp01-026.prod.phx3.secureserver.net) ([10.6.1\n...more lines omitted...\nload mail?\nloading full messages\nConnecting...\nb'+OK <31655.1273347055@p3pop01-25.prod.phx3.secureserver.net>'\n(3, 7)\n(4, 7)\n(5, 7)\n(6, 7)\n(7, 7)\nReceived: (qmail 25683 invoked from network); 6 May 2010 14:12:07 \u22120000\nReceived: from unknown (HELO p3pismtp01-018.prod.phx3.secureserver.net) ([10.6.1\n...more lines omitted...\nParsed: A B C D E F G\nFiddle de dum, Fiddle de dee,\nEric the half a bee.\nPress Enter to exit\nThe mailtools Utility Package | 985Updating the pymail Console Client\nAs a final email example in this chapter, and to give a better use case for the mail\ntools module package of the preceding sections, Example 13-27 provides an updated\nversion of the pymail program we met earlier (Example 13-20). It uses our mailtools\npackage to access email, instead of interfacing with Python\u2019s email package directly.\nCompare its code to the original pymail in this chapter to see how mailtools is employed\nhere. You\u2019ll find that its mail download and send logic is substantially simpler.\nExample 13-27. PP4E\\Internet\\Email\\pymail2.py\n#!/usr/local/bin/python\n\"\"\"\n################################################################################\npymail2 - simple console email interface client in Python;  this version uses\nthe mailtools package, which in turn uses poplib, smtplib, and the email package\nfor parsing and composing emails;  displays first text part of mails, not the\nentire full text;  fetches just mail headers initially, using the TOP command;\nfetches full text of just email selected to be displayed;  caches already\nfetched mails; caveat: no way to refresh index;  uses standalone mailtools\nobjects - they can also be used as superclasses;\n################################################################################\n\"\"\"\nimport mailconfig, mailtools\nfrom pymail import inputmessage\nmailcache = {}\ndef fetchmessage(i):\n    try:\n        fulltext = mailcache[i]\n    except KeyError:\n        fulltext = fetcher.downloadMessage(i)\n        mailcache[i] = fulltext\n    return fulltext\ndef sendmessage():\n    From, To, Subj, text = inputmessage()\n    sender.sendMessage(From, To, Subj, [], text, attaches=None)\ndef deletemessages(toDelete, verify=True):\n    print('To be deleted:', toDelete)\n    if verify and input('Delete?')[:1] not in ['y', 'Y']:\n        print('Delete cancelled.')\n    else:\n        print('Deleting messages from server...')\n        fetcher.deleteMessages(toDelete)\ndef showindex(msgList, msgSizes, chunk=5):\n    count = 0\n    for (msg, size) in zip(msgList, msgSizes):     # email.message.Message, int\n        count += 1                                 # 3.x iter ok here\n        print('%d:\\t%d bytes' % (count, size))\n        for hdr in ('From', 'To', 'Date', 'Subject'):\n986 | Chapter 13:\u2002Client-Side Scriptingprint('\\t%-8s=>%s' % (hdr, msg.get(hdr, '(unknown)')))\n        if count % chunk == 0:\n            input('[Press Enter key]')             # pause after each chunk\ndef showmessage(i, msgList):\n    if 1 <= i <= len(msgList):\n        fulltext = fetchmessage(i)\n        message  = parser.parseMessage(fulltext)\n        ctype, maintext = parser.findMainText(message)\n        print('-' * 79)\n        print(maintext.rstrip() + '\\n')   # main text part, not entire mail\n        print('-' * 79)                   # and not any attachments after\n    else:\n        print('Bad message number')\ndef savemessage(i, mailfile, msgList):\n    if 1 <= i <= len(msgList):\n        fulltext = fetchmessage(i)\n        savefile = open(mailfile, 'a', encoding=mailconfig.fetchEncoding)   # 4E\n        savefile.write('\\n' + fulltext + '-'*80 + '\\n')\n    else:\n        print('Bad message number')\ndef msgnum(command):\n    try:\n        return int(command.split()[1])\n    except:\n        return \u22121   # assume this is bad\nhelptext = \"\"\"\nAvailable commands:\ni     - index display\nl n?  - list all messages (or just message n)\nd n?  - mark all messages for deletion (or just message n)\ns n?  - save all messages to a file (or just message n)\nm     - compose and send a new mail message\nq     - quit pymail\n?     - display this help text\n\"\"\"\ndef interact(msgList, msgSizes, mailfile):\n    showindex(msgList, msgSizes)\n    toDelete = []\n    while True:\n        try:\n            command = input('[Pymail] Action? (i, l, d, s, m, q, ?) ')\n        except EOFError:\n            command = 'q'\n        if not command: command = '*'\n        if command == 'q':                     # quit\n            break\n        elif command[0] == 'i':                # index\n            showindex(msgList, msgSizes)\nThe mailtools Utility Package | 987elif command[0] == 'l':                # list\n            if len(command) == 1:\n                for i in range(1, len(msgList)+1):\n                    showmessage(i, msgList)\n            else:\n                showmessage(msgnum(command), msgList)\n        elif command[0] == 's':                # save\n            if len(command) == 1:\n                for i in range(1, len(msgList)+1):\n                    savemessage(i, mailfile, msgList)\n            else:\n                savemessage(msgnum(command), mailfile, msgList)\n        elif command[0] == 'd':                # mark for deletion later\n            if len(command) == 1:              # 3.x needs list(): iter\n                toDelete = list(range(1, len(msgList)+1))\n            else:\n                delnum = msgnum(command)\n                if (1 <= delnum <= len(msgList)) and (delnum not in toDelete):\n                    toDelete.append(delnum)\n                else:\n                    print('Bad message number')\n        elif command[0] == 'm':                # send a new mail via SMTP\n            try:\n                sendmessage()\n            except:\n                print('Error - mail not sent')\n        elif command[0] == '?':\n            print(helptext)\n        else:\n            print('What? -- type \"?\" for commands help')\n    return toDelete\ndef main():\n    global parser, sender, fetcher\n    mailserver = mailconfig.popservername\n    mailuser   = mailconfig.popusername\n    mailfile   = mailconfig.savemailfile\n    parser     = mailtools.MailParser()\n    sender     = mailtools.MailSender()\n    fetcher    = mailtools.MailFetcherConsole(mailserver, mailuser)\n    def progress(i, max):\n        print(i, 'of', max)\n    hdrsList, msgSizes, ignore = fetcher.downloadAllHeaders(progress)\n    msgList = [parser.parseHeaders(hdrtext) for hdrtext in hdrsList]\n    print('[Pymail email client]')\n    toDelete = interact(msgList, msgSizes, mailfile)\n988 | Chapter 13:\u2002Client-Side Scriptingif toDelete: deletemessages(toDelete)\nif __name__ == '__main__': main()\nRunning the pymail2 console client\nThis program is used interactively, the same as the original. In fact, the output is nearly\nidentical, so we won\u2019t go into further details. Here\u2019s a quick look at this script in action;\nrun this on your own machine to see it firsthand:\nC:\\...\\PP4E\\Internet\\Email> pymail2.py\nuser: PP4E@learning-python.com\nloading headers\nConnecting...\nPassword for PP4E@learning-python.com on pop.secureserver.net?\nb'+OK <24460.1273347818@pop15.prod.mesa1.secureserver.net>'\n1 of 7\n2 of 7\n3 of 7\n4 of 7\n5 of 7\n6 of 7\n7 of 7\nload headers exit\n[Pymail email client]\n1:      1860 bytes\n        From    =>lutz@rmi.net\n        To      =>pp4e@learning-python.com\n        Date    =>Wed, 5 May 2010 11:29:36 \u22120400 (EDT)\n        Subject =>I'm a Lumberjack, and I'm Okay\n2:      1408 bytes\n        From    =>lutz@learning-python.com\n        To      =>PP4E@learning-python.com\n        Date    =>Wed, 05 May 2010 08:33:47 \u22120700\n        Subject =>testing\n3:      1049 bytes\n        From    =>Eric.the.Half.a.Bee@yahoo.com\n        To      =>PP4E@learning-python.com\n        Date    =>Thu, 06 May 2010 14:11:07 \u22120000\n        Subject =>A B C D E F G\n4:      1038 bytes\n        From    =>Eric.the.Half.a.Bee@aol.com\n        To      =>nobody.in.particular@marketing.com\n        Date    =>Thu, 06 May 2010 14:32:32 \u22120000\n        Subject =>a b c d e f g\n5:      957 bytes\n        From    =>PP4E@learning-python.com\n        To      =>maillist\n        Date    =>Thu, 06 May 2010 10:58:40 \u22120400\n        Subject =>test interactive smtplib\n[Press Enter key]\n6:      1037 bytes\n        From    =>Cardinal@hotmail.com\n        To      =>PP4E@learning-python.com\n        Date    =>Fri, 07 May 2010 20:32:38 \u22120000\nThe mailtools Utility Package | 989Subject =>Among our weapons are these\n7:      3248 bytes\n        From    =>PP4E@learning-python.com\n        To      =>PP4E@learning-python.com\n        Date    =>Sat, 08 May 2010 19:26:22 \u22120000\n        Subject =>testing mailtools package\n[Pymail] Action? (i, l, d, s, m, q, ?) l 7\nload 7\nConnecting...\nb'+OK <20110.1273347827@pop07.prod.mesa1.secureserver.net>'\n-------------------------------------------------------------------------------\nHere is my source code\n-------------------------------------------------------------------------------\n[Pymail] Action? (i, l, d, s, m, q, ?) d 7\n[Pymail] Action? (i, l, d, s, m, q, ?) m\nFrom? lutz@rmi.net\nTo?   PP4E@learning-python.com\nSubj? test pymail2 send\nType message text, end with line=\".\"\nRun away! Run away!\n.\nSending to...['PP4E@learning-python.com']\nFrom: lutz@rmi.net\nTo: PP4E@learning-python.com\nSubject: test pymail2 send\nDate: Sat, 08 May 2010 19:44:25 \u22120000\nRun away! Run away!\nSend exit\n[Pymail] Action? (i, l, d, s, m, q, ?) q\nTo be deleted: [7]\nDelete?y\nDeleting messages from server...\ndeleting mails\nConnecting...\nb'+OK <11553.1273347873@pop17.prod.mesa1.secureserver.net>'\nThe messages in our mailbox have quite a few origins now\u2014ISP webmail clients, basic\nSMTP scripts, the Python interactive command line, mailtools self-test code, and two\nconsole-based email clients; in later chapters, we\u2019ll add even more. All their mails look\nthe same to our script; here\u2019s a verification of the email we just sent (the second fetch\nfinds it already in-cache):\nC:\\...\\PP4E\\Internet\\Email> pymail2.py\nuser: PP4E@learning-python.com\nloading headers\nConnecting...\n...more lines omitted...\n[Press Enter key]\n6:      1037 bytes\n        From    =>Cardinal@hotmail.com\n        To      =>PP4E@learning-python.com\n990 | Chapter 13:\u2002Client-Side ScriptingDate    =>Fri, 07 May 2010 20:32:38 \u22120000\n        Subject =>Among our weapons are these\n7:      984 bytes\n        From    =>lutz@rmi.net\n        To      =>PP4E@learning-python.com\n        Date    =>Sat, 08 May 2010 19:44:25 \u22120000\n        Subject =>test pymail2 send\n[Pymail] Action? (i, l, d, s, m, q, ?) l 7\nload 7\nConnecting...\nb'+OK <31456.1273348189@p3pop01-03.prod.phx3.gdg>'\n-------------------------------------------------------------------------------\nRun away! Run away!\n-------------------------------------------------------------------------------\n[Pymail] Action? (i, l, d, s, m, q, ?) l 7\n-------------------------------------------------------------------------------\nRun away! Run away!\n-------------------------------------------------------------------------------\n[Pymail] Action? (i, l, d, s, m, q, ?) q\nStudy pymail2\u2019s code for more insights. As you\u2019ll see, this version eliminates some\ncomplexities, such as the manual formatting of composed mail message text. It also\ndoes a better job of displaying a mail\u2019s text\u2014instead of blindly listing the full mail text\n(attachments and all), it uses mailtools to fetch the first text part of the message. The\nmessages we\u2019re using are too simple to show the difference, but for a mail with attach-\nments, this new version will be more focused about what it displays.\nMoreover, because the interface to mail is encapsulated in the mailtools package\u2019s\nmodules, if it ever must change, it will only need to be changed in that module, re-\ngardless of how many mail clients use its tools. And because the code in mailtools is\nshared, if we know it works for one client, we can be sure it will work in another; there\nis no need to debug new code.\nOn the other hand, pymail2 doesn\u2019t really leverage much of the power of either mail\ntools or the underlying email package it uses. For example, things like attachments,\nInternationalized headers, and inbox synchronization are not handled at all, and print-\ning of some decoded main text may contain character sets incompatible with the con-\nsole terminal interface. To see the full scope of the email package, we need to explore\na larger email system, such as PyMailGUI or PyMailCGI. The first of these is the topic\nof the next chapter, and the second appears in Chapter 16. First, though, let\u2019s quickly\nsurvey a handful of additional client-side protocol tools.\nNNTP: Accessing Newsgroups\nSo far in this chapter, we have focused on Python\u2019s FTP and email processing tools and\nhave met a handful of client-side scripting modules along the way: ftplib, poplib,\nsmtplib, email, mimetypes, urllib, and so on. This set is representative of Python\u2019s\nNNTP: Accessing Newsgroups | 991client-side library tools for transferring and processing information over the Internet,\nbut it\u2019s not at all complete.\nA more or less comprehensive list of Python\u2019s Internet-related modules appears at the\nstart of the previous chapter. Among other things, Python also includes client-side\nsupport libraries for Internet news, Telnet, HTTP, XML-RPC, and other standard pro-\ntocols. Most of these are analogous to modules we\u2019ve already met\u2014they provide an\nobject-based interface that automates the underlying sockets and message structures.\nFor instance, Python\u2019s nntplib module supports the client-side interface to NNTP\u2014\nthe Network News Transfer Protocol\u2014which is used for reading and posting articles\nto Usenet newsgroups on the Internet. Like other protocols, NNTP runs on top of\nsockets and merely defines a standard message protocol; like other modules, nntplib\nhides most of the protocol details and presents an object-based interface to Python\nscripts.\nWe won\u2019t get into full protocol details here, but in brief, NNTP servers store a range\nof articles on the server machine, usually in a flat-file database. If you have the domain\nor IP name of a server machine that runs an NNTP server program listening on the\nNNTP port, you can write scripts that fetch or post articles from any machine that has\nPython and an Internet connection. For instance, the script in Example 13-28 by default\nfetches and displays the last 10 articles from Python\u2019s Internet newsgroup,\ncomp.lang.python, from the news.rmi.net NNTP server at one of my ISPs.\nExample 13-28. PP4E\\Internet\\Other\\readnews.py\n\"\"\"\nfetch and print usenet newsgroup posting from comp.lang.python via the\nnntplib module, which really runs on top of sockets; nntplib also supports\nposting new messages, etc.; note: posts not deleted after they are read;\n\"\"\"\nlistonly = False\nshowhdrs = ['From', 'Subject', 'Date', 'Newsgroups', 'Lines']\ntry:\n    import sys\n    servername, groupname, showcount = sys.argv[1:]\n    showcount  = int(showcount)\nexcept:\n    servername = nntpconfig.servername       # assign this to your server\n    groupname  = 'comp.lang.python'          # cmd line args or defaults\n    showcount  = 10                          # show last showcount posts\n# connect to nntp server\nprint('Connecting to', servername, 'for', groupname)\nfrom nntplib import NNTP\nconnection = NNTP(servername)\n(reply, count, first, last, name) = connection.group(groupname)\nprint('%s has %s articles: %s-%s' % (name, count, first, last))\n# get request headers only\nfetchfrom = str(int(last) - (showcount-1))\n992 | Chapter 13:\u2002Client-Side Scripting(reply, subjects) = connection.xhdr('subject', (fetchfrom + '-' + last))\n# show headers, get message hdr+body\nfor (id, subj) in subjects:                  # [-showcount:] if fetch all hdrs\n    print('Article %s [%s]' % (id, subj))\n    if not listonly and input('=> Display?') in ['y', 'Y']:\n        reply, num, tid, list = connection.head(id)\n        for line in list:\n            for prefix in showhdrs:\n                if line[:len(prefix)] == prefix:\n                    print(line[:80])\n                    break\n        if input('=> Show body?') in ['y', 'Y']:\n            reply, num, tid, list = connection.body(id)\n            for line in list:\n                print(line[:80])\n    print()\nprint(connection.quit())\nAs for FTP and email tools, the script creates an NNTP object and calls its methods to\nfetch newsgroup information and articles\u2019 header and body text. The xhdr method, for\nexample, loads selected headers from a range of messages.\nFor NNTP servers that require authentication, you may also have to pass a username,\na password, and possibly a reader-mode flag to the NNTP call. See the Python Library\nmanual for more on other NNTP parameters and object methods.\nIn the interest of space and time, I\u2019ll omit this script\u2019s outputs here. When run, it\nconnects to the server and displays each article\u2019s subject line, pausing to ask whether\nit should fetch and show the article\u2019s header information lines (headers listed in the\nvariable showhdrs only) and body text. We can also pass this script an explicit server\nname, newsgroup, and display count on the command line to apply it in different ways.\nWith a little more work, we could turn this script into a full-blown news interface. For\ninstance, new articles could be posted from within a Python script with code of this\nform (assuming the local file already contains proper NNTP header lines):\n# to post, say this (but only if you really want to post!)\nconnection = NNTP(servername)\nlocalfile = open('filename')      # file has proper headers\nconnection.post(localfile)        # send text to newsgroup\nconnection.quit()\nWe might also add a tkinter-based GUI frontend to this script to make it more usable,\nbut we\u2019ll leave such an extension on the suggested exercise heap (see also the PyMail-\nGUI interface\u2019s suggested extensions at the end of the next chapter\u2014email and news\nmessages have a similar structure).\nNNTP: Accessing Newsgroups | 993HTTP: Accessing Websites\nPython\u2019s standard library (the modules that are installed with the interpreter) also in-\ncludes client-side support for HTTP\u2014the Hypertext Transfer Protocol\u2014a message\nstructure and port standard used to transfer information on the World Wide Web. In\nshort, this is the protocol that your web browser (e.g., Internet Explorer, Firefox,\nChrome, or Safari) uses to fetch web pages and run applications on remote servers as\nyou surf the Web. Essentially, it\u2019s just bytes sent over port 80.\nTo really understand HTTP-style transfers, you need to know some of the server-side\nscripting topics covered in Chapter 15 (e.g., script invocations and Internet address\nschemes), so this section may be less useful to readers with no such background.\nLuckily, though, the basic HTTP interfaces in Python are simple enough for a cursory\nunderstanding even at this point in the book, so let\u2019s take a brief look here.\nPython\u2019s standard http.client module automates much of the protocol defined by\nHTTP and allows scripts to fetch web pages as clients much like web browsers; as we\u2019ll\nsee in Chapter 15, http.server also allows us to implement web servers to handle the\nother side of the dialog. For instance, the script in Example 13-29 can be used to grab\nany file from any server machine running an HTTP web server program. As usual, the\nfile (and descriptive header lines) is ultimately transferred as formatted messages over\na standard socket port, but most of the complexity is hidden by the http.client module\n(see our raw socket dialog with a port 80 HTTP server in Chapter 12 for a comparison).\nExample 13-29. PP4E\\Internet\\Other\\http-getfile.py\n\"\"\"\nfetch a file from an HTTP (web) server over sockets via http.client;  the filename\nparameter may have a full directory path, and may name a CGI script with ? query\nparameters on the end to invoke a remote program;  fetched file data or remote\nprogram output could be saved to a local file to mimic FTP, or parsed with str.find\nor html.parser module;  also: http.client request(method, url, body=None, hdrs={});\n\"\"\"\nimport sys, http.client\nshowlines = 6\ntry:\n    servername, filename = sys.argv[1:]           # cmdline args?\nexcept:\n    servername, filename = 'learning-python.com', '/index.html'\nprint(servername, filename)\nserver = http.client.HTTPConnection(servername)   # connect to http site/server\nserver.putrequest('GET', filename)                # send request and headers\nserver.putheader('Accept', 'text/html')           # POST requests work here too\nserver.endheaders()                               # as do CGI script filenames\nreply = server.getresponse()                      # read reply headers + data\nif reply.status != 200:                           # 200 means success\n    print('Error sending request', reply.status, reply.reason)\nelse:\n994 | Chapter 13:\u2002Client-Side Scriptingdata = reply.readlines()                      # file obj for data received\n    reply.close()                                 # show lines with eoln at end\n    for line in data[:showlines]:                 # to save, write data to file\n        print(line)                               # line already has \\n, but bytes\nDesired server names and filenames can be passed on the command line to override\nhardcoded defaults in the script. You need to know something of the HTTP protocol\nto make the most sense of this code, but it\u2019s fairly straightforward to decipher. When\nrun on the client, this script makes an HTTP object to connect to the server, sends it a\nGET request along with acceptable reply types, and then reads the server\u2019s reply. Much\nlike raw email message text, the HTTP server\u2019s reply usually begins with a set of\ndescriptive header lines, followed by the contents of the requested file. The HTTP\nobject\u2019s getfile method gives us a file object from which we can read the downloaded\ndata.\nLet\u2019s fetch a few files with this script. Like all Python client-side scripts, this one works\non any machine with Python and an Internet connection (here it runs on a Windows\nclient). Assuming that all goes well, the first few lines of the downloaded file are printed;\nin a more realistic application, the text we fetch would probably be saved to a local file,\nparsed with Python\u2019s html.parser module (introduced in Chapter 19), and so on.\nWithout arguments, the script simply fetches the HTML index page at http://learning\n-python.com, a domain name I host at a commercial service provider:\nC:\\...\\PP4E\\Internet\\Other> http-getfile.py\nlearning-python.com /index.html\nb'<HTML>\\n'\nb' \\n'\nb'<HEAD>\\n'\nb\"<TITLE>Mark Lutz's Python Training Services</TITLE>\\n\"\nb'<!--mstheme--><link rel=\"stylesheet\" type=\"text/css\" href=\"_themes/blends/blen...'\nb'</HEAD>\\n'\nNotice that in Python 3.X the fetched data comes back as bytes strings again, not str;\nsince the Python html.parser HTML parse we\u2019ll meet in Chapter 19 expects str text\nstrings instead of bytes, you\u2019ll likely need to resolve a Unicode encoding choice here\nin order to parse, much the same as we did for email message text earlier in this chapter.\nAs there, we might decode from bytes to str per a default, user preferences or selections,\nheaders inspection, or byte structure analysis. Because sockets send raw bytes, we con-\nfront this choice point whenever data shipped over them is text in nature; unless that\ntext\u2019s type is known or always simple in form, Unicode implies extra steps.\nWe can also list a server and file to be fetched on the command line, if we want to be\nmore specific. In the following code, we use the script to fetch files from two different\nwebsites by listing their names on the command lines (I\u2019ve truncated some of these\nlines so they fit in this book). Notice that the filename argument can include an arbitrary\nremote directory path to the desired file, as in the last fetch here:\nC:\\...\\PP4E\\Internet\\Other> http-getfile.py www.python.org /index.html\nwww.python.org /index.html\nb'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3....'\nHTTP: Accessing Websites | 995b'\\n'\nb'\\n'\nb'<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\\n'\nb'\\n'\nb'<head>\\n'\nC:\\...\\PP4E\\Internet\\Other> http-getfile.py www.python.org index.html\nwww.python.org index.html\nError sending request 400 Bad Request\nC:\\...\\PP4E\\Internet\\Other> http-getfile.py www.rmi.net /~lutz\nwww.rmi.net /~lutz\nError sending request 301 Moved Permanently\nC:\\...\\PP4E\\Internet\\Other> http-getfile.py www.rmi.net /~lutz/index.html\nwww.rmi.net /~lutz/index.html\nb'<HTML>\\n'\nb'\\n'\nb'<HEAD>\\n'\nb\"<TITLE>Mark Lutz's Book Support Site</TITLE>\\n\"\nb'</HEAD>\\n'\nb'<BODY BGCOLOR=\"#f1f1ff\">\\n'\nNotice the second and third attempts in this code: if the request fails, the script receives\nand displays an HTTP error code from the server (we forgot the leading slash on the\nsecond, and the \u201cindex.html\u201d on the third\u2014required for this server and interface). With\nthe raw HTTP interfaces, we need to be precise about what we want.\nTechnically, the string we call filename in the script can refer to either a simple static\nweb page file or a server-side program that generates HTML as its output. Those server-\nside programs are usually called CGI scripts\u2014the topic of Chapters 15 and 16. For\nnow, keep in mind that when filename refers to a script, this program can be used to\ninvoke another program that resides on a remote server machine. In that case, we can\nalso specify parameters (called a query string) to be passed to the remote program after\na ?.\nHere, for instance, we pass a language=Python parameter to a CGI script we will meet\nin Chapter 15 (to make this work, we also need to first spawn a locally running HTTP\nweb server coded in Python using a script we first met in Chapter 1 and will revisit in\nChapter 15):\nIn a different window\nC:\\...\\PP4E\\Internet\\Web> webserver.py\nwebdir \".\", port 80\nC:\\...\\PP4E\\Internet\\Other> http-getfile.py localhost\n                               /cgi-bin/languages.py?language=Python\nlocalhost /cgi-bin/languages.py?language=Python\nb'<TITLE>Languages</TITLE>\\n'\nb'<H1>Syntax</H1><HR>\\n'\nb'<H3>Python</H3><P><PRE>\\n'\nb\" print('Hello World')               \\n\"\n996 | Chapter 13:\u2002Client-Side Scriptingb'</PRE></P><BR>\\n'\nb'<HR>\\n'\nThis book has much more to say later about HTML, CGI scripts, and the meaning of\nthe HTTP GET request used in Example 13-29 (along with POST, one of two way to\nformat information sent to an HTTP server), so we\u2019ll skip additional details here.\nSuffice it to say, though, that we could use the HTTP interfaces to write our own web\nbrowsers and build scripts that use websites as though they were subroutines. By send-\ning parameters to remote programs and parsing their results, websites can take on the\nrole of simple in-process functions (albeit, much more slowly and indirectly).\nThe urllib Package Revisited\nThe http.client module we just met provides low-level control for HTTP clients.\nWhen dealing with items available on the Web, though, it\u2019s often easier to code down-\nloads with Python\u2019s standard urllib.request module, introduced in the FTP section\nearlier in this chapter. Since this module is another way to talk HTTP, let\u2019s expand on\nits interfaces here.\nRecall that given a URL, urllib.request either downloads the requested object over\nthe Net to a local file or gives us a file-like object from which we can read the requested\nobject\u2019s contents. As a result, the script in Example 13-30 does the same work as the\nhttp.client script we just wrote but requires noticeably less code.\nExample 13-30. PP4E\\Internet\\Other\\http-getfile-urllib1.py\n\"\"\"\nfetch a file from an HTTP (web) server over sockets via urllib;  urllib supports\nHTTP, FTP, files, and HTTPS via URL address strings;  for HTTP, the URL can name\na file or trigger a remote CGI script;  see also the urllib example in the FTP\nsection, and the CGI script invocation in a later chapter;  files can be fetched\nover the net with Python in many ways that vary in code and server requirements:\nover sockets, FTP, HTTP, urllib, and CGI outputs;  caveat: should run filename\nthrough urllib.parse.quote to escape properly unless hardcoded--see later chapters;\n\"\"\"\nimport sys\nfrom urllib.request import urlopen\nshowlines = 6\ntry:\n    servername, filename = sys.argv[1:]              # cmdline args?\nexcept:\n    servername, filename = 'learning-python.com', '/index.html'\nremoteaddr = 'http://%s%s' % (servername, filename)  # can name a CGI script too\nprint(remoteaddr)\nremotefile = urlopen(remoteaddr)                     # returns input file object\nremotedata = remotefile.readlines()                  # read data directly here\nremotefile.close()\nfor line in remotedata[:showlines]: print(line)      # bytes with embedded \\n\nThe urllib Package Revisited | 997Almost all HTTP transfer details are hidden behind the urllib.request interface here.\nThis version works in almost the same way as the http.client version we wrote first,\nbut it builds and submits an Internet URL address to get its work done (the constructed\nURL is printed as the script\u2019s first output line). As we saw in the FTP section of this\nchapter, the urllib.request function urlopen returns a file-like object from which we\ncan read the remote data. But because the constructed URLs begin with \u201chttp://\u201d here,\nthe urllib.request module automatically employs the lower-level HTTP interfaces to\ndownload the requested file instead of FTP:\nC:\\...\\PP4E\\Internet\\Other> http-getfile-urllib1.py\nhttp://learning-python.com/index.html\nb'<HTML>\\n'\nb' \\n'\nb'<HEAD>\\n'\nb\"<TITLE>Mark Lutz's Python Training Services</TITLE>\\n\"\nb'<!--mstheme--><link rel=\"stylesheet\" type=\"text/css\" href=\"_themes/blends/blen...'\nb'</HEAD>\\n'\nC:\\...\\PP4E\\Internet\\Other> http-getfile-urllib1.py www.python.org /index\nhttp://www.python.org/index\nb'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3....'\nb'\\n'\nb'\\n'\nb'<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\\n'\nb'\\n'\nb'<head>\\n'\nC:\\...\\PP4E\\Internet\\Other> http-getfile-urllib1.py www.rmi.net /~lutz\nhttp://www.rmi.net/~lutz\nb'<HTML>\\n'\nb'\\n'\nb'<HEAD>\\n'\nb\"<TITLE>Mark Lutz's Book Support Site</TITLE>\\n\"\nb'</HEAD>\\n'\nb'<BODY BGCOLOR=\"#f1f1ff\">\\n'\nC:\\...\\PP4E\\Internet\\Other> http-getfile-urllib1.py\n                                localhost /cgi-bin/languages.py?language=Java\nhttp://localhost/cgi-bin/languages.py?language=Java\nb'<TITLE>Languages</TITLE>\\n'\nb'<H1>Syntax</H1><HR>\\n'\nb'<H3>Java</H3><P><PRE>\\n'\nb' System.out.println(\"Hello World\"); \\n'\nb'</PRE></P><BR>\\n'\nb'<HR>\\n'\nAs before, the filename argument can name a simple file or a program invocation with\noptional parameters at the end, as in the last run here. If you read this output carefully,\nyou\u2019ll notice that this script still works if you leave the \u201cindex.html\u201d off the end of a\nsite\u2019s root filename (in the third command line); unlike the raw HTTP version of the\npreceding section, the URL-based interface is smart enough to do the right thing.\n998 | Chapter 13:\u2002Client-Side ScriptingOther urllib Interfaces\nOne last mutation: the following urllib.request downloader script uses the slightly\nhigher-level urlretrieve interface in that module to automatically save the downloaded\nfile or script output to a local file on the client machine. This interface is handy if we\nreally mean to store the fetched data (e.g., to mimic the FTP protocol). If we plan on\nprocessing the downloaded data immediately, though, this form may be less convenient\nthan the version we just met: we need to open and read the saved file. Moreover, we\nneed to provide an extra protocol for specifying or extracting a local filename, as in\nExample 13-31.\nExample 13-31. PP4E\\Internet\\Other\\http-getfile-urllib2.py\n\"\"\"\nfetch a file from an HTTP (web) server over sockets via urlllib;  this version\nuses an interface that saves the fetched data to a local binary-mode file; the\nlocal filename is either passed in as a cmdline arg or stripped from the URL with\nurllib.parse: the filename argument may have a directory path at the front and query\nparameters at end, so os.path.split is not enough (only splits off directory path);\ncaveat: should urllib.parse.quote filename unless known ok--see later chapters;\n\"\"\"\nimport sys, os, urllib.request, urllib.parse\nshowlines = 6\ntry:\n    servername, filename = sys.argv[1:3]              # first 2 cmdline args?\nexcept:\n    servername, filename = 'learning-python.com', '/index.html'\nremoteaddr = 'http://%s%s' % (servername, filename)   # any address on the Net\nif len(sys.argv) == 4:                                # get result filename\n    localname = sys.argv[3]\nelse:\n    (scheme, server, path, parms, query, frag) = urllib.parse.urlparse(remoteaddr)\n    localname = os.path.split(path)[1]\nprint(remoteaddr, localname)\nurllib.request.urlretrieve(remoteaddr, localname)       # can be file or script\nremotedata = open(localname, 'rb').readlines()          # saved to local file\nfor line in remotedata[:showlines]: print(line)         # file is bytes/binary\nLet\u2019s run this last variant from a command line. Its basic operation is the same as the\nlast two versions: like the prior one, it builds a URL, and like both of the last two, we\ncan list an explicit target server and file path on the command line:\nC:\\...\\PP4E\\Internet\\Other> http-getfile-urllib2.py\nhttp://learning-python.com/index.html index.html\nb'<HTML>\\n'\nb' \\n'\nb'<HEAD>\\n'\nb\"<TITLE>Mark Lutz's Python Training Services</TITLE>\\n\"\nb'<!--mstheme--><link rel=\"stylesheet\" type=\"text/css\" href=\"_themes/blends/blen...'\nb'</HEAD>\\n'\nThe urllib Package Revisited | 999C:\\...\\PP4E\\Internet\\Other> http-getfile-urllib2.py www.python.org /index.html\nhttp://www.python.org/index.html index.html\nb'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3....'\nb'\\n'\nb'\\n'\nb'<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\\n'\nb'\\n'\nb'<head>\\n'\nBecause this version uses a urllib.request interface that automatically saves the down-\nloaded data in a local file, it\u2019s similar to FTP downloads in spirit. But this script must\nalso somehow come up with a local filename for storing the data. You can either let the\nscript strip and use the base filename from the constructed URL, or explicitly pass a\nlocal filename as a last command-line argument. In the prior run, for instance, the\ndownloaded web page is stored in the local file index.html in the current working\ndirectory\u2014the base filename stripped from the URL (the script prints the URL and\nlocal filename as its first output line). In the next run, the local filename is passed\nexplicitly as py-index.html:\nC:\\...\\PP4E\\Internet\\Other> http-getfile-urllib2.py\n                                www.python.org /index.html py-index.html\nhttp://www.python.org/index.html py-index.html\nb'<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3....'\nb'\\n'\nb'\\n'\nb'<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\\n'\nb'\\n'\nb'<head>\\n'\nC:\\...\\PP4E\\Internet\\Other> http-getfile-urllib2.py www.rmi.net /~lutz books.html\nhttp://www.rmi.net/~lutz books.html\nb'<HTML>\\n'\nb'\\n'\nb'<HEAD>\\n'\nb\"<TITLE>Mark Lutz's Book Support Site</TITLE>\\n\"\nb'</HEAD>\\n'\nb'<BODY BGCOLOR=\"#f1f1ff\">\\n'\nC:\\...\\PP4E\\Internet\\Other> http-getfile-urllib2.py www.rmi.net /~lutz/about-pp.html\nhttp://www.rmi.net/~lutz/about-pp.html about-pp.html\nb'<HTML>\\n'\nb'\\n'\nb'<HEAD>\\n'\nb'<TITLE>About \"Programming Python\"</TITLE>\\n'\nb'</HEAD>\\n'\nb'\\n'\nInvoking programs and escaping text\nThe next listing shows this script being used to trigger a remote program. As before, if\nyou don\u2019t give the local filename explicitly, the script strips the base filename out of\nthe filename argument. That\u2019s not always easy or appropriate for program\n1000 | Chapter 13:\u2002Client-Side Scriptinginvocations\u2014the filename can contain both a remote directory path at the front and\nquery parameters at the end for a remote program invocation.\nGiven a script invocation URL and no explicit output filename, the script extracts the\nbase filename in the middle by using first the standard urllib.parse module to pull out\nthe file path, and then os.path.split to strip off the directory path. However, the re-\nsulting filename is a remote script\u2019s name, and it may or may not be an appropriate\nplace to store the data locally. In the first run that follows, for example, the script\u2019s\noutput goes in a local file called languages.py, the script name in the middle of the URL;\nin the second, we instead name the output CxxSyntax.html explicitly to suppress file-\nname extraction:\nC:\\...\\PP4E\\Internet\\Other> python http-getfile-urllib2.py localhost\n                                /cgi-bin/languages.py?language=Scheme\nhttp://localhost/cgi-bin/languages.py?language=Scheme languages.py\nb'<TITLE>Languages</TITLE>\\n'\nb'<H1>Syntax</H1><HR>\\n'\nb'<H3>Scheme</H3><P><PRE>\\n'\nb' (display \"Hello World\") (newline)  \\n'\nb'</PRE></P><BR>\\n'\nb'<HR>\\n'\nC:\\...\\PP4E\\Internet\\Other> python http-getfile-urllib2.py localhost\n                                /cgi-bin/languages.py?language=C++ CxxSyntax.html\nhttp://localhost/cgi-bin/languages.py?language=C++ CxxSyntax.html\nb'<TITLE>Languages</TITLE>\\n'\nb'<H1>Syntax</H1><HR>\\n'\nb'<H3>C  </H3><P><PRE>\\n'\nb\"Sorry--I don't know that language\\n\"\nb'</PRE></P><BR>\\n'\nb'<HR>\\n'\nThe remote script returns a not-found message when passed \u201cC++\u201d in the last com-\nmand here. It turns out that \u201c+\u201d is a special character in URL strings (meaning a space),\nand to be robust, both of the urllib scripts we\u2019ve just written should really run the\nfilename string through something called urllib.parse.quote, a tool that escapes spe-\ncial characters for transmission. We will talk about this in depth in Chapter 15, so\nconsider this a preview for now. But to make this invocation work, we need to use\nspecial sequences in the constructed URL. Here\u2019s how to do it by hand:\nC:\\...\\PP4E\\Internet\\Other> python http-getfile-urllib2.py  localhost\n                               /cgi-bin/languages.py?language=C%2b%2b CxxSyntax.html\nhttp://localhost/cgi-bin/languages.py?language=C%2b%2b CxxSyntax.html\nb'<TITLE>Languages</TITLE>\\n'\nb'<H1>Syntax</H1><HR>\\n'\nb'<H3>C++</H3><P><PRE>\\n'\nb' cout &lt;&lt; \"Hello World\" &lt;&lt; endl;     \\n'\nb'</PRE></P><BR>\\n'\nb'<HR>\\n'\nThe odd %2b strings in this command line are not entirely magical: the escaping required\nfor URLs can be seen by running standard Python tools manually\u2014this is what these\nThe urllib Package Revisited | 1001scripts should do automatically to be able to handle all possible cases well;\nurllib.parse.unquote can undo these escapes if needed:\nC:\\...\\PP4E\\Internet\\Other> python\n>>> import urllib.parse\n>>> urllib.parse.quote('C++')\n'c%2B%2B'\nAgain, don\u2019t work too hard at understanding these last few commands; we will revisit\nURLs and URL escapes in Chapter 15, while exploring server-side scripting in Python.\nI will also explain there why the C++ result came back with other oddities like\n&lt;&lt;\u2014HTML escapes for <<, generated by the tool cgi.escape in the script on the\nserver that produces the reply, and usually undone by HTML parsers including Py-\nthon\u2019s html.parser module we\u2019ll meet in Chapter 19:\n>>> import cgi\n>>> cgi.escape('<<')\n'&lt;&lt;'\nAlso in Chapter 15, we\u2019ll meet urllib support for proxies, and its support for client-\nside cookies. We\u2019ll discuss the related HTTPS concept in Chapter 16\u2014HTTP trans-\nmissions over secure sockets, supported by urllib.request on the client side if SSL\nsupport is compiled into your Python. For now, it\u2019s time to wrap up our look at the\nWeb, and the Internet at large, from the client side of the fence.\nOther Client-Side Scripting Options\nIn this chapter, we focused on client-side interfaces to standard protocols that run over\nsockets, but as suggested in an earlier footnote, client-side programming can take other\nforms, too. We outlined many of these at the start of Chapter 12\u2014web service protocols\n(including SOAP and XML-RPC); Rich Internet Application toolkits (including Flex,\nSilverlight, and pyjamas); cross-language framework integration (including Java\nand .NET); and more.\nAs mentioned, most of these serve to extend the functionality of web browsers, and so\nultimately run on top of the HTTP protocol we explored in this chapter. For instance:\n\u2022 The Jython system, a compiler that supports Python-coded Java applets\u2014general-\npurpose programs downloaded from a server and run locally on the client when\naccessed or referenced by a URL, which extend the functionality of web browsers\nand interactions.\n\u2022 Similarly, RIAs provide AJAX communication and widget toolkits that allow Java-\nScript to implement user interaction within web browsers, which is more dynamic\nand rich than HTML and web browsers otherwise support.\n\u2022 In Chapter 19, we\u2019ll also study Python\u2019s support for XML\u2014structured text that is\nused as the data transfer medium of client/server dialogs in web service protocols\nsuch as XML-RPC, which transfer XML-encoded objects over HTTP, and are\n1002 | Chapter 13:\u2002Client-Side Scriptingsupported by Python\u2019s xmlrpc standard library package. Such protocols can sim-\nplify the interface to web servers in their clients.\nIn deference to time and space, though, we won\u2019t go into further details on these and\nother client-side tools here. If you are interested in using Python to script clients, you\nshould take a few minutes to become familiar with the list of Internet tools documented\nin the Python library reference manual. All work on similar principles but have slightly\ndistinct interfaces.\nIn Chapter 15, we\u2019ll hop the fence to the other side of the Internet world and explore\nscripts that run on server machines. Such programs give rise to the grander notion of\napplications that live entirely on the Web and are launched by web browsers. As we\ntake this leap in structure, keep in mind that the tools we met in this and the preceding\nchapter are often sufficient to implement all the distributed processing that many ap-\nplications require, and they can work in harmony with scripts that run on a server. To\ncompletely understand the Web worldview, though, we need to explore the server\nrealm, too.\nBefore we get there, though, the next chapter puts concepts we\u2019ve learned here to work\nby presenting a complete client-side program\u2014a full-blown mail client GUI, which ties\ntogether many of the tools we\u2019ve learned and coded. In fact, much of the email work\nwe\u2019ve done in this chapter was designed to lay the groundwork we\u2019ll need to tackle the\nrealistically scaled PyMailGUI example of the next chapter. Really, much of this book\nso far has served to build up skills required to equip us for this task: as we\u2019ll see,\nPyMailGUI combines system tools, GUIs, and client-side Internet protocols to produce\na useful system that does real work. As an added bonus, this example will help us\nunderstand the trade-offs between the client solutions we\u2019ve met here and the server-\nside solutions we\u2019ll study later in this part of the book.\nOther Client-Side Scripting Options | 1003", "14": "CHAPTER 14\nThe PyMailGUI Client\n\u201cUse the Source, Luke\u201d\nThe preceding chapter introduced Python\u2019s client-side Internet protocols tool set\u2014the \nstandard library modules available for email, FTP, network news, HTTP, and more, \nfrom within a Python script. This chapter picks up where the last one left off and \npresents a complete client-side example\u2014PyMailGUI, a Python program that sends, \nreceives, composes, and parses Internet email messages.\nAlthough the end result is a working program that you can actually use for your email, \nthis chapter also has a few additional agendas worth noting before we get started:\nClient-side scripting \nPyMailGUI implements a full-featured desktop GUI that runs on your machine \nand communicates with your mail servers when necessary. As such, it is a network \nclient program that further illustrates some of the preceding chapter\u2019s topics, and \nit will help us contrast server-side solutions introduced in the next chapter.\nCode reuse \nAdditionally, PyMailGUI ties together a number of the utility modules we\u2019ve been \nwriting in the book so far, and it demonstrates the power of code reuse in the \nprocess\u2014it uses a thread module to allow mail transfers to overlap in time, a set \nof mail modules to process message content and route it across networks, a window \nprotocol module to handle icons, a text editor component, and so on. Moreover, \nit inherits the power of tools in the Python standard library, such as the email\npackage; message construction and parsing, for example, is nearly trivial here.\nProgramming in the large \nAnd finally, this chapter serves to illustrate realistic and large-scale software de-\nvelopment in action. Because PyMailGUI is a relatively large and complete pro-\ngram, it shows by example some of the code structuring techniques that prove \nuseful once we leave the realm of the small and artificial. For instance, object-\noriented programming and modular design work well here to divide the system in \nsmaller, self-contained units.\n1005Ultimately, though, PyMailGUI serves to illustrate just how far the combination of\nGUIs, networking, and Python can take us. Like all Python programs, this system is\nscriptable\u2014once you\u2019ve learned its general structure, you can easily change it to work\nas you like, by modifying its source code. And like all Python programs, this one is\nportable\u2014you can run it on any system with Python and a network connection, without\nhaving to change its code. Such advantages become automatic when your software is\ncoded in an open source, portable, and readable language like Python.\nSource Code Modules and Size\nThis chapter is something of a self-study exercise. Because PyMailGUI is fairly large\nand mostly applies concepts we\u2019ve already learned, we won\u2019t go into much detail about\nits actual code. Instead, it is listed for you to read on your own. I encourage you to\nstudy the source and comments and to run this program live to get a feel for its oper-\nation; example save-mail files are included so you can even experiment offline.\nAs you study and run this program, you\u2019ll also want to refer back to the modules we\nintroduced earlier in the book and are reusing here, to gain a full understanding of the\nsystem. For reference, here are the major examples that will see new action in this\nchapter:\nExample 13-21: PP4E.Internet.Email.mailtools (package)\nServer sends and receives, parsing, construction (Client-side scripting chapter)\nExample 10-20: PP4E.Gui.Tools.threadtools.py\nThread queue management for GUI callbacks (GUI tools chapter)\nExample 10-16: PP4E.Gui.Tools.windows.py\nBorder configuration for top-level window (GUI tools chapter)\nExample 11-4: PP4E.Gui.TextEditor.textEditor.py\nText widget used in mail view windows, and in some pop ups (GUI examples\nchapter)\nSome of these modules in turn use additional examples we coded earlier but that are\nnot imported by PyMailGUI itself (textEditor, for instance, uses guimaker to create its\nwindows and toolbar). Naturally, we\u2019ll also be coding new modules here. The following\nnew modules are intended to be potentially useful in other programs:\npopuputil.py\nVarious pop-up windows, written for general use\nmessagecache.py\nA cache manager that keeps track of mail already loaded\nwraplines.py\nA utility for wrapping long lines of messages\nmailconfig.py\nUser configuration parameters\u2014server names, fonts, and so on (augmented here)\n1006 | Chapter 14:\u2002The PyMailGUI Clienthtml2text.py\nA rudimentary parser for extracting plain text from HTML-based emails\nFinally, the following are the new major modules coded in this chapter which are spe-\ncific to the PyMailGUI program. In total, PyMailGUI itself consists of the ten modules\nin this and the preceding lists, along with a handful of less prominent source files we\u2019ll\nsee in this chapter:\nSharedNames.py\nProgram-wide globals used by multiple files\nViewWindows.py\nThe implementation of View, Write, Reply, and Forward message view windows\nListWindows.py\nThe implementation of mail-server and local-file message list windows\nPyMailGuiHelp.py\nUser-oriented help text, opened by the main window\u2019s bar button\nPyMailGui.py\nThe main, top-level file of the program, run to launch the main window\nCode size\nAs a realistically scaled system, PyMailGUI\u2019s size is also instructive. All told, PyMailGUI\nis composed of 18 new files: the 10 new Python modules in the two preceding lists,\nplus an HTML help file, a small configuration file for PyEdit pop ups, a currently unused\npackage initialization file, and 5 short Python files in a subdirectory used for alternate\naccount configuration.\nTogether, it contains some 2,400 new lines of program source code in 16 Python files\n(including comments and whitespace), plus roughly 1,700 lines of help text in one\nPython and one HTML file (in two flavors). This 4,100 new line total doesn\u2019t include\nthe four other book examples listed in the previous section that are reused in PyMail-\nGUI. The reused examples themselves constitute 2,600 additional lines of Python pro-\ngram code\u2014roughly 1,000 lines each for PyEdit and mailtools alone. That brings the\ngrand total to 6,700 lines: 4,100 new + 2,600 reused. Of this total, 5,000 lines is in\nprogram code files (2,400 of which are new here) and 1,700 lines is help text.*\nI obtained these lines counts with PyEdit\u2019s Info pop up, and opened the files with the\ncode button in the PyDemos entry for this program (the Source button in PyMailGUI\u2019s\n* And remember: you would have to multiply these line counts by a factor of four or more to get the equivalent\nin a language like C or C++. If you\u2019ve done much programming, you probably recognize that the fact that\nwe can implement a fairly full-featured mail processing program in roughly 5,000 total lines of program code\nspeaks volumes about the power of the Python language and its libraries. For comparison, the original 1.0\nversion of this program from the second edition of this book was just 745 total lines in 3 new modules, but\nit also was very limited\u2014it did not support PyMailGUI 2.X\u2019s attachments, thread overlap, local mail files,\nand so on, and did not have the Internationalization support or other features of this edition\u2019s PyMailGUI 3.X.\n\u201cUse the Source, Luke\u201d | 1007own text-based help window does similar work). For the break down by individual \nfiles, see the Excel spreadsheet file linecounts.xls in the media subdirectory of PyMail-\nGUI; this file is also used to test attachment sends and receives, and so appears near \nthe end of the emails in file SavedEmail\\version30-4E if opened in the GUI (we\u2019ll see \nhow to open mail save files in a moment).\nWatch for the changes section ahead for size comparisons to prior versions. Also see \nthe SLOC counter script in Chapter 6 for an alternative way to count source lines that \nis less manual, but can\u2019t include all related files in a single run and doesn\u2019t discriminate \nbetween program code and help text.\nCode Structure\nAs these statistics probably suggest, this is the largest example we\u2019ll see in this book, \nbut you shouldn\u2019t be deterred by its size. Because it uses modular and OOP techniques, \nthe code is simpler than you may think:\n\u2022 Python\u2019s modules allow us to divide the system into files that have a cohesive \npurpose, with minimal coupling between them\u2014code is easier to locate and un-\nderstand if your modules have a logical, self-contained structure.\n\u2022 Python\u2019s OOP support allows us to factor code for reuse and avoid redundancy\u2014 \nas you\u2019ll see, code is customized, not repeated, and the classes we will code reflect \nthe actual components of the GUI to make them easy to follow.\nFor instance, the implementation of mail list windows is easy to read and change, be-\ncause it has been factored into a common shared superclass, which is customized by \nsubclasses for mail-server and save-file lists; since these are mostly just variations on a \ntheme, most of the code appears in just one place. Similarly, the code that implements \nthe message view window is a superclass shared by write, reply, and forward compo-\nsition windows; subclasses simply tailor it for writing rather than viewing.\nAlthough we\u2019ll deploy these techniques in the context of a mail processing program \nhere, such techniques will apply to any nontrivial program you\u2019ll write in Python.\nTo help get you started, the PyMailGuiHelp.py module listed in part near the end of this \nchapter includes a help text string that describes how this program is used, as well as \nits major features. You can also view this help live in both text and HTML form when \nthe program is run. Experimenting with the system, while referring to its code, is prob-\nably the best and quickest way to uncover its secrets.\nWhy PyMailGUI?\nBefore we start digging into the code of this relatively large system, some context is in \norder. PyMailGUI is a Python program that implements a client-side email processing \nuser interface with the standard tkinter GUI toolkit. It is presented both as an instance\n1008 | Chapter 14:\u2002The PyMailGUI Clientof Python Internet scripting and as a realistically scaled example that ties together other\ntools we\u2019ve already seen, such as threads and tkinter GUIs.\nLike the pymail console-based program we wrote in Chapter 13, PyMailGUI runs en-\ntirely on your local computer. Your email is fetched from and sent to remote mail servers\nover sockets, but the program and its user interface run locally. As a result, PyMailGUI\nis called an email client: like pymail, it employs Python\u2019s client-side tools to talk to mail\nservers from the local machine. Unlike pymail, though, PyMailGUI is a full-featured\nuser interface: email operations are performed with point-and-click operations and\nadvanced mail processing such as attachments, save files, and Internationalization is\nsupported.\nLike many examples presented in this text, PyMailGUI is a practical, useful program.\nIn fact, I run it on all kinds of machines to check my email while traveling around the\nworld teaching Python classes. Although PyMailGUI won\u2019t put Microsoft Outlook out\nof business anytime soon, it has two key pragmatic features alluded to earlier that have\nnothing to do with email itself\u2014portability and scriptability, which are attractive fea-\ntures in their own right and merit a few additional words here:\nIt\u2019s portable\nPyMailGUI runs on any machine with sockets and a Python with tkinter installed.\nBecause email is transferred with the Python libraries, any Internet connection that\nsupports Post Office Protocol (POP) and Simple Mail Transfer Protocol (SMTP)\naccess will do. Moreover, because the user interface is coded with tkinter, PyMail-\nGUI should work, unchanged, on Windows, the X Window System (Unix, Linux),\nand the Macintosh (classic and OS X), as long as Python 3.X runs there too.\nMicrosoft Outlook may be a more feature-rich package, but it has to be run on\nWindows, and more specifically, on a single Windows machine. Because it gener-\nally deletes email from a server as it is downloaded by default and stores it on the\nclient, you cannot run Outlook on multiple machines without spreading your email\nacross all those machines. By contrast, PyMailGUI saves and deletes email only on\nrequest, and so it is a bit friendlier to people who check their email in an ad hoc\nfashion on arbitrary computers (like me).\nIt\u2019s scriptable\nPyMailGUI can become anything you want it to be because it is fully programma-\nble. In fact, this is the real killer feature of PyMailGUI and of open source software\nlike Python in general\u2014because you have full access to PyMailGUI\u2019s source code,\nyou are in complete control of where it evolves from here. You have nowhere near\nas much control over commercial, closed products like Outlook; you generally get\nwhatever a large company decided you need, along with whatever bugs that com-\npany might have introduced.\nAs a Python script, PyMailGUI is a much more flexible tool. For instance, we can\nchange its layout, disable features, and add completely new functionality quickly\nby changing its Python source code. Don\u2019t like the mail-list display? Change a few\n\u201cUse the Source, Luke\u201d | 1009lines of code to customize it. Want to save and delete your mail automatically as\nit is loaded? Add some more code and buttons. Tired of seeing junk mail? Add a\nfew lines of text processing code to the load function to filter spam. These are just\na few examples. The point is that because PyMailGUI is written in a high-level,\neasy-to-maintain scripting language, such customizations are relatively simple, and\nmight even be fun.\nAt the end of the day, because of such features, this is a realistic Python program that\nI actually use\u2014both as a primary email tool and as a fallback option when my ISP\u2019s\nwebmail system goes down (which, as I mentioned in the prior chapter, has a way of\nhappening at the worst possible times).\u2020 Python scripting is an enabling skill to have.\nRunning PyMailGUI\nOf course, to script PyMailGUI on your own, you\u2019ll need to be able to run it. PyMailGUI\nrequires only a computer with some sort of Internet connectivity (a PC with a broad-\nband or dial-up account will do) and an installed Python with the tkinter extension\nenabled. The Windows port of Python has this capability, so Windows PC users should\nbe able to run this program immediately by clicking its icon.\nTwo notes on running the system: first, you\u2019ll want to change the file mailconfig.py in\nthe program\u2019s source directory to reflect your account\u2019s parameters, if you wish to send\nor receive mail from a live server; more on this as we interact with the system ahead.\nSecond, you can still experiment with the system without a live Internet connection\u2014\nfor a quick look at message view windows, use the main window\u2019s Open buttons to\nopen saved-mail files included in the program\u2019s SavedMail subdirectory. The PyDemos\nlauncher script at the top of the book\u2019s examples directory, for example, forces Py-\nMailGUI to open saved-mail files by passing filenames on the command line. Although\nyou\u2019ll probably want to connect to your email servers eventually, viewing saved mails\noffline is enough to sample the system\u2019s flavor and does not require any configuration\nfile changes.\nPresentation Strategy\nPyMailGUI is easily the largest program in this book, but it doesn\u2019t introduce many\nlibrary interfaces that we haven\u2019t already seen in this book. For instance:\n\u2022 The PyMailGUI interface is built with Python\u2019s tkinter, using the familiar listboxes,\nbuttons, and text widgets we met earlier.\n\u2022 Python\u2019s email package is applied to pull-out headers, text, and attachments of\nmessages, and to compose the same.\n\u2020 In fact, my ISP\u2019s webmail send system went down the very day I had to submit the third edition of this book\nto my publisher! No worries\u2014I fired up PyMailGUI and used it to send the book as attachment files through\na different server. In a sense, this book submitted itself.\n1010 | Chapter 14:\u2002The PyMailGUI Client\u2022 Python\u2019s POP and SMTP library modules are used to fetch, send, and delete mail\nover sockets.\n\u2022 Python threads, if installed in your Python interpreter, are put to work to avoid\nblocking during potentially overlapping, long-running mail operations.\nWe\u2019re also going to reuse the PyEdit TextEditor object we wrote in Chapter 11 to view\nand compose messages and to pop up raw text, attachments, and source; the mail\ntools package\u2019s tools we wrote in Chapter 13 to load, send, and delete mail with a\nserver; and the mailconfig module strategy introduced in Chapter 13 to support end-\nuser settings. PyMailGUI is largely an exercise in combining existing tools.\nOn the other hand, because this program is so long, we won\u2019t exhaustively document\nall of its code. Instead, we\u2019ll begin with a quick look at how PyMailGUI has evolved,\nand then move on to describing how it works today from an end user\u2019s perspective\u2014\na brief demo of its windows in action. After that, we\u2019ll list the system\u2019s new source code\nmodules without many additional comments, for further study.\nLike most of the longer case studies in this book, this section assumes that you already\nknow enough Python to make sense of the code on your own. If you\u2019ve been reading\nthis book linearly, you should also know enough about tkinter, threads, and mail in-\nterfaces to understand the library tools applied here. If you get stuck, you may wish to\nbrush up on the presentation of these topics earlier in the book.\nMajor PyMailGUI Changes\nLike the PyEdit text editor of Chapter 11, PyMailGUI serves as a good example of\nsoftware evolution in action. Because its revisions help document this system\u2019s func-\ntionality, and because this example is as much about software engineering as about\nPython itself, let\u2019s take a quick look at its recent changes.\nNew in Version 2.1 and 2.0 (Third Edition)\nThe 2.1 version of PyMailGUI presented in the third edition of the book in early 2006\nis still largely present and current in this fourth edition in 2010. Version 2.1 added a\nhandful of enhancements to version 2.0, and version 2.0 was a complete rewrite of the\n1.0 version of the second edition with a radically expanded feature set.\nIn fact, the second edition\u2019s version 1.0 of this program written in early 2000 was only\nsome 685 total program lines long (515 lines for the GUI main script and 170 lines in\nan email utilities module), not counting related examples reused, and just 60 lines in\nits help text module. Version 1.0 was really something of a prototype (if not toy), written\nmostly to serve as a short book example.\nAlthough it did not yet support Internationalized mail content or other 3.0 extensions,\nin the third edition, PyMailGUI 2.1 became a much more realistic and feature-rich\nprogram that could be used for day-to-day email processing. It grew by nearly a factor\nMajor PyMailGUI Changes | 1011of three to be 1,800 new program source lines (plus 1,700 program lines in related\nmodules reused, and 500 additional lines of help text). By comparison, version 3.0 by\nitself grew only by some 30% to be 2,400 new program source lines as described earlier\n(plus 2,500 lines in related modules, and 1,700 lines of help text). Statistically minded\nreaders: consult file linecounts-prior-version.xls in PyMailGUI\u2019s media subdirectory for\na line counts breakdown for version 2.1 by file.\nIn version 2.1, among PyMailGUI\u2019s new weapons were (and still are) these:\n\u2022 MIME multipart mails with attachments may be both viewed and composed.\n\u2022 Mail transfers are no longer blocking, and may overlap in time.\n\u2022 Mail may be saved and processed offline from a local file.\n\u2022 Message parts may now be opened automatically within the GUI.\n\u2022 Multiple messages may be selected for processing in list windows.\n\u2022 Initial downloads fetch mail headers only; full mails are fetched on request.\n\u2022 View window headers and list window columns are configurable.\n\u2022 Deletions are performed immediately, not delayed until program exit.\n\u2022 Most server transfers report their progress in the GUI.\n\u2022 Long lines are intelligently wrapped in viewed and quoted text.\n\u2022 Fonts and colors in list and view windows may be configured by the user.\n\u2022 Authenticating SMTP mail-send servers that require login are supported.\n\u2022 Sent messages are saved in a local file, which may be opened in the GUI.\n\u2022 View windows intelligently pick a main text part to be displayed.\n\u2022 Already fetched mail headers and full mails are cached for speed.\n\u2022 Date strings and addresses in composed mails are formatted properly.\n\u2022 View windows now have quick-access buttons for attachments/parts (2.1).\n\u2022 Inbox out-of-sync errors are detected on deletes, and on index and mail loads (2.1).\n\u2022 Save-mail file loads and deletes are threaded, to avoid pauses for large files (2.1).\nThe last three items on this list were added in version 2.1; the rest were part of the 2.0\nrewrite. Some of these changes were made simple by growth in standard library tools\n(e.g., support for attachments is straightforward with the new email package), but most\nrepresented changes in PyMailGUI itself. There were also a few genuine fixes: addresses\nwere parsed more accurately, and date and time formats in sent mails became standards\nconforming, because these tasks used new tools in the email package.\nNew in Version 3.0 (Fourth Edition)\nPyMailGUI version 3.0, presented in this fourth edition of this book, inherits all of 2.1\u2019s\nupgrades described in the prior section and adds many of its own. Changes are perhaps\nless dramatic in version 3.0, though some address important usability issues, and they\n1012 | Chapter 14:\u2002The PyMailGUI Clientseem collectively sufficient to justify assigning this version a new major release number.\nHere\u2019s a summary of what\u2019s new this time around:\nPython 3.X port\nThe code was updated to run under Python 3.X only; Python 2.X is no longer\nsupported without code changes. Although some of the task of porting to Python\n3.X requires only minor coding changes, other idiomatic implications are more far\nreaching. Python 3.X\u2019s new Unicode focus, for example, motivated much of the\nInternationalization support in this version of PyMailGUI (discussed ahead).\nLayout improvements\nView window forms are laid out with gridding instead of packed column frames,\nfor better appearance and platform neutrality of email headers (see Chapter 9 for\nmore details on form layout). In addition, list window toolbars are now arranged\nwith expanding separators for clarity; this effectively groups buttons by their roles\nand scope. List windows are also larger when initially opened to show more.\nText editor fix for Tk change\nBoth the embedded text editor and some text editor instances popped up on de-\nmand are now forcibly updated before new text is inserted, for accurate initial\npositioning at line 1. See PyEdit in Chapter 11 for more on this requirement; it\nstems from a recent change (bug?) in either Tk or tkinter.\nText editor upgrades inherited\nBecause the PyEdit program is reused in multiple roles here, this version of Py-\nMailGUI also acquires all its latest fixes by proxy. Most prominently, these include\na new Grep external files search dialog and support for displaying, opening, and\nsaving Unicode text. See Chapter 11 for details.\nWorkaround for Python 3.1 bug on traceback prints\nIn the obscure-but-all-too-typical category: the common function in\nSharedNames.py that prints traceback details had to be changed to work correctly\nunder Python 3.X. The traceback module\u2019s print_tb function can no longer print\na stack trace to sys.stdout if the calling program is spawned from another on\nWindows; it still can as before if the caller was run normally from a shell prompt.\nSince this function is called from the main thread on worker thread exceptions, if\nallowed to fail any printed error kills the GUI entirely when it is spawned from the\ngadget or demo launchers.\nTo work around this, the function now catches exceptions when print_tb is called\nand in response runs it again with a real file instead of sys.stdout. This appears to\nbe a Python 3.X regression, as the same code worked correctly in both contexts in\nPython 2.5 and 2.6. Unlike some similar issues, it has nothing to do with printing\nUnicode, as stack traces are all ASCII text. Even more baffling, directly printing to\nstdout in the same function works fine. Hey, if it were easy, they wouldn\u2019t call it\n\u201cwork.\u201d\nMajor PyMailGUI Changes | 1013Bcc addresses added to envelope but header omitted\nMinor change: addresses entered in the user-selectable Bcc header line of edit win-\ndows are included in the recipients list (the \u201cenvelope\u201d), but the Bcc header line\nitself is no longer included in the message text sent. Otherwise, Bcc recipients might\nbe seen by some email readers and clients (including PyMailGUI), which defeats\nmost of this header\u2019s purpose.\nAvoiding parallel fetches of the same mail\nPyMailGUI loads only mail headers initially, and fetches a mail\u2019s full text later when\nneeded for viewing and other operations, allowing multiple fetches to overlap in\ntime (they are run in parallel threads). Though unlikely, it was not impossible for\na user to trigger a new fetch for a mail that was currently being fetched, by selecting\nthe mail again during its download (clicking its list entry twice quickly sufficed to\nkick this off). Although the message cache updates performed in the parallel fetch\nthreads appeared to be thread safe, this behavior seemed odd and wasted time.\nTo do better, this version now keeps track of all fetches in progress in the main\nthread, to avoid this overlap potential entirely\u2014a message fetch in progress disa-\nbles all new fetch requests that it is a part of, until its fetch completes. Multiple\noverlapping fetches are still allowed, as long as their targets do not intersect. A set\nis used to detect nondisjoint fetch requests. Mails already fetched and cached are\nnot subject to this check and can always be selected irrespective of any fetches in\nprogress.\nMultiple recipients separated in GUI by commas, not semicolons\nIn the prior edition, \u201c;\u201d was used as the recipient character, and addresses were\nnaively split on \u201c;\u201d on a send. This attempted to avoid conflicts with \u201c,\u201d commonly\nused in email names. Replies dropped the name part if it contained a \u201c;\u201d when\nextracting a To address, but it was not impossible that clashes could still arise if a\n\u201c;\u201d appeared both as the separator and in manually typed address\u2019s name.\nTo improve, this edition uses \u201c,\u201d as the recipient separator, and fully parses email\naddress lists with the email package\u2019s getaddresses and parseaddr tools, instead of\nsplitting naively. Because these tools fully parse the list\u2019s content, \u201c,\u201d characters\nembedded in email address name parts are not mistakenly takes as address sepa-\nrators, and so do not clash. Servers and clients generally expect \u201c,\u201d separators, too,\nso this works naturally.\nWith this fix, commas can appear both as address separators as well as embedded\nin address name components. For replies, this is handled automatically: the To\nfield is prefilled with the From in the original message. For sends, the split happens\nautomatically in email tools for To, Cc, and Bcc headers fields (the latter two are\nignored if they contain just the initial \u201c?\u201d when sent).\nHTML help display\nHelp can now be displayed in text form in a GUI window, in HTML form in a\nlocally running web browser, or both. User settings in the mailconfig module select\nwhich form or forms to display. The HTML version is new; it uses a simple\n1014 | Chapter 14:\u2002The PyMailGUI Clienttranslation of the help text with added links to sections and external sites and\nPython\u2019s webbrowser module, discussed earlier in this book, to open a browser. The\ntext help display is now redundant, but it is retained because the HTML display\ncurrently lacks its ability to open source file viewers.\nThread callback queue speedup\nThe global thread queue dispatches GUI update callbacks much faster now\u2014up\nto 100 times per second, instead of the prior 10. This is due both to checking more\nfrequently (20 timer events per second versus 10) and to dispatching more callbacks\nper timer event (5 versus the prior 1). Depending on the interleaving of queue puts\nand gets, this speeds up initial loads for larger mailboxes by as much as an order\nof magnitude (factor of 10), at some potential minor cost in CPU utilization. On\nmy Windows 7 laptop, though, PyMailGUI still shows 0% CPU utilization in Task\nManager when idle.\nI bumped up the queue\u2019s speed to support an email account having 4,800 inbox\nmessages (actually, even more by the time I got around to taking screenshots for\nthis chapter). Without the speedup, initial header loads for this account took 8\nminutes to work through the 4,800 progress callbacks (4800 \u00f7 10 \u00f7 60), even\nthough most reflected messages skipped immediately by the new mail fetch limits\n(see the next item). With the speedup, the initial load takes just 48 seconds\u2014\nperhaps not ideal still, but this initial headers load is normally performed only once\nper session, and this policy strikes a balance between CPU resources and respon-\nsiveness. This email account is an arguably pathological case, of course, but most\ninitial loads benefit from the faster speed.\nSee Chapter 10\u2019s threadtools for most of this change\u2019s code, as well as additional\nbackground details. We could alternatively loop through all queued events on each\ntimer event, but this may block the GUI indefinitely if updates are queued quickly.\nMail fetch limits\nSince 2.1, PyMailGUI loads only mail headers initially, not full mail text, and only\nloads newly arrived headers thereafter. Depending on your Internet and server\nspeeds, though, this may still be impractical for very large inboxes (as mentioned,\none of mine currently has some 4,800 emails). To support such cases, a new mail\nconfig setting can be used to limit the number of headers (or full mails if TOP is\nunsupported) fetched on loads.\nGiven this setting N, PyMailGUI fetches at most N of the most recently arrived\nmails. Older mails outside this set are not fetched from the server, but are displayed\nas empty/dummy emails which are mostly inoperative (though they can generally\nstill be fetched on demand).\nThis feature is inherited from mailtools code in Chapter 13; see the mailconfig\nmodule ahead for the user setting associated with it. Note that even with this fix,\nbecause the threadtools queue system used here dispatches GUI events such as\nprogress updates only up to 100 times per second, a 4,800 mail inbox still takes\nMajor PyMailGUI Changes | 101548 seconds to complete an initially header load. The queue should either run faster\nstill, or I should delete an email once in a while!\nHTML main text extraction (prototype)\nPyMailGUI is still somewhat plain-text biased, despite the emergence of HTML\nemails in recent years. When the main (or only) text part of a mail is HTML, it is\ndisplayed in a popped-up web browser. In the prior version, though, its HTML\ntext was still displayed in a PyEdit text editor component and was still quoted for\nthe main text of replies and forwards.\nBecause most people are not HTML parsers, this edition\u2019s version attempts to do\nbetter by extracting plain text from the part\u2019s HTML with a simple HTML parsing\nstep. The extracted plain text is then displayed in the mail view window and used\nas original text in replies and forwards.\nThis HTML parser is at best a prototype and is largely included to provide a first\nstep that you can tailor for your tastes and needs, but any result it produces is better\nthan showing raw HTML. If this fails to render the plain text well, users can still\nfall back on viewing in the web browser and cutting and pasting from there into\nreplies and forwards. See also the note about open source alternatives by this\nparser\u2019s source code later in this chapter; this is an already explored problem\ndomain.\nReply copies all original recipients by default\nIn this version, replies are really reply-to-all by default\u2014they automatically prefill\nthe Cc header in the replies composition window with all the original recipients of\nthe message. To do so, replies extract all addresses among both the original To and\nCc headers, and remove duplicates as well as the new sender\u2019s address by using set\noperations. The net effect is to copy all other recipients on the reply. This is in\naddition to replying to the sender by initializing To with the original sender\u2019s\naddress.\nThis feature is intended to reflect common usage: email circulated among groups.\nSince it might not always be desirable, though, it can be disabled in mailconfig so\nthat replies initialize just To headers to reply to the original sender only. If enabled,\nusers may need to delete the Cc prefill if not wanted; if disabled, users may need\nto insert Cc addresses manually instead. Both cases seem equally likely. Moreover,\nit\u2019s not impossible that the original recipients include mail list names, aliases, or\nspurious addresses that will be either incorrect or irrelevant when the reply is sent.\nLike the Bcc prefill described in the next item, the reply\u2019s Cc initialization can be\nedited prior to sends if needed, and disabled entirely if preferred. Also see the\nsuggested enhancements for this feature at the end of this chapter\u2014allowing this\nto be enabled or disabled in the GUI per message might be a better approach.\nOther upgrades: Bcc prefills, \u201cRe\u201d and \u201cFwd\u201d case, list size, duplicate recipients\nIn addition, there have been smaller enhancements throughout. Among them: Bcc\nheaders in edit windows are now prefilled with the sender\u2019s address as a conven-\nience (a common role for this header); Reply and Forward now ignore case when\n1016 | Chapter 14:\u2002The PyMailGUI Clientdetermining if adding a \u201cRe:\u201d or \u201cFwd:\u201d to the subject would be redundant; mail\nlist window width and height may now be configured in mailconfig; duplicates are\nremoved from the recipient address list in mailtools on sends to avoid sending\nanyone multiple copies of the same mail (e.g., if an address appears in both To and\nCc); and other minor improvements which I won\u2019t cover here. Look for \u201c3.0\u201d and\n\u201c4E\u201d in program comments here and in the underlying mailtools package of\nChapter 13 to see other specific code changes.\nUnicode (Internationalization) support\nI\u2019ve saved the most significant PyMailGUI 3.0 upgrade for last: it now supports\nUnicode encoding of fetched, saved, and sent mails, to the extent allowed by the\nPython 3.1 email package. Both text parts of messages and message headers are\ndecoded when displayed and encoded when sent. Since this is too large a change\nto explain in this format, the next section elaborates.\nVersion 3.0 Unicode support policies\nThe last item on the preceding list is probably the most substantial. Per Chapter 13, a\nuser-configurable setting in the mailconfig module is used on a session-wide basis to\ndecode full message bytes into Unicode strings when fetched, and to encode and decode\nmail messages stored in text-mode save files.\nMore visibly, when composing, the main text and attached text parts of composed mails\nmay be given explicit Unicode encodings in mailconfig or via user input; when viewing,\nmessage header information of parsed emails is used to determine the Unicode types\nof both the main mail text as well as text parts opened on demand. In addition, Inter-\nnationalized mail headers (e.g., Subject, To, and From) are decoded per email, MIME,\nand Unicode standards when displayed according to their own content, and are auto-\nmatically encoded if non-ASCII when sent.\nOther Unicode policies (and fixes) of Chapter 13\u2019s mailtools package are inherited\nhere, too; see the prior chapter for more details. In summation, here is how all these\npolicies play out in terms of user interfaces:\nFetched emails\nWhen fetching mails, a session-wide user setting is used to decode full message\nbytes to Unicode strings, as required by Python\u2019s current email parser; if this fails,\na handful of guesses are applied. Most mail text will likely be 7 or 8 bit in nature,\nsince original email standards required ASCII.\nComposed text parts\nWhen sending new mails, user settings are used to determine Unicode type for the\nmain text part and any text attachment parts. If these are not set in mailconfig, the\nuser will instead be asked for encoding names in the GUI for each text part. These\nare ultimately used to add character set headers, and to invoke MIME encoding.\nIn all cases, the program falls back on UTF-8 if the user\u2019s encoding setting or input\ndoes not work for the text being sent\u2014for instance, if the user has chosen ASCII\nMajor PyMailGUI Changes | 1017for the main text of a reply to or forward of a non-ASCII message or for non-ASCII\nattachments.\nComposed headers\nWhen sending new mails, if header lines or the name component of an email address\nin address-related lines do not encode properly as ASCII text, we first encode the\nheader per email Internationalization standard. This is done per UTF-8 by default,\nbut a mailconfig setting can request a different encoding. In email address pairs,\nnames which cannot be encoded are dropped, and only the email address is used.\nIt is assumed that servers will respect the encoded names in email addresses.\nDisplayed text parts\nWhen viewing fetched mail, Unicode encoding names in message headers are used\nto decode whenever possible. The main-text part is decoded into str Unicode text\nper header information prior to inserting it into a PyEdit component. The content\nof all other text parts, as well as all binary parts, is saved in bytes form in binary-\nmode files, from where the part may be opened later in the GUI on demand. When\nsuch on-demand text parts are opened, they are displayed in PyEdit pop-up win-\ndows by passing to PyEdit the name of the part\u2019s binary-mode file, as well as the\npart\u2019s encoding name obtained from part message headers.\nIf the encoding name in a text part\u2019s header is absent or fails to decode, encoding\nguesses are tried for main-text parts, and PyEdit\u2019s separate Unicode policies are\napplied to text parts opened on demand (see Chapter 11\u2014it may prompt for an\nencoding if not known). In addition to these rules, HTML text parts are saved in\nbinary mode and opened in a web browser, relying on the browser\u2019s own character\nset support; this may in turn use tags in the HTML itself, guesses, or user encoding\nselections.\nDisplayed headers\nWhen viewing email, message headers are automatically decoded per email stand-\nards. This includes both full headers such as Subject, as well as the name compo-\nnents of all email address fields in address-related headers such as From, To, and\nCc, and allows these components to be completely encoded or contain encoded\nsubstrings. Because their content gives their MIME and Unicode encodings, no\nuser interaction is required to decode headers.\nIn other words, PyMailGUI now supports Internationalized message display and com-\nposition for both payloads and headers. For broadest utility, this support is distributed\nacross multiple packages and examples. For example, Unicode decoding of full message\ntext on fetches actually occurs deep in the imported mailtool package classes. Because\nof this, full (unparsed) message text is always Unicode str here. Similarly, headers are\ndecoded for display here using tools implemented in mailtools, but headers encoding\nis both initiated and performed within mailtools itself on sends.\nFull text decoding illustrates the types of choices required. It is done according to the\nfetchEncoding variable in the mailconfig module. This user setting is used across an\n1018 | Chapter 14:\u2002The PyMailGUI Cliententire PyMailGUI session to decode fetched message bytes to the required str text prior\nto parsing, and to save and load full message text to save files. Users may set this variable\nto a Unicode encoding name string which works for their mails\u2019 encodings; \u201clatin-1\u201d,\n\u201cutf-8\u201d, and \u201cascii\u201d are reasonable guesses for most emails, as email standards originally\ncalled for ASCII (though \u201clatin-1\u201d was required to decode some old mail save files\ngenerated by the prior version). If decoding with this encoding name fails, other com-\nmon encodings are attempted, and as a last resort the message is still displayed if its\nheaders can be decoded, but its body is changed to an error message; to view such\nunlikely mails, try running PyMailGUI again with a different encoding.\nIn the negatives column, nothing is done about the Unicode format for the full text of\nsent mails, apart from that inherited from Python\u2019s libraries (as we learned in Chap-\nter 13, smtplib attempts to encode per ASCII when messages are sent, which is one\nreason that header encoding is required). And while mail content character sets are\nfully supported, the GUI itself still uses English for its labels and buttons.\nAs explained in Chapter 13, this program\u2019s Unicode polices are a broad but partial\nsolution, because the email package in Python 3.1, upon which PyMailGUI utterly relies\nfor correct operation, is in a state of flux for some use cases. An updated version which\nhandles the Python 3.X str/bytes distinctions more accurately and completely is likely\nto appear in the future; watch this book\u2019s updates page (see the Preface) for future\nchanges and improvements to this program\u2019s Unicode policies. Hopefully, the current\nemail package underlying PyMailGUI 3.0 will be available for some time to come.\nAlthough there is still room for improvement (see the list at the end of this chapter),\nthe PyMailGUI program is able to provide a full-featured email interface, represents\nthe most substantial example in this book, and serves to demonstrate a realistic appli-\ncation of the Python language and software engineering at large. As its users often attest,\nPython may be fun to work with, but it\u2019s also useful for writing practical and nontrivial\nsoftware. This example, more than any other in this book, testifies the same. The next\nsection shows how.\nA PyMailGUI Demo\nPyMailGUI is a multiwindow interface. It consists of the following:\n\u2022 A main mail-server list window opened initially, for online mail processing\n\u2022 One or more mail save-file list windows for offline mail processing\n\u2022 One or more mail-view windows for viewing and editing messages\n\u2022 PyEdit windows for displaying raw mail text, extracted text parts, and the system\u2019s\nsource code\n\u2022 Nonblocking busy state pop-up dialogs\n\u2022 Assorted pop-up dialogs for opened message parts, help, and more\nA PyMailGUI Demo | 1019Operationally, PyMailGUI runs as a set of parallel threads, which may overlap in time:\none for each active server transfer, and one for each active offline save file load or\ndeletion. PyMailGUI supports mail save files, automatic saves of sent messages, con-\nfigurable fonts and colors, viewing and adding attachments, main message text extrac-\ntion, plain text conversion for HTML, and much more.\nTo make this case study easier to understand, let\u2019s begin by seeing what PyMailGUI\nactually does\u2014its user interaction and email processing functionality\u2014before jumping\ninto the Python code that implements that behavior. As you read this part, feel free to\njump ahead to the code listings that appear after the screenshots, but be sure to read\nthis section, too; this, along with the prior discussion of version changes, is where some\nsubtleties of PyMailGUI\u2019s design are explained. After this section, you are invited to\nstudy the system\u2019s Python source code listings on your own for a better and more\ncomplete explanation than can be crafted in English.\nGetting Started\nOK, it\u2019s time to take the system out for a test drive. I\u2019m going to run the following demo\non my Windows 7 laptop. It may look slightly different on different platforms (includ-\ning other versions of Windows) thanks to the GUI toolkit\u2019s native-look-and-feel sup-\nport, but the basic functionality will be similar.\nPyMailGUI is a Python/tkinter program, run by executing its top-level script file,\nPyMailGui.py. Like other Python programs, PyMailGUI can be started from the system\ncommand line, by clicking on its filename icon in a file explorer interface, or by pressing\nits button in the PyDemos or PyGadgets launcher bar. However it is started, the first\nwindow PyMailGUI presents is captured in Figure 14-1, shown after running a Load\nto fetch mail headers from my ISP\u2019s email server. Notice the \u201cPY\u201d window icon: this is\nthe handiwork of window protocol tools we wrote earlier in this book. Also notice the\nnon-ASCII subject lines here; I\u2019ll talk about Internationalization features later.\nThis is the PyMailGUI main window\u2014every operation starts here. It consists of:\n\u2022 A help button (the bar at the top)\n\u2022 A clickable email list area for fetched emails (the middle section)\n\u2022 A button bar at the bottom for processing messages selected in the list area\nIn normal operation, users load their email, select an email from the list area by clicking\non it, and press a button at the bottom to process it. No mail messages are shown\ninitially; we need to first load them with the Load button\u2014a simple password input\ndialog is displayed, a busy dialog appears that counts down message headers being\ndownloaded to give a status indication, and the index is filled with messages ready to\nbe selected.\n1020 | Chapter 14:\u2002The PyMailGUI ClientPyMailGUI\u2019s list windows, such as the one in Figure 14-1, display mail header details\nin fixed-width columns, up to a maximum size. Mails with attachments are prefixed\nwith a \u201c*\u201d in mail index list windows, and fonts and colors in PyMailGUI windows like\nthis one can be customized by the user in the mailconfig configuration file. You can\u2019t\ntell in this black-and-white book, but most of the mail index lists we\u2019ll see are configured\nto be Indian red, view windows are light blue, pop-up PyEdit windows are beige instead\nof PyEdit\u2019s normal light cyan, and help is steel blue. You can change most of these as\nyou like, and PyEdit pop-up window appearance can be altered in the GUI itself (see\nExample 8-11 for help with color definition strings, and watch for alternative config-\nuration examples ahead).\nList windows allow multiple messages to be selected at once\u2014the action selected at\nthe bottom of the window is applied to all selected mails. For instance, to view many\nmails, select them all and press View; each will be fetched (if needed) and displayed in\nits own view window. Use the All check button in the bottom right corner to select or\ndeselect every mail in the list, and Ctrl-Click and Shift-Click combinations to select\nmore than one (the standard Windows multiple selection operations apply\u2014try it).\nBefore we go any further, though, let\u2019s press the help bar at the top of the list window\nin Figure 14-1 to see what sort of help is available; Figure 14-2 shows the text-based\nhelp window pop up that appears\u2014one of two help flavors available.\nThe main part of this window is simply a block of text in a scrolled-text widget, along\nwith two buttons at the bottom. The entire help text is coded as a single triple-quoted\nstring in the Python program. As we\u2019ll see in a moment, a fancier option which opens\nFigure 14-1. PyMailGUI main server list window\nA PyMailGUI Demo | 1021an HTML rendition of this text in a spawned web browser is also available, but simple\ntext is sufficient for many people\u2019s tastes.\u2021 The Cancel button makes this nonmodal\n(i.e., nonblocking) window go away. More interestingly, the Source button pops up\nPyEdit text editor viewer windows for all the source files of PyMailGUI\u2019s implementa-\ntion; Figure 14-3 captures one of these (there are many; this is intended as a demon-\nstration, not as a development environment). Not every program shows you its source\ncode, but PyMailGUI follows Python\u2019s open source motif.\nNew in this edition, help is also displayed in HTML form in a web browser, in addition\nto or instead of the scrolled text display just shown. Choosing help in text, HTML, or\nboth is controlled by a setting in the mailconfig module. The HTML flavor uses the\nPython webbrowser module to pop up the HTML file in a browser on the local machine,\nFigure 14-2. PyMailGUI text help pop up\n\u2021 Actually, the help display started life even less fancy: it originally displayed help text in a standard information\npop up common dialog, generated by the tkinter showinfo call used earlier in the book. This worked fine on\nWindows (at least with a small amount of help text), but it failed on Linux because of a default line-length\nlimit in information pop-up boxes; lines were broken so badly as to be illegible. Over the years, common\ndialogs were replaced by scrolled text, which has now been largely replaced by HTML; I suppose the next\nedition will require a holographic help interface\u2026\n1022 | Chapter 14:\u2002The PyMailGUI Clientand currently lacks the source-file opening button of the text display version (one reason\nyou may wish to display the text viewer, too). HTML help is captured in Figure 14-4.\nWhen a message is selected for viewing in the mail list window by a mouse click and\nView press, PyMailGUI downloads its full text (if it has not yet been downloaded in\nthis session), and a formatted email viewer window appears, as captured in Fig-\nure 14-5 for an existing message in my account\u2019s inbox.\nView windows are built in response to actions in list windows and take the following\nform:\n\u2022 The top portion consists of action buttons (Part to list all message parts, Split to\nsave and open parts using a selected directory, and Cancel to close this nonmodal\nwindow), along with a section for displaying email header lines (From, To, and\nso on).\n\u2022 In the middle, a row of quick-access buttons for opening message parts, including\nattachments, appears. When clicked, PyMailGUI opens known and generally safe\nparts according to their type. Media types may open in a web browser or image\nviewer, text parts in PyEdit, HTML in a web browser, Windows document types\nper the Windows Registry, and so on.\nFigure 14-3. PyMailGUI text help source code viewer window\nA PyMailGUI Demo | 1023\u2022 The bulk of this window (its entire lower portion) is just another reuse of the\nTextEditor class object of the PyEdit program we wrote in Chapter 11\u2014PyMailGUI\nsimply attaches an instance of TextEditor to every view and compose window in\norder to get a full-featured text editor component for free. In fact, much on the\nwindow shown in Figure 14-5 is implemented by TextEditor, not by PyMailGUI.\nReusing PyEdit\u2019s class this way means that all of its tools are at our disposal for email\ntext\u2014cut and paste, find and goto, saving a copy of the text to a file, and so on. For\ninstance, the PyEdit Save button at the bottom left of Figure 14-5 can be used to save\njust the main text of the mail (as we\u2019ll see later, clicking the leftmost part button in the\nmiddle of the screen affords similar utility, and you can also save the entire message\nfrom a list window). To make this reuse even more concrete, if we pick the Tools menu\nof the text portion of this window and select its Info entry, we get the standard PyEdit\nTextEditor object\u2019s text statistics box shown in Figure 14-6\u2014the same pop up we\u2019d\nget in the standalone PyEdit text editor and in the PyView image view programs we\nwrote in Chapter 11.\nIn fact, this is the third reuse of TextEditor in this book: PyEdit, PyView, and now\nPyMailGUI all present the same text-editing interface to users, simply because they all\nuse the same TextEditor object and code. PyMailGUI uses it in multiple roles\u2014it both\nattaches instances of this class for mail viewing and composition, and pops up instances\nin independent windows for some text mail parts, raw message text display, and Python\nFigure 14-4. PyMailGUI HTML help display (new in 3.0)\n1024 | Chapter 14:\u2002The PyMailGUI Clientsource-code viewing (we saw the latter in Figure 14-3). For mail view components,\nPyMailGUI customizes PyEdit text fonts and colors per its own configuration module;\nfor pop ups, user preferences in a local textConfig module are applied.\nTo display email, PyMailGUI inserts its text into an attached TextEditor object; to\ncompose email, PyMailGUI presents a TextEditor and later fetches all its text to ship\nover the Net. Besides the obvious simplification here, this code reuse makes it easy to\npick up improvements and fixes\u2014any changes in the TextEditor object are automati-\ncally inherited by PyMailGUI, PyView, and PyEdit.\nIn the third edition\u2019s version, for instance, PyMailGUI supports edit undo and redo,\njust because PyEdit had gained that feature. And in this fourth edition, all PyEdit im-\nporters also inherit its new Grep file search, as well as its new support for viewing and\nediting text of arbitrary Unicode encodings\u2014especially useful for text parts in emails\nof arbitrary origin like those displayed here (see Chapter 11 for more about PyEdit\u2019s \nevolution).\nLoading Mail\nNext, let\u2019s go back to the PyMailGUI main server list window, and click the Load button\nto retrieve incoming email over the POP protocol. PyMailGUI\u2019s load function gets\nFigure 14-5. PyMailGUI view window\nA PyMailGUI Demo | 1025account parameters from the mailconfig module listed later in this chapter, so be sure\nto change this file to reflect your email account parameters (i.e., server names and\nusernames) if you wish to use PyMailGUI to read your own email. Unless you can guess\nthe book\u2019s email account password, the presets in this file won\u2019t work for you.\nThe account password parameter merits a few extra words. In PyMailGUI, it may come\nfrom one of two places:\nLocal file\nIf you put the name of a local file containing the password in the mailconfig mod-\nule, PyMailGUI loads the password from that file as needed.\nPop up dialog\nIf you don\u2019t put a password filename in mailconfig (or if PyMailGUI can\u2019t load it\nfrom the file for whatever reason), PyMailGUI will instead ask you for your pass-\nword anytime it is needed.\nFigure 14-7 shows the password input prompt you get if you haven\u2019t stored your pass-\nword in a local file. Note that the password you type is not shown\u2014a show='*' option\nfor the Entry field used in this pop up tells tkinter to echo typed characters as stars (this\noption is similar in spirit to both the getpass console input module we met earlier in\nthe prior chapter and an HTML type=password option we\u2019ll meet in a later chapter).\nOnce entered, the password lives only in memory on your machine; PyMailGUI itself\ndoesn\u2019t store it anywhere in a permanent way.\nFigure 14-6. PyMailGUI attached PyEdit info box\n1026 | Chapter 14:\u2002The PyMailGUI ClientAlso notice that the local file password option requires you to store your password\nunencrypted in a file on the local client computer. This is convenient (you don\u2019t need\nto retype a password every time you check email), but it is not generally a good idea on\na machine you share with others, of course; leave this setting blank in mailconfig if you\nprefer to always enter your password in a pop up.\nOnce PyMailGUI fetches your mail parameters and somehow obtains your password,\nit will next attempt to pull down just the header text of all your incoming email from\nyour inbox on your POP email server. On subsequent loads, only newly arrived mails\nare loaded, if any. To support obscenely large inboxes (like one of mine), the program\nis also now clever enough to skip fetching headers for all but the last batch of messages,\nwhose size you can configure in mailconfig\u2014they show up early in the mail list with\nsubject line \u201c--mail skipped--\u201d; see the 3.0 changes overview earlier for more details.\nTo save time, PyMailGUI fetches message header text only to populate the list window.\nThe full text of messages is fetched later only when a message is selected for viewing or\nprocessing, and then only if the full text has not yet been fetched during this session.\nPyMailGUI reuses the load-mail tools in the mailtools module of Chapter 13 to fetch\nmessage header text, which in turn uses Python\u2019s standard poplib module to retrieve\nyour email.\nThreading Model\nNow that we\u2019re downloading mails, I need to explain the juggling act that PyMailGUI\nperforms to avoid becoming blocked and support operations that overlap in time. Ul-\ntimately, mail fetches run over sockets on relatively slow networks. While the download\nis in progress, the rest of the GUI remains active\u2014you may compose and send other\nmails at the same time, for instance. To show its progress, the nonblocking dialog of\nFigure 14-8 is displayed when the mail index is being fetched.\nIn general, all server transfers display such dialogs. Figure 14-9 shows the busy dialog\ndisplayed while a full text download of five selected and uncached (not yet fetched)\nmails is in progress, in response to a View action. After this download finishes, all five\npop up in individual view windows.\nSuch server transfers, and other long-running operations, are run in threads to avoid\nblocking the GUI. They do not disable other actions from running in parallel, as long\nas those actions would not conflict with a currently running thread. Multiple mail sends\nand disjoint fetches can overlap in time, for instance, and can run in parallel with the\nFigure 14-7. PyMailGUI password input dialog\nA PyMailGUI Demo | 1027GUI itself\u2014the GUI responds to moves, redraws, and resizes during the transfers.\nOther transfers such as mail deletes must run all by themselves and disable other trans-\nfers until they are finished; deletes update the inbox and internal caches too radically\nto support other parallel operations.\nOn systems without threads, PyMailGUI instead goes into a blocked state during such\nlong-running operations (it essentially stubs out the thread-spawn operation to perform\na simple function call). Because the GUI is essentially dead without threads, covering\nand uncovering the GUI during a mail load on such platforms will erase or otherwise\ndistort its contents. Threads are enabled by default on most platforms that run Python\n(including Windows), so you probably won\u2019t see such oddness on your machine.\nFigure 14-8. Nonblocking progress indicator: Load\nFigure 14-9. Nonblocking progress indicator: View\n1028 | Chapter 14:\u2002The PyMailGUI ClientThreading model implementation\nOn nearly every platform, though, long-running tasks like mail fetches and sends are\nspawned off as parallel threads, so that the GUI remains active during the transfer\u2014it\ncontinues updating itself and responding to new user requests, while transfers occur\nin the background. While that\u2019s true of threading in most GUIs, here are two notes\nregarding PyMailGUI\u2019s specific implementation and threading model:\nGUI updates: exit callback queue\nAs we learned earlier in this book, only the main thread that creates windows\nshould generally update them. See Chapter 9 for more on this; tkinter doesn\u2019t\nsupport parallel GUI changes. As a result, PyMailGUI takes care to not do anything\nrelated to the user interface within threads that load, send, or delete email. Instead,\nthe main GUI thread continues responding to user interface events and updates,\nand uses a timer-based event to watch a queue for exit callbacks to be added by\nworker threads, using the thread tools we implemented earlier in Chapter 10\n(Example 10-20). Upon receipt, the main GUI thread pulls the callback off the\nqueue and invokes it to modify the GUI in the main thread.\nSuch queued exit callbacks can display a fetched email message, update the mail\nindex list, change a progress indicator, report an error, or close an email compo-\nsition window\u2014all are scheduled by worker threads on the queue but performed\nin the main GUI thread. This scheme makes the callback update actions automat-\nically thread safe: since they are run by one thread only, such GUI updates cannot\noverlap in time.\nTo make this easy, PyMailGUI stores bound method objects on the thread queue,\nwhich combine both the function to be called and the GUI object itself. Since\nthreads all run in the same process and memory space, the GUI object queued gives\naccess to all GUI state needed for exit updates, including displayed widget objects.\nPyMailGUI also runs bound methods as thread actions to allow threads to update\nstate in general, too, subject to the next paragraph\u2019s rules.\nOther state updates: operation overlap locks\nAlthough the queued GUI update callback scheme just described effectively re-\nstricts GUI updates to the single main thread, it\u2019s not enough to guarantee thread\nsafety in general. Because some spawned threads update shared object state used\nby other threads (e.g., mail caches), PyMailGUI also uses thread locks to prevent\noperations from overlapping in time if they could lead to state collisions. This\nincludes both operations that update shared objects in memory (e.g., loading mail\nheaders and content into caches), as well as operations that may update POP mes-\nsage numbers of loaded email (e.g., deletions).\nWhere thread overlap might be an issue, the GUI tests the state of thread locks,\nand pops up a message when an operation is not currently allowed. See the source\ncode and this program\u2019s help text for specific cases where this rule is applied.\nA PyMailGUI Demo | 1029Operations such as individual sends and views that are largely independent can\noverlap broadly, but deletions and mail header fetches cannot.\nIn addition, some potentially long-running save-mail operations are threaded to\navoid blocking the GUI, and this edition uses a set object to prevent fetch threads\nfor requests that include a message whose fetch is in progress in order to avoid\nredundant work (see the 3.0 changes review earlier).\nFor more on why such things matter in general, be sure to see the discussion of threads\nin GUIs in Chapters 5, 9, and 10. PyMailGUI is really just a concrete realization of\nconcepts we\u2019ve explored earlier.\nLoad Server Interface\nLet\u2019s return to loading our email: because the load operation is really a socket operation,\nPyMailGUI automatically connects to your email server using whatever connectivity\nexists on the machine on which it is run. For instance, if you connect to the Net over\na modem and you\u2019re not already connected, Windows automatically pops up the\nstandard connection dialog. On the broadband connections that most of us use today,\nthe interface to your email server is normally automatic.\nAfter PyMailGUI finishes loading your email, it populates the main window\u2019s scrolled\nlistbox with all of the messages on your email server and automatically scrolls to the\nmost recently received message. Figure 14-10 shows what the main window looks like\nafter selecting a message with a click and resizing\u2014the text area in the middle grows\nand shrinks with the window, revealing more header columns as it grows.\nFigure 14-10. PyMailGUI main window resized\nTechnically, the Load button fetches all your mail\u2019s header text the first time it is\npressed, but it fetches only newly arrived email headers on later presses. PyMailGUI\nkeeps track of the last email loaded, and requests only higher email numbers on later\nloads. Already loaded mail is kept in memory, in a Python list, to avoid the cost of\ndownloading it again. PyMailGUI does not delete email from your server when it is\n1030 | Chapter 14:\u2002The PyMailGUI Clientloaded; if you really want to not see an email on a later load, you must explicitly\ndelete it.\nEntries in the main list show just enough to give the user an idea of what the message\ncontains\u2014each entry gives the concatenation of portions of the message\u2019s Subject,\nFrom, Date, To, and other header lines, separated by | characters and prefixed with\nthe message\u2019s POP number (e.g., there are 13 emails in this list). Columns are aligned\nby determining the maximum size needed for any entry, up to a fixed maximum, and\nthe set of headers displayed can be configured in the mailconfig module. Use the hor-\nizontal scroll or expand the window to see additional header details such as message\nsize and mailer.\nAs we\u2019ve seen, a lot of magic happens when downloading email\u2014the client (the ma-\nchine on which PyMailGUI runs) must connect to the server (your email account ma-\nchine) over a socket and transfer bytes over arbitrary Internet links. If things go wrong,\nPyMailGUI pops up standard error dialog boxes to let you know what happened. For\nexample, if you type an incorrect username or password for your account (in the mail\nconfig module or in the password pop up), you\u2019ll receive the message in Fig-\nure 14-11. The details displayed here are just the Python exception type and exception\ndata. Additional details, including a stack trace, show up in standard output (the con-\nsole window) on errors.\nFigure 14-11. PyMailGUI invalid password error box\nOffline Processing with Save and Open\nWe\u2019ve seen how to fetch and view emails from a server, but PyMailGUI can also be\nused in completely offline mode. To save mails in a local file for offline processing,\nselect the desired messages in any mail list window and press the Save action button;\nas usual, any number of messages may be selected for saving together as a set. A\nstandard file-selection dialog appears, like that in Figure 14-12, and the mails are saved\nto the end of the chosen text file.\nA PyMailGUI Demo | 1031Figure 14-12. Save mail selection dialog\nTo view saved emails later, select the Open action at the bottom of any list window\nand pick your save file in the selection dialog. A new mail index list window appears\nfor the save file and it is filled with your saved messages eventually\u2014there may be a\nslight delay for large save files, because of the work involved. PyMailGUI runs file loads\nand deletions in threads to avoid blocking the rest of the GUI; these threads can overlap\nwith operations on other open save-mail files, server transfer threads, and the GUI at\nlarge.\nWhile a mail save file is being loaded in a parallel thread, its window title is set to\n\u201cLoading\u2026\u201d as a status indication; the rest of the GUI remains active during the load\n(you can fetch and delete server messages, view mails in other files, write new messages,\nand so on). The window title changes to the loaded file\u2019s name after the load is finished.\nOnce filled, a message index appears in the save file\u2019s window, like the one captured\nin Figure 14-13 (this window also has three mails selected for processing).\nIn general, there can be one server mail list window and any number of save-mail file\nlist windows open at any time. Save-mail file list windows like that in Figure 14-13 can\nbe opened at any time, even before fetching any mail from the server. They are identical\nto the server\u2019s inbox list window, but there is no help bar, the Load action button is\nomitted since this is not a server view, and all other action buttons are mapped to the\nsave file, not to the server.\n1032 | Chapter 14:\u2002The PyMailGUI ClientFor example, View opens the selected message in a normal mail view window identical\nto that in Figure 14-5, but the mail originates from the local file. Similarly, Delete re-\nmoves the message from the save file, instead of from the server\u2019s inbox. Deletions from\nsave-mail files are also run in a thread, to avoid blocking the rest of the GUI\u2014the\nwindow title changes to \u201cDeleting\u2026\u201d during the delete as a status indicator. Status\nindicators for loads and deletions in the server inbox window use pop ups instead,\nbecause the wait is longer and there is progress to display (see Figure 14-8).\nTechnically, saves always append raw message text to the chosen file; the file is opened\nin 'a' mode to append text, which creates the file if it\u2019s new and writes at its end. The\nSave and Open operations are also smart enough to remember the last directory you\nselected; their file dialogs begin navigation there the next time you press Save or Open.\nYou can also save mails from a saved file\u2019s window\u2014use Save and Delete to move mails\nfrom file to file. In addition, saving to a file whose window is open for viewing auto-\nmatically updates that file\u2019s list window in the GUI. This is also true for the automat-\nically written sent-mail save file, described in the next section.\nSending Email and Attachments\nOnce we\u2019ve loaded email from the server or opened a local save file, we can process\nour messages with the action buttons at the bottom of list windows. We can also send\nnew emails at any time, even before a load or open. Pressing the Write button in any\nlist window (server or file) generates a mail composition window; one has been cap-\ntured in Figure 14-14.\nFigure 14-13. List window for mail save file, multiple selections\nA PyMailGUI Demo | 1033Figure 14-14. PyMailGUI write-mail compose window\nThis window is much like the message view window we saw in Figure 14-5, except\nthere are no quick-access part buttons in the middle (this window is a new mail). It has\nfields for entering header line detail, action buttons for sending the email and managing\nattachment files added to it when sent, and an attached TextEditor object component\nfor writing and editing the main text of the new email.\nThe PyEdit text editor component at the bottom has no File menu in this role, but it\ndoes have a Save button\u2014useful for saving a draft of your mail\u2019s text in a file. You can\ncut and paste this temporary copy into a composition window later if needed to begin\ncomposing again from scratch. PyEdit\u2019s separate Unicode policies apply to mail text\ndrafts saved this way (it may ask for an encoding\u2014see Chapter 11).\nFor write operations, PyMailGUI automatically fills the From line and inserts a signa-\nture text line (the last two lines shown), from your mailconfig module settings. You\ncan change these to any text you like in the GUI, but the defaults are filled in auto-\nmatically from your mailconfig. When the mail is sent, an email.utils call handles\ndate and time formatting in the mailtools module in Chapter 13.\nThere is also a new set of action buttons in the upper left here: Cancel closes the window\n(if verified), and Send delivers the mail\u2014when you press the Send button, the text you\ntyped into the body of this window is mailed to all the addresses you typed into the To,\nCc, and Bcc lines, after removing duplicates, and using Python\u2019s smtplib module. Py-\nMailGUI adds the header fields you type as mail header lines in the sent message\n(exception: Bcc recipients receive the mail, but no header line is generated).\nTo send to more than one address, separate them with a comma character in header\nfields, and feel free to use full \u201cname\u201d <address> pairs for recipients. In this mail, I fill\nin the To header with my own email address in order to send the message to myself for\n1034 | Chapter 14:\u2002The PyMailGUI Clientillustration purposes. New in this version, PyMailGUI also prefills the Bcc header with\nthe sender\u2019s own address if this header is enabled in mailconfig; this prefill sends a copy\nto the sender (in addition to that written to the sent-mail file), but it can be deleted if\nunwanted.\nAlso in compose windows, the Attach button issues a file selection dialog for attaching\na file to your message, as in Figure 14-15. The Parts button pops up a dialog displaying\nfiles already attached, like that in Figure 14-16. When your message is sent, the text in\nthe edit portion of the window is sent as the main message text, and any attached part\nfiles are sent as attachments properly encoded according to their type.\nFigure 14-15. Attachment file dialog for Attach\nAs we\u2019ve seen, smtplib ultimately sends bytes to a server over a socket. Since this can\nbe a long-running operation, PyMailGUI delegates this operation to a spawned thread,\ntoo. While the send thread runs, a nonblocking wait window appears and the entire\nGUI stays alive; redraw and move events are handled in the main program thread while\nthe send thread talks to the SMTP server, and the user may perform other tasks in\nparallel, including other views and sends.\nYou\u2019ll get an error pop up if Python cannot send a message to any of the target recipients\nfor any reason, and the mail composition window will pop up so that you can try again\nor save its text for later use. If you don\u2019t get an error pop up, everything worked cor-\nrectly, and your mail will show up in the recipients\u2019 mailboxes on their email servers.\nA PyMailGUI Demo | 1035Since I sent the earlier message to myself, it shows up in mine the next time I press the\nmain window\u2019s Load button, as we see in Figure 14-17.\nFigure 14-17. PyMailGUI main window after loading sent mail\nFigure 14-16. Attached parts list dialog for Parts\n1036 | Chapter 14:\u2002The PyMailGUI ClientIf you look back to the last main window shot, you\u2019ll notice that there is only one new\nemail now\u2014PyMailGUI is smart enough to download only the one new message\u2019s\nheader text and tack it onto the end of the loaded email list. Mail send operations\nautomatically save sent mails in a save file that you name in your configuration module;\nuse Open to view sent messages in offline mode and Delete to clean up the sent mail\nfile if it grows too large (you can also save from the sent-mail file to another file to copy\nmails into other save files per category).\nViewing Email and Attachments\nNow let\u2019s view the mail message that was sent and received. PyMailGUI lets us view\nemail in formatted or raw mode. First, highlight (single-click) the mail you want to see\nin the main window, and press the View button. After the full message text is down-\nloaded (unless it is already cached), a formatted mail viewer window like that shown\nin Figure 14-18 appears. If multiple messages are selected, the View button will down-\nload all that are not already cached (i.e., that have not already been fetched) and will\npop up a view window for each selected. Like all long-running operations, full message\ndownloads are run in parallel threads to avoid blocking.\nFigure 14-18. PyMailGUI view incoming mail window\nPython\u2019s email module is used to parse out header lines from the raw text of the email\nmessage; their text is placed in the fields in the top right of the window. The message\u2019s\nmain text is fetched from its body and stuffed into a new TextEditor object for display\nat the window bottom. PyMailGUI uses heuristics to extract the main text of the mes-\nsage to display, if there is one; it does not blindly show the entire raw text of the mail.\nHTML-only mail is handled specially, but I\u2019ll defer details on this until later in this\ndemo.\nA PyMailGUI Demo | 1037Any other parts of the message attached are displayed and opened with quick-access\nbuttons in the middle. They are also listed by the Parts pop up dialog, and they can be\nsaved and opened all at once with Split. Figure 14-19 shows this window\u2019s Parts list\npop up, and Figure 14-20 displays this window\u2019s Split dialog in action.\nFigure 14-19. Parts dialog listing all message parts\nFigure 14-20. Split dialog selection\n1038 | Chapter 14:\u2002The PyMailGUI ClientWhen the Split dialog in Figure 14-20 is submitted, all message parts are saved to the\ndirectory you select, and known parts are automatically opened. Individual parts are\nalso automatically opened by the row of quick-access buttons labeled with the part\u2019s\nfilename in the middle of the view window, after being saved to a temporary directory;\nthis is usually more convenient, especially when there are many attachments.\nFor instance, Figure 14-21 shows the two image parts attached to the mail we sent open\non my Windows laptop, in a standard image viewer on that platform; other platforms\nmay open this in a web browser instead. Click the image filenames\u2019 quick-access but-\ntons just below the message headers in Figure 14-18 to view them immediately, or run\nSplit to open all parts at once.\nFigure 14-21. PyMailGUI opening image parts in a viewer or browser\nBy this point, the photo attachments displayed in Figure 14-21 have really gotten\naround: they have been MIME encoded, attached, and sent, and then fetched, parsed,\nand MIME decoded. Along the way, they have moved through multiple machines\u2014\nfrom the client, to the SMTP server, to the POP server, and back to the client, crossing\narbitrary distances along the way.\nIn terms of user interaction, we attached the images to the email in Figure 14-14 using\nthe dialog in Figure 14-15 before we sent the email. To access them later, we selected\nthe email for viewing in Figure 14-17 and clicked on their quick-access button in Fig-\nure 14-18. PyMailGUI encoded the photos in Base64 form, inserted them in the email\u2019s\ntext, and later extracted and decoded it to get the original photos. With Python email\ntools, and our own code that rides above them, this all just works as expected.\nNotice how in Figures 14-18 and 14-19 the main message text counts as a mail part,\ntoo\u2014when selected, it opens in a PyEdit window, like that captured in Figure 14-22,\nA PyMailGUI Demo | 1039from which it can be processed and saved (you can also save the main mail text with\nthe Save button in the View window itself). The main part is included, because not all\nmails have a text part. For messages that have only HTML for their main text part,\nPyMailGUI displays plain text extracted from its HTML text in its own window, and\nopens a web browser to view the mail with its HTML formatting. Again, I\u2019ll say more\non HTML-only mails later.\nFigure 14-22. Main text part opened in PyEdit\nBesides images and plain text, PyMailGUI also opens HTML and XML attachments in\na web browser and uses the Windows Registry to open well-known Windows docu-\nment types. For example, .doc and .docx, .xls and .xlsx, and .pdf files usually open,\nrespectively, in Word, Excel, and Adobe Reader. Figure 14-23 captures the response\nto the lp4e-pref.html quick-access part button in Figure 14-18 on my Windows laptop.\nIf you inspect this screenshot closely, or run live for a better look, you\u2019ll notice that the\nHTML attachment is displayed in both a web browser and a PyEdit window; the latter\ncan be disabled in mailconfig, but is on by default to give an indication of the HTML\u2019s\nencoding.\nThe quick-access buttons in the middle of the Figure 14-18 view window are a more\ndirect way to open parts than Split\u2014you don\u2019t need to select a save directory, and you\ncan open just the part you want to view. The Split button, though, allows all parts to\nbe opened in a single step, allows you to choose where to save parts, and supports an\narbitrary number of parts. Files that cannot be opened automatically because of their\ntype can be inspected in the local save directory, after both Split and quick-access but-\nton selections (pop up dialogs name the directory to use for this).\nAfter a fixed maximum number of parts, the quick-access row ends with a button\nlabeled \u201c...\u201d, which simply runs Split to save and open additional parts when selected.\nFigure 14-24 captures one such message in the GUI; this message is available in\nSavedMail file version30-4E if you want to view it offline\u2014a relatively complex mail,\nwith 11 total parts of mixed types.\n1040 | Chapter 14:\u2002The PyMailGUI ClientFigure 14-24. View window for a mail with many parts\nLike much of PyMailGUI\u2019s behavior, the maximum number of part buttons to display\nin view windows can be configured in the mailconfig.py user settings module. That\nsetting specified eight buttons in Figure 14-24. Figure 14-25 shows what the same mail\nlooks like when the part buttons setting has been changed to a maximum of five. The\nsetting can be higher than eight, but at some point the buttons may become unreadable\n(use Split instead).\nFigure 14-23. Attached HTML part opened in a web browser\nA PyMailGUI Demo | 1041Figure 14-25. View window with part buttons setting decreased\nAs a sample of other attachments\u2019 behavior, Figures 14-26 and 14-27 show what hap-\npens when the sousa.au and chapter25.pdf buttons in Figures 14-24 and 14-18 are\npressed on my Windows laptop. The results vary per machine; the audio file opens in\nWindows Media Player, MP3 files open in iTunes instead, and some platforms may\nopen such files directly in a web browser.\nFigure 14-26. An audio part opened by PyMailGUI\nBesides the nicely formatted view window, PyMailGUI also lets us see the raw text of\na mail message. Double-click on a message\u2019s entry in the main window\u2019s list to bring\n1042 | Chapter 14:\u2002The PyMailGUI Clientup a simple unformatted display of the mail\u2019s raw text (its full text is downloaded in a\nthread if it hasn\u2019t yet been fetched and cached). Part of the raw version of the mail I\nsent to myself in Figure 14-18 is shown in Figure 14-28; in this edition, raw text is\ndisplayed in a PyEdit pop-up window (its prior scrolled-text display is still present as\nan option, but PyEdit adds tools such as searching, saves, and so on).\nThis raw text display can be useful to see special mail headers not shown in the for-\nmatted view. For instance, the optional X-Mailer header in the raw text display iden-\ntifies the program that transmitted a message; PyMailGUI adds it automatically, along\nwith standard headers like From and To. Other headers are added as the mail is trans-\nmitted: the Received headers name machines that the message was routed through on\nits way to our email server, and Content-Type is added and parsed by Python\u2019s email\npackage in response to calls from PyMailGUI.\nAnd really, the raw text form is all there is to an email message\u2014it\u2019s what is transferred\nfrom machine to machine when mail is sent. The nicely formatted display of the GUI\u2019s\nview windows simply parses out and decodes components from the mail\u2019s raw text\nwith standard Python tools, and places them in the associated fields of the display.\nNotice the Base64 encoding text of the image file at the end of Figure 14-28, for ex-\nample; it\u2019s created when sent, transferred over the Internet, and decoded when fetched\nto recreate the image\u2019s original bytes. Quite a feat, but largely automatic with the code\nand libraries invoked.\nEmail Replies and Forwards and Recipient Options\nIn addition to reading and writing email, PyMailGUI also lets users forward and reply\nto incoming email sent from others. These are both just composition operations, but\nthey quote the original text and prefill header lines as appropriate. To reply to an email,\nselect its entry in the main window\u2019s list and click the Reply button. If I reply to the\nFigure 14-27. A PDF part opened in PyMailGUI\nA PyMailGUI Demo | 1043mail I just sent to myself (arguably narcissistic, but demonstrative), the mail composi-\ntion window shown in Figure 14-29 appears.\nThis window is identical in format to the one we saw for the Write operation, except\nthat PyMailGUI fills in some parts automatically. In fact, the only thing I\u2019ve added in\nthis window is the first line in the text editor part; the rest is filled in by PyMailGUI:\n\u2022 The From line is set to your email address in your mailconfig module.\n\u2022 The To line is initialized to the original message\u2019s From address (we\u2019re replying to\nthe original sender, after all).\n\u2022 The Subject line is set to the original message\u2019s subject line, prepended with a \u201cRe:\u201d,\nthe standard follow-up subject line form (unless it already has one, in uppercase\nor lowercase).\nFigure 14-28. PyMailGUI raw mail text view window (PyEdit)\n1044 | Chapter 14:\u2002The PyMailGUI Client\u2022 The optional Bcc line, if enabled in the mailconfig module, is prefilled with the\nsender\u2019s address, too, since it\u2019s often used this way to retain a copy (new in this\nversion).\n\u2022 The body of the reply is initialized with the signature line in mailconfig, along with\nthe original message\u2019s text. The original message text is quoted with > characters\nand is prepended with a few header lines extracted from the original message to\ngive some context.\n\u2022 Not shown in this example and new in this version, too, the Cc header in replies\nis also prefilled with all the original recipients of the message, by extracting ad-\ndresses among the original To and Cc headers, removing duplicates, and removing\nyour address from the result. In other words, Reply really is Reply-to-All by\ndefault\u2014it replies to the sender and copies all other recipients as a group. Since\nthe latter isn\u2019t always desirable, it can be disabled in mailconfig so that replies only\ninitialize To with the original sender. You can also simply delete the Cc prefill if\nnot wanted, but you may have to add addresses to Cc manually if this feature is\ndisabled. We\u2019ll see reply Cc prefills at work later.\nFigure 14-29. PyMailGUI reply compose window\nA PyMailGUI Demo | 1045Luckily, all of this is much easier than it may sound. Python\u2019s standard email module\nextracts all of the original message\u2019s header lines, and a single string replace method\ncall does the work of adding the > quotes to the original message body. I simply type\nwhat I wish to say in reply (the initial paragraph in the mail\u2019s text area) and press the\nSend button to route the reply message to the mailbox on my mail server again. Phys-\nically sending the reply works the same as sending a brand-new message\u2014the mail is\nrouted to your SMTP server in a spawned send-mail thread, and the send-mail wait\npop up appears while the thread runs.\nForwarding a message is similar to replying: select the message in the main window,\npress the Fwd button, and fill in the fields and text area of the popped-up composition\nwindow. Figure 14-30 shows the window created to forward the mail we originally\nwrote and received after a bit of editing.\nFigure 14-30. PyMailGUI forward compose window\nMuch like replies, forwards fill From with the sender\u2019s address in mailconfig; the orig-\ninal text is automatically quoted in the message body again; Bcc is preset initially the\nsame as From; and the subject line is preset to the original message\u2019s subject prepended\nwith the string \u201cFwd:\u201d. All these lines can be changed manually before sending if you\nwish to tailor. I always have to fill in the To line manually, though, because a forward\nis not a direct reply\u2014it doesn\u2019t necessarily go back to the original sender. Further, the\n1046 | Chapter 14:\u2002The PyMailGUI ClientCc prefill of original recipients done by Reply isn\u2019t performed for forwards, because\nthey are not a continuation of group discussions.\nNotice that I\u2019m forwarding this message to three different addresses (two in the To,\nand one manually entered in the Bcc). I\u2019m also using full \u201cname <address>\u201d formats\nfor email addresses. Multiple recipient addresses are separated with a comma (,) in the\nTo, Cc, and Bcc header fields, and PyMailGUI is happy to use the full address form\nanywhere you type an address, including your own in mailconfig. As demonstrated by\nthe first To recipient in Figure 14-30, commas in address names don\u2019t clash with those\nthat separate recipients, because address lines are parsed fully in this version. When\nwe\u2019re ready, the Send button in this window fires the forwarded message off to all\naddresses listed in these headers, after removing any duplicates to avoid sending the\nsame recipient the same mail more than once.\nI\u2019ve now written a new message, replied to it, and forwarded it. The reply and forward\nwere sent to my email address, too; if we press the main window\u2019s Load button again,\nthe reply and forward messages should show up in the main window\u2019s list. In Fig-\nure 14-31, they appear as messages 15 and 16 (the order they appear in may depend\non timing issues at your server, and I\u2019ve stretched this horizontally in the GUI to try to\nreveal the To header of the last of these).\nFigure 14-31. PyMailGUI mail list after sends and load\nKeep in mind that PyMailGUI runs on the local computer, but the messages you see in\nthe main window\u2019s list actually live in a mailbox on your email server machine. Every\ntime we press Load, PyMailGUI downloads but does not delete newly arrived emails\u2019\nheaders from the server to your computer. The three messages we just wrote (14\nthrough 16) will also appear in any other email program you use on your account (e.g.,\nin Outlook or in a webmail interface). PyMailGUI does not automatically delete mes-\nsages as they are downloaded, but simply stores them in your computer\u2019s memory for\nprocessing. If we now select message 16 and press View, we see the forward message\nwe sent, as in Figure 14-32.\nA PyMailGUI Demo | 1047This message went from my machine to a remote email server and was downloaded\nfrom there into a Python list from which it is displayed. In fact, it went to three different\nemail accounts I have (the other two appear later in this demo\u2014see Figure 14-45). The\nthird recipient doesn\u2019t appear in Figure 14-32 here because it was a Bcc blind-copy\u2014\nit receives the message, but no header line is added to the mail itself.\nFigure 14-32. PyMailGUI view forwarded mail\nFigure 14-33 shows what the forward message\u2019s raw text looks like; again, double-click\non a main window\u2019s entry to display this form. The formatted display in Fig-\nure 14-32 simply extracts bits and pieces out of the text shown in the raw display form.\nOne last pointer on replies and forwards: as mentioned, replies in this version reply to\nall original recipients, assuming that more than one means that this is a continuation\nof a group discussion. To illustrate, Figure 14-34 shows an original message on top, a\nforward of it on the lower left, and a reply to it on the lower right. The Cc header in\nthe reply has been automatically prefilled with all the original recipients, less any du-\nplicates and the new sender\u2019s address; the Bcc (enabled here) has also been prefilled\nwith the sender in both. These are just initial settings which can be edited and removed\nprior to sends. Moreover, the Cc prefill for replies can be disabled entirely in the con-\nfiguration file. Without it, though, you may have to manually cut-and-paste to insert\n1048 | Chapter 14:\u2002The PyMailGUI Clientaddresses in group mail scenarios. Open this version\u2019s mail save file to view this mail\u2019s\nbehavior live, and see the suggested enhancements later for more ideas.\nDeleting Email\nSo far, we\u2019ve covered every action button on list windows except for Delete and the All\ncheckbox. The All checkbox simply toggles from selecting all messages at once or de-\nselecting all (View, Delete, Reply, Fwd, and Save action buttons apply to all currently\nselected messages). PyMailGUI also lets us delete messages from the server perma-\nnently, so that we won\u2019t see them the next time we access our inbox.\nDelete operations are kicked off the same way as Views and Saves; just press the Delete\nbutton instead. In typical operation, I eventually delete email I\u2019m not interested in, and\nsave and delete emails that are important. We met Save earlier in this demo.\nLike View, Save, and other operations, Delete can be applied to one or more messages.\nDeletes happen immediately, and like all server transfers, they are run in a nonblocking\nthread but are performed only if you verify the operation in a pop up, such as the one\nshown in Figure 14-35. During the delete, a progress dialog like those in Figures 14-8\nand 14-9 provide status.\nFigure 14-33. PyMailGUI view forwarded mail, raw\nA PyMailGUI Demo | 1049Figure 14-35. PyMailGUI delete verification on quit\nBy design, no mail is ever removed automatically: you will see the same messages the\nnext time PyMailGUI runs. It deletes mail from your server only when you ask it to,\nand then only if verified in the last pop up shown (this is your last chance to prevent\npermanent mail removal). After the deletions are performed, the mail index is updated,\nand the GUI session continues.\nDeletions disable mail loads and other deletes while running and cannot be run in\nparallel with loads or other deletes already in progress because they may change POP\nmessage numbers and thus modify the mail index list (they may also modify the email\nFigure 14-34. Reply-to-all Cc prefills\n1050 | Chapter 14:\u2002The PyMailGUI Clientcache). Messages may still be composed during a deletion, however, and offline save\nfiles may be processed.\nPOP Message Numbers and Synchronization\nBy now, we\u2019ve seen all the basic functionality of PyMailGUI\u2014enough to get you started\nsending and receiving simple but typical text-based messages. In the rest of this demo,\nwe\u2019re going to turn our attention to some of the deeper concepts in this system, in-\ncluding inbox synchronization, HTML mails, Internationalization, and multiple ac-\ncount configuration. Since the first of these is related to the preceding section\u2019s tour of\nmail deletions, let\u2019s begin here.\nThough they might seem simple from an end-user perspective, it turns out that deletions\nare complicated by POP\u2019s message-numbering scheme. We learned about the potential\nfor synchronization errors between the server\u2019s inbox and the fetched email list in\nChapter 13, when studying the mailtools package PyMailGUI uses (near Exam-\nple 13-24). In brief, POP assigns each message a relative sequential number, starting\nfrom one, and these numbers are passed to the server to fetch and delete messages. The\nserver\u2019s inbox is normally locked while a connection is held so that a series of deletions\ncan be run as an atomic operation; no other inbox changes occur until the connection\nis closed.\nHowever, message number changes also have some implications for the GUI itself. It\u2019s\nnever an issue if new mail arrives while we\u2019re displaying the result of a prior download\u2014\nthe new mail is assigned higher numbers, beyond what is displayed on the client. But\nif we delete a message in the middle of a mailbox after the index has been loaded from\nthe mail server, the numbers of all messages after the one deleted change (they are\ndecremented by one). As a result, some message numbers might no longer be valid if\ndeletions are made while viewing previously loaded email.\nTo work around this, PyMailGUI adjusts all the displayed numbers after a Delete by\nsimply removing the entries for deleted mails from its index list and mail cache. How-\never, this adjustment is not enough to keep the GUI in sync with the server\u2019s inbox if\nthe inbox is modified at a position other than after the end, by deletions in another\nemail client (even in another PyMailGUI session), or by deletions performed by the\nmail server itself (e.g., messages determined to be undeliverable and automatically re-\nmoved from the inbox). Such modifications outside PyMailGUI\u2019s scope are uncom-\nmon, but not impossible.\nTo handle these cases, PyMailGUI uses the safe deletion and synchronization tests in\nmailtools. That module uses mail header matching to detect mail list and server inbox\nsynchronization errors. For instance, if another email client has deleted a message prior\nto the one to be deleted by PyMailGUI, mailtools catches the problem and cancels the\ndeletion, and an error pop up like the one in Figure 14-36 is displayed.\nA PyMailGUI Demo | 1051Figure 14-36. Safe deletion test detection of inbox difference\nSimilarly, both index list loads and individual message fetches run a synchronization\ntest in mailtools, as well. Figure 14-37 captures the error generated on a fetch if a\nmessage has been deleted in another client since we last loaded the server index win-\ndow. The same error is issued when this occurs during a load operation, but the first\nline reads \u201cLoad failed.\u201d\nFigure 14-37. Synchronization error after delete in another client\n1052 | Chapter 14:\u2002The PyMailGUI ClientIn both synchronization error cases, the mail list is automatically reloaded with the new\ninbox content by PyMailGUI immediately after the error pop up is dismissed. This\nscheme ensures that PyMailGUI won\u2019t delete or display the wrong message, in the rare\ncase that the server\u2019s inbox is changed without its knowledge. See mailtools in Chap-\nter 13 for more on synchronization tests; these errors are detected and raised in mail\ntools, but triggered by calls made in the mail cache manager here.\nHandling HTML Content in Email\nUp to this point, we\u2019ve seen PyMailGUI\u2019s basic operation in the context of plain-text\nemails. We\u2019ve also seen it handling HTML part attachments, but not the main text of\nHTML messages. Today, of course, HTML is common for mail content too. Because\nthe PyEdit mail display deployed by PyMailGUI uses a tkinter Text widget oriented\ntoward plain text, HTML content is handled specially:\n\u2022 For text/HTML alternative mails, PyMailGUI displays the plain text part in its view\nwindow and includes a button for opening the HTML rendition in a web browser\non demand.\n\u2022 For HTML-only mails, the main text area shows plain text extracted from the\nHTML by a simple parser (not the raw HTML), and the HTML is also displayed\nin a web browser automatically.\nIn all cases, the web browser\u2019s display of International character set content in the\nHTML depends upon encoding information in tags in the HTML, guesses, or user\nfeedback. Well-formed HTML parts already have \u201c<meta>\u201d tags in their \u201c<head>\u201d\nsections which give the HTML\u2019s encoding, but they may be absent or incorrect. We\u2019ll\nlearn more about Internationalization support in the next section.\nFigure 14-38 gives the scene when a text/HTML alternative mail is viewed, and Fig-\nure 14-39 shows what happens when an HTML-only email is viewed. The web browser\nin Figure 14-38 was opened by clicking the HTML part\u2019s button; this is no different\nthan the HTML attachment example we saw earlier.\nFor HTML-only messages, though, behavior is new here: the view window on the left\nin Figure 14-39 reflects the results of extracting plain text from the HTML shown in\nthe popped-up web browser behind it. The HTML parser used for this is something of\na first-cut prototype, but any result it can give is an improvement on displaying raw\nHTML in the view window for HTML-only mails. For simpler HTML mails of the sort\nsent by individuals instead of those sent by mass-mailing companies (like those shown\nhere), the results are generally good in tests run to date, though time will tell how this\nprototype parser fares in today\u2019s unforgiving HTML jungle of nonstandard and non-\nconforming code\u2014improve as desired.\nA PyMailGUI Demo | 1053Figure 14-39. Viewing HTML-only mails\nFigure 14-38. Viewing text/HTML alternative mails\n1054 | Chapter 14:\u2002The PyMailGUI ClientOne caveat here: PyMailGUI can today display HTML in a web browser and extract\nplain text from it, but it cannot display HTML directly in its own window and has no\nsupport for editing it specially. These are enhancements that will have to await further\nattention by other programmers who may find them useful.\nMail Content Internationalization Support\nOur next advanced feature is something of an inevitable consequence of the Internet\u2019s\nsuccess. As described earlier when summarizing version 3.0 changes, PyMailGUI fully\nsupports International character sets in mail content\u2014both text part payloads and\nemail headers are decoded for display and encoded when sent, according to email,\nMIME, and Unicode standards. This may be the most significant change in this version\nof the program. Regrettably, capturing this in screenshots is a bit of a challenge and\nyou can get a better feel for how this pans out by running an Open on the following\nincluded mail save file, viewing its messages in formatted and raw modes, starting\nreplies and forwards for them, and so on:\nC:\\...\\PP4E\\Internet\\Email\\PyMailGui\\SavedMail\\i18n-4E\nTo sample the flavor of this support here, Figure 14-40 shows the scene when this file\nis opened, shown for variety here with one of the alternate account configurations\ndescribed the next section. This figure\u2019s index list window and mail view windows\ncapture Russian and Chinese language messages sent to my email account (these were\nunsolicited email of no particular significance, but suffice as reasonable test cases).\nNotice how both message headers and text payload parts are decoded for display in\nboth the mail list window and the mail view windows.\nFigure 14-41 shows portions of the raw text of the two fetched messages, obtained by\ndouble-clicking their list entries (you can open these mails from the save file listed earlier\nif you have trouble seeing their details as shown in this book). Notice how the body\ntext is encoded per both MIME and Unicode conventions\u2014the headers at the top and\ntext at the bottom of these windows show the actual Base64 and quoted-printable\nstrings that must be decoded to achieve the nicely displayed output in Figure 14-40.\nFor the text parts, the information in the part\u2019s header describes its content\u2019s encoding\nschemes. For instance, charset=\"gb2312\" in the content type header identifies a Chinese\nUnicode character set, and the transfer encoding header gives the part\u2019s MIME encod-\ning type (e.g. base64).\nThe headers are encoded per i18n standards here as well\u2014their content self-describes\ntheir MIME and Unicode encodings. For example, the header prefix =?koi8-r?B means\nRussian text, Base64 encoded. PyMailGUI is clever enough to decode both full headers\nand the name fields of addresses for display, whether they are completely encoded (as\nshown here) or contain just encoded substrings (as shown by other saved mails in the\nversion30-4E file in this example\u2019s SavedMail directory).\nA PyMailGUI Demo | 1055Figure 14-41. Raw text of fetched Internationalized mails, headers and body encoded\nAs additional context, Figure 14-42 shows how these messages\u2019 main parts appear when\nopened via their part buttons. Their content is saved as raw post-MIME bytes in binary\nmode, but the PyEdit pop ups decode according to passed-in encoding names obtained\nFigure 14-40. Internationalization support, headers and body decoded for display\n1056 | Chapter 14:\u2002The PyMailGUI Clientfrom the raw message headers. As we learned in Chapters 9 and 11, the underlying\ntkinter toolkit generally renders decoded str better than raw bytes.\nSo far, we\u2019ve displayed Internationalized emails, but PyMailGUI allows us to send them\nas well, and handles any encoding tasks implied by the text content. Figure 14-43 shows\nthe result of running replies and forwards to the Russian language email, with the To\naddress changed to protect the innocent. Headers in the view window were decoded\nfor display, encoded when sent, and decoded back again for display; text parts in the\nmail body were similarly decoded, encoded, and re-decoded along the way and headers\nare also decoded within the \u201c>\u201d quoted original text inserted at the end of the message.\nAnd finally, Figure 14-44 shows a portion of the raw text of the Russian language reply\nmessage that appears in the lower right of the formatted view of Figure 14-43. Again,\ndouble-click to see these details live. Notice how both headers and body text have been\nencoded per email and MIME standards.\nAs configured, the body text is always MIME encoded to UTF-8 when sent if it fails to\nencode as ASCII, the default setting in the mailconfig module. Other defaults can be\nused if desired and will be encoded appropriately for sends; in fact, text that won\u2019t work\nin the full text of email is MIME encoded the same way as binary parts such as images.\nThis is also true for non-Internationalized character sets\u2014the text part of a message\nwritten in English with any non-ASCII quotes, for example, will be UTF-8 and Base64\nencoded in the same way as the message in Figure 14-44, and assume that the recipient\u2019s\nemail reader will decode (any reasonable modern email client will). This allows non-\nASCII text to be embedded in the full email text sent.\nFigure 14-42. Main text parts of Internationalized mails, decoded in PyEdit pop-ups\nA PyMailGUI Demo | 1057Message headers are similarly encoded per UTF-8 if they are non-ASCII when sent, so \nthey will work in the full email text. In fact, if you study this closely you\u2019ll find that the \nSubject here was originally encoded per a Russian Unicode scheme but is UTF-8 now\u2014 \nits new representation yields the same characters (code points) when decoded for \ndisplay.\nIn short, although the GUI itself is still in English (its labels and the like), the content \nof emails displayed and sent support arbitrary character sets. Decoding for display is \ndone per content where possible, using message headers for text payloads and content \nfor headers. Encoding for sends is performed according to user settings and policies, \nusing user settings or inputs, or a UTF-8 default. Required MIME and email header \nencodings are implemented in a largely automatic fashion by the underlying email\npackage.\nNot shown here are the pop-up dialogs that may be issued to prompt for text part \nencoding preferences on sends if so configured in mailconfig, and PyEdit\u2019s similar \nprompts under certain user configurations. Some of these user configurations are meant \nfor illustration and generality; the presets seem to work well for most scenarios I\u2019ve run \ninto, but your International mileage may vary. For more details, experiment with the \nfile\u2019s messages on your own and see the system\u2019s source code.\nFigure 14-43. Result of reply and forward with International character sets, re-decoded\n1058 | Chapter 14:\u2002The PyMailGUI ClientAlternative Configurations and Accounts\nSo far, we\u2019ve mostly seen PyMailGUI being run on an email account I created for this\nbook\u2019s examples, but it\u2019s easy to tailor its mailconfig module for different accounts, as\nwell as different visual effects. For example, Figure 14-45 captures the scene with Py-\nMailGUI being run on three different email accounts I use for books and training. All\nthree instances are run in independent processes here. Each main list window is dis-\nplaying a different email account\u2019s messages, and each customizes appearance or be-\nhavior in some fashion. The message view window at the top, opened from the server\nlist window in the lower left also applies custom color and displayed headers schemes.\nYou can always change mailconfigs in-place for a specific account if you use just one,\nbut we\u2019ll later see how the altconfigs subdirectory applies one possible solution to\nallow configuring for multiple accounts such as these, completely external to the orig-\ninal source code. The altconfigs option renders the windows in Figure 14-45, and\nsuffices as my launching interface; see its code ahead.\nFigure 14-44. Raw text of sent Russian reply, headers and body re-encoded\nA PyMailGUI Demo | 1059Multiple Windows and Status Messages\nFinally, PyMailGUI is really meant to be a multiple-window interface\u2014a detail that\nmost of the earlier screenshots haven\u2019t really done justice to. For example, Fig-\nure 14-46 shows PyMailGUI with the main server list window, two save-file list win-\ndows, two message view windows, and help. All these windows are nonmodal; that is,\nthey are all active and independent, and do not block other windows from being se-\nlected, even though they are all running a single PyMailGUI process.\nIn general, you can have any number of mail view or compose windows up at once,\nand cut and paste between them. This matters, because PyMailGUI must take care to\nmake sure that each window has a distinct text-editor object. If the text-editor object\nwere a global, or used globals internally, you\u2019d likely see the same text in each window\n(and the Send operations might wind up sending text from another window). To avoid\nthis, PyMailGUI creates and attaches a new TextEditor instance to each view and com-\npose window it creates, and associates the new editor with the Send button\u2019s callback\nhandler to make sure we get the right text. This is just the usual OOP state retention,\nbut it acquires a tangible benefit here.\nThough not GUI-related, PyMailGUI also prints a variety of status messages as it runs,\nbut you see them only if you launch the program from the system command-line console\nwindow (e.g., a DOS box on Windows or an xterm on Linux) or by double-clicking on\nits filename icon (its main script is a .py, not a .pyw). On Windows, you won\u2019t see these\nFigure 14-45. Alternative accounts and configurations\n1060 | Chapter 14:\u2002The PyMailGUI Clientmessages when PyMailGUI is started from another program, such as the PyDemos or\nPyGadgets launcher bar GUIs. These status messages print server information; show\nmail loading status; and trace the load, store, and delete threads that are spawned along\nthe way. If you want PyMailGUI to be more verbose, launch it from a command line\nand watch:\nC:\\...\\PP4E\\Internet\\Email\\PyMailGui> PyMailGui.py\nuser: PP4E@learning-python.com\nloading headers\nConnecting...\nb'+OK <24715.1275632750@pop05.mesa1.secureserver.net>'\nload headers exit\nsynch check\nConnecting...\nb'+OK <26056.1275632770@pop19.prod.mesa1.secureserver.net>'\nSame headers text\nloading headers\nConnecting...\nb'+OK <18798.1275632771@pop04.mesa1.secureserver.net>'\nload headers exit\nsynch check\nConnecting...\nb'+OK <28403.1275632790@pop19.prod.mesa1.secureserver.net>'\nSame headers text\nload 16\nConnecting...\nb'+OK <28472.1275632791@pop19.prod.mesa1.secureserver.net>'\nSending to...['lutz@rmi.net', 'PP4E@learning-python.com']\nFigure 14-46. PyMailGUI multiple windows and text editors\nA PyMailGUI Demo | 1061MIME-Version: 1.0\nContent-Type: text/plain; charset=\"us-ascii\"\nContent-Transfer-Encoding: 7bit\nFrom: PP4E@learning-python.com\nTo: lutz@rmi.net\nSubject: Already got one...\nDate: Fri, 04 Jun 2010 06:30:26 \u22120000\nX-Mailer: PyMailGUI 3.0 (Python)\n> -----Origin\nSend exit\nYou can also double-click on the PyMailGui.py filename in your file explorer GUI and\nmonitor the popped-up DOS console box on Windows. Console messages are mostly\nintended for debugging, but they can be used to help understand the system\u2019s operation\nas well.\nFor more details on using PyMailGUI, see its help display (press the help bar at the top\nof its main server list windows), or read the help string in the module PyMailGui\nHelp.py, described in the next section.\nPyMailGUI Implementation\nLast but not least, we get to the code. PyMailGUI consists of the new modules listed\nnear the start of this chapter, along with a handful of peripheral files described there.\nThe source code for these modules is listed in this section. Before we get started, here\nare two quick reminders to help you study:\nCode reuse\nBesides the code here, PyMailGUI also gets a lot of mileage out of reusing modules\nwe wrote earlier and won\u2019t repeat here: mailtools for mail loads, composition,\nparsing, and delete operations; threadtools for managing server and local file ac-\ncess threads; the GUI section\u2019s TextEditor for displaying and editing mail message\ntext; and so on. See the example numbers list earlier in this chapter.\nIn addition, standard Python modules and packages such as poplib, smtplib, and\nemail hide most of the details of pushing bytes around the Net and extracting and\nbuilding message components. As usual, the tkinter standard library module also\nimplements GUI components in a portable fashion.\nCode structure\nAs mentioned earlier, PyMailGUI applies code factoring and OOP to leverage code\nreuse. For instance, list view windows are implemented as a common superclass\nthat codes most actions, along with one subclass for the server inbox list window\nand one for local save-file list windows. The subclasses customize the common\nsuperclass for their specific mail media.\nThis design reflects the operation of the GUI itself\u2014server list windows load mail\nover POP, and save-file list windows load from local files. The basic operation of\n1062 | Chapter 14:\u2002The PyMailGUI Clientlist window layout and actions, though, is similar for both and is shared in the\ncommon superclass to avoid redundancy and simplify the code. Message view\nwindows are similarly factored: a common view window superclass is reused and\ncustomized for write, reply, and forward view windows.\nTo make the code easier to follow, it is divided into two main modules that reflect\nthe structure of the GUI\u2014one for the implementation of list window actions and\none for view window actions. If you are looking for the implementation of a button\nthat appears in a mail view or edit window, for instance, see the view window\nmodule and search for a method whose name begins with the word on\u2014the con-\nvention used for callback handler methods. A specific button\u2019s text can also be\nlocated in name/callback tables used to build the windows. Actions initiated on\nlist windows are coded in the list window module instead.\nIn addition, the message cache is split off into an object and module of its own,\nand potentially reusable tools are coded in importable modules (e.g., line wrapping\nand utility pop ups). PyMailGUI also includes a main module that defines startup\nwindow classes, a simple HTML to plain-text parser, a module that contains the\nhelp text as a string, the mailconfig user settings module (a version specific to\nPyMailGUI is used here), and a small handful of related files.\nThe following subsections present each of PyMailGUI\u2019s source code files for you to\nstudy. As you read, refer back to the demo earlier in this chapter and run the program\nlive to map its behavior back to its code.\nOne accounting note up-front: the only one of PyMailGUI\u2019s 18 new source files not\nlisted in this section is its __init__.py package initialization file. This file is mostly\nempty except for a comment string and is unused in the system today. It exists only for\nfuture expansion, in case PyMailGUI is ever used as a package in the future\u2014some of\nits modules may be useful in other programs. As is, though, same-directory internal\nimports here are not package-relative, so they assume this system is either run as a top-\nlevel program (to import from \u201c.\u201d) or is listed on sys.path directly (to use absolute\nimports). In Python 3.X, a package\u2019s directory is not included on sys.path automati-\ncally, so future use as a package would require changes to internal imports (e.g., moving\nthe main script up one level and using from . import module throughout). See resources\nsuch as the book Learning Python for more on packages and package imports.\nPyMailGUI: The Main Module\nExample 14-1 defines the file run to start PyMailGUI. It implements top-level list win-\ndows in the system\u2014combinations of PyMailGUI\u2019s application logic and the window\nprotocol superclasses we wrote earlier in the text. The latter of these define window\ntitles, icons, and close behavior.\nThe main internal, nonuser documentation is also in this module, as well as command-\nline logic\u2014the program accepts the names of one or more save-mail files on the\nPyMailGUI Implementation | 1063command line, and automatically opens them when the GUI starts up. This is used by\nthe PyDemos launcher of Chapter 10, for example.\nExample 14-1. PP4E\\Internet\\Email\\PyMailGui\\PyMailGui.py\n\"\"\"\n##################################################################################\nPyMailGui 3.0 - A Python/tkinter email client.\nA client-side tkinter-based GUI interface for sending and receiving email.\nSee the help string in PyMailGuiHelp.py for usage details, and a list of\nenhancements in this version.\nVersion 2.0 was a major, complete rewrite.  The changes from 2.0 (July '05)\nto 2.1 (Jan '06) were quick-access part buttons on View windows, threaded\nloads and deletes of local save-mail files, and checks for and recovery from\nmessage numbers out-of-synch with mail server inbox on deletes, index loads,\nand message loads.\nVersion 3.0 (4E) is a port to Python 3.X; uses grids instead of packed column\nframes for better form layout of headers in view windows; runs update() after\ninserting into a new text editor for accurate line positioning (see PyEdit\nloadFirst changes in Chapter 11); provides an HTML-based version of its help\ntext; extracts plain-text from HTML main/only parts for display and quoting;\nsupports separators in toolbars; addresses both message content and header\nUnicode/I18N encodings for fetched, sent, and saved mails (see Ch13 and Ch14);\nand much more (see Ch14 for the full rundown on 3.0 upgrades); fetched message\ndecoding happens deep in the mailtools package, on mail cache load operations\nhere; mailtools also fixes a few email package bugs (see Ch13);\nThis file implements the top-level windows and interface.  PyMailGui uses a\nnumber of modules that know nothing about this GUI, but perform related tasks,\nsome of which are developed in other sections of the book.  The mailconfig\nmodule is expanded for this program.\n==Modules defined elsewhere and reused here:==\nmailtools (package)\n    client-side scripting chapter\n    server sends and receives, parsing, construction     (Example 13-21+)\nthreadtools.py\n    GUI tools chapter\n    thread queue manangement for GUI callbacks           (Example 10-20)\nwindows.py\n    GUI tools chapter\n    border configuration for top-level windows           (Example 10-16)\ntextEditor.py\n    GUI programs chapter\n    text widget used in mail view windows, some pop ups  (Example 11-4)\n==Generally useful modules defined here:==\npopuputil.py\n    help and busy windows, for general use\nmessagecache.py\n1064 | Chapter 14:\u2002The PyMailGUI Clienta cache that keeps track of mail already loaded\nwraplines.py\n    utility for wrapping long lines of messages\nhtml2text.py\n    rudimentary HTML parser for extracting plain text\nmailconfig.py\n    user configuration parameters: server names, fonts, etc.\n==Program-specific modules defined here:==\nSharedNames.py\n    objects shared between window classes and main file\nViewWindows.py\n    implementation of view, write, reply, forward windows\nListWindows.py\n    implementation of mail-server and local-file list windows\nPyMailGuiHelp.py (see also PyMailGuiHelp.html)\n    user-visible help text, opened by main window bar\nPyMailGui.py\n    main, top-level file (run this), with main window types\n##################################################################################\n\"\"\"\nimport mailconfig, sys\nfrom SharedNames import appname, windows\nfrom ListWindows import PyMailServer, PyMailFile\n###############################################################################\n# top-level window classes\n#\n# View, Write, Reply, Forward, Help, BusyBox all inherit from PopupWindow\n# directly: only usage;  askpassword calls PopupWindow and attaches;  the\n# order matters here!--PyMail classes redef some method defaults in the\n# Window classes, like destroy and okayToExit: must be leftmost;  to use\n# PyMailFileWindow standalone, imitate logic in PyMailCommon.onOpenMailFile;\n###############################################################################\n# uses icon file in cwd or default in tools dir\nsrvrname = mailconfig.popservername or 'Server'\nclass PyMailServerWindow(PyMailServer, windows.MainWindow):\n    \"a Tk, with extra protocol and mixed-in methods\"\n    def __init__(self):\n        windows.MainWindow.__init__(self, appname, srvrname)\n        PyMailServer.__init__(self)\nclass PyMailServerPopup(PyMailServer, windows.PopupWindow):\n    \"a Toplevel, with extra protocol and mixed-in methods\"\n    def __init__(self):\n        windows.PopupWindow.__init__(self, appname, srvrnane)\n        PyMailServer.__init__(self)\nclass PyMailServerComponent(PyMailServer, windows.ComponentWindow):\n    \"a Frame, with extra protocol and mixed-in methods\"\nPyMailGUI Implementation | 1065def __init__(self):\n        windows.ComponentWindow.__init__(self)\n        PyMailServer.__init__(self)\nclass PyMailFileWindow(PyMailFile, windows.PopupWindow):\n    \"a Toplevel, with extra protocol and mixed-in methods\"\n    def __init__(self, filename):\n        windows.PopupWindow.__init__(self, appname, filename)\n        PyMailFile.__init__(self, filename)\n###############################################################################\n# when run as a top-level program: create main mail-server list window\n###############################################################################\nif __name__ == '__main__':\n    rootwin = PyMailServerWindow()              # open server window\n    if len(sys.argv) > 1:                       # 3.0: fix to add len()\n        for savename in sys.argv[1:]:\n            rootwin.onOpenMailFile(savename)    # open save file windows (demo)\n        rootwin.lift()                          # save files loaded in threads\n    rootwin.mainloop()\nSharedNames: Program-Wide Globals\nThe module in Example 14-2 implements a shared, system-wide namespace that col-\nlects resources used in most modules in the system and defines global objects that span\nfiles. This allows other files to avoid redundantly repeating common imports and en-\ncapsulates the locations of package imports; it is the only file that must be updated if\npaths change in the future. Using globals can make programs more difficult to under-\nstand in general (the source of some names is not as clear), but it is reasonable if all\nsuch names are collected in a single expected module such as this one, because there\nis only one place to search for unknown names.\nExample 14-2. PP4E\\Internet\\Email\\PyMailGui\\SharedNames.py\n\"\"\"\n##############################################################################\nobjects shared by all window classes and main file: program-wide globals\n##############################################################################\n\"\"\"\n# used in all window, icon titles\nappname  = 'PyMailGUI 3.0'\n# used for list save, open, delete; also for sent messages file\nsaveMailSeparator = 'PyMailGUI' + ('-'*60) + 'PyMailGUI\\n'\n# currently viewed mail save files; also for sent-mail file\nopenSaveFiles = {}                     # 1 window per file,{name:win}\n# standard library services\nimport sys, os, email.utils, email.message, webbrowser, mimetypes\n1066 | Chapter 14:\u2002The PyMailGUI Clientfrom tkinter import *\nfrom tkinter.simpledialog import askstring\nfrom tkinter.filedialog   import SaveAs, Open, Directory\nfrom tkinter.messagebox   import showinfo, showerror, askyesno\n# reuse book examples\nfrom PP4E.Gui.Tools      import windows      # window border, exit protocols\nfrom PP4E.Gui.Tools      import threadtools  # thread callback queue checker\nfrom PP4E.Internet.Email import mailtools    # load,send,parse,build utilities\nfrom PP4E.Gui.TextEditor import textEditor   # component and pop up\n# modules defined here\nimport mailconfig                            # user params: servers, fonts, etc.\nimport popuputil                             # help, busy, passwd pop-up windows\nimport wraplines                             # wrap long message lines\nimport messagecache                          # remember already loaded mail\nimport html2text                             # simplistic html->plaintext extract\nimport PyMailGuiHelp                         # user documentation\ndef printStack(exc_info):\n    \"\"\"\n    debugging: show exception and stack traceback on stdout;\n    3.0: change to print stack trace to a real log file if print\n    to sys.stdout fails: it does when launched from another program\n    on Windows;  without this workaround, PMailGUI aborts and exits\n    altogether, as this is called from the main thread on spawned\n    thread failures;  likely a Python 3.1 bug: it doesn't occur in\n    2.5 or 2.6, and the traceback object works fine if print to file;\n    oddly, the print() calls here work (but go nowhere) if spawned;\n    \"\"\"\n    print(exc_info[0])\n    print(exc_info[1])\n    import traceback\n    try:\n        traceback.print_tb(exc_info[2], file=sys.stdout)   # ok unless spawned!\n    except:\n        log = open('_pymailerrlog.txt', 'a')               # use a real file\n        log.write('-'*80)                                  # else gui may exit\n        traceback.print_tb(exc_info[2], file=log)          # in 3.X, not 2.5/6\n# thread busy counters for threads run by this GUI\n# sendingBusy shared by all send windows, used by main window quit\nloadingHdrsBusy = threadtools.ThreadCounter()   # only 1\ndeletingBusy    = threadtools.ThreadCounter()   # only 1\nloadingMsgsBusy = threadtools.ThreadCounter()   # poss many\nsendingBusy     = threadtools.ThreadCounter()   # poss many\nListWindows: Message List Windows\nThe code in Example 14-3 implements mail index list windows\u2014for the server inbox\nwindow and for one or more local save-mail file windows. These two types of windows\nlook and behave largely the same, and in fact share most of their code in common in a\nPyMailGUI Implementation | 1067superclass. The window subclasses mostly just customize the superclass to map mail\nLoad and Delete calls to the server or a local file.\nList windows are created on program startup (the initial server window, and possible\nsave-file windows for command-line options), as well as in response to Open button\nactions in existing list windows (for opening new save-file list windows). See the Open\nbutton\u2019s callback in this example for initiation code.\nNotice that the basic mail processing operations in the mailtools package from Chap-\nter 13 are mixed into PyMailGUI in a variety of ways. The list window classes in\nExample 14-3 inherit from the mailtools mail parser class, but the server list window\nclass embeds an instance of the message cache object, which in turn inherits from the\nmailtools mail fetcher. The mailtools mail sender class is inherited by message view\nwrite windows, not list windows; view windows also inherit from the mail parser.\nThis is a fairly large file; in principle it could be split into three files, one for each class,\nbut these classes are so closely related that it is handy to have their code in a single file\nfor edits. Really, this is one class, with two minor extensions.\nExample 14-3. PP4E\\Internet\\Email\\PyMailGui\\ListWindows.py\n\"\"\"\n###############################################################################\nImplementation of mail-server and save-file message list main windows:\none class per kind.  Code is factored here for reuse: server and file\nlist windows are customized versions of the PyMailCommon list window class;\nthe server window maps actions to mail transferred from a server, and the\nfile window applies actions to a local file.\nList windows create View, Write, Reply, and Forward windows on user actions.\nThe server list window is the main window opened on program startup by the\ntop-level file;  file list windows are opened on demand via server and file\nlist window \"Open\".  Msgnums may be temporarily out of sync with server if\nPOP inbox changes (triggers full reload here).\nChanges here in 2.1:\n-now checks on deletes and loads to see if msg nums in sync with server\n-added up to N attachment direct-access buttons on view windows\n-threaded save-mail file loads, to avoid N-second pause for big files\n-also threads save-mail file deletes so file write doesn't pause GUI\nTBD:\n-save-mail file saves still not threaded: may pause GUI briefly, but\n uncommon - unlike load and delete, save/send only appends the local file.\n-implementation of local save-mail files as text files with separators\n is mostly a prototype: it loads all full mails into memory, and so limits\n the practical size of these files; better alternative: use 2 DBM keyed\n access files for hdrs and fulltext, plus a list to map keys to position;\n in this scheme save-mail files become directories, no longer readable.\n###############################################################################\n\"\"\"\nfrom SharedNames import *     # program-wide global objects\n1068 | Chapter 14:\u2002The PyMailGUI Clientfrom ViewWindows import ViewWindow, WriteWindow, ReplyWindow, ForwardWindow\n###############################################################################\n# main frame - general structure for both file and server message lists\n###############################################################################\nclass PyMailCommon(mailtools.MailParser):\n    \"\"\"\n    an abstract widget package, with main mail listbox;\n    mixed in with a Tk, Toplevel, or Frame by top-level window classes;\n    must be customized in mode-specific subclass with actions() and other;\n    creates view and write windows on demand: they serve as MailSenders;\n    \"\"\"\n    # class attrs shared by all list windows\n    threadLoopStarted = False                     # started by first window\n    queueChecksPerSecond = 20                     # tweak if CPU use too high\n    queueDelay = 1000 // queueChecksPerSecond     # min msecs between timer events\n    queueBatch = 5                                # max callbacks per timer event\n    # all windows use same dialogs: remember last dirs\n    openDialog = Open(title=appname + ': Open Mail File')\n    saveDialog = SaveAs(title=appname + ': Append Mail File')\n    # 3.0: avoid downloading (fetching) same message in parallel\n    beingFetched = set()\n    def __init__(self):\n        self.makeWidgets()                        # draw my contents: list,tools\n        if not PyMailCommon.threadLoopStarted:\n            # start thread exit check loop\n            # a timer event loop that dispatches queued GUI callbacks;\n            # just one loop for all windows: server,file,views can all thread;\n            # self is a Tk, Toplevel,or Frame: any widget type will suffice;\n            # 3.0/4E: added queue delay/batch for progress speedup: ~100x/sec;\n            PyMailCommon.threadLoopStarted = True\n            threadtools.threadChecker(self, self.queueDelay, self.queueBatch)\n    def makeWidgets(self):\n        # add all/none checkbtn at bottom\n        tools = Frame(self, relief=SUNKEN, bd=2, cursor='hand2')    # 3.0: configs\n        tools.pack(side=BOTTOM, fill=X)\n        self.allModeVar = IntVar()\n        chk = Checkbutton(tools, text=\"All\")\n        chk.config(variable=self.allModeVar, command=self.onCheckAll)\n        chk.pack(side=RIGHT)\n        # add main buttons at bottom toolbar\n        for (title, callback) in self.actions():\n            if not callback:\n                sep = Label(tools, text=title)                # 3.0: separator\n                sep.pack(side=LEFT, expand=YES, fill=BOTH)    # expands with window\nPyMailGUI Implementation | 1069else:\n                Button(tools, text=title, command=callback).pack(side=LEFT)\n        # add multiselect listbox with scrollbars\n        listwide = mailconfig.listWidth  or 74    # 3.0: config start size\n        listhigh = mailconfig.listHeight or 15    # wide=chars, high=lines\n        mails    = Frame(self)\n        vscroll  = Scrollbar(mails)\n        hscroll  = Scrollbar(mails, orient='horizontal')\n        fontsz   = (sys.platform[:3] == 'win' and 8) or 10      # defaults\n        listbg   = mailconfig.listbg   or 'white'\n        listfg   = mailconfig.listfg   or 'black'\n        listfont = mailconfig.listfont or ('courier', fontsz, 'normal')\n        listbox  = Listbox(mails, bg=listbg, fg=listfg, font=listfont)\n        listbox.config(selectmode=EXTENDED)\n        listbox.config(width=listwide, height=listhigh) # 3.0: init wider\n        listbox.bind('<Double-1>', (lambda event: self.onViewRawMail()))\n        # crosslink listbox and scrollbars\n        vscroll.config(command=listbox.yview, relief=SUNKEN)\n        hscroll.config(command=listbox.xview, relief=SUNKEN)\n        listbox.config(yscrollcommand=vscroll.set, relief=SUNKEN)\n        listbox.config(xscrollcommand=hscroll.set)\n        # pack last = clip first\n        mails.pack(side=TOP, expand=YES, fill=BOTH)\n        vscroll.pack(side=RIGHT,  fill=BOTH)\n        hscroll.pack(side=BOTTOM, fill=BOTH)\n        listbox.pack(side=LEFT, expand=YES, fill=BOTH)\n        self.listBox = listbox\n    #################\n    # event handlers\n    #################\n    def onCheckAll(self):\n        # all or none click\n        if self.allModeVar.get():\n            self.listBox.select_set(0, END)\n        else:\n            self.listBox.select_clear(0, END)\n    def onViewRawMail(self):\n        # possibly threaded: view selected messages - raw text headers, body\n        msgnums = self.verifySelectedMsgs()\n        if msgnums:\n            self.getMessages(msgnums, after=lambda: self.contViewRaw(msgnums))\n    def contViewRaw(self, msgnums, pyedit=True):     # do we need full TextEditor?\n        for msgnum in msgnums:                       # could be a nested def\n            fulltext = self.getMessage(msgnum)       # fulltext is Unicode decoded\n            if not pyedit:\n                # display in a scrolledtext\n                from tkinter.scrolledtext import ScrolledText\n                window  = windows.QuietPopupWindow(appname, 'raw message viewer')\n1070 | Chapter 14:\u2002The PyMailGUI Clientbrowser = ScrolledText(window)\n                browser.insert('0.0', fulltext)\n                browser.pack(expand=YES, fill=BOTH)\n            else:\n                # 3.0/4E: more useful PyEdit text editor\n                wintitle = ' - raw message text'\n                browser = textEditor.TextEditorMainPopup(self, winTitle=wintitle)\n                browser.update()\n                browser.setAllText(fulltext)\n                browser.clearModified()\n    def onViewFormatMail(self):\n        \"\"\"\n        possibly threaded: view selected messages - pop up formatted display\n        not threaded if in savefile list, or messages are already loaded\n        the after action runs only if getMessages prefetch allowed and worked\n        \"\"\"\n        msgnums = self.verifySelectedMsgs()\n        if msgnums:\n            self.getMessages(msgnums, after=lambda: self.contViewFmt(msgnums))\n    def contViewFmt(self, msgnums):\n        \"\"\"\n        finish View: extract main text, popup view window(s) to display;\n        extracts plain text from html text if required, wraps text lines;\n        html mails: show extracted text, then save in temp file and open\n        in web browser;  part can also be opened manually from view window\n        Split or part button;  if non-multipart, other: part must be opened\n        manually with Split or part button;  verify html open per mailconfig;\n        3.0: for html-only mails, main text is str here, but save its raw\n        bytes in binary mode to finesse encodings;  worth the effort because\n        many mails are just html today;  this first tried N encoding guesses\n        (utf-8, latin-1, platform dflt), but now gets and saves raw bytes to\n        minimize any fidelity loss;  if a part is later opened on demand, it\n        is saved in a binary file as raw bytes in the same way;\n        caveat: the spawned web browser won't have any original email headers:\n        it may still have to guess or be told the encoding, unless the html\n        already has its own encoding headers (these take the form of <meta>\n        html tags within <head> sections if present; none are inserted in the\n        html here, as some well-formed html parts have them);  IE seems to\n        handle most html part files anyhow;  always encoding html parts to\n        utf-8 may suffice too: this encoding can handle most types of text;\n        \"\"\"\n        for msgnum in msgnums:\n            fulltext = self.getMessage(msgnum)             # 3.0: str for parser\n            message  = self.parseMessage(fulltext)\n            type, content = self.findMainText(message)     # 3.0: Unicode decoded\n            if type in ['text/html', 'text/xml']:          # 3.0: get plain text\n                content = html2text.html2text(content)\n            content  = wraplines.wrapText1(content, mailconfig.wrapsz)\n            ViewWindow(headermap   = message,\n                       showtext    = content,\n                       origmessage = message)              # 3.0: decodes headers\nPyMailGUI Implementation | 1071# non-multipart, content-type text/HTML (rude but true!)\n            if type == 'text/html':\n                if ((not mailconfig.verifyHTMLTextOpen) or\n                    askyesno(appname, 'Open message text in browser?')):\n                    # 3.0: get post mime decode, pre unicode decode bytes\n                    type, asbytes = self.findMainText(message, asStr=False)\n                    try:\n                        from tempfile import gettempdir # or a Tk HTML viewer?\n                        tempname = os.path.join(gettempdir(), 'pymailgui.html')\n                        tmp = open(tempname, 'wb')      # already encoded\n                        tmp.write(asbytes)\n                        webbrowser.open_new('file://' + tempname)\n                    except:\n                        showerror(appname, 'Cannot open in browser')\n    def onWriteMail(self):\n        \"\"\"\n        compose a new email from scratch, without fetching others;\n        nothing to quote here, but adds sig, and prefills Bcc with the\n        sender's address if this optional header enabled in mailconfig;\n        From may be i18N encoded in mailconfig: view window will decode;\n        \"\"\"\n        starttext = '\\n'                         # use auto signature text\n        if mailconfig.mysignature:\n            starttext += '%s\\n' % mailconfig.mysignature\n        From  = mailconfig.myaddress\n        WriteWindow(starttext = starttext,\n                    headermap = dict(From=From, Bcc=From))    # 3.0: prefill bcc\n    def onReplyMail(self):\n        # possibly threaded: reply to selected emails\n        msgnums = self.verifySelectedMsgs()\n        if msgnums:\n            self.getMessages(msgnums, after=lambda: self.contReply(msgnums))\n    def contReply(self, msgnums):\n        \"\"\"\n        finish Reply: drop attachments, quote with '>', add signature;\n        presets initial to/from values from mail or config module;\n        don't use original To for From: may be many or a listname;\n        To keeps name+<addr> format even if ',' separator in name;\n        Uses original From for To, ignores reply-to header is any;\n        3.0: replies also copy to all original recipients by default;\n        3.0: now uses getaddresses/parseaddr full parsing to separate\n        addrs on commas, and handle any commas that appear nested in\n        email name parts;  multiple addresses are separated by comma\n        in GUI, we copy comma separators when displaying headers, and\n        we use getaddresses to split addrs as needed;  ',' is required\n        by servers for separator;  no longer uses parseaddr to get 1st\n        name/addr pair of getaddresses result: use full From for To;\n        3.0: we decode the Subject header here because we need its text,\n1072 | Chapter 14:\u2002The PyMailGUI Clientbut the view window superclass of edit windows performs decoding\n        on all displayed headers (the extra Subject decode is a no-op);\n        on sends, all non-ASCII hdrs and hdr email names are in decoded\n        form in the GUI, but are encoded within the mailtools package;\n        quoteOrigText also decodes the initial headers it inserts into\n        the quoted text block, and index lists decode for display;\n        \"\"\"\n        for msgnum in msgnums:\n            fulltext = self.getMessage(msgnum)\n            message  = self.parseMessage(fulltext)         # may fail: error obj\n            maintext = self.formatQuotedMainText(message)  # same as forward\n            # from and to are decoded by view window\n            From = mailconfig.myaddress                    # not original To\n            To   = message.get('From', '')                 # 3.0: ',' sept\n            Cc   = self.replyCopyTo(message)               # 3.0: cc all recipients?\n            Subj = message.get('Subject', '(no subject)')\n            Subj = self.decodeHeader(Subj)                 # deocde for str\n            if Subj[:4].lower() != 're: ':                 # 3.0: unify case\n                Subj = 'Re: ' + Subj\n            ReplyWindow(starttext = maintext,\n                        headermap =\n                            dict(From=From, To=To, Cc=Cc, Subject=Subj, Bcc=From))\n    def onFwdMail(self):\n        # possibly threaded: forward selected emails\n        msgnums = self.verifySelectedMsgs()\n        if msgnums:\n            self.getMessages(msgnums, after=lambda: self.contFwd(msgnums))\n    def contFwd(self, msgnums):\n        \"\"\"\n        finish Forward: drop attachments, quote with '>', add signature;\n        see notes about headers decoding in the Reply action methods;\n        view window superclass will decode the From header we pass here;\n        \"\"\"\n        for msgnum in msgnums:\n            fulltext = self.getMessage(msgnum)\n            message  = self.parseMessage(fulltext)\n            maintext = self.formatQuotedMainText(message)  # same as reply\n            # initial From value from config, not mail\n            From = mailconfig.myaddress                    # encoded or not\n            Subj = message.get('Subject', '(no subject)')\n            Subj = self.decodeHeader(Subj)                 # 3.0: send encodes\n            if Subj[:5].lower() != 'fwd: ':                # 3.0: unify case\n                Subj = 'Fwd: ' + Subj\n            ForwardWindow(starttext = maintext,\n                          headermap = dict(From=From, Subject=Subj, Bcc=From))\n    def onSaveMailFile(self):\n        \"\"\"\n        save selected emails to file for offline viewing;\n        disabled if target file load/delete is in progress;\n        disabled by getMessages if self is a busy file too;\nPyMailGUI Implementation | 1073contSave not threaded: disables all other actions;\n        \"\"\"\n        msgnums = self.selectedMsgs()\n        if not msgnums:\n            showerror(appname, 'No message selected')\n        else:\n            # caveat: dialog warns about replacing file\n            filename = self.saveDialog.show()             # shared class attr\n            if filename:                                  # don't verify num msgs\n                filename = os.path.abspath(filename)      # normalize / to \\\n                self.getMessages(msgnums,\n                        after=lambda: self.contSave(msgnums, filename))\n    def contSave(self, msgnums, filename):\n        # test busy now, after poss srvr msgs load\n        if (filename in openSaveFiles.keys() and           # viewing this file?\n            openSaveFiles[filename].openFileBusy):         # load/del occurring?\n            showerror(appname, 'Target file busy - cannot save')\n        else:\n            try:                                           # caveat:not threaded\n                fulltextlist = []                          # 3.0: use encoding\n                mailfile = open(filename, 'a', encoding=mailconfig.fetchEncoding)\n                for msgnum in msgnums:                     # < 1sec for N megs\n                    fulltext = self.getMessage(msgnum)     # but poss many msgs\n                    if fulltext[-1] != '\\n': fulltext += '\\n'\n                    mailfile.write(saveMailSeparator)\n                    mailfile.write(fulltext)\n                    fulltextlist.append(fulltext)\n                mailfile.close()\n            except:\n                showerror(appname, 'Error during save')\n                printStack(sys.exc_info())\n            else:                                          # why .keys(): EIBTI\n                if filename in openSaveFiles.keys():       # viewing this file?\n                    window = openSaveFiles[filename]       # update list, raise\n                    window.addSavedMails(fulltextlist)     # avoid file reload\n                    #window.loadMailFileThread()           # this was very slow\n    def onOpenMailFile(self, filename=None):\n        # process saved mail offline\n        filename = filename or self.openDialog.show()      # shared class attr\n        if filename:\n            filename = os.path.abspath(filename)           # match on full name\n            if filename in openSaveFiles.keys():           # only 1 win per file\n                openSaveFiles[filename].lift()             # raise file's window\n                showinfo(appname, 'File already open')     # else deletes odd\n            else:\n                from PyMailGui import PyMailFileWindow     # avoid duplicate win\n                popup = PyMailFileWindow(filename)         # new list window\n                openSaveFiles[filename] = popup            # removed in quit\n                popup.loadMailFileThread()                 # try load in thread\n    def onDeleteMail(self):\n        # delete selected mails from server or file\n        msgnums = self.selectedMsgs()                      # subclass: fillIndex\n1074 | Chapter 14:\u2002The PyMailGUI Clientif not msgnums:                                    # always verify here\n            showerror(appname, 'No message selected')\n        else:\n            if askyesno(appname, 'Verify delete %d mails?' % len(msgnums)):\n                self.doDelete(msgnums)\n    ##################\n    # utility methods\n    ##################\n    def selectedMsgs(self):\n        # get messages selected in main listbox\n        selections = self.listBox.curselection()  # tuple of digit strs, 0..N-1\n        return [int(x)+1 for x in selections]     # convert to ints, make 1..N\n    warningLimit = 15\n    def verifySelectedMsgs(self):\n        msgnums = self.selectedMsgs()\n        if not msgnums:\n            showerror(appname, 'No message selected')\n        else:\n            numselects = len(msgnums)\n            if numselects > self.warningLimit:\n                if not askyesno(appname, 'Open %d selections?' % numselects):\n                    msgnums = []\n        return msgnums\n    def fillIndex(self, maxhdrsize=25):\n        \"\"\"\n        fill all of main listbox from message header mappings;\n        3.0: decode headers per email/mime/unicode here if encoded;\n        3.0: caveat: large chinese characters can break '|' alignment;\n        \"\"\"\n        hdrmaps  = self.headersMaps()                   # may be empty\n        showhdrs = ('Subject', 'From', 'Date', 'To')    # default hdrs to show\n        if hasattr(mailconfig, 'listheaders'):          # mailconfig customizes\n            showhdrs = mailconfig.listheaders or showhdrs\n        addrhdrs = ('From', 'To', 'Cc', 'Bcc')    # 3.0: decode i18n specially\n        # compute max field sizes <= hdrsize\n        maxsize = {}\n        for key in showhdrs:\n            allLens = []                                # too big for a list comp!\n            for msg in hdrmaps:\n                keyval = msg.get(key, ' ')\n                if key not in addrhdrs:\n                    allLens.append(len(self.decodeHeader(keyval)))\n                else:\n                    allLens.append(len(self.decodeAddrHeader(keyval)))\n            if not allLens: allLens = [1]\n            maxsize[key] = min(maxhdrsize, max(allLens))\n        # populate listbox with fixed-width left-justified fields\n        self.listBox.delete(0, END)                     # show multiparts with *\n        for (ix, msg) in enumerate(hdrmaps):            # via content-type hdr\nPyMailGUI Implementation | 1075msgtype = msg.get_content_maintype()        # no is_multipart yet\n            msgline = (msgtype == 'multipart' and '*') or ' '\n            msgline += '%03d' % (ix+1)\n            for key in showhdrs:\n                mysize  = maxsize[key]\n                if key not in addrhdrs:\n                    keytext = self.decodeHeader(msg.get(key, ' '))\n                else:\n                    keytext = self.decodeAddrHeader(msg.get(key, ' '))\n                msgline += ' | %-*s' % (mysize, keytext[:mysize])\n            msgline += '| %.1fK' % (self.mailSize(ix+1) / 1024)   # 3.0: .0 optional\n            self.listBox.insert(END, msgline)\n        self.listBox.see(END)         # show most recent mail=last line\n    def replyCopyTo(self, message):\n        \"\"\"\n        3.0: replies copy all original recipients, by prefilling\n        Cc header with all addreses in original To and Cc after\n        removing duplicates and new sender;  could decode i18n addrs\n        here, but the view window will decode to display (and send\n        will reencode) and the unique set filtering here will work\n        either way, though a sender's i18n address is assumed to be\n        in encoded form in mailconfig (else it is not removed here);\n        empty To or Cc headers are okay: split returns empty lists;\n        \"\"\"\n        if not mailconfig.repliesCopyToAll:\n            # reply to sender only\n            Cc = ''\n        else:\n            # copy all original recipients (3.0)\n            allRecipients = (self.splitAddresses(message.get('To', '')) +\n                             self.splitAddresses(message.get('Cc', '')))\n            uniqueOthers  = set(allRecipients) - set([mailconfig.myaddress])\n            Cc = ', '.join(uniqueOthers)\n        return Cc or '?'\n    def formatQuotedMainText(self, message):\n        \"\"\"\n        3.0: factor out common code shared by Reply and Forward:\n        fetch decoded text, extract text if html, line wrap, add > quote\n        \"\"\"\n        type, maintext = self.findMainText(message)       # 3.0: decoded str\n        if type in ['text/html', 'text/xml']:             # 3.0: get plain text\n            maintext = html2text.html2text(maintext)\n        maintext = wraplines.wrapText1(maintext, mailconfig.wrapsz-2) # 2 = '> '\n        maintext = self.quoteOrigText(maintext, message)              # add hdrs, >\n        if mailconfig.mysignature:\n            maintext = ('\\n%s\\n' % mailconfig.mysignature) + maintext\n        return maintext\n    def quoteOrigText(self, maintext, message):\n        \"\"\"\n        3.0: we need to decode any i18n (internationalizd) headers here too,\n        or they show up in email+MIME encoded form in the quoted text block;\n        decodeAddrHeader works on one addr or all in a comma-separated list;\n1076 | Chapter 14:\u2002The PyMailGUI Clientthis may trigger full text encoding on sends, but the main text is\n        also already in fully decoded form: could be in any Unicode scheme;\n        \"\"\"\n        quoted = '\\n-----Original Message-----\\n'\n        for hdr in ('From', 'To', 'Subject', 'Date'):\n            rawhdr = message.get(hdr, '?')\n            if hdr not in ('From', 'To'):\n                dechdr = self.decodeHeader(rawhdr)       # full value\n            else:\n                dechdr = self.decodeAddrHeader(rawhdr)   # name parts only\n            quoted += '%s: %s\\n' % (hdr, dechdr)\n        quoted += '\\n' + maintext\n        quoted  = '\\n' + quoted.replace('\\n', '\\n> ')\n        return quoted\n    ########################\n    # subclass requirements\n    ########################\n    def getMessages(self, msgnums, after):        # used by view,save,reply,fwd\n        after()                                   # redef if cache, thread test\n    # plus okayToQuit?, any unique actions\n    def getMessage(self, msgnum): assert False    # used by many: full mail text\n    def headersMaps(self): assert False           # fillIndex: hdr mappings list\n    def mailSize(self, msgnum): assert False      # fillIndex: size of msgnum\n    def doDelete(self): assert False              # onDeleteMail: delete button\n###############################################################################\n# main window - when viewing messages in local save file (or sent-mail file)\n###############################################################################\nclass PyMailFile(PyMailCommon):\n    \"\"\"\n    customize PyMailCommon for viewing saved-mail file offline;\n    mixed with a Tk, Toplevel, or Frame, adds main mail listbox;\n    maps load, fetch, delete actions to local text file storage;\n    file opens and deletes here run in threads for large files;\n    save and send not threaded, because only append to file; save\n    is disabled if source or target file busy with load/delete;\n    save disables load, delete, save just because it is not run\n    in a thread (blocks GUI);\n    TBD: may need thread and O/S file locks if saves ever do run in\n    threads: saves could disable other threads with openFileBusy, but\n    file may not be open in GUI;  file locks not sufficient, because\n    GUI updated too;  TBD: appends to sent-mail file may require O/S\n    locks: as is, user gets error pop up if sent during load/del;\n    3.0: mail save files are now Unicode text, encoded per an encoding\n    name setting in the mailconfig module; this may not support worst\n    case scenarios of unusual or mixed encodings, but most full mail\nPyMailGUI Implementation | 1077text is ascii, and the Python 3.1 email package is partly broken;\n    \"\"\"\n    def actions(self):\n        return [ ('Open',   self.onOpenMailFile),\n                 ('Write',  self.onWriteMail),\n                 ('  ',     None),                           # 3.0:  separators\n                 ('View',   self.onViewFormatMail),\n                 ('Reply',  self.onReplyMail),\n                 ('Fwd',    self.onFwdMail),\n                 ('Save',   self.onSaveMailFile),\n                 ('Delete', self.onDeleteMail),\n                 ('  ',     None),\n                 ('Quit',   self.quit) ]\n    def __init__(self, filename):\n        # caller: do loadMailFileThread next\n        PyMailCommon.__init__(self)\n        self.filename = filename\n        self.openFileBusy = threadtools.ThreadCounter()      # one per window\n    def loadMailFileThread(self):\n        \"\"\"\n        load or reload file and update window index list;\n        called on Open, startup, and possibly on Send if\n        sent-mail file appended is currently open;  there\n        is always a bogus first item after the text split;\n        alt: [self.parseHeaders(m) for m in self.msglist];\n        could pop up a busy dialog, but quick for small files;\n        2.1: this is now threaded--else runs < 1sec for N meg\n        files, but can pause GUI N seconds if very large file;\n        Save now uses addSavedMails to append msg lists for\n        speed, not this reload;  still called from Send just\n        because msg text unavailable - requires refactoring;\n        delete threaded too: prevent open and delete overlap;\n        \"\"\"\n        if self.openFileBusy:\n            # don't allow parallel open/delete changes\n            errmsg = 'Cannot load, file is busy:\\n\"%s\"' % self.filename\n            showerror(appname, errmsg)\n        else:\n            #self.listBox.insert(END, 'loading...')      # error if user clicks\n            savetitle = self.title()                     # set by window class\n            self.title(appname + ' - ' + 'Loading...')\n            self.openFileBusy.incr()\n            threadtools.startThread(\n                action   = self.loadMailFile,\n                args     = (),\n                context  = (savetitle,),\n                onExit   = self.onLoadMailFileExit,\n                onFail   = self.onLoadMailFileFail)\n    def loadMailFile(self):\n        # run in a thread while GUI is active\n        # open, read, parser may all raise excs: caught in thread utility\n1078 | Chapter 14:\u2002The PyMailGUI Clientfile = open(self.filename, 'r', encoding=mailconfig.fetchEncoding)   # 3.0\n        allmsgs = file.read()\n        self.msglist  = allmsgs.split(saveMailSeparator)[1:]       # full text\n        self.hdrlist  = list(map(self.parseHeaders, self.msglist)) # msg objects\n    def onLoadMailFileExit(self, savetitle):\n        # on thread success\n        self.title(savetitle)         # reset window title to filename\n        self.fillIndex()              # updates GUI: do in main thread\n        self.lift()                   # raise my window\n        self.openFileBusy.decr()\n    def onLoadMailFileFail(self, exc_info, savetitle):\n        # on thread exception\n        showerror(appname, 'Error opening \"%s\"\\n%s\\n%s' %\n                           ((self.filename,) +  exc_info[:2]))\n        printStack(exc_info)\n        self.destroy()                # always close my window?\n        self.openFileBusy.decr()      # not needed if destroy\n    def addSavedMails(self, fulltextlist):\n        \"\"\"\n        optimization: extend loaded file lists for mails\n        newly saved to this window's file; in past called\n        loadMailThread to reload entire file on save - slow;\n        must be called in main GUI thread only: updates GUI;\n        sends still reloads sent file if open: no msg text;\n        \"\"\"\n        self.msglist.extend(fulltextlist)\n        self.hdrlist.extend(map(self.parseHeaders, fulltextlist))  # 3.x iter ok\n        self.fillIndex()\n        self.lift()\n    def doDelete(self, msgnums):\n        \"\"\"\n        simple-minded, but sufficient: rewrite all\n        nondeleted mails to file; can't just delete\n        from self.msglist in-place: changes item indexes;\n        Py2.3 enumerate(L) same as zip(range(len(L)), L)\n        2.1: now threaded, else N sec pause for large files\n        \"\"\"\n        if self.openFileBusy:\n            # dont allow parallel open/delete changes\n            errmsg = 'Cannot delete, file is busy:\\n\"%s\"' % self.filename\n            showerror(appname, errmsg)\n        else:\n            savetitle = self.title()\n            self.title(appname + ' - ' + 'Deleting...')\n            self.openFileBusy.incr()\n            threadtools.startThread(\n                action   = self.deleteMailFile,\n                args     = (msgnums,),\n                context  = (savetitle,),\n                onExit   = self.onDeleteMailFileExit,\n                onFail   = self.onDeleteMailFileFail)\nPyMailGUI Implementation | 1079def deleteMailFile(self, msgnums):\n        # run in a thread while GUI active\n        indexed = enumerate(self.msglist)\n        keepers = [msg for (ix, msg) in indexed if ix+1 not in msgnums]\n        allmsgs = saveMailSeparator.join([''] + keepers)\n        file = open(self.filename, 'w', encoding=mailconfig.fetchEncoding)   # 3.0\n        file.write(allmsgs)\n        self.msglist = keepers\n        self.hdrlist = list(map(self.parseHeaders, self.msglist))\n    def onDeleteMailFileExit(self, savetitle):\n        self.title(savetitle)\n        self.fillIndex()              # updates GUI: do in main thread\n        self.lift()                   # reset my title, raise my window\n        self.openFileBusy.decr()\n    def onDeleteMailFileFail(self, exc_info, savetitle):\n        showerror(appname, 'Error deleting \"%s\"\\n%s\\n%s' %\n                           ((self.filename,) +  exc_info[:2]))\n        printStack(exc_info)\n        self.destroy()                # always close my window?\n        self.openFileBusy.decr()      # not needed if destroy\n    def getMessages(self, msgnums, after):\n        \"\"\"\n        used by view,save,reply,fwd: file load and delete\n        threads may change the msg and hdr lists, so disable\n        all other operations that depend on them to be safe;\n        this test is for self: saves also test target file;\n        \"\"\"\n        if self.openFileBusy:\n            errmsg = 'Cannot fetch, file is busy:\\n\"%s\"' % self.filename\n            showerror(appname, errmsg)\n        else:\n            after()                      # mail already loaded\n    def getMessage(self, msgnum):\n        return self.msglist[msgnum-1]    # full text of 1 mail\n    def headersMaps(self):\n        return self.hdrlist              # email.message.Message objects\n    def mailSize(self, msgnum):\n        return len(self.msglist[msgnum-1])\n    def quit(self):\n        # don't destroy during update: fillIndex next\n        if self.openFileBusy:\n            showerror(appname, 'Cannot quit during load or delete')\n        else:\n            if askyesno(appname, 'Verify Quit Window?'):\n                # delete file from open list\n                del openSaveFiles[self.filename]\n                Toplevel.destroy(self)\n1080 | Chapter 14:\u2002The PyMailGUI Client###############################################################################\n# main window - when viewing messages on the mail server\n###############################################################################\nclass PyMailServer(PyMailCommon):\n    \"\"\"\n    customize PyMailCommon for viewing mail still on server;\n    mixed with a Tk, Toplevel, or Frame, adds main mail listbox;\n    maps load, fetch, delete actions to email server inbox;\n    embeds a MessageCache, which is a mailtools MailFetcher;\n    \"\"\"\n    def actions(self):\n        return [ ('Load',   self.onLoadServer),\n                 ('Open',   self.onOpenMailFile),\n                 ('Write',  self.onWriteMail),\n                 ('  ',     None),                           # 3.0:  separators\n                 ('View',   self.onViewFormatMail),\n                 ('Reply',  self.onReplyMail),\n                 ('Fwd',    self.onFwdMail),\n                 ('Save',   self.onSaveMailFile),\n                 ('Delete', self.onDeleteMail),\n                 ('  ',     None),\n                 ('Quit',   self.quit) ]\n    def __init__(self):\n        PyMailCommon.__init__(self)\n        self.cache = messagecache.GuiMessageCache()    # embedded, not inherited\n       #self.listBox.insert(END, 'Press Load to fetch mail')\n    def makeWidgets(self):                             # help bar: main win only\n        self.addHelpBar()\n        PyMailCommon.makeWidgets(self)\n    def addHelpBar(self):\n        msg = 'PyMailGUI - a Python/tkinter email client  (help)'\n        title = Button(self, text=msg)\n        title.config(bg='steelblue', fg='white', relief=RIDGE)\n        title.config(command=self.onShowHelp)\n        title.pack(fill=X)\n    def onShowHelp(self):\n        \"\"\"\n        load,show text block string\n        3.0: now uses HTML and webbrowser module here too\n        user setting in mailconfig selects text, HTML, or both\n        always displays one or the other: html if both false\n        \"\"\"\n        if mailconfig.showHelpAsText:\n            from PyMailGuiHelp import helptext\n            popuputil.HelpPopup(appname, helptext, showsource=self.onShowMySource)\n        if mailconfig.showHelpAsHTML or (not mailconfig.showHelpAsText):\nPyMailGUI Implementation | 1081from PyMailGuiHelp import showHtmlHelp\n            showHtmlHelp()    # 3.0: HTML version without source file links\n    def onShowMySource(self, showAsMail=False):\n        \"\"\"\n        display my sourcecode file, plus imported modules here & elsewhere\n        \"\"\"\n        import PyMailGui, ListWindows, ViewWindows, SharedNames, textConfig\n        from PP4E.Internet.Email.mailtools import (    # mailtools now a pkg\n             mailSender, mailFetcher, mailParser)      # can't use * in def\n        mymods = (\n            PyMailGui, ListWindows, ViewWindows, SharedNames,\n            PyMailGuiHelp, popuputil, messagecache, wraplines, html2text,\n            mailtools, mailFetcher, mailSender, mailParser,\n            mailconfig, textConfig, threadtools, windows, textEditor)\n        for mod in mymods:\n            source = mod.__file__\n            if source.endswith('.pyc'):\n                source = source[:-4] + '.py'       # assume a .py in same dir\n            if showAsMail:\n                # this is a bit cheesey...\n                code   = open(source).read()       # 3.0: platform encoding\n                user   = mailconfig.myaddress\n                hdrmap = {'From': appname, 'To': user, 'Subject': mod.__name__}\n                ViewWindow(showtext=code,\n                           headermap=hdrmap,\n                           origmessage=email.message.Message())\n            else:\n                # more useful PyEdit text editor\n                # 4E: assume in UTF8 Unicode encoding (else PeEdit may ask!)\n                wintitle = ' - ' + mod.__name__\n                textEditor.TextEditorMainPopup(self, source, wintitle, 'utf-8')\n    def onLoadServer(self, forceReload=False):\n        \"\"\"\n        threaded: load or reload mail headers list on request;\n        Exit,Fail,Progress run by threadChecker after callback via queue;\n        load may overlap with sends, but disables all but send;\n        could overlap with loadingMsgs, but may change msg cache list;\n        forceReload on delete/synch fail, else loads recent arrivals only;\n        2.1: cache.loadHeaders may do quick check to see if msgnums\n        in synch with server, if we are loading just newly arrived hdrs;\n        \"\"\"\n        if loadingHdrsBusy or deletingBusy or loadingMsgsBusy:\n            showerror(appname, 'Cannot load headers during load or delete')\n        else:\n            loadingHdrsBusy.incr()\n            self.cache.setPopPassword(appname) # don't update GUI in the thread!\n            popup = popuputil.BusyBoxNowait(appname, 'Loading message headers')\n            threadtools.startThread(\n                action     = self.cache.loadHeaders,\n                args       = (forceReload,),\n                context    = (popup,),\n                onExit     = self.onLoadHdrsExit,\n                onFail     = self.onLoadHdrsFail,\n1082 | Chapter 14:\u2002The PyMailGUI ClientonProgress = self.onLoadHdrsProgress)\n    def onLoadHdrsExit(self, popup):\n        self.fillIndex()\n        popup.quit()\n        self.lift()\n        loadingHdrsBusy.decr()                     # allow other actions to run\n    def onLoadHdrsFail(self, exc_info, popup):\n        popup.quit()\n        showerror(appname, 'Load failed: \\n%s\\n%s' % exc_info[:2])\n        printStack(exc_info)                       # send stack trace to stdout\n        loadingHdrsBusy.decr()\n        if exc_info[0] == mailtools.MessageSynchError:    # synch inbox/index\n            self.onLoadServer(forceReload=True)           # new thread: reload\n        else:\n            self.cache.popPassword = None          # force re-input next time\n    def onLoadHdrsProgress(self, i, n, popup):\n        popup.changeText('%d of %d' % (i, n))\n    def doDelete(self, msgnumlist):\n        \"\"\"\n        threaded: delete from server now - changes msg nums;\n        may overlap with sends only, disables all except sends;\n        2.1: cache.deleteMessages now checks TOP result to see\n        if headers match selected mails, in case msgnums out of\n        synch with mail server: poss if mail deleted by other client,\n        or server deletes inbox mail automatically - some ISPs may\n        move a mail from inbox to undeliverable on load failure;\n        \"\"\"\n        if loadingHdrsBusy or deletingBusy or loadingMsgsBusy:\n            showerror(appname, 'Cannot delete during load or delete')\n        else:\n            deletingBusy.incr()\n            popup = popuputil.BusyBoxNowait(appname, 'Deleting selected mails')\n            threadtools.startThread(\n                action     = self.cache.deleteMessages,\n                args       = (msgnumlist,),\n                context    = (popup,),\n                onExit     = self.onDeleteExit,\n                onFail     = self.onDeleteFail,\n                onProgress = self.onDeleteProgress)\n    def onDeleteExit(self, popup):\n        self.fillIndex()                     # no need to reload from server\n        popup.quit()                         # refill index with updated cache\n        self.lift()                          # raise index window, release lock\n        deletingBusy.decr()\n    def onDeleteFail(self, exc_info, popup):\n        popup.quit()\n        showerror(appname, 'Delete failed: \\n%s\\n%s' % exc_info[:2])\n        printStack(exc_info)\n        deletingBusy.decr()                  # delete or synch check failure\nPyMailGUI Implementation | 1083self.onLoadServer(forceReload=True)  # new thread: some msgnums changed\n    def onDeleteProgress(self, i, n, popup):\n        popup.changeText('%d of %d' % (i, n))\n    def getMessages(self, msgnums, after):\n        \"\"\"\n        threaded: prefetch all selected messages into cache now;\n        used by save, view, reply, and forward to prefill cache;\n        may overlap with other loadmsgs and sends, disables delete,load;\n        only runs \"after\" action if the fetch allowed and successful;\n        2.1: cache.getMessages tests if index in synch with server,\n        but we only test if we have to go to server, not if cached;\n        3.0: see messagecache note: now avoids potential fetch of mail\n        currently being fetched, if user clicks again while in progress;\n        any message being fetched by any other request in progress must\n        disable entire toLoad batch: else, need to wait for N other loads;\n        fetches are still allowed to overlap in time, as long as disjoint;\n        \"\"\"\n        if loadingHdrsBusy or deletingBusy:\n            showerror(appname, 'Cannot fetch message during load or delete')\n        else:\n            toLoad = [num for num in msgnums if not self.cache.isLoaded(num)]\n            if not toLoad:\n                after()         # all already loaded\n                return          # process now, no wait pop up\n            else:\n                if set(toLoad) & self.beingFetched:   # 3.0: any in progress?\n                    showerror(appname, 'Cannot fetch any message being fetched')\n                else:\n                    self.beingFetched |= set(toLoad)\n                    loadingMsgsBusy.incr()\n                    from popuputil import BusyBoxNowait\n                    popup = BusyBoxNowait(appname, 'Fetching message contents')\n                    threadtools.startThread(\n                        action     = self.cache.getMessages,\n                        args       = (toLoad,),\n                        context    = (after, popup, toLoad),\n                        onExit     = self.onLoadMsgsExit,\n                        onFail     = self.onLoadMsgsFail,\n                        onProgress = self.onLoadMsgsProgress)\n    def onLoadMsgsExit(self, after, popup, toLoad):\n        self.beingFetched -= set(toLoad)\n        popup.quit()\n        after()\n        loadingMsgsBusy.decr()    # allow other actions after onExit done\n    def onLoadMsgsFail(self, exc_info, after, popup, toLoad):\n        self.beingFetched -= set(toLoad)\n        popup.quit()\n        showerror(appname, 'Fetch failed: \\n%s\\n%s' % exc_info[:2])\n        printStack(exc_info)\n        loadingMsgsBusy.decr()\n1084 | Chapter 14:\u2002The PyMailGUI Clientif exc_info[0] == mailtools.MessageSynchError:      # synch inbox/index\n            self.onLoadServer(forceReload=True)             # new thread: reload\n    def onLoadMsgsProgress(self, i, n, after, popup, toLoad):\n        popup.changeText('%d of %d' % (i, n))\n    def getMessage(self, msgnum):\n        return self.cache.getMessage(msgnum)                # full mail text\n    def headersMaps(self):\n        # list of email.message.Message objects, 3.x requires list() if map()\n        # return [self.parseHeaders(h) for h in self.cache.allHdrs()]\n        return list(map(self.parseHeaders, self.cache.allHdrs()))\n    def mailSize(self, msgnum):\n        return self.cache.getSize(msgnum)\n    def okayToQuit(self):\n        # any threads still running?\n        filesbusy = [win for win in openSaveFiles.values() if win.openFileBusy]\n        busy = loadingHdrsBusy or deletingBusy or sendingBusy or loadingMsgsBusy\n        busy = busy or filesbusy\n        return not busy\nViewWindows: Message View Windows\nExample 14-4 lists the implementation of mail view and edit windows. These windows\nare created in response to actions in list windows\u2014View, Write, Reply, and Forward\nbuttons. See the callbacks for these actions in the list window module of Exam-\nple 14-3 for view window initiation calls.\nAs in the prior module (Example 14-3), this file is really one common class and a handful\nof customizations. The mail view window is nearly identical to the mail edit window,\nused for Write, Reply, and Forward requests. Consequently, this example defines the\ncommon appearance and behavior in the view window superclass, and extends it by\nsubclassing for edit windows.\nReplies and forwards are hardly different from the write window here, because their\ndetails (e.g., From and To addresses and quoted message text) are worked out in the\nlist window implementation before an edit window is created.\nExample 14-4. PP4E\\Internet\\Email\\PyMailGui\\ViewWindows.py\n\"\"\"\n###############################################################################\nImplementation of View, Write, Reply, Forward windows: one class per kind.\nCode is factored here for reuse: a Write window is a customized View window,\nand Reply and Forward are custom Write windows.  Windows defined in this\nfile are created by the list windows, in response to user actions.\nCaveat:'split' pop ups for opening parts/attachments feel nonintuitive.\n2.1: this caveat was addressed, by adding quick-access attachment buttons.\nNew in 3.0: platform-neutral grid() for mail headers, not packed col frames.\nPyMailGUI Implementation | 1085New in 3.0: supports Unicode encodings for main text + text attachments sent.\nNew in 3.0: PyEdit supports arbitrary Unicode for message parts viewed.\nNew in 3.0: supports Unicode/mail encodings for headers in  mails sent.\nTBD: could avoid verifying quits unless text area modified (like PyEdit2.0),\nbut these windows are larger, and would not catch headers already changed.\nTBD: should Open dialog in write windows be program-wide? (per-window now).\n###############################################################################\n\"\"\"\nfrom SharedNames import *     # program-wide global objects\n###############################################################################\n# message view window - also a superclass of write, reply, forward\n###############################################################################\nclass ViewWindow(windows.PopupWindow, mailtools.MailParser):\n    \"\"\"\n    a Toplevel, with extra protocol and embedded TextEditor;\n    inherits saveParts,partsList from mailtools.MailParser;\n    mixes in custom subclass logic by direct inheritance here;\n    \"\"\"\n    # class attributes\n    modelabel       = 'View'                   # used in window titles\n    from mailconfig import okayToOpenParts     # open any attachments at all?\n    from mailconfig import verifyPartOpens     # ask before open each part?\n    from mailconfig import maxPartButtons      # show up to this many + '...'\n    from mailconfig import skipTextOnHtmlPart  # 3.0: just browser, not PyEdit?\n    tempPartDir     = 'TempParts'              # where 1 selected part saved\n    # all view windows use same dialog: remembers last dir\n    partsDialog = Directory(title=appname + ': Select parts save directory')\n    def __init__(self, headermap, showtext, origmessage=None):\n        \"\"\"\n        header map is origmessage, or custom hdr dict for writing;\n        showtext is main text part of the message: parsed or custom;\n        origmessage is parsed email.message.Message for view mail windows\n        \"\"\"\n        windows.PopupWindow.__init__(self, appname, self.modelabel)\n        self.origMessage = origmessage\n        self.makeWidgets(headermap, showtext)\n    def makeWidgets(self, headermap, showtext):\n        \"\"\"\n        add headers, actions, attachments, text editor\n        3.0: showtext is assumed to be decoded Unicode str here;\n        it will be encoded on sends and saves as directed/needed;\n        \"\"\"\n        actionsframe = self.makeHeaders(headermap)\n        if self.origMessage and self.okayToOpenParts:\n            self.makePartButtons()\n        self.editor  = textEditor.TextEditorComponentMinimal(self)\n1086 | Chapter 14:\u2002The PyMailGUI Clientmyactions    = self.actionButtons()\n        for (label, callback) in myactions:\n            b = Button(actionsframe, text=label, command=callback)\n            b.config(bg='beige', relief=RIDGE, bd=2)\n            b.pack(side=TOP, expand=YES, fill=BOTH)\n        # body text, pack last=clip first\n        self.editor.pack(side=BOTTOM)               # may be multiple editors\n        self.update()                               # 3.0: else may be @ line2\n        self.editor.setAllText(showtext)            # each has own content\n        lines = len(showtext.splitlines())\n        lines = min(lines + 3, mailconfig.viewheight or 20)\n        self.editor.setHeight(lines)                # else height=24, width=80\n        self.editor.setWidth(80)                    # or from PyEdit textConfig\n        if mailconfig.viewbg:\n            self.editor.setBg(mailconfig.viewbg)    # colors, font in mailconfig\n        if mailconfig.viewfg:\n            self.editor.setFg(mailconfig.viewfg)\n        if mailconfig.viewfont:                     # also via editor Tools menu\n            self.editor.setFont(mailconfig.viewfont)\n    def makeHeaders(self, headermap):\n        \"\"\"\n        add header entry fields, return action buttons frame;\n        3.0: uses grid for platform-neutral layout of label/entry rows;\n        packed row frames with fixed-width labels would work well too;\n        3.0: decoding of i18n headers (and email names in address headers)\n        is performed here if still required as they are added to the GUI;\n        some may have been decoded already for reply/forward windows that\n        need to use decoded text, but the extra decode here is harmless for\n        these, and is required for other headers and cases such as fetched\n        mail views;  always, headers are in decoded form when displayed in\n        the GUI, and will be encoded within mailtools on Sends if they are\n        non-ASCII (see Write);  i18n header decoding also occurs in list\n        window mail indexes, and for headers added to quoted mail text;\n        text payloads in the mail body are also decoded for display and\n        encoded for sends elsewhere in the system (list windows, Write);\n        3.0: creators of edit windows prefill Bcc header with sender email\n        address to be picked up here, as a convenience for common usages if\n        this header is enabled in mailconfig;  Reply also now prefills the\n        Cc header with all unique original recipients less From, if enabled;\n        \"\"\"\n        top    = Frame(self); top.pack   (side=TOP,   fill=X)\n        left   = Frame(top);  left.pack  (side=LEFT,  expand=NO,  fill=BOTH)\n        middle = Frame(top);  middle.pack(side=LEFT,  expand=YES, fill=X)\n        # headers set may be extended in mailconfig (Bcc, others?)\n        self.userHdrs = ()\n        showhdrs = ('From', 'To', 'Cc', 'Subject')\n        if hasattr(mailconfig, 'viewheaders') and mailconfig.viewheaders:\n            self.userHdrs = mailconfig.viewheaders\n            showhdrs += self.userHdrs\n        addrhdrs = ('From', 'To', 'Cc', 'Bcc')    # 3.0: decode i18n specially\nPyMailGUI Implementation | 1087self.hdrFields = []\n        for (i, header) in enumerate(showhdrs):\n            lab = Label(middle, text=header+':', justify=LEFT)\n            ent = Entry(middle)\n            lab.grid(row=i, column=0, sticky=EW)\n            ent.grid(row=i, column=1, sticky=EW)\n            middle.rowconfigure(i, weight=1)\n            hdrvalue = headermap.get(header, '?')    # might be empty\n            # 3.0: if encoded, decode per email+mime+unicode\n            if header not in addrhdrs:\n                hdrvalue = self.decodeHeader(hdrvalue)\n            else:\n                hdrvalue = self.decodeAddrHeader(hdrvalue)\n            ent.insert('0', hdrvalue)\n            self.hdrFields.append(ent)               # order matters in onSend\n        middle.columnconfigure(1, weight=1)\n        return left\n    def actionButtons(self):                         # must be method for self\n        return [('Cancel', self.destroy),            # close view window silently\n                ('Parts',  self.onParts),            # multiparts list or the body\n                ('Split',  self.onSplit)]\n    def makePartButtons(self):\n        \"\"\"\n        add up to N buttons that open attachments/parts\n        when clicked; alternative to Parts/Split (2.1);\n        okay that temp dir is shared by all open messages:\n        part file not saved till later selected and opened;\n        partname=partname is required in lambda in Py2.4;\n        caveat: we could try to skip the main text part;\n        \"\"\"\n        def makeButton(parent, text, callback):\n            link = Button(parent, text=text, command=callback, relief=SUNKEN)\n            if mailconfig.partfg: link.config(fg=mailconfig.partfg)\n            if mailconfig.partbg: link.config(bg=mailconfig.partbg)\n            link.pack(side=LEFT, fill=X, expand=YES)\n        parts = Frame(self)\n        parts.pack(side=TOP, expand=NO, fill=X)\n        for (count, partname) in enumerate(self.partsList(self.origMessage)):\n            if count == self.maxPartButtons:\n                makeButton(parts, '...', self.onSplit)\n                break\n            openpart = (lambda partname=partname: self.onOnePart(partname))\n            makeButton(parts, partname, openpart)\n    def onOnePart(self, partname):\n        \"\"\"\n        locate selected part for button and save and open;\n        okay if multiple mails open: resaves each time selected;\n        we could probably just use web browser directly here;\n        caveat: tempPartDir is relative to cwd - poss anywhere;\n        caveat: tempPartDir is never cleaned up: might be large,\n1088 | Chapter 14:\u2002The PyMailGUI Clientcould use tempfile module (just like the HTML main text\n        part display code in onView of the list window class);\n        \"\"\"\n        try:\n            savedir  = self.tempPartDir\n            message  = self.origMessage\n            (contype, savepath) = self.saveOnePart(savedir, partname, message)\n        except:\n            showerror(appname, 'Error while writing part file')\n            printStack(sys.exc_info())\n        else:\n            self.openParts([(contype, os.path.abspath(savepath))])   # reuse\n    def onParts(self):\n        \"\"\"\n        show message part/attachments in pop-up window;\n        uses same file naming scheme as save on Split;\n        if non-multipart, single part = full body text\n        \"\"\"\n        partnames = self.partsList(self.origMessage)\n        msg = '\\n'.join(['Message parts:\\n'] + partnames)\n        showinfo(appname, msg)\n    def onSplit(self):\n        \"\"\"\n        pop up save dir dialog and save all parts/attachments there;\n        if desired, pop up HTML and multimedia parts in web browser,\n        text in TextEditor, and well-known doc types on windows;\n        could show parts in View windows where embedded text editor\n        would provide a save button, but most are not readable text;\n        \"\"\"\n        savedir = self.partsDialog.show()          # class attr: at prior dir\n        if savedir:                                # tk dir chooser, not file\n            try:\n                partfiles = self.saveParts(savedir, self.origMessage)\n            except:\n                showerror(appname, 'Error while writing part files')\n                printStack(sys.exc_info())\n            else:\n                if self.okayToOpenParts: self.openParts(partfiles)\n    def askOpen(self, appname, prompt):\n        if not self.verifyPartOpens:\n            return True\n        else:\n            return askyesno(appname, prompt)   # pop-up dialog\n    def openParts(self, partfiles):\n        \"\"\"\n        auto-open well known and safe file types, but only if verified\n        by the user in a pop up; other types must be opened manually\n        from save dir;  at this point, the named parts have been already\n        MIME-decoded and saved as raw bytes in binary-mode files, but text\n        parts may be in any Unicode encoding;  PyEdit needs to know the\n        encoding to decode, webbrowsers may have to guess or be told;\nPyMailGUI Implementation | 1089caveat: punts for type application/octet-stream even if it has\n        safe filename extension such as .html; caveat: image/audio/video\n        could be opened with the book's playfile.py; could also do that\n        if text viewer fails: would start notepad on Windows via startfile;\n        webbrowser may handle most cases here too, but specific is better;\n        \"\"\"\n        def textPartEncoding(fullfilename):\n            \"\"\"\n            3.0: map a text part filename back to charset param in content-type\n            header of part's Message, so we can pass this on to the PyEdit\n            constructor for proper text display;  we could return the charset\n            along with content-type from mailtools for text parts, but fewer\n            changes are needed if this is handled as a special case here;\n            part content is saved in binary mode files by mailtools to avoid\n            encoding issues, but here the original part Message is not directly\n            available; we need this mapping step to extract a Unicode encoding\n            name if present; 4E's PyEdit now allows an explicit encoding name for\n            file opens, and resolves encoding on saves; see Chapter 11 for PyEdit\n            policies: it may ask user for an encoding if charset absent or fails;\n            caveat: move to mailtools.mailParser to reuse for <meta> in PyMailCGI?\n            \"\"\"\n            partname = os.path.basename(fullfilename)\n            for (filename, contype, part) in self.walkNamedParts(self.origMessage):\n                if filename == partname:\n                    return part.get_content_charset()     # None if not in header\n            assert False, 'Text part not found'           # should never happen\n        for (contype, fullfilename) in partfiles:\n            maintype  = contype.split('/')[0]                      # left side\n            extension = os.path.splitext(fullfilename)[1]          # not [-4:]\n            basename  = os.path.basename(fullfilename)             # strip dir\n            # HTML and XML text, web pages, some media\n            if contype  in ['text/html', 'text/xml']:\n                browserOpened = False\n                if self.askOpen(appname, 'Open \"%s\" in browser?' % basename):\n                    try:\n                        webbrowser.open_new('file://' + fullfilename)\n                        browserOpened = True\n                    except:\n                        showerror(appname, 'Browser failed: trying editor')\n                if not browserOpened or not self.skipTextOnHtmlPart:\n                    try:\n                        # try PyEdit to see encoding name and effect\n                        encoding = textPartEncoding(fullfilename)\n                        textEditor.TextEditorMainPopup(parent=self,\n                                   winTitle=' - %s email part' % (encoding or '?'),\n                                   loadFirst=fullfilename, loadEncode=encoding)\n                    except:\n                        showerror(appname, 'Error opening text viewer')\n            # text/plain, text/x-python, etc.; 4E: encoding, may fail\n1090 | Chapter 14:\u2002The PyMailGUI Clientelif maintype == 'text':\n                if self.askOpen(appname, 'Open text part \"%s\"?' % basename):\n                    try:\n                        encoding = textPartEncoding(fullfilename)\n                        textEditor.TextEditorMainPopup(parent=self,\n                                   winTitle=' - %s email part' % (encoding or '?'),\n                                   loadFirst=fullfilename, loadEncode=encoding)\n                    except:\n                        showerror(appname, 'Error opening text viewer')\n            # multimedia types: Windows opens mediaplayer, imageviewer, etc.\n            elif maintype in ['image', 'audio', 'video']:\n                if self.askOpen(appname, 'Open media part \"%s\"?' % basename):\n                    try:\n                        webbrowser.open_new('file://' + fullfilename)\n                    except:\n                        showerror(appname, 'Error opening browser')\n            # common Windows documents: Word, Excel, Adobe, archives, etc.\n            elif (sys.platform[:3] == 'win' and\n                  maintype == 'application' and                      # 3.0: +x types\n                  extension in ['.doc', '.docx', '.xls', '.xlsx',    # generalize me\n                                '.pdf', '.zip',  '.tar', '.wmv']):\n                    if self.askOpen(appname, 'Open part \"%s\"?' % basename):\n                        os.startfile(fullfilename)\n            else:  # punt!\n                msg = 'Cannot open part: \"%s\"\\nOpen manually in: \"%s\"'\n                msg = msg % (basename, os.path.dirname(fullfilename))\n                showinfo(appname, msg)\n###############################################################################\n# message edit windows - write, reply, forward\n###############################################################################\nif mailconfig.smtpuser:                              # user set in mailconfig?\n    MailSenderClass = mailtools.MailSenderAuth       # login/password required\nelse:\n    MailSenderClass = mailtools.MailSender\nclass WriteWindow(ViewWindow, MailSenderClass):\n    \"\"\"\n    customize view display for composing new mail\n    inherits sendMessage from mailtools.MailSender\n    \"\"\"\n    modelabel = 'Write'\n    def __init__(self, headermap, starttext):\n        ViewWindow.__init__(self, headermap, starttext)\n        MailSenderClass.__init__(self)\n        self.attaches   = []                     # each win has own open dialog\n        self.openDialog = None                   # dialog remembers last dir\nPyMailGUI Implementation | 1091def actionButtons(self):\n        return [('Cancel', self.quit),           # need method to use self\n                ('Parts',  self.onParts),        # PopupWindow verifies cancel\n                ('Attach', self.onAttach),\n                ('Send',   self.onSend)]         # 4E: don't pad: centered\n    def onParts(self):\n        # caveat: deletes not currently supported\n        if not self.attaches:\n            showinfo(appname, 'Nothing attached')\n        else:\n            msg = '\\n'.join(['Already attached:\\n'] + self.attaches)\n            showinfo(appname, msg)\n    def onAttach(self):\n        \"\"\"\n        attach a file to the mail: name added here will be\n        added as a part on Send, inside the mailtools pkg;\n        4E: could ask Unicode type here instead of on send\n        \"\"\"\n        if not self.openDialog:\n            self.openDialog = Open(title=appname + ': Select Attachment File')\n        filename = self.openDialog.show()        # remember prior dir\n        if filename:\n            self.attaches.append(filename)       # to be opened in send method\n    def resolveUnicodeEncodings(self):\n        \"\"\"\n        3.0/4E: to prepare for send, resolve Unicode encoding for text parts:\n        both main text part, and any text part attachments;  the main text part\n        may have had a known encoding if this is a reply or forward, but not for\n        a write, and it may require a different encoding after editing anyhow;\n        smtplib in 3.1 requires that full message text be encodable per ASCII\n        when sent (if it's a str), so it's crucial to get this right here; else\n        fails if reply/fwd to UTF8 text when config=ascii if any non-ascii chars;\n        try user setting and reply but fall back on general UTF8 as a last resort;\n        \"\"\"\n        def isTextKind(filename):\n            contype, encoding = mimetypes.guess_type(filename)\n            if contype is None or encoding is not None:    # 4E utility\n                return False                               # no guess, compressed?\n            maintype, subtype = contype.split('/', 1)      # check for text/?\n            return maintype == 'text'\n        # resolve many body text encoding\n        bodytextEncoding = mailconfig.mainTextEncoding\n        if bodytextEncoding == None:\n            asknow = askstring('PyMailGUI', 'Enter main text Unicode encoding name')\n            bodytextEncoding = asknow or 'latin-1'    # or sys.getdefaultencoding()?\n        # last chance: use utf-8 if can't encode per prior selections\n        if bodytextEncoding != 'utf-8':\n            try:\n1092 | Chapter 14:\u2002The PyMailGUI Clientbodytext = self.editor.getAllText()\n                bodytext.encode(bodytextEncoding)\n            except (UnicodeError, LookupError):       # lookup: bad encoding name\n                bodytextEncoding = 'utf-8'            # general code point scheme\n        # resolve any text part attachment encodings\n        attachesEncodings = []\n        config = mailconfig.attachmentTextEncoding\n        for filename in self.attaches:\n            if not isTextKind(filename):\n                attachesEncodings.append(None)        # skip non-text: don't ask\n            elif config != None:\n                attachesEncodings.append(config)      # for all text parts if set\n            else:\n                prompt = 'Enter Unicode encoding name for %' % filename\n                asknow = askstring('PyMailGUI', prompt)\n                attachesEncodings.append(asknow or 'latin-1')\n            # last chance: use utf-8 if can't decode per prior selections\n            choice = attachesEncodings[-1]\n            if choice != None and choice != 'utf-8':\n                try:\n                    attachbytes = open(filename, 'rb').read()\n                    attachbytes.decode(choice)\n                except (UnicodeError, LookupError, IOError):\n                    attachesEncodings[-1] = 'utf-8'\n        return bodytextEncoding, attachesEncodings\n    def onSend(self):\n        \"\"\"\n        threaded: mail edit window Send button press;\n        may overlap with any other thread, disables none but quit;\n        Exit,Fail run by threadChecker via queue in after callback;\n        caveat: no progress here, because send mail call is atomic;\n        assumes multiple recipient addrs are separated with ',';\n        mailtools module handles encodings, attachments, Date, etc;\n        mailtools module also saves sent message text in a local file\n        3.0: now fully parses To,Cc,Bcc (in mailtools) instead of\n        splitting on the separator naively;  could also use multiline\n        input widgets instead of simple entry;  Bcc added to envelope,\n        not headers;\n        3.0: Unicode encodings of text parts is resolved here, because\n        it may require GUI prompts;  mailtools performs the actual\n        encoding for parts as needed and requested;\n        3.0: i18n headers are already decoded in the GUI fields here;\n        encoding of any non-ASCII i18n headers is performed in mailtools,\n        not here, because no GUI interaction is required;\n        \"\"\"\n        # resolve Unicode encoding for text parts;\n        bodytextEncoding, attachesEncodings = self.resolveUnicodeEncodings()\nPyMailGUI Implementation | 1093# get components from GUI; 3.0: i18n headers are decoded\n        fieldvalues = [entry.get() for entry in self.hdrFields]\n        From, To, Cc, Subj = fieldvalues[:4]\n        extraHdrs = [('Cc', Cc), ('X-Mailer', appname + ' (Python)')]\n        extraHdrs += list(zip(self.userHdrs, fieldvalues[4:]))\n        bodytext = self.editor.getAllText()\n        # split multiple recipient lists on ',', fix empty fields\n        Tos = self.splitAddresses(To)\n        for (ix, (name, value)) in enumerate(extraHdrs):\n            if value:                                           # ignored if ''\n                if value == '?':                                # ? not replaced\n                    extraHdrs[ix] = (name, '')\n                elif name.lower() in ['cc', 'bcc']:             # split on ','\n                    extraHdrs[ix] = (name, self.splitAddresses(value))\n        # withdraw to disallow send during send\n        # caveat: might not be foolproof - user may deiconify if icon visible\n        self.withdraw()\n        self.getPassword()      # if needed; don't run pop up in send thread!\n        popup = popuputil.BusyBoxNowait(appname, 'Sending message')\n        sendingBusy.incr()\n        threadtools.startThread(\n            action  = self.sendMessage,\n            args    = (From, Tos, Subj, extraHdrs, bodytext, self.attaches,\n                                         saveMailSeparator,\n                                         bodytextEncoding,\n                                         attachesEncodings),\n            context = (popup,),\n            onExit  = self.onSendExit,\n            onFail  = self.onSendFail)\n    def onSendExit(self, popup):\n        \"\"\"\n        erase wait window, erase view window, decr send count;\n        sendMessage call auto saves sent message in local file;\n        can't use window.addSavedMails: mail text unavailable;\n        \"\"\"\n        popup.quit()\n        self.destroy()\n        sendingBusy.decr()\n        # poss \\ when opened, / in mailconfig\n        sentname = os.path.abspath(mailconfig.sentmailfile)  # also expands '.'\n        if sentname in openSaveFiles.keys():                 # sent file open?\n            window = openSaveFiles[sentname]                 # update list,raise\n            window.loadMailFileThread()\n    def onSendFail(self, exc_info, popup):\n        # pop-up error, keep msg window to save or retry, redraw actions frame\n        popup.quit()\n        self.deiconify()\n        self.lift()\n        showerror(appname, 'Send failed: \\n%s\\n%s' % exc_info[:2])\n        printStack(exc_info)\n1094 | Chapter 14:\u2002The PyMailGUI ClientMailSenderClass.smtpPassword = None        # try again; 3.0/4E: not on self\n        sendingBusy.decr()\n    def askSmtpPassword(self):\n        \"\"\"\n        get password if needed from GUI here, in main thread;\n        caveat: may try this again in thread if no input first\n        time, so goes into a loop until input is provided; see\n        pop paswd input logic for a nonlooping alternative\n        \"\"\"\n        password = ''\n        while not password:\n            prompt = ('Password for %s on %s?' %\n                     (self.smtpUser, self.smtpServerName))\n            password = popuputil.askPasswordWindow(appname, prompt)\n        return password\nclass ReplyWindow(WriteWindow):\n    \"\"\"\n    customize write display for replying\n    text and headers set up by list window\n    \"\"\"\n    modelabel = 'Reply'\nclass ForwardWindow(WriteWindow):\n    \"\"\"\n    customize reply display for forwarding\n    text and headers set up by list window\n    \"\"\"\n    modelabel = 'Forward'\nmessagecache: Message Cache Manager\nThe class in Example 14-5 implements a cache for already loaded messages. Its logic is\nsplit off into this file in order to avoid further complicating list window implementa-\ntions. The server list window creates and embeds an instance of this class to interface\nwith the mail server and to keep track of already loaded mail headers and full text. In\nthis version, the server list window also keeps track of mail fetches in progress, to avoid\nattempting to load the same mail more than once in parallel. This task isn\u2019t performed\nhere, because it may require GUI operations.\nExample 14-5. PP4E\\Internet\\Email\\PyMailGui\\messagecache.py\n\"\"\"\n##############################################################################\nmanage message and header loads and context, but not GUI;\na MailFetcher, with a list of already loaded headers and messages;\nthe caller must handle any required threading or GUI interfaces;\n3.0 change: use full message text  Unicode encoding name in local\nmailconfig module; decoding happens deep in mailtools, when a message\nPyMailGUI Implementation | 1095is fetched - mail text is always Unicode str from that point on;\nthis may change in a future Python/email: see Chapter 13 for details;\n3.0 change: inherits the new mailconfig.fetchlimit feature of mailtools,\nwhich can be used to limit the maximum number of most recent headers or\nfull mails (if no TOP) fetched on each load request; note that this\nfeature is independent of the loadfrom used here to limit loads to\nnewly-arrived mails only, though it is applied at the same time: at\nmost fetchlimit newly-arrived mails are loaded;\n3.0 change: though unlikely, it's not impossible that a user may trigger a\nnew fetch of a message that is currently being fetched in a thread, simply\nby clicking the same message again (msg fetches, but not full index loads,\nmay overlap with other fetches and sends); this seems to be thread safe here,\nbut can lead to redundant and possibly parallel downloads of the same mail\nwhich are pointless and seem odd (selecting all mails and pressing View\ntwice downloads most messages twice!); fixed by keeping track of fetches in\nprogress in the main GUI thread so that this overlap is no longer possible:\na message being fetched disables any fetch request which it is part of, and\nparallel fetches are still allowed as long as their targets do not intersect;\n##############################################################################\n\"\"\"\nfrom PP4E.Internet.Email import mailtools\nfrom popuputil import askPasswordWindow\nclass MessageInfo:\n    \"\"\"\n    an item in the mail cache list\n    \"\"\"\n    def __init__(self, hdrtext, size):\n        self.hdrtext  = hdrtext            # fulltext is cached msg\n        self.fullsize = size               # hdrtext is just the hdrs\n        self.fulltext = None               # fulltext=hdrtext if no TOP\nclass MessageCache(mailtools.MailFetcher):\n    \"\"\"\n    keep track of already loaded headers and messages;\n    inherits server transfer methods from MailFetcher;\n    useful in other apps: no GUI or thread assumptions;\n    3.0: raw mail text bytes are decoded to str to be\n    parsed with Py3.1's email pkg and saved to files;\n    uses the local mailconfig module's encoding setting;\n    decoding happens automatically in mailtools on fetch;\n    \"\"\"\n    def __init__(self):\n        mailtools.MailFetcher.__init__(self)   # 3.0: inherits fetchEncoding\n        self.msglist = []                      # 3.0: inherits fetchlimit\n    def loadHeaders(self, forceReloads, progress=None):\n        \"\"\"\n        three cases to handle here: the initial full load,\n1096 | Chapter 14:\u2002The PyMailGUI Clientload newly arrived, and forced reload after delete;\n        don't refetch viewed msgs if hdrs list same or extended;\n        retains cached msgs after a delete unless delete fails;\n        2.1: does quick check to see if msgnums still in sync\n        3.0: this is now subject to mailconfig.fetchlimit max;\n        \"\"\"\n        if forceReloads:\n            loadfrom = 1\n            self.msglist = []                         # msg nums have changed\n        else:\n            loadfrom = len(self.msglist)+1            # continue from last load\n        # only if loading newly arrived\n        if loadfrom != 1:\n            self.checkSynchError(self.allHdrs())      # raises except if bad\n        # get all or newly arrived msgs\n        reply = self.downloadAllHeaders(progress, loadfrom)\n        headersList, msgSizes, loadedFull = reply\n        for (hdrs, size) in zip(headersList, msgSizes):\n            newmsg = MessageInfo(hdrs, size)\n            if loadedFull:                            # zip result may be empty\n                newmsg.fulltext = hdrs                # got full msg if no 'top'\n            self.msglist.append(newmsg)\n    def getMessage(self, msgnum):                     # get raw msg text\n        cacheobj = self.msglist[msgnum-1]             # add to cache if fetched\n        if not cacheobj.fulltext:                     # harmless if threaded\n            fulltext = self.downloadMessage(msgnum)   # 3.0: simpler coding\n            cacheobj.fulltext = fulltext\n        return cacheobj.fulltext\n    def getMessages(self, msgnums, progress=None):\n        \"\"\"\n        prefetch full raw text of multiple messages, in thread;\n        2.1: does quick check to see if msgnums still in sync;\n        we can't get here unless the index list already loaded;\n        \"\"\"\n        self.checkSynchError(self.allHdrs())          # raises except if bad\n        nummsgs = len(msgnums)                        # adds messages to cache\n        for (ix, msgnum) in enumerate(msgnums):       # some poss already there\n             if progress: progress(ix+1, nummsgs)     # only connects if needed\n             self.getMessage(msgnum)                  # but may connect > once\n    def getSize(self, msgnum):                        # encapsulate cache struct\n        return self.msglist[msgnum-1].fullsize        # it changed once already!\n    def isLoaded(self, msgnum):\n        return self.msglist[msgnum-1].fulltext\n    def allHdrs(self):\n        return [msg.hdrtext for msg in self.msglist]\n    def deleteMessages(self, msgnums, progress=None):\nPyMailGUI Implementation | 1097\"\"\"\n        if delete of all msgnums works, remove deleted entries\n        from mail cache, but don't reload either the headers list\n        or already viewed mails text: cache list will reflect the\n        changed msg nums on server;  if delete fails for any reason,\n        caller should forceably reload all hdrs next, because _some_\n        server msg nums may have changed, in unpredictable ways;\n        2.1: this now checks msg hdrs to detect out of synch msg\n        numbers, if TOP supported by mail server; runs in thread\n        \"\"\"\n        try:\n            self.deleteMessagesSafely(msgnums, self.allHdrs(), progress)\n        except mailtools.TopNotSupported:\n            mailtools.MailFetcher.deleteMessages(self, msgnums, progress)\n        # no errors: update index list\n        indexed = enumerate(self.msglist)\n        self.msglist = [msg for (ix, msg) in indexed if ix+1 not in msgnums]\nclass GuiMessageCache(MessageCache):\n    \"\"\"\n    add any GUI-specific calls here so cache usable in non-GUI apps\n    \"\"\"\n    def setPopPassword(self, appname):\n        \"\"\"\n        get password from GUI here, in main thread\n        forceably called from GUI to avoid pop ups in threads\n        \"\"\"\n        if not self.popPassword:\n            prompt = 'Password for %s on %s?' % (self.popUser, self.popServer)\n            self.popPassword = askPasswordWindow(appname, prompt)\n    def askPopPassword(self):\n        \"\"\"\n        but don't use GUI pop up here: I am run in a thread!\n        when tried pop up in thread, caused GUI to hang;\n        may be called by MailFetcher superclass, but only\n        if passwd is still empty string due to dialog close\n        \"\"\"\n        return self.popPassword\npopuputil: General-Purpose GUI Pop Ups\nExample 14-6 implements a handful of utility pop-up windows in a module, in case\nthey ever prove useful in other programs. Note that the same windows utility module\nis imported here, to give a common look-and-feel to the pop ups (icons, titles, and\nso on).\n1098 | Chapter 14:\u2002The PyMailGUI ClientExample 14-6. PP4E\\Internet\\Email\\PyMailGui\\popuputil.py\n\"\"\"\n#############################################################################\nutility windows - may be useful in other programs\n#############################################################################\n\"\"\"\nfrom tkinter import *\nfrom PP4E.Gui.Tools.windows import PopupWindow\nclass HelpPopup(PopupWindow):\n    \"\"\"\n    custom Toplevel that shows help text as scrolled text\n    source button runs a passed-in callback handler\n    3.0 alternative: use HTML file and webbrowser module\n    \"\"\"\n    myfont = 'system'  # customizable\n    mywidth = 78       # 3.0: start width\n    def __init__(self, appname, helptext, iconfile=None, showsource=lambda:0):\n        PopupWindow.__init__(self, appname, 'Help', iconfile)\n        from tkinter.scrolledtext import ScrolledText    # a nonmodal dialog\n        bar  = Frame(self)                               # pack first=clip last\n        bar.pack(side=BOTTOM, fill=X)\n        code = Button(bar, bg='beige', text=\"Source\", command=showsource)\n        quit = Button(bar, bg='beige', text=\"Cancel\", command=self.destroy)\n        code.pack(pady=1, side=LEFT)\n        quit.pack(pady=1, side=LEFT)\n        text = ScrolledText(self)                   # add Text + scrollbar\n        text.config(font=self.myfont)\n        text.config(width=self.mywidth)             # too big for showinfo\n        text.config(bg='steelblue', fg='white')     # erase on btn or return\n        text.insert('0.0', helptext)\n        text.pack(expand=YES, fill=BOTH)\n        self.bind(\"<Return>\", (lambda event: self.destroy()))\ndef askPasswordWindow(appname, prompt):\n    \"\"\"\n    modal dialog to input password string\n    getpass.getpass uses stdin, not GUI\n    tkSimpleDialog.askstring echos input\n    \"\"\"\n    win = PopupWindow(appname, 'Prompt')               # a configured Toplevel\n    Label(win, text=prompt).pack(side=LEFT)\n    entvar = StringVar(win)\n    ent = Entry(win, textvariable=entvar, show='*')    # display * for input\n    ent.pack(side=RIGHT, expand=YES, fill=X)\n    ent.bind('<Return>', lambda event: win.destroy())\n    ent.focus_set(); win.grab_set(); win.wait_window()\n    win.update()                                       # update forces redraw\n    return entvar.get()                                # ent widget is now gone\nPyMailGUI Implementation | 1099class BusyBoxWait(PopupWindow):\n    \"\"\"\n    pop up blocking wait message box: thread waits\n    main GUI event thread stays alive during wait\n    but GUI is inoperable during this wait state;\n    uses quit redef here because lower, not leftmost;\n    \"\"\"\n    def __init__(self, appname, message):\n        PopupWindow.__init__(self, appname, 'Busy')\n        self.protocol('WM_DELETE_WINDOW', lambda:0)        # ignore deletes\n        label = Label(self, text=message + '...')          # win.quit() to erase\n        label.config(height=10, width=40, cursor='watch')  # busy cursor\n        label.pack()\n        self.makeModal()\n        self.message, self.label = message, label\n    def makeModal(self):\n        self.focus_set()                                   # grab application\n        self.grab_set()                                    # wait for threadexit\n    def changeText(self, newtext):\n        self.label.config(text=self.message + ': ' + newtext)\n    def quit(self):\n        self.destroy()                                     # don't verify quit\nclass BusyBoxNowait(BusyBoxWait):\n    \"\"\"\n    pop up nonblocking wait window\n    call changeText to show progress, quit to close\n    \"\"\"\n    def makeModal(self):\n        pass\nif __name__ == '__main__':\n    HelpPopup('spam', 'See figure 1...\\n')\n    print(askPasswordWindow('spam', 'enter password'))\n    input('Enter to exit')  # pause if clicked\nwraplines: Line Split Tools\nThe module in Example 14-7 implements general tools for wrapping long lines, at either\na fixed column or the first delimiter at or before a fixed column. PyMailGUI uses this\nfile\u2019s wrapText1 function for text in view, reply, and forward windows, but this code is\npotentially useful in other programs. Run the file as a script to watch its self-test code\nat work, and study its functions to see its text-processing logic.\nExample 14-7. PP4E\\Internet\\Email\\PyMailGui\\wraplines.py\n\"\"\"\n###############################################################################\nsplit lines on fixed columns or at delimiters before a column;\nsee also: related but different textwrap standard library module (2.3+);\n4E caveat: this assumes str; supporting bytes might help avoid some decodes;\n###############################################################################\n\"\"\"\n1100 | Chapter 14:\u2002The PyMailGUI Clientdefaultsize = 80\ndef wrapLinesSimple(lineslist, size=defaultsize):\n    \"split at fixed position size\"\n    wraplines = []\n    for line in lineslist:\n        while True:\n            wraplines.append(line[:size])         # OK if len < size\n            line = line[size:]                    # split without analysis\n            if not line: break\n    return wraplines\ndef wrapLinesSmart(lineslist, size=defaultsize, delimiters='.,:\\t '):\n    \"wrap at first delimiter left of size\"\n    wraplines = []\n    for line in lineslist:\n        while True:\n            if len(line) <= size:\n                wraplines += [line]\n                break\n            else:\n                for look in range(size-1, size // 2, \u22121):       # 3.0: need // not /\n                    if line[look] in delimiters:\n                        front, line = line[:look+1], line[look+1:]\n                        break\n                else:\n                    front, line = line[:size], line[size:]\n                wraplines += [front]\n    return wraplines\n###############################################################################\n# common use case utilities\n###############################################################################\ndef wrapText1(text, size=defaultsize):         # better for line-based txt: mail\n    \"when text read all at once\"               # keeps original line brks struct\n    lines = text.split('\\n')                   # split on newlines\n    lines = wrapLinesSmart(lines, size)        # wrap lines on delimiters\n    return '\\n'.join(lines)                    # put back together\ndef wrapText2(text, size=defaultsize):         # more uniform across lines\n    \"same, but treat as one long line\"         # but loses original line struct\n    text  = text.replace('\\n', ' ')            # drop newlines if any\n    lines = wrapLinesSmart([text], size)       # wrap single line on delimiters\n    return lines                               # caller puts back together\ndef wrapText3(text, size=defaultsize):\n    \"same, but put back together\"\n    lines = wrapText2(text, size)              # wrap as single long line\n    return '\\n'.join(lines) + '\\n'             # make one string with newlines\ndef wrapLines1(lines, size=defaultsize):\n    \"when newline included at end\"\n    lines = [line[:-1] for line in lines]      # strip off newlines (or .rstrip)\n    lines = wrapLinesSmart(lines, size)        # wrap on delimiters\nPyMailGUI Implementation | 1101return [(line + '\\n') for line in lines]   # put them back\ndef wrapLines2(lines, size=defaultsize):       # more uniform across lines\n    \"same, but concat as one long line\"        # but loses original structure\n    text  = ''.join(lines)                     # put together as 1 line\n    lines = wrapText2(text)                    # wrap on delimiters\n    return [(line + '\\n') for line in lines]   # put newlines on ends\n###############################################################################\n# self-test\n###############################################################################\nif __name__ == '__main__':\n    lines = ['spam ham ' * 20 + 'spam,ni' * 20,\n             'spam ham ' * 20,\n             'spam,ni'   * 20,\n             'spam ham.ni' * 20,\n             '',\n             'spam'*80,\n             ' ',\n             'spam ham eggs']\n    sep = '-' * 30\n    print('all', sep)\n    for line in lines: print(repr(line))\n    print('simple', sep)\n    for line in wrapLinesSimple(lines): print(repr(line))\n    print('smart', sep)\n    for line in wrapLinesSmart(lines): print(repr(line))\n    print('single1', sep)\n    for line in wrapLinesSimple([lines[0]], 60): print(repr(line))\n    print('single2', sep)\n    for line in wrapLinesSmart([lines[0]], 60): print(repr(line))\n    print('combined text', sep)\n    for line in wrapLines2(lines): print(repr(line))\n    print('combined lines', sep)\n    print(wrapText1('\\n'.join(lines)))\n    assert ''.join(lines) == ''.join(wrapLinesSimple(lines, 60))\n    assert ''.join(lines) == ''.join(wrapLinesSmart(lines, 60))\n    print(len(''.join(lines)), end=' ')\n    print(len(''.join(wrapLinesSimple(lines))), end=' ')\n    print(len(''.join(wrapLinesSmart(lines))), end=' ')\n    print(len(''.join(wrapLinesSmart(lines, 60))), end=' ')\n    input('Press enter')   # pause if clicked\nhtml2text: Extracting Text from HTML (Prototype, Preview)\nExample 14-8 lists the code of the simple-minded HTML parser that PyMailGUI uses\nto extract plain text from mails whose main (or only) text part is in HTML form. This\nextracted text is used both for display and for the initial text in replies and forwards.\n1102 | Chapter 14:\u2002The PyMailGUI ClientIts original HTML form is also displayed in its full glory in a popped-up web browser\nas before.\nThis is a prototype. Because PyMailGUI is oriented toward plain text today, this parser\nis intended as a temporary workaround until a HTML viewer/editor widget solution is\nfound. Because of that, this is at best a first cut which has not been polished to any\nsignificant extent. Robustly parsing HTML in its entirety is a task well beyond the scope\nof this chapter and book. When this parser fails to render good plain text (and it will!),\nusers can still view and cut-and-paste the properly formatted text from the web browser.\nThis is also a preview. HTML parsing is not covered until Chapter 19 of this book, so\nyou\u2019ll have to take this on faith until we refer back to it in that later chapter. Unfortu-\nnately, this feature was added to PyMailGUI late in the book project, and avoiding this\nforward reference didn\u2019t seem to justify omitting the improvement altogether. For more\ndetails on HTML parsing, stay tuned for (or flip head to) Chapter 19.\nIn short, the class here provides handler methods that receive callbacks from an HTML\nparser, as tags and their content is recognized; we use this model here to save text we\u2019re\ninterested in along the way. Besides the parser class, we could also use Python\u2019s\nhtml.entities module to map more entity types than are hardcoded here\u2014another\ntool we will meet in Chapter 19.\nDespite its limitations, this example serves as a rough guide to help get you started, and\nany result it produces is certainly an improvement upon the prior edition\u2019s display and\nquoting of raw HTML.\nExample 14-8. PP4E\\Internet\\Email\\PyMailGui\\html2text.py\n\"\"\"\n################################################################\n*VERY* preliminary html-to-text extractor, for text to be\nquoted in replies and forwards, and displayed in the main\ntext display component.  Only used when the main text part\nis HTML (i.e., no alternative or other text parts to show).\nWe also need to know if this is HTML or not, but findMainText\nalready returns the main text's content type.\nThis is mostly provided as a first cut, to help get you started\non a more complete solution.  It hasn't been polished, because\nany result is better than displaying raw HTML, and it's probably\na better idea to migrate to an HTML viewer/editor widget in the\nfuture anyhow.  As is, PyMailGUI is still plain-text biased.\nIf (really, when) this parser fails to render well, users can\ninstead view and cut-and-paste from the web browser popped up\nto display the HTML.  See Chapter 19 for more on HTML parsing.\n################################################################\n\"\"\"\nfrom html.parser import HTMLParser     # Python std lib parser (sax-like model)\nclass Parser(HTMLParser):              # subclass parser, define callback methods\n    def __init__(self):                # text assumed to be str, any encoding ok\nPyMailGUI Implementation | 1103HTMLParser.__init__(self)\n        self.text = '[Extracted HTML text]'\n        self.save = 0\n        self.last = ''\n    def addtext(self, new):\n        if self.save > 0:\n            self.text += new\n            self.last = new\n    def addeoln(self, force=False):\n        if force or self.last != '\\n':\n            self.addtext('\\n')\n    def handle_starttag(self, tag, attrs):    # + others imply content start?\n        if tag in ('p', 'div', 'table', 'h1', 'h2', 'li'):\n            self.save += 1\n            self.addeoln()\n        elif tag == 'td':\n            self.addeoln()\n        elif tag == 'style':                  # + others imply end of prior?\n            self.save -= 1\n        elif tag == 'br':\n            self.addeoln(True)\n        elif tag == 'a':\n            alts = [pair for pair in attrs if pair[0] == 'alt']\n            if alts:\n                name, value = alts[0]\n                self.addtext('[' + value.replace('\\n', '') + ']')\n    def handle_endtag(self, tag):\n        if tag in ('p', 'div', 'table', 'h1', 'h2', 'li'):\n            self.save -= 1\n            self.addeoln()\n        elif tag == 'style':\n            self.save += 1\n    def handle_data(self, data):\n        data = data.replace('\\n', '')          # what about <PRE>?\n        data = data.replace('\\t', ' ')\n        if data != ' ' * len(data):\n            self.addtext(data)\n    def handle_entityref(self, name):\n        xlate = dict(lt='<', gt='>', amp='&', nbsp='').get(name, '?')\n        if xlate:\n            self.addtext(xlate)     # plus many others: show ? as is\ndef html2text(text):\n    try:\n        hp = Parser()\n        hp.feed(text)\n        return(hp.text)\n    except:\n        return text\n1104 | Chapter 14:\u2002The PyMailGUI Clientif __name__ == '__main__':\n    # to test me: html2text.py media\\html2text-test\\htmlmail1.html\n    # parse file name in commandline, display result in tkinter Text\n    # file assumed to be in Unicode platform default, but text need not be\n    import sys, tkinter\n    text = open(sys.argv[1], 'r').read()\n    text = html2text(text)\n    t = tkinter.Text()\n    t.insert('1.0', text)\n    t.pack()\n    t.mainloop()\nAfter this example and chapter had been written and finalized, I did a\nsearch for HTML-to-text translators on the Web to try to find better\noptions, and I discovered a Python-coded solution which is much more\ncomplete and robust than the simple prototype script here. Regrettably,\nI also discovered that this system is named the same as the script\nlisted here!\nThis was unintentional and unforeseen (alas, developers are predis-\nposed to think alike). For details on this more widely tested and much\nbetter alternative, search the Web for html2text. It\u2019s open source, but\nfollows the GPL license, and is available only for Python 2.X at this\nwriting (e.g., it uses the 2.X sgmllib which has been removed in favor\nof the new html.parser in 3.X). Unfortunately, its GPL license may raise\ncopyright concerns if shipped with PyMailGUI in this book\u2019s example\npackage or otherwise; worse, its 2.X status means it cannot be used at\nall with this book\u2019s 3.X examples today.\nThere are additional plain-text extractor options on the Web worth\nchecking out, including BeautifulSoup and yet another named\nhtml2text.py (no, really!). They also appear to be available for just 2.X\ntoday, though naturally, this story may change by the time you read this\nnote. There\u2019s no reason to reinvent the wheel, unless existing wheels\ndon\u2019t fit your cart!\nmailconfig: User Configurations\nIn Example 14-9, PyMailGUI\u2019s mailconfig user settings module is listed. This program\nhas its own version of this module because many of its settings are unique for PyMail-\nGUI. To use the program for reading your own email, set its initial variables to reflect\nyour POP and SMTP server names and login parameters. The variables in this module\nalso allow the user to tailor the appearance and operation of the program without\nfinding and editing actual program logic.\nAs is, this is a single-account configuration. We could generalize this module\u2019s code to\nallow for multiple email accounts, selected by input at the console when first imported;\nPyMailGUI Implementation | 1105in an upcoming section we\u2019ll see a different approach that allows this module to be\nextended externally.\nExample 14-9. PP4E\\Internet\\Email\\PyMailGui\\mailconfig.py\n\"\"\"\n################################################################################\nPyMailGUI user configuration settings.\nEmail scripts get their server names and other email config options from\nthis module: change me to reflect your machine names, sig, and preferences.\nThis module also specifies some widget style preferences applied to the GUI,\nas well as message Unicode encoding policy and more in version 3.0.  See\nalso: local textConfig.py, for customizing PyEdit pop-ups made by PyMailGUI.\nWarning: PyMailGUI won't run without most variables here: make a backup copy!\nCaveat: somewhere along the way this started using mixed case inconsistently...;\nTBD: we could get some user settings from the command line too, and a configure\ndialog GUI would be better, but this common module file suffices for now.\n################################################################################\n\"\"\"\n#-------------------------------------------------------------------------------\n# (required for load, delete) POP3 email server machine, user;\n#-------------------------------------------------------------------------------\n#popservername = '?Please set your mailconfig.py attributes?'\npopservername = 'pop.secureserver.net'             # see altconfigs/ for others\npopusername   = 'PP4E@learning-python.com'\n#-------------------------------------------------------------------------------\n# (required for send) SMTP email server machine name;\n# see Python smtpd module for a SMTP server class to run locally ('localhost');\n# note: your ISP may require that you be directly connected to their system:\n# I once could email through Earthlink on dial up, but not via Comcast cable;\n#-------------------------------------------------------------------------------\nsmtpservername = 'smtpout.secureserver.net'\n#-------------------------------------------------------------------------------\n# (optional) personal information used by PyMailGUI to fill in edit forms;\n# if not set, does not fill in initial form values;\n# signature  -- can be a triple-quoted block, ignored if empty string;\n# address    -- used for initial value of \"From\" field if not empty,\n# no longer tries to guess From for replies--varying success;\n#-------------------------------------------------------------------------------\nmyaddress   = 'PP4E@learning-python.com'\nmysignature = ('Thanks,\\n'\n               '--Mark Lutz  (http://learning-python.com, http://rmi.net/~lutz)')\n#-------------------------------------------------------------------------------\n# (may be required for send) SMTP user/password if authenticated;\n# set user to None or '' if no login/authentication is required, and set\n1106 | Chapter 14:\u2002The PyMailGUI Client# pswd to name of a file holding your SMTP password, or an empty string to\n# force programs to ask (in a console, or GUI)\n#-------------------------------------------------------------------------------\nsmtpuser  = None                           # per your ISP\nsmtppasswdfile  = ''                       # set to '' to be asked\n#smtpuser = popusername\n#-------------------------------------------------------------------------------\n# (optional) PyMailGUI: name of local one-line text file with your POP\n# password; if empty or file cannot be read, pswd is requested when first\n# connecting; pswd not encrypted: leave this empty on shared machines;\n# PyMailCGI always asks for pswd (runs on a possibly remote server);\n#-------------------------------------------------------------------------------\npoppasswdfile  = r'c:\\temp\\pymailgui.txt'      # set to '' to be asked\n#-------------------------------------------------------------------------------\n# (required) local file where sent messages are always saved;\n# PyMailGUI 'Open' button allows this file to be opened and viewed;\n# don't use '.' form if may be run from another dir: e.g., pp4e demos\n#-------------------------------------------------------------------------------\n#sentmailfile = r'.\\sentmail.txt'             # . means in current working dir\n#sourcedir    = r'C:\\...\\PP4E\\Internet\\Email\\PyMailGui\\'\n#sentmailfile = sourcedir + 'sentmail.txt'\n# determine automatically from one of my source files\nimport wraplines, os\nmysourcedir   = os.path.dirname(os.path.abspath(wraplines.__file__))\nsentmailfile  = os.path.join(mysourcedir, 'sentmail.txt')\n#-------------------------------------------------------------------------------\n# (defunct) local file where pymail saves POP mail (full text);\n# PyMailGUI instead asks for a name in GUI with a pop-up dialog;\n# Also asks for Split directory, and part buttons save in ./TempParts;\n#-------------------------------------------------------------------------------\n#savemailfile = r'c:\\temp\\savemail.txt'       # not used in PyMailGUI: dialog\n#-------------------------------------------------------------------------------\n# (optional) customize headers displayed in PyMailGUI list and view windows;\n# listheaders replaces default, viewheaders extends it; both must be tuple of\n# strings, or None to use default hdrs;\n#-------------------------------------------------------------------------------\nlistheaders = ('Subject', 'From', 'Date', 'To', 'X-Mailer')\nviewheaders = ('Bcc',)\n#-------------------------------------------------------------------------------\n# (optional) PyMailGUI fonts and colors for text server/file message list\n# windows, message content view windows, and view window attachment buttons;\n# use ('family', size, 'style') for font; 'colorname' or hexstr '#RRGGBB' for\nPyMailGUI Implementation | 1107# color (background, foreground);  None means use defaults;  font/color of\n# view windows can also be set interactively with texteditor's Tools menu;\n# see also the setcolor.py example in the GUI part (ch8) for custom colors;\n#-------------------------------------------------------------------------------\nlistbg   = 'indianred'                  # None, 'white', '#RRGGBB'\nlistfg   = 'black'\nlistfont = ('courier', 9, 'bold')       # None, ('courier', 12, 'bold italic')\n                                        # use fixed-width font for list columns\nviewbg     = 'light blue'               # was '#dbbedc'\nviewfg     = 'black'\nviewfont   = ('courier', 10, 'bold')\nviewheight = 18                         # max lines for height when opened (20)\npartfg   = None\npartbg   = None\n# see Tk color names: aquamarine paleturquoise powderblue goldenrod burgundy ....\n#listbg = listfg = listfont = None\n#viewbg = viewfg = viewfont = viewheight = None      # to use defaults\n#partbg = partfg = None\n#-------------------------------------------------------------------------------\n# (optional) column at which mail's original text should be wrapped for view,\n# reply, and forward;  wraps at first delimiter to left of this position;\n# composed text is not auto-wrapped: user or recipient's mail tool must wrap\n# new text if desired; to disable wrapping, set this to a high value (1024?);\n#-------------------------------------------------------------------------------\nwrapsz = 90\n#-------------------------------------------------------------------------------\n# (optional) control how PyMailGUI opens mail parts in the GUI;\n# for view window Split actions and attachment quick-access buttons;\n# if not okayToOpenParts, quick-access part buttons will not appear in\n# the GUI, and Split saves parts in a directory but does not open them;\n# verifyPartOpens used by both Split action and quick-access buttons:\n# all known-type parts open automatically on Split if this set to False;\n# verifyHTMLTextOpen used by web browser open of HTML main text part:\n#-------------------------------------------------------------------------------\nokayToOpenParts    = True      # open any parts/attachments at all?\nverifyPartOpens    = False     # ask permission before opening each part?\nverifyHTMLTextOpen = False     # if main text part is HTML, ask before open?\n#-------------------------------------------------------------------------------\n# (optional) the maximum number of quick-access mail part buttons to show\n# in the middle of view windows; after this many, a \"...\" button will be\n# displayed, which runs the \"Split\" action to extract additional parts;\n#-------------------------------------------------------------------------------\nmaxPartButtons = 8             # how many part buttons in view windows\n# *** 3.0 additions follow ***\n1108 | Chapter 14:\u2002The PyMailGUI Client#-------------------------------------------------------------------------------\n# (required, for fetch) the Unicode encoding used to decode fetched full message\n# bytes, and to encode and decode message text stored in text-mode save files; see\n# the book's Chapter 13 for details: this is a limited and temporary approach to\n# Unicode encodings until a new bytes-friendly email package parser is provided\n# which can handle Unicode encodings more accurately on a message-level basis;\n# note: 'latin1' (an 8-bit encoding which is a superset of 7-bit ascii) was\n# required to decode message in some old email save files I had, not 'utf8';\n#-------------------------------------------------------------------------------\nfetchEncoding = 'latin-1'    # how to decode and store full message text (ascii?)\n#-------------------------------------------------------------------------------\n# (optional, for send) Unicode encodings for composed mail's main text plus all\n# text attachments; set these to None to be prompted for encodings on mail send,\n# else uses values here across entire session; default='latin-1' if GUI Cancel;\n# in all cases, falls back on UTF-8 if your encoding setting or input does not\n# work for the text being sent (e.g., ascii chosen for reply to non-ascii text,\n# or non-ascii attachments); the email package is pickier than Python about\n# names: latin-1 is known (uses qp MIME), but latin1 isn't (uses base64 MIME);\n# set these to sys.getdefaultencoding() result to choose the platform default;\n# encodings of text parts of fetched email are automatic via message headers;\n#-------------------------------------------------------------------------------\nmainTextEncoding       = 'ascii'   # main mail body text part sent (None=ask)\nattachmentTextEncoding = 'ascii'   # all text part attachments sent (utf-8, latin-1)\n#-------------------------------------------------------------------------------\n# (optional, for send) set this to a Unicode encoding name to be applied to\n# non-ASCII headers, as well as non-ASCII names in email addresses in headers,\n# in composed messages when they are sent;  None means use the UTF-8 default,\n# which should work for most use cases; email names that fail to decode are\n# dropped (the address part is used);  note that header decoding is performed\n# automatically for display, according to header content, not user setting;\n#-------------------------------------------------------------------------------\nheadersEncodeTo = None     # how to encode non-ASCII headers sent (None=UTF-8)\n#-------------------------------------------------------------------------------\n# (optional) select text, HTML, or both versions of the help document;\n# always shows one or the other: displays HTML if both of these are turned off\n#-------------------------------------------------------------------------------\nshowHelpAsText = True      # scrolled text, with button for opening source files\nshowHelpAsHTML = True      # HTML in a web browser, without source file links\n#-------------------------------------------------------------------------------\n# (optional) if True, don't show a selected HTML text message part in a PyEdit\n# popup too if it is being displayed in a web browser; if False show both, to\n# see Unicode encoding name and effect in a  text widget (browser may not know);\n#-------------------------------------------------------------------------------\nskipTextOnHtmlPart = False       # don't show html part in PyEdit popup too\n#-------------------------------------------------------------------------------\nPyMailGUI Implementation | 1109# (optional) the maximum number of mail headers or messages that will be\n# downloaded on each load request; given this setting N, PyMailGUI fetches at\n# most N of the most recently arrived mails; older mails outside this set are\n# not fetched from the server, but are displayed as empty/dummy emails; if this\n# is assigned to None (or 0), loads will have no such limit; use this if you\n# have very many mails in your inbox, and your Internet or mail server speed\n# makes full loads too slow to be practical; PyMailGUI also loads only\n# newly-arrived headers, but this setting is independent of that feature;\n#-------------------------------------------------------------------------------\nfetchlimit = 50            # maximum number headers/emails to fetch on loads\n#-------------------------------------------------------------------------------\n# (optional) initial width, height of mail index lists (chars x lines);  just\n# a convenience, since the window can be resized/expanded freely once opened;\n#-------------------------------------------------------------------------------\nlistWidth = None           # None = use default 74\nlistHeight = None          # None = use default 15\n#-------------------------------------------------------------------------------\n# (optional, for reply) if True, the Reply operation prefills the reply's Cc\n# with all original mail recipients, after removing duplicates and the new sender;\n# if False, no CC prefill occurs, and the reply is configured to reply to the\n# original sender only; the Cc line may always be edited later, in either case.\n#-------------------------------------------------------------------------------\nrepliesCopyToAll = True   # True=reply to sender + all recipients, else sender\n#end\ntextConfig: Customizing Pop-Up PyEdit Windows\nThe prior section\u2019s mailconfig module provides user settings for tailoring the PyEdit\ncomponent used to view and edit main mail text, but PyMailGUI also uses PyEdit to\ndisplay other kinds of pop-up text, including raw mail text, some text attachments, and\nsource code in its help system. To customize display for these pop ups, PyMailGUI\nrelies on PyEdit\u2019s own utility, which attempts to load a module like that in Exam-\nple 14-10 from the client application\u2019s own directory. By contrast, PyEdit\u2019s Unicode\nsettings are loaded from the single textConfig module in its own package\u2019s directory\nsince they are not expected to vary across a platform (see Chapter 11 for more details).\nExample 14-10. PP4E\\Internet\\Email\\PyMailGui\\textConfig.py\n\"\"\"\ncustomize PyEdit pop-up windows other than the main mail text component;\nthis module (not its package) is assumed to be on the path for these settings;\nPyEdit Unicode settings come from its own package's textConfig.py, not this;\n\"\"\"\nbg = 'beige'                        # absent=white; colorname or RGB hexstr\nfg = 'black'                        # absent=black;  e.g., 'beige', '#690f96'\n1110 | Chapter 14:\u2002The PyMailGUI Client# etc -- see PP4E\\Gui\\TextEditor\\textConfig.py\n# font = ('courier', 9, 'normal')\n# height = 20                       # Tk default: 24 lines\n# width  = 80                       # Tk default: 80 characters\nPyMailGUIHelp: User Help Text and Display\nFinally, Example 14-11 lists the module that defines the text displayed in PyMailGUI\u2019s\nhelp pop up as one triple-quoted string, as well as a function for displaying the HTML\nrendition of this text. The HTML version of help itself is in a separate file not listed in\nfull here but included in the book\u2019s examples package.\nIn fact, I\u2019ve omitted most of the help text string, too, to conserve space here (it spanned\n11 pages in the prior edition, and would be longer in this one!). For the full story, see\nthis module in the examples package, or run PyMailGUI live and click the help bar at\nthe top of its main server list window to learn more about how PyMailGUI\u2019s interface\noperates. If fact, you probably should; the help display may explain some properties of\nPyMailGUI not introduced by the demo and other material earlier in this chapter.\nThe HTML rendition of help includes section links, and is popped up in a web browser.\nBecause the text version also is able to pop up source files and minimizes external\ndependencies (HTML fails if no browser can be located), both the text and HTML\nversions are provided and selected by users in the mailconfig module. Other schemes\nare possible (e.g., converting HTML to text by parsing as a fallback option), but they\nare left as suggested improvements.\nExample 14-11. PP4E\\Internet\\PyMailGui\\PyMailGuiHelp.py (partial)\n\"\"\"\n##########################################################################\nPyMailGUI help text string and HTML display function;\nHistory: this display began as an info box pop up which had to be\nnarrow for Linux; it later grew to use scrolledtext with buttons\ninstead; it now also displays an HTML rendition in a web browser;\n2.1/3E: the help string is stored in this separate module to avoid\ndistracting from executable code.  As coded, we throw up this text\nin a simple scrollable text box; in the future, we might instead\nuse an HTML file opened with a browser (use webbrowser module, or\nrun a \"browser help.html\" or DOS \"start help.html\" with os.system);\n3.0/4E: the help text is now also popped up in a web browser in HTML\nform, with lists, section links, and separators; see the HTML file\nPyMailGuiHelp.html in the examples package for the simple HTML\ntranslation of the help text string here, popped up in a browser;\nboth the scrolled text widget and HTML browser forms are currently\nsupported: change mailconfig.py to use the flavor(s) you prefer;\n##########################################################################\n\"\"\"\nPyMailGUI Implementation | 1111# new HTML help for 3.0/4E\nhelpfile = 'PyMailGuiHelp.html'     # see book examples package\ndef showHtmlHelp(helpfile=helpfile):\n    \"\"\"\n    3.0: popup HTML version of help file in a local web browser via webbrowser;\n    this module is importable, but html file might not be in current working dir\n    \"\"\"\n    import os, webbrowser\n    mydir = os.path.dirname(__file__)       # dir of this module's filename\n    mydir = os.path.abspath(mydir)          # make absolute: may be .., etc\n    webbrowser.open_new('file://' + os.path.join(mydir, helpfile))\n##########################################################################\n# string for older text display: client responsible for GUI construction\n##########################################################################\nhelptext = \"\"\"PyMailGUI, version 3.0\nMay, 2010 (2.1 January, 2006)\nProgramming Python, 4th Edition\nMark Lutz, for O'Reilly Media, Inc.\nPyMailGUI is a multiwindow interface for processing email, both online and\noffline.  Its main interfaces include one list window for the mail server,\nzero or more list windows for mail save files, and multiple view windows for\ncomposing or viewing emails selected in a list window.  On startup, the main\n(server) list window appears first, but no mail server connection is attempted\nuntil a Load or message send request.  All PyMailGUI windows may be resized,\nwhich is especially useful in list windows to see additional columns.\nNote: To use PyMailGUI to read and write email of your own, you must change\nthe POP and SMTP server names and login details in the file mailconfig.py,\nlocated in PyMailGUI's source-code directory.  See section 11 for details.\nContents:\n0)  VERSION ENHANCEMENTS\n1)  LIST WINDOW ACTIONS\n2)  VIEW WINDOW ACTIONS\n3)  OFFLINE PROCESSING\n4)  VIEWING TEXT AND ATTACHMENTS\n5)  SENDING TEXT AND ATTACHMENTS\n6)  MAIL TRANSFER OVERLAP\n7)  MAIL DELETION\n8)  INBOX MESSAGE NUMBER SYNCHRONIZATION\n9)  LOADING EMAIL\n10) UNICODE AND INTERNATIONALIZATION SUPPORT\n11) THE mailconfig CONFIGURATION MODULE\n12) DEPENDENCIES\n13) MISCELLANEOUS HINTS (\"Cheat Sheet\")\n...rest of file omitted...\n13) MISCELLANEOUS HINTS (\"Cheat Sheet\")\n1112 | Chapter 14:\u2002The PyMailGUI Client- Use ',' between multiple addresses in To, Cc, and Bcc headers.\n- Addresses may be given in the full '\"name\" <addr>' form.\n- Payloads and headers are decoded on fetches and encoded on sends.\n- HTML mails show extracted plain text plus HTML in a web browser.\n- To, Cc, and Bcc receive composed mail, but no Bcc header is sent.\n- If enabled in mailconfig, Bcc is prefilled with sender address.\n- Reply and Fwd automatically quote the original mail text.\n- If enabled, replies prefill Cc with all original recipients.\n- Attachments may be added for sends and are encoded as required.\n- Attachments may be opened after View via Split or part buttons.\n- Double-click a mail in the list index to view its raw text.\n- Select multiple mails to process as a set: Ctrl|Shift + click, or All.\n- Sent mails are saved to a file named in mailconfig: use Open to view.\n- Save pops up a dialog for selecting a file to hold saved mails.\n- Save always appends to the chosen save file, rather than erasing it.\n- Split asks for a save directory; part buttons save in ./TempParts.\n- Open and save dialogs always remember the prior directory.\n- Use text editor's Save to save a draft of email text being composed.\n- Passwords are requested if/when needed, and not stored by PyMailGUI.\n- You may list your password in a file named in mailconfig.py.\n- To print emails, \"Save\" to a text file and print with other tools.\n- See the altconfigs directory for using with multiple email accounts.\n- Emails are never deleted from the mail server automatically.\n- Delete does not reload message headers, unless it fails.\n- Delete checks your inbox to make sure it deletes the correct mail.\n- Fetches detect inbox changes and may automatically reload the index.\n- Any number of sends and disjoint fetches may overlap in time.\n- Click this window's Source button to view PyMailGUI source-code files.\n- Watch http://www.rmi.net/~lutz for updates and patches\n- This is an Open Source system: change its code as you like.\n\"\"\"\nif __name__ == '__main__':\n    print(helptext)                   # to stdout if run alone\n    input('Press Enter key')          # pause in DOS console pop ups\nSee the examples package for the HTML help file, the first few lines of which are shown\nin Example 14-12; it\u2019s a simple translation of the module\u2019s help text string (adding a\nbit more pizzazz to this page is left in the suggested exercise column).\nExample 14-12. PP4E\\Internet\\PyMailGui\\PyMailGuiHelp.html (partial)\n<HTML>\n<TITLE>PyMailGUI 3.0 Help</TITLE>\n<!-- TO DO: add pictures, screen shots, and such --!>\n<BODY>\n<H1 align=center>PyMailGUI, Version 3.0</H1>\n<P align=center>\nPyMailGUI Implementation | 1113<B><I>May, 2010 (2.1 January, 2006)</I></B><BR>\n<B><I>Programming Python, 4th Edition</I></B><BR>\n<B><I>Mark Lutz, for O'Reilly Media, Inc.</I></B>\n<P>\n<I>PyMailGUI</I> is a multiwindow interface for processing email, both online and\n...rest of file omitted...\naltconfigs: Configuring for Multiple Accounts\nThough not an \u201cofficial\u201d part of the system, I use a few additional short files to launch\nand test it. If you have multiple email accounts, it can be inconvenient to change a\nconfiguration file every time you want to open one in particular. Moreover, if you open\nmultiple PyMailGUI sessions for your accounts at the same time, it would be better if\nthey could use custom appearance and behavior schemes to make them distinct.\nTo address this, the altconfigs directory in the examples source directory provides a\nsimple way to select an account and configurations for it at start-up time. It defines a\nnew top-level script which tailors the module import search path, along with a mail\nconfig that prompts for and loads a custom configuration module whose suffix is\nnamed by console input. A launcher script is also provided to run without module\nsearch path configurations\u2014from PyGadgets or a desktop shortcut, for example, with-\nout requiring PYTHONPATH settings for the PP4E root. Examples 14-13 through\n14-17 list the files involved.\nExample 14-13. PP4E\\Internet\\PyMailGui\\altconfigs\\PyMailGui.py\nimport sys                             # ..\\PyMailGui.py or 'book' for book configs\nsys.path.insert(1, '..')               # add visibility for real dir\nexec(open('../PyMailGui.py').read())   # do this, but get mailconfig here\nExample 14-14. PP4E\\Internet\\PyMailGui\\altconfigs\\mailconfig.py\nabove = open('../mailconfig.py').read()       # copy version above here (hack?)\nopen('mailconfig_book.py', 'w').write(above)  # used for 'book' and as others' base\nacct = input('Account name?')                 # book, rmi, train\nexec('from mailconfig_%s import *' % acct)    # . is first on sys.path\nExample 14-15. PP4E\\Internet\\PyMailGui\\altconfigs\\mailconfig_rmi.py\nfrom mailconfig_book import *                 # get base in . (copied from ..)\npopservername = 'pop.rmi.net'                 # this is a big inbox: 4800 emails!\npopusername   = 'lutz'\nmyaddress     = 'lutz@rmi.net'\nlistbg = 'navy'\nlistfg = 'white'\nlistHeight = 20         # higher initially\nviewbg = '#dbbedc'\nviewfg = 'black'\nwrapsz = 80             # wrap at 80 cols\nfetchlimit = 300        # load more headers\n1114 | Chapter 14:\u2002The PyMailGUI ClientExample 14-16. PP4E\\Internet\\PyMailGui\\altconfigs\\mailconfig_train.py\nfrom mailconfig_book import *                 # get base in . (copied from ..)\npopusername = 'lutz@learning-python.com'\nmyaddress   = 'lutz@learning-python.com'\nlistbg = 'wheat'                              # goldenrod, dark green, beige\nlistfg = 'navy'                               # chocolate, brown,...\nviewbg = 'aquamarine'\nviewfg = 'black'\nwrapsz = 80\nviewheaders = None      # no Bcc\nfetchlimit = 100        # load more headers\nExample 14-17. PP4E\\Internet\\PyMailGui\\altconfigs\\launch_PyMailGui.py\n# to run without PYTHONPATH setup (e.g., desktop)\nimport os                                         # Launcher.py is overkill\nos.environ['PYTHONPATH'] = r'..\\..\\..\\..\\..'      # hmm; generalize me\nos.system('PyMailGui.py')                         # inherits path env var\nAccount files like those in Examples 14-15 and 14-16 can import the base \u201cbook\u201d\nmodule (to extend it) or not (to replace it entirely). To use these alternative account\nconfigurations, run a command line like the following or run the self-configuring\nlauncher script in Example 14-17 from any location. Either way, you can open these\naccount\u2019s windows to view the included saved mails, but be sure to change configura-\ntions for your own email accounts and preferences first if you wish to fetch or send mail\nfrom these clients:\nC:\\...\\PP4E\\Internet\\Email\\PyMailGui\\altconfigs> PyMailGui.py\nAccount name?rmi\nAdd a \u201cstart\u201d to the beginning of this command to keep your console alive on Windows\nso you can open multiple accounts (try a \u201c&\u201d at the end on Unix). Figure 14-45 earlier\nshows the scene with all three of my accounts open in PyMailGUI. I keep them open\nperpetually on my desktop, since a Load fetches just newly arrived headers no matter\nhow long the GUI may have sat dormant, and a Send requires nothing to be loaded at\nall. While they\u2019re open, the alternative color schemes make the accounts\u2019 windows\ndistinct. A desktop shortcut to the launcher script makes opening my accounts even\neasier.\nAs is, account names are only requested when this special PyMailGui.py file is run\ndirectly, and not when the original file is run directly or by program launchers (in which\ncase there may be no stdin to read). Extending a module like mailconfig which might\nbe imported in multiple places this way turns out to be an interesting task (which is\nlargely why I don\u2019t consider its quick solution here to be an official end-user feature).\nFor instance, there are other ways to allow for multiple accounts, including:\n\u2022 Changing the single mailconfig module in-place\n\u2022 Importing alternative modules and storing them as key \u201cmailconfig\u201d in sys.modules\nPyMailGUI Implementation | 1115\u2022 Copying alternative module variables to mailconfig attributes using __dict__ and\nsetattr\n\u2022 Using a class for configuration to better support customization in subclasses\n\u2022 Issuing a pop-up in the GUI to prompt for an account name after or before the\nmain window appears\nAnd so on. The separate subdirectory scheme used here was chosen to minimize im-\npacts on existing code in general; to avoid changes to the existing mailconfig module\nspecifically (which works fine for the single account case); to avoid requiring extra user\ninput of any kind in single account cases; and to allow for the fact that an \u201cimport\nmodule1 as module2\u201d statement doesn\u2019t prevent \u201cmodule1\u201d from being imported di-\nrectly later. This last point is more fraught with peril than you might expect\u2014importing\na customized version of a module is not merely a matter of using the \u201cas\u201d renaming\nextension:\nimport m1 as m2      # custom import: load m1 as m2 alternative\nprint(m2.attr)       # prints attr in m1.py\nimport m2            # later imports: loads m2.py anyhow!\nprint(m2.attr)       # prints attr in m2.py\nIn other words, this is a quick-and-dirty solution that I originally wrote for testing\npurposes, and it seems a prime candidate for improvement\u2014along with the other ideas\nin the next section\u2019s chapter wrap up.\nIdeas for Improvement\nAlthough I use the 3.0 version of PyMailGUI as is on a regular basis for both personal\nand business communications, there is always room for improvement to software, and\nthis system is no exception. If you wish to experiment with its code, here are a few\nsuggested projects to close out this chapter:\nColumn sorts and list layout\nMail list windows could be sorted by columns on demand. This may require a more\nsophisticated list window structure which presents columns more distinctly. The\ncurrent display of mail lists seems like the most obvious candidate for cosmetic\nupgrade in general, and any column sorting solution would likely address this as\nwell. tkinter extensions such as the Tix HList widget may show promise here, and\nthe third-party TkinterTreectrl supports multicolumn sortable listboxes, too, but\nis available only for Python 2.X today; consult the Web and other resources for\npointers and details.\nMail save file (and sent file) size\nThe implementation of save-mail files limits their size by loading them into memory\nall at once; a DBM keyed-access implementation may work around this constraint.\nSee the list windows module comments for ideas. This also applies to sent-mail\n1116 | Chapter 14:\u2002The PyMailGUI Clientsave files, though the user can limit their sizes with periodic deletions; users might\nalso benefit from a prompt for deletions if they grow too large.\nEmbedded links\nHyperlink URLs within messages could be highlighted visually and made to spawn\na web browser automatically when clicked by using the launcher tools we met in\nthe GUI and system parts of this book (tkinter\u2019s text widget supports links directly).\nHelp text redundancy\nIn this version, the help text had grown so large that it is also implemented as\nHTML and displayed in a web browser using Python\u2019s webbrowser module (instead\nof or in addition to text, per mailconfig settings). That means there are currently\ntwo copies of the basic help text: simple text and HTML. This is less than ideal\nfrom a maintenance perspective going forward.\nWe may want to either drop the simple text version altogether, or attempt to extract\nthe simple text from the HTML with Python\u2019s html.parser module to avoid re-\ndundant copies; see Chapter 19 for more on HTML parsing in general, and see\nPyMailGUI\u2019s new html2text module for a plain-text extraction tool prototype. The\nHTML help version also does not include links to display source files; these could\nbe inserted into the HTML automatically with string formatting, though it\u2019s not\nclear what all browsers will do with Python source code (some may try to run it).\nMore threading contexts\nMessage Save and Split file writes could also be threaded for worst-case scenarios.\nFor pointers on making Saves parallel, see the comments in the file class of List\nWindows.py; there may be some subtle issues that require both thread locks and\ngeneral file locking for potentially concurrent updates. List window index fills\nmight also be threaded for pathologically large mailboxes and woefully slow ma-\nchines (optimizing to avoid reparsing headers may help here, too).\nAttachment list deletes\nThere is currently no way to delete an attachment once it has been added in com-\npose windows. This might be supported by adding quick-access part buttons to\ncompose windows, too, which could verify and delete the part when clicked.\nSpam filtering\nWe could add an automatic spam filter for mails fetched, in addition to any pro-\nvided at the email server or ISP. The Python-based SpamBayes might help. This is\noften better implemented by servers than clients, but not all ISPs filter spam.\nImprove multiple account usage\nPer the prior section, the current system selects one of multiple email accounts and\nuses its corresponding mail configuration module by running special code in the\naltconfigs subdirectory. This works for a book example, but it would be fairly\nstraightforward to improve for broader audiences.\nIdeas for Improvement | 1117Increased visibility for sent file\nWe may want to add an explicit button for opening the sent-mails file. PyMailGUI\nalready does save sent messages to a text file automatically, which may be opened\ncurrently with the list window\u2019s Open button. Frankly, though, this feature may\nbe a too-well-kept secret\u2014I forgot about it myself when I revisited the program\nfor this edition! It might also be useful to allow sent-mail saves to be disabled in\nmailconfig for users who might never delete from this file (it can grow large fairly\nquickly; see the earlier prompt-for-deletion suggestion as well).\nThread queue speed tuning\nAs mentioned when describing version 3.0 changes, the thread queue has been\nsped up by as much as a factor of 10 in this version to quicken initial header down-\nloads. This is achieved both by running more than one callback per timer event\nand scheduling timer events to occur twice as often as before. Checking the queue\ntoo often, however, might increase CPU utilization beyond acceptable levels on\nsome machines. On my Windows laptop, this overhead is negligible (the program\u2019s\nCPU utilization is 0% when idle), but you may want to tune this if it\u2019s significant\non your platform.\nSee the list windows code for speed settings, and threadtools.py in Chapter 10 for\nthe base code. In general, increasing the number of callbacks per event and de-\ncreasing timer frequency will decrease CPU drain without sacrificing responsive-\nness. (And if I had a nickel for every time I said that\u2026)\nMailing lists\nWe could add support for mailing lists, allowing users to associate multiple email\naddresses with a saved list name. On sends to a list name, the mail would be sent\nto all on the list (the To addresses passed to smtplib), but the email list could be\nused for the email\u2019s To header line. See Chapter 13\u2019s SMTP coverage for mailing\nlist\u2013related examples.\nHTML main text views and edits\nPyMailGUI is still oriented toward supporting only plain text for the main text of\na message, despite the fact that some mailers today are more HTML-biased in this\nregard. This partly stems from the fact that PyMailGUI uses a simple tkinter Text\nwidget for main text composition. PyMailGUI can display such messages\u2019 HTML\nin a popped-up web browser, and it attempts to extract text from the HTML for\ndisplay per the next note, but it doesn\u2019t come with its own HTML editor. Fully\nsupporting HTML for main message text will likely require a tkinter extension (or,\nregrettably, a port to another GUI toolkit with working support for this feature).\nHTML parser honing\nOn a related note, as described earlier, this version includes a simple-minded\nHTML parser, applied to extract text from HTML main (or only) text parts when\nthey are displayed or quoted in replies and forwards. As also mentioned earlier,\nthis parser is nowhere near complete or robust; for production-level quality, this\nwould have to be improved by testing over a large set of HTML emails. Better yet,\n1118 | Chapter 14:\u2002The PyMailGUI Clientwatch for a Python 3.X\u2013compatible version of more robust and complete open\nsource alternatives, such as the html2text.py same-named third-party utility de-\nscribed in this chapter\u2019s earlier note. The open source BeautifulSoup system offers\nanother lenient and forgiving HTML parser, but is based on SGMLParser tools\navailable in 2.X only (removed in 3.X).\nText/HTML alternative mails\nAlso in the HTML department, there is presently no support for sending both text\nand HTML versions of a mail as a MIME multipart/alternative message\u2014a popular\nscheme which supports both text- and HTML-based clients and allows users to\nchoose which to use. Such messages can be viewed (both parts are offered in the\nGUI), but cannot be composed. Again, since there is no support for HTML editing\nanyhow, this is a moot point; if such an editor is ever added, we\u2019d need to support\nthis sort of mail structure in mailtools message object construction code and re-\nfactor parts of its current send logic so that it can be shared.\nInternationalized headers throw list columns off\nAs is so often true in software, one feature added in this version broke another\nalready present: the fonts used for display of some non-ASCII Unicode header fields\nis large enough to throw off the fixed-width columns in mail index list windows.\nThey rely on the assumption that N characters is always the same width among all\nmails, and this is no longer true for some Chinese and other character set encodings.\nThis isn\u2019t a showstopper\u2014it only occurs when some i18n headers are displayed,\nand simply means that \u201c|\u201d column separators are askew for such mails only, but\ncould still be addressed. The fix here is probably to move to a more sophisticated\nlist display, and might be resolved as a side effect of allowing for the column sorts\ndescribed earlier.\nAddress books\nPyMailGUI has no notion of automatically filling in an email address from an ad-\ndress book, as many modern email clients do. Adding this would be an interesting\nextension; low-level keyboard event binding may allow matching as addresses are\ntyped, and Python\u2019s pickle and shelve modules of Chapters 1 and 17 might come\nin handy for data storage.\nSpelling checker\nThere is currently no spelling checker of the sort most email programs have today.\nThis could be added in PyMailGUI, but it would probably be more appropriate to\nadd it in the PyEdit text edit component/program that it uses, so the spell-checking\nwould be inherited by all PyEdit clients. A quick web search reveals a variety of\noptions, including the interesting PyEnchant third-party package, none of which\nwe have space to explore here.\nMail searches\nSimilarly, there is no support for searching emails\u2019 content (headers or bodies) for\na given string. It\u2019s not clear how this should be provided given that the system\nfetches and caches just message headers until a mail is requested, but searching\nIdeas for Improvement | 1119large inboxes can be convenient. As is, this can be performed manually by running\na Save to store fetched mails in a text file and searching in that file externally.\nFrozen binary distribution\nAs a desktop program, PyMailGUI seems an ideal candidate for packing as a self-\ncontained frozen binary executable, using tools such as PyInstaller, Py2Exe, and\nothers. When distributed this way, users need not install Python, since the Python\nruntime is embedded in the executable.\nSelecting Reply versus Reply-All in the GUI\nAs described in the 3.0 changes overview earlier, in this version, Reply by default\nnow copies all the original mail\u2019s recipients by prefilling the Cc line, in addition to\nreplying to the original sender. This Cc feature can be turned off in mailconfig\nbecause it may not be desirable in all cases. Ideally, though, this should be select-\nable in the GUI on a mail-by-mail basis, not per session. Adding another button to\nlist windows for ReplyAll would suffice; since this feature was added too late in\nthis project for GUI changes, though, this will have to be relegated to the domain\nof suggested exercise.\nPropagating attachments?\nWhen replying to or forwarding an email, PyMailGUI discards any attachments\non the original message. This is by design, partly because there is currently no way\nto delete attached parts in the GUI prior to sending (you couldn\u2019t remove selectively\nand couldn\u2019t remove all), and partly because this system\u2019s current sole user prefers\nto work this way.\nUsers can work around this by running a Split to save all parts in a directory, and\nthen adding any desired attachments to the mail from there. Still, it might be better\nto allow the user to choose that this happen automatically for replies and forwards.\nSimilarly, forwarding HTML mails well currently requires saving and attaching the\nHTML part to avoid quoting the text; this might be similarly addressed by parts\npropagation in general.\nDisable editing for viewed mails?\nMail text is editable in message view windows, even though a new mail is not being\ncomposed. This is deliberate\u2014users can annotate the message\u2019s text and save it in\na text file with the Save button at the bottom of the window, or simply cut-and-\npaste portions of it into other windows. This might be confusing, though, and is\nredundant (we can also edit and save by clicking on the main text\u2019s quick-access\npart button). Removing edit tools would require extending PyEdit. Using PyEdit\nfor display in general is a useful design\u2014users also have access to all of PyEdit\u2019s\ntools for the mail text, including save, find, goto, grep, replace, undo/redo, and so,\nthough edits might be superfluous in this context.\nAutomatic periodic new mail check?\nIt would be straightforward to add the ability to automatically check for and fetch\nnew incoming email periodically, by registering long-duration timer events with\neither the after widget method or the threading module\u2019s timer object. I haven\u2019t\n1120 | Chapter 14:\u2002The PyMailGUI Clientdone so because I have a personal bias against being surprised by software, but\nyour mileage may vary.\nReply and Forward buttons on view windows, too?\nMinor potential ergonomic improvement: we could include Reply and Forward\nbuttons on the message view windows, too, instead of requiring these operations\nto be selected in mail list windows only. As this system\u2019s sole user, I prefer the\nuncluttered appearance and conceptual simplicity of the current latter approach;\nGUIs have a way of getting out of hand when persistent pop-up windows start\nnesting too deeply. It would be trivial to have Reply/Forward on view windows,\ntoo, though; they could probably fetch mail components straight from the GUI\ninstead of reparsing a message.\nOmit Bcc header in view windows?\nMinor nit: mail view windows may be better off omitting the Bcc header even if\nit\u2019s enabled in the configuration file. Since it shouldn\u2019t be present once a mail is\nsent, it really needs to be included in composition windows only. It\u2019s displayed as\nis anyhow, to verify that Bcc is omitted on sends (the prior edition did not), to\nmaintain a uniform look for all mail windows, to avoid special-casing this in the\ncode, and to avoid making such ergonomic decisions in the absence of actual user\nfeedback.\nCheck for empty Subject lines?\nMinor usability issue: it would be straightforward to add a check for an empty\nSubject field on sends and to pop up a verification dialog to give the user a second\nchance to fill the field in. A blank subject is probably unintended. We could do the\nsame for the To field as well, though there may be valid use cases for omitting this\nfrom mail headers (the mail is still sent to Cc and Bcc recipients).\nRemoving duplicate recipients more accurately?\nAs is, the send operation attempts to remove duplicate recipients using set opera-\ntions. This works, but it may be inaccurate if the same email address appears twice\nwith a different name component (e.g., \u201cname1 <eml>, name2 <eml>\u201d). To do\nbetter, we could fully parse the recipient addresses to extract and compare just the\naddress portion of the full email address. Arguably, though, it\u2019s not clear what\nshould be done if the same recipient address appears with different names. Could\nmultiple people be using the same email account? If not, which name should we\nchoose to use?\nFor now, end user or mail server intervention may be required in the rare cases\nwhere this might crop up. In most cases, other email clients will likely handle names\nin consistent ways that make this a moot point. On related notes, Reply removes\nduplicates in Cc prefills in the same simplistic way, and both sends and replies\ncould use case-insensitive string comparisons when filtering for duplicates.\nHandling newsgroup messages, too?\nBecause Internet newsgroup posts are similar in structure to emails (header lines\nplus body text; see the nntplib example in Chapter 13), this script could in principle\nIdeas for Improvement | 1121be extended to display both email messages and news articles. Classifying such a\nmutation as clever generalization or diabolical hack is left as an exercise in itself.\nSMTP sends may not work in some network configurations?\nOn my home/office network, SMTP works fine and as shown for sending emails,\nbut I have occasionally seen sends have issues on public networks of the sort avail-\nable in hotels and airports. In some cases, mail sends can fail with exceptions and\nerror messages in the GUI; in worst cases, such sends might fail with no exception\nat all and without reporting an error in the GUI. The mail simply goes nowhere,\nwhich is obviously less than ideal if its content matters.\nIt\u2019s not clear if these issues are related to limitations of the networks used, of Py-\nthon\u2019s smtplib, or of the ISP-provided SMTP server I use. Unfortunately, I ran out\nof time to recreate the problem and investigate further (again, a system with a single\nuser also has just a single tester).\nResolving any such issues is left as an exercise for the reader, but as a caution: if\nyou wish to use the system to send important emails, you should first test sends in\na new network environment to ensure that they will be routed correctly. Sending\nan email to yourself and verifying receipt should suffice.\nPerformance tuning?\nAlmost all of the work done on this system to date has been related to its func-\ntionality. The system does allow some operation threads to run in parallel, and\noptimizes mail downloads by fetching just headers initially and caching already-\nfetched full mail text to avoid refetching. Apart from this, though, its performance\nin terms of CPU utilization and memory requirements has not been explored in\nany meaningful way at all. That\u2019s for the best\u2014in general we code for utility and\nclarity first in Python, and deal with performance later if and only if needed. Having\nsaid that, a broader audience for this program might mandate some performance\nanalysis and improvement.\nFor example, although the full text of fetched mails is kept just once in a cache,\neach open view of a message retains a copy of the parsed mail in memory. For large\nmails, this may impact memory growth. Caching parsed mails as well might help\ndecrease memory footprints, though these will still not be small for large mails,\nand the cache might hold onto memory longer than required if not intelligently\ndesigned. Storing messages or their parts in files (perhaps as pickled objects) in-\nstead of in memory might alleviate some growth, too, though that may also require\na mechanism for reaping temporary files. As is, Python\u2019s garbage collector should\nreclaim all such message space eventually as windows are closed, but this can de-\npend upon how and where we retain object references. See also the gc standard\nlibrary modules for possible pointers on finer-grained garbage collection control.\nUnicode model tuning?\nAs discussed in brief at the start of this chapter and in full in Chapter 13, PyMail-\nGUI\u2019s support for Unicode encoding of message text and header components is\nbroad, but not necessarily as general or universally applicable as it might be. Some\n1122 | Chapter 14:\u2002The PyMailGUI ClientUnicode limitations here stem from the limitations of the email package in\nPython 3.1 upon which PyMailGUI heavily depends. It may be difficult for Python-\ncoded email clients to support some features better until Python\u2019s libraries do, too.\nMoreover, the Unicode support that is present in this program has been tested\nneither widely nor rigorously. Just like Chapter 11\u2019s PyEdit, this is currently still a\nsingle-user system designed to work as a book example, not an open source project.\nBecause of that, some of the current Unicode policies are partially heuristic in\nnature and may have to be honed with time and practice.\nFor example, it may prove better in the end to use UTF-8 encoding (or none at all)\nfor sends in general, instead of supporting some of the many user options which\nare included in this book for illustration purposes. Since UTF-8 can represent most\nUnicode code points, it\u2019s broadly applicable.\nMore subtly, we might also consider propagating the main text part\u2019s Unicode\nencoding to the embedded PyEdit component in view and edit windows, so it can\nbe used as a known encoding by the PyEdit Save button. As is, users can pop up\nthe main text\u2019s part in view windows to save with a known encoding automatically,\nbut saves of drafts for mails being edited fall back on PyEdit\u2019s own Unicode policies\nand GUI prompts. The ambiguous encoding for saved drafts may be unavoidable,\nthough\u2014users might enter characters from any character set, both while writing\nnew mails from scratch and while editing the text of replies and forwards (just like\nheaders in replies and forwards, the initial known encoding of the original main\ntext part may no longer apply after arbitrary edits).\nIn addition, there is no support for non-ASCII encodings of full mail text, it\u2019s not\nimpossible that i18n encoded text might appear in other contexts in rare emails\n(e.g., in attachment filenames, whose undecoded form may or may not be valid on\nthe receiving platform\u2019s filesystem, and may require renaming if allowed at all),\nand although Internationalization is supported for mail content, the GUI itself still\nuses English for its buttons, labels, and titles\u2014something that a truly location-\nneutral program may wish to address.\nIn other words, if this program were to ever take the leap to commercial-grade or\nbroadly used software, its Unicode story would probably have to be revisited. Also\ndiscussed in Chapter 13, a future release of the email package may solve some\nUnicode issues automatically, though PyMailGUI may also require updates for the\nsolutions, as well as for incompatibilities introduced by them. For now, this will\nhave to stand as a useful object lesson in itself: for both better and worse, such\nchanges will always be a fact of life in the constantly evolving world of software\ndevelopment.\nAnd so on\u2014because this software is open source, it is also necessarily open-ended.\nUltimately, writing a complete email client is a substantial undertaking, and we\u2019ve\ntaken this example as far as we can in this book. To move PyMailGUI further along,\nwe\u2019d probably have to consider the suitability of both the underlying Python 3.1\nIdeas for Improvement | 1123email package, as well as the tkinter GUI toolkit. Both are fully sufficient for the utility\nwe\u2019ve implemented here, but they might limit further progress.\nFor example, the current lack of an HTML viewer widget in the base tkinter toolkit\nprecludes HTML mail viewing and composition in the GUI itself. Moreover, although\nPyMailGUI broadly supports Internationalization today, it must rely on workarounds\nto get email to work at all. To be fair, some of the email package\u2019s issues described in\nthis book will likely be fixed by the time you read about them, and email in general is\nprobably close to a worst case for Internationalization issues brought into the spotlight\nby Unicode prominence in Python 3.X. Still, such tool constraints might impede further\nsystem evolution.\nOn the other hand, despite any limitations in the tools it deploys, PyMailGUI does\nachieve all its goals\u2014it\u2019s an arguably full-featured and remarkably quick desktop email\nclient, which works surprisingly well for my emails and preferences and performs ad-\nmirably on the cases I\u2019ve tested to date. It may not satisfy your tastes or constraints,\nbut it is open to customization and imitation. Suggested exercises and further tweaking\nare therefore officially delegated to your imagination; this is Python, after all.\nThis concludes our tour of Python client-side protocols programming. In the next\nchapter, we\u2019ll hop the fence to the other side of the Internet world and explore scripts\nthat run on server machines. Such programs give rise to the grander notion of applica-\ntions that live entirely on the Web and are launched by web browsers. As we take this\nleap in structure, keep in mind that the tools we met in this and the previous chapter\nare often sufficient to implement all the distributed processing that many applications\nrequire, and they can work in harmony with scripts that run on a server. To completely\nunderstand the Web world view, though, we need to explore the server realm, too.\n1124 | Chapter 14:\u2002The PyMailGUI Client", "15": "CHAPTER 15\nServer-Side Scripting\n\u201cOh, What a Tangled Web We Weave\u201d\nThis chapter is the fourth part of our look at Python Internet programming. In the last \nthree chapters, we explored sockets and basic client-side programming interfaces such \nas FTP and email. In this chapter, our main focus will be on writing server-side scripts \nin Python\u2014a type of program usually referred to as CGI scripts. Though something of \na lowest common denominator for web development today, such scripts still provide \na simple way to get started with implementing interactive websites in Python.\nServer-side scripting and its derivatives are at the heart of much of the interaction that \nhappens on the Web. This is true both when scripting manually with CGI and when \nusing the higher-level frameworks that automate some of the work. Because of that, \nthe fundamental web model we\u2019ll explore here in the context of CGI scripting is pre-\nrequisite knowledge for programming the Web well, regardless of the tools you choose \nto deploy.\nAs we\u2019ll see, Python is an ideal language for writing scripts to implement and customize \nwebsites, because of both its ease of use and its library support. In the following chapter, \nwe will use the basics we learn in this chapter to implement a full-blown website. Here, \nour goal is to understand the fundamentals of server-side scripting, before exploring \nsystems that deploy or build upon that basic model.\nA House upon the Sand\nAs you read the next two chapters of this book, please keep in mind that they focus on \nthe fundamentals of server-side scripting and are intended only as an introduction to \nprogramming in this domain with Python. The web domain is large and complex, \nchanges rapidly and constantly, and often prescribes many ways to accomplish a given \ngoal\u2014some of which can vary from browser to browser and server to server.\nFor instance, the password encryption scheme of the next chapter may be unnecessary \nunder certain scenarios (with a suitable server, we could use secure HTTP instead). \nMoreover, some of the HTML we\u2019ll use here may not leverage all of that language\u2019s\n1125power, and may even not conform to current HTML standards. In fact, much of the\nmaterial added in later editions of this book reflects recent technology shifts in this\ndomain.\nGiven such a large and dynamic field, this part of the book does not even pretend to\nbe a complete look at the server-side scripting domain. That is, you should not take\nthis text to be a final word on the subject. To become truly proficient in this area, you\nshould also expect to spend some time studying other texts for additional\nwebmaster-y details and techniques\u2014for example, Chuck Musciano and Bill\nKennedy\u2019s HTML & XHTML: The Definitive Guide (O\u2019Reilly).\nThe good news is that here you will explore the core ideas behind server-side program-\nming, meet Python\u2019s CGI tool set, and learn enough to start writing substantial websites\nof your own in Python. This knowledge should apply to wherever the Web or you head\nnext.\nWhat\u2019s a Server-Side CGI Script?\nSimply put, CGI scripts implement much of the interaction you typically experience\non the Web. They are a standard and widely used mechanism for programming web-\nbased systems and website interaction, and they underlie most of the larger web\ndevelopment models.\nThere are other ways to add interactive behavior to websites with Python, both on the\nclient and the server. We briefly met some such alternatives near the start of Chap-\nter 12. For instance, client-side solutions include Jython applets, RIAs such as Silver-\nlight and pyjamas, Active Scripting on Windows, and the emerging HTML 5 standard.\nOn the server side, there are a variety of additional technologies that build on the basic\nCGI model, such as Python Server Pages, and web frameworks such as Django, App\nEngine, CherryPy, and Zope, many of which utilize the MVC programming model.\nBy and large, though, CGI server-side scripts are used to program much of the activity\non the Web, whether it\u2019s programmed directly or partly automated by frameworks and\ntools. CGI scripting is perhaps the most primitive approach to implementing websites,\nand it does not by itself offer the tools that are often built into larger frameworks such\nas state retention, database interfaces, and reply templating. CGI scripts, however, are\nin many ways the simplest technique for server-side scripting. As a result, they are an\nideal way to get started with programming on the server side of the Web. Especially for\nsimpler sites that do not require enterprise-level tools, CGI is sufficient, and it can be\naugmented with additional libraries as needed.\nThe Script Behind the Curtain\nFormally speaking, CGI scripts are programs that run on a server machine and adhere\nto the Common Gateway Interface\u2014a model for browser/server communications,\n1126 | Chapter 15:\u2002Server-Side Scriptingfrom which CGI scripts take their name. CGI is an application protocol that web servers\nuse to transfer input data and results between web browsers and other clients and\nserver-side scripts. Perhaps a more useful way to understand CGI, though, is in terms\nof the interaction it implies.\nMost people take this interaction for granted when browsing the Web and pressing\nbuttons in web pages, but a lot is going on behind the scenes of every transaction on\nthe Web. From the perspective of a user, it\u2019s a fairly familiar and simple process:\nSubmission\nWhen you visit a website to search, purchase a product, or submit information\nonline, you generally fill in a form in your web browser, press a button to submit\nyour information, and begin waiting for a reply.\nResponse\nAssuming all is well with both your Internet connection and the computer you are\ncontacting, you eventually get a reply in the form of a new web page. It may be a\nsimple acknowledgment (e.g., \u201cThanks for your order\u201d) or a new form that must\nbe filled out and submitted again.\nAnd, believe it or not, that simple model is what makes most of the Web hum. But\ninternally, it\u2019s a bit more complex. In fact, a subtle client/server socket-based architec-\nture is at work\u2014your web browser running on your computer is the client, and the\ncomputer you contact over the Web is the server. Let\u2019s examine the interaction scenario\nagain, with all the gory details that users usually never see:\nSubmission\nWhen you fill out a form page in a web browser and press a submission button,\nbehind the scenes your web browser sends your information across the Internet to\nthe server machine specified as its receiver. The server machine is usually a remote\ncomputer that lives somewhere else in both cyberspace and reality. It is named in\nthe URL accessed\u2014the Internet address string that appears at the top of your\nbrowser. The target server and file can be named in a URL you type explicitly, but\nmore typically they are specified in the HTML that defines the submission page\nitself\u2014either in a hyperlink or in the \u201caction\u201d tag of the input form\u2019s HTML.\nHowever the server is specified, the browser running on your computer ultimately\nsends your information to the server as bytes over a socket, using techniques we\nsaw in the last three chapters. On the server machine, a program called an HTTP\nserver runs perpetually, listening on a socket for incoming connection requests and\ndata from browsers and other clients, usually on port number 80.\nProcessing\nWhen your information shows up at the server machine, the HTTP server program\nnotices it first and decides how to handle the request. If the requested URL names\na simple web page (e.g., a URL ending in .html), the HTTP server opens the named\nHTML file on the server machine and sends its text back to the browser over a\nWhat\u2019s a Server-Side CGI Script? | 1127socket. On the client, the browser reads the HTML and uses it to construct the\nnext page you see.\nBut if the URL requested by the browser names an executable program instead (e.g.,\na URL ending in .cgi or .py), the HTTP server starts the named program on the\nserver machine to process the request and redirects the incoming browser data to\nthe spawned program\u2019s stdin input stream, environment variables, and command-\nline arguments. That program started by the server is usually a CGI script\u2014a pro-\ngram run on the remote server machine somewhere in cyberspace, usually not on\nyour computer. The CGI script is responsible for handling the request from this\npoint on; it may store your information in a database, perform a search, charge\nyour credit card, and so on.\nResponse\nUltimately, the CGI script prints HTML, along with a few header lines, to generate\na new response page in your browser. When a CGI script is started, the HTTP\nserver takes care to connect the script\u2019s stdout standard output stream to a socket\nthat the browser is listening to. As a result, HTML code printed by the CGI script\nis sent over the Internet, back to your browser, to produce a new page. The HTML\nprinted back by the CGI script works just as if it had been stored and read from an\nHTML file; it can define a simple response page or a brand-new form coded to\ncollect additional information. Because it is generated by a script, it may include\ninformation dynamically determined per request.\nIn other words, CGI scripts are something like callback handlers for requests generated\nby web browsers that require a program to be run dynamically. They are automatically\nrun on the server machine in response to actions in a browser. Although CGI scripts\nultimately receive and send standard structured messages over sockets, CGI is more\nlike a higher-level procedural convention for sending and receiving information be-\ntween a browser and a server.\nWriting CGI Scripts in Python\nIf all of this sounds complicated, relax\u2014Python, as well as the resident HTTP server,\nautomates most of the tricky bits. CGI scripts are written as fairly autonomous pro-\ngrams, and they assume that startup tasks have already been accomplished. The HTTP\nweb server program, not the CGI script, implements the server side of the HTTP pro-\ntocol itself. Moreover, Python\u2019s library modules automatically dissect information sent\nup from the browser and give it to the CGI script in an easily digested form. The upshot\nis that CGI scripts may focus on application details like processing input data and\nproducing a result page.\nAs mentioned earlier, in the context of CGI scripts, the stdin and stdout streams are\nautomatically tied to sockets connected to the browser. In addition, the HTTP server\npasses some browser information to the CGI script in the form of shell environment\nvariables, and possibly command-line arguments. To CGI programmers, that means:\n1128 | Chapter 15:\u2002Server-Side Scripting\u2022 Input data sent from the browser to the server shows up as a stream of bytes in the\nstdin input stream, along with shell environment variables.\n\u2022 Output is sent back from the server to the client by simply printing properly for-\nmatted HTML to the stdout output stream.\nThe most complex parts of this scheme include parsing all the input information sent\nup from the browser and formatting information in the reply sent back. Happily, Py-\nthon\u2019s standard library largely automates both tasks:\nInput\nWith the Python cgi module, input typed into a web browser form or appended\nto a URL string shows up as values in a dictionary-like object in Python CGI scripts.\nPython parses the data itself and gives us an object with one key : value pair per\ninput sent by the browser that is fully independent of transmission style (roughly,\nby fill-in form or by direct URL).\nOutput\nThe cgi module also has tools for automatically escaping strings so that they are\nlegal to use in HTML (e.g., replacing embedded <, >, and & characters with HTML\nescape codes). Module urllib.parse provides additional tools for formatting text\ninserted into generated URL strings (e.g., adding %XX and + escapes).\nWe\u2019ll study both of these interfaces in detail later in this chapter. For now, keep in mind\nthat although any language can be used to write CGI scripts, Python\u2019s standard modules\nand language attributes make it a snap.\nPerhaps less happily, CGI scripts are also intimately tied to the syntax of HTML, since\nthey must generate it to create a reply page. In fact, it can be said that Python CGI\nscripts embed HTML, which is an entirely distinct language in its own right.* As we\u2019ll\nalso see, the fact that CGI scripts create a user interface by printing HTML syntax means\nthat we have to take special care with the text we insert into a web page\u2019s code (e.g.,\nescaping HTML operators). Worse, CGI scripts require at least a cursory knowledge\nof HTML forms, since that is where the inputs and target script\u2019s address are typically\nspecified.\nThis book won\u2019t teach HTML in depth; if you find yourself puzzled by some of the\narcane syntax of the HTML generated by scripts here, you should glance at an HTML\nintroduction, such as HTML & XHTML: The Definitive Guide. Also keep in mind that\nhigher-level tools and frameworks can sometimes hide the details of HTML generation\nfrom Python programmers, albeit at the cost of any new complexity inherent in the\n* Interestingly, in Chapter 12 we briefly introduced other systems that take the opposite route\u2014embedding\nPython code or calls in HTML. The server-side templating languages in Zope, PSP, and other web frameworks\nuse this model, running the embedded Python code to produce part of a reply page. Because Python is\nembedded, these systems must run special servers to evaluate the embedded tags. Because Python CGI scripts\nembed HTML in Python instead, they can be run as standalone programs directly, though they must be\nlaunched by a CGI-capable web server.\nWhat\u2019s a Server-Side CGI Script? | 1129framework itself. With HTMLgen and similar packages, for instance, it\u2019s possible to\ndeal in Python objects, not HTML syntax, though you must learn this system\u2019s API as \nwell.\nRunning Server-Side Examples\nLike GUIs, web-based systems are highly interactive, and the best way to get a feel for\nsome of these examples is to test-drive them live. Before we get into some code, let\u2019s\nget set up to run the examples we\u2019re going to see.\nRunning CGI-based programs requires three pieces of software:\n\u2022 The client, to submit requests: a browser or script\n\u2022 The web server that receives the request\n\u2022 The CGI script, which is run by the server to process the request\nWe\u2019ll be writing CGI scripts as we move along, and any web browser can be used as a\nclient (e.g., Firefox, Safari, Chrome, or Internet Explorer). As we\u2019ll see later, Python\u2019s\nurllib.request module can also serve as a web client in scripts we write. The only\nmissing piece here is the intermediate web server.\nWeb Server Options\nThere are a variety of approaches to running web servers. For example, the open source\nApache system provides a complete, production-grade web server, and its mod_python\nextension discussed later runs Python scripts quickly. Provided you are willing to install\nand configure it, it is a complete solution, which you can run on a machine of your\nown. Apache usage is beyond our present scope here, though.\nIf you have access to an account on a web server machine that runs Python 3.X, you\ncan also install the HTML and script files we\u2019ll see there. For the second edition of this\nbook, for instance, all the web examples were uploaded to an account I had on the\n\u201cstarship\u201d Python server, and were accessed with URLs of this form:\nhttp://starship.python.net/~lutz/PyInternetDemos.html\nIf you go this route, replace starship.python.net/~lutz with the names of your own\nserver and account directory path. The downside of using a remote server account is\nthat changing code is more involved\u2014you will have to either work on the server ma-\nchine itself or transfer code back and forth on changes. Moreover, you need access to\nsuch a server in the first place, and server configuration details can vary widely. On the\nstarship machine, for example, Python CGI scripts were required to have a .cgi filename\nextension, executable permission, and the Unix #! line at the top to point the shell to\nPython.\nFinding a server that supports Python 3.X used by this book\u2019s examples might prove a\nstumbling block for some time to come as well; neither of my own ISPs had it installed\n1130 | Chapter 15:\u2002Server-Side Scriptingwhen I wrote this chapter in mid-2010, though it\u2019s possible to find commercial ISPs\ntoday that do. Naturally, this may change over time.\nRunning a Local Web Server\nTo keep things simple, this edition is taking a different approach. All the examples will\nbe run using a simple web server coded in Python itself. Moreover, the web server will\nbe run on the same local machine as the web browser client. This way, all you have to\ndo to run the server-side examples is start the web server script and use \u201clocalhost\u201d as\nthe server name in all the URLs you will submit or code (see Chapter 12 if you\u2019ve\nforgotten why this name means the local machine). For example, to view a web page,\nuse a URL of this form in the address field of your web browser:\nhttp://localhost/tutor0.html\nThis also avoids some of the complexity of per-server differences, and it makes changing\nthe code simple\u2014it can be edited on the local machine directly.\nFor this book\u2019s examples, we\u2019ll use the web server in Example 15-1. This is essentially\nthe same script introduced in Chapter 1, augmented slightly to allow the working di-\nrectory and port number to be passed in as command-line arguments (we\u2019ll also run\nthis in the root directory of a larger example in the next chapter). We won\u2019t go into\ndetails on all the modules and classes Example 15-1 uses here; see the Python library\nmanual. But as described in Chapter 1, this script implements an HTTP web server,\nwhich:\n\u2022 Listens for incoming socket requests from clients on the machine it is run on and\nthe port number specified in the script or command line (which defaults to 80, that\nstandard HTTP port)\n\u2022 Serves up HTML pages from the webdir directory specified in the script or com-\nmand line (which defaults to the directory it is launched from)\n\u2022 Runs Python CGI scripts that are located in the cgi-bin (or htbin) subdirectory of\nthe webdir directory, with a .py filename extension\nSee Chapter 1 for additional background on this web server\u2019s operation.\nExample 15-1. PP4E\\Internet\\Web\\webserver.py\n\"\"\"\nImplement an HTTP web server in Python which knows how to serve HTML\npages and run server-side CGI scripts coded in Python;  this is not\na production-grade server (e.g., no HTTPS, slow script launch/run on\nsome platforms), but suffices for testing, especially on localhost;\nServes files and scripts from the current working dir and port 80 by\ndefault, unless these options are specified in command-line arguments;\nPython CGI scripts must be stored in webdir\\cgi-bin or webdir\\htbin;\nmore than one of this server may be running on the same machine to serve\nfrom different directories, as long as they listen on different ports;\nRunning Server-Side Examples | 1131\"\"\"\nimport os, sys\nfrom http.server import HTTPServer, CGIHTTPRequestHandler\nwebdir = '.'   # where your HTML files and cgi-bin script directory live\nport   = 80    # http://servername/ if 80, else use http://servername:xxxx/\nif len(sys.argv) > 1: webdir = sys.argv[1]             # command-line args\nif len(sys.argv) > 2: port   = int(sys.argv[2])        # else default ., 80\nprint('webdir \"%s\", port %s' % (webdir, port))\nos.chdir(webdir)                                       # run in HTML root dir\nsrvraddr = ('', port)                                  # my hostname, portnumber\nsrvrobj  = HTTPServer(srvraddr, CGIHTTPRequestHandler)\nsrvrobj.serve_forever()                                # serve clients till exit\nTo start the server to run this chapter\u2019s examples, simply run this script from the di-\nrectory the script\u2019s file is located in, with no command-line arguments. For instance,\nfrom a DOS command line:\nC:\\...\\PP4E\\Internet\\Web> webserver.py\nwebdir \".\", port 80\nOn Windows, you can simply click its icon and keep the console window open, or\nlaunch it from a DOS command prompt. On Unix it can be run from a command line\nin the background, or in its own terminal window. Some platforms may also require\nyou to have administrator privileges to run servers on reserved ports, such as the Web\u2019s\nport 80; if this includes your machine, either run the server with the required permis-\nsions, or run on an alternate port number (more on port numbers later in this chapter).\nBy default, while running locally this way, the script serves up HTML pages requested\non \u201clocalhost\u201d from the directory it lives in or is launched from, and runs Python CGI\nscripts from the cgi-bin subdirectory located there; change its webdir variable or pass\nin a command-line argument to point it to a different directory. Because of this struc-\nture, in the examples distribution HTML files are in the same directory as the web server\nscript and CGI scripts are located in the cgi-bin subdirectory. In other words, to visit\nweb pages and run scripts, we\u2019ll be using URLs of these forms, respectively:\nhttp://localhost/somepage.html\nhttp://localhost/cgi-bin/somescript.py\nBoth map to the directory that contains the web server script (PP4E\\Internet\\Web) by\ndefault. Again, to run the examples on a different server machine of your own, simply\nreplace the \u201clocalhost\u201d and \u201clocalhost/cgi-bin\u201d parts of these addresses with your server\nname and directory path details (more on URLs later in this chapter); with this address\nchange the examples work the same, but requests are routed across a network to the\nserver, instead of being routed between programs running on the same local machine.\nThe server in Example 15-1 is by no means a production-grade web server, but it can\nbe used to experiment with this book\u2019s examples and is viable as a way to test your CGI\n1132 | Chapter 15:\u2002Server-Side Scriptingscripts locally with server name \u201clocalhost\u201d before deploying them on a real remote\nserver. If you wish to install and run the examples under a different web server, you\u2019ll\nwant to extrapolate the examples for your context. Things like server names and path-\nnames in URLs, as well as CGI script filename extensions and other conventions, can\nvary widely; consult your server\u2019s documentation for more details. For this chapter and\nthe next, we\u2019ll assume that you have the webserver.py script running locally.\nThe Server-Side Examples Root Page\nTo confirm that you are set up to run the examples, start the web server script in\nExample 15-1 and type the following URL in the address field at the top of your web\nbrowser:\nhttp://localhost/PyInternetDemos.html\nThis address loads a launcher page with links to this chapter\u2019s example files (see the\nexamples distribution for this page\u2019s HTML source code, which is not listed in this\nbook). The launcher page itself appears as in Figure 15-1, shown displayed in the In-\nternet Explorer web browser on Windows 7 (it looks similar on other browsers and\nplatforms). Each major example has a link on this page, which runs when clicked.\nFigure 15-1. The PyInternetDemos launcher page\nRunning Server-Side Examples | 1133It\u2019s possible to open some of the examples by clicking on their HTML file directly in\nyour system\u2019s file explorer GUI. However, the CGI scripts ultimately invoked by some\nof the example links must be run by a web server. If you click to browse such pages\ndirectly, your browser will likely display the scripts\u2019 source code, instead of running it.\nTo run scripts, too, be sure to open the HTML pages by typing their \u201clocalhost\u201d URL\naddress into your browser\u2019s address field.\nEventually, you probably will want to start using a more powerful web server, so we\nwill study additional CGI installation details later in this chapter. You may also wish\nto review our prior exploration of custom server options in Chapter 12 (Apache and\nmod_python are a popular option). Such details can be safely skipped or skimmed if\nyou will not be installing on another server right away. For now, we\u2019ll run locally.\nViewing Server-Side Examples and Output\nThe source code of examples in this part of the book is listed in the text and included\nin the book\u2019s examples distribution package. In all cases, if you wish to view the source\ncode of an HTML file, or the HTML generated by a Python CGI script, you can also\nsimply select your browser\u2019s View Source menu option while the corresponding web\npage is displayed.\nKeep in mind, though, that your browser\u2019s View Source option lets you see the out-\nput of a server-side script after it has run, but not the source code of the script itself.\nThere is no automatic way to view the Python source code of the CGI scripts themselves,\nshort of finding them in this book or in its examples distribution.\nTo address this issue, later in this chapter we\u2019ll also write a CGI-based program\ncalled getfile, which allows the source code of any file on this book\u2019s website (HTML,\nCGI script, and so on) to be downloaded and viewed. Simply type the desired file\u2019s\nname into a web page form referenced by the getfile.html link on the Internet demos\nlauncher page of Figure 15-1, or add it to the end of an explicitly typed URL as a\nparameter like the following; replace tutor5.py at the end with the name of the script\nwhose code you wish to view, and omit the cgi-bin component at the end to view HTML\nfiles instead:\nhttp://localhost/cgi-bin/getfile.py?filename=cgi-bin\\tutor5.py\nIn response, the server will ship back the text of the named file to your browser. This\nprocess requires explicit interface steps, though, and much more knowledge of URLs\nthan we\u2019ve gained thus far; to learn how and why this magic line works, let\u2019s move on\nto the next section.\n1134 | Chapter 15:\u2002Server-Side ScriptingClimbing the CGI Learning Curve\nNow that we\u2019ve looked at setup issues, it\u2019s time to get into concrete programming\ndetails. This section is a tutorial that introduces CGI coding one step at a time\u2014from\nsimple, noninteractive scripts to larger programs that utilize all the common web page\nuser input devices (what we called widgets in the tkinter GUI chapters in Part III).\nAlong the way, we\u2019ll also explore the core ideas behind server-side scripting. We\u2019ll move\nslowly at first, to learn all the basics; the next chapter will use the ideas presented here\nto build up larger and more realistic website examples. For now, let\u2019s work through a\nsimple CGI tutorial, with just enough HTML thrown in to write basic server-side\nscripts.\nA First Web Page\nAs mentioned, CGI scripts are intimately bound up with HTML, so let\u2019s start with a\nsimple HTML page. The file tutor0.html, shown in Example 15-2, defines a bona fide,\nfully functional web page\u2014a text file containing HTML code, which specifies the\nstructure and contents of a simple web page.\nExample 15-2. PP4E\\Internet\\Web\\tutor0.html\n<HTML>\n<TITLE>HTML 101</TITLE>\n<BODY>\n<H1>A First HTML Page</H1>\n<P>Hello, HTML World!</P>\n</BODY></HTML>\nIf you point your favorite web browser to the Internet address of this file, you should\nsee a page like that shown in Figure 15-2. This figure shows the Internet Explorer\nbrowser at work on the address http://localhost/tutor0.html (type this into your\nbrowser\u2019s address field), and it assumes that the local web server described in the prior\nsection is running; other browsers render the page similarly. Since this is a static HTML\nfile, you\u2019ll get the same result if you simply click on the file\u2019s icon on most platforms,\nthough its text won\u2019t be delivered by the web server in this mode.\nClimbing the CGI Learning Curve | 1135Figure 15-2. A simple web page from an HTML file\nTo truly understand how this little file does its work, you need to know something\nabout HTML syntax, Internet addresses, and file permission rules. Let\u2019s take a quick\nfirst look at each of these topics before we move on to the next example.\nHTML basics\nI promised that I wouldn\u2019t teach much HTML in this book, but you need to know\nenough to make sense of examples. In short, HTML is a descriptive markup language,\nbased on tags\u2014 items enclosed in <> pairs. Some tags stand alone (e.g., <HR> specifies\na horizontal rule). Others appear in begin/end pairs in which the end tag includes an\nextra slash.\nFor instance, to specify the text of a level-one header line, we write HTML code of the\nform <H1> text </H1>; the text between the tags shows up on the web page. Some tags\nalso allow us to specify options (sometimes called attributes). For example, a tag pair\nlike <A href=\" address \">text</A> specifies a hyperlink: pressing the link\u2019s text in the\npage directs the browser to access the Internet address (URL) listed in the href option.\nIt\u2019s important to keep in mind that HTML is used only to describe pages: your web\nbrowser reads it and translates its description to a web page with headers, paragraphs,\nlinks, and the like. Notably absent are both layout information\u2014the browser is re-\nsponsible for arranging components on the page\u2014and syntax for programming logic\u2014\nthere are no if statements, loops, and so on. Also, Python code is nowhere to be found\nin Example 15-2; raw HTML is strictly for defining pages, not for coding programs or\nspecifying all user interface details.\nHTML\u2019s lack of user interface control and programmability is both a strength and a\nweakness. It\u2019s well suited to describing pages and simple user interfaces at a high level.\nThe browser, not you, handles physically laying out the page on your screen. On the\nother hand, HTML by itself does not directly support full-blown GUIs and requires us\nto introduce CGI scripts (or other technologies such as RIAs) to websites in order to\nadd dynamic programmability to otherwise static HTML.\n1136 | Chapter 15:\u2002Server-Side ScriptingInternet addresses (URLs)\nOnce you write an HTML file, you need to put it somewhere a web browser can ref-\nerence it. If you are using the locally running Python web server described earlier, this\nbecomes trivial: use a URL of the form http://localhost/file.html to access web pages,\nand http://localhost/cgi-bin/file.py to name CGI scripts. This is implied by the fact that\nthe web server script by default serves pages and scripts from the directory in which it\nis run.\nOn other servers, URLs may be more complex. Like all HTML files, tutor0.html must\nbe stored in a directory on the server machine, from which the resident web server\nprogram allows browsers to fetch pages. For example, on the server used for the second\nedition of this book, the page\u2019s file must be stored in or below the public_html directory\nof my personal home directory\u2014that is, somewhere in the directory tree rooted\nat /home/lutz/public_html. The complete Unix pathname of this file on the server is:\n/home/lutz/public_html/tutor0.html\nThis path is different from its PP4E\\Internet\\Web location in the book\u2019s examples dis-\ntribution, as given in the example file listing\u2019s title. When referencing this file on the\nclient, though, you must specify its Internet address, sometimes called a URL, instead\nof a directory path name. The following URL was used to load the remote page from\nthe server:\nhttp://starship.python.net/~lutz/tutor0.html\nThe remote server maps this URL to the Unix pathname automatically, in much the\nsame way that the http://localhost resolves to the examples directory containing the web\nserver script for our locally-running server. In general, URL strings like the one just\nlisted are composed as the concatenation of multiple parts:\nProtocol name: http\nThe protocol part of this URL tells the browser to communicate with the HTTP\n(i.e., web) server program on the server machine, using the HTTP message proto-\ncol. URLs used in browsers can also name different protocols\u2014for example,\nftp:// to reference a file managed by the FTP protocol and server, file:// to reference\na file on the local machine, telnet to start a Telnet client session, and so on.\nServer machine name and port: starship.python.net\nA URL also names the target server machine\u2019s domain name or Internet Protocol\n(IP) address following the protocol type. Here, we list the domain name of the\nserver machine where the examples are installed; the machine name listed is used\nto open a socket to talk to the server. As usual, a machine name of localhost (or the\nequivalent IP address 127.0.0.1) here means the server is running on the same\nmachine as the client.\nOptionally, this part of the URL may also explicitly give the socket port on which\nthe server is listening for connections, following a colon (e.g., starship.python.net:\n8000, or 127.0.0.1:80). For HTTP, the socket is usually connected to port number\nClimbing the CGI Learning Curve | 113780, so this is the default if the port is omitted. See Chapter 12 if you need a refresher\non machine names and ports.\nFile path: ~lutz/tutor0.html\nFinally, the URL gives the path to the desired file on the remote machine. The\nHTTP web server automatically translates the URL\u2019s file path to the file\u2019s true\npathname: on the starship server, ~lutz is automatically translated to the\npublic_html directory in my home directory. When using the Python-coded web\nserver script in Example 15-1, files are mapped to the server\u2019s current working\ndirectory instead. URLs typically map to such files, but they can reference other\nsorts of items as well, and as we\u2019ll see in a few moments may name an executable\nCGI script to be run when accessed.\nQuery parameters (used in later examples)\nURLs may also be followed by additional input parameters for CGI programs.\nWhen used, they are introduced by a ? and are typically separated by & characters.\nFor instance, a string of the form ?name=bob&job=hacker at the end of a URL passes\nparameters named name and job to the CGI script named earlier in the URL, with\nvalues bob and hacker, respectively. As we\u2019ll discuss later in this chapter when we\nexplore escaping rules, the parameters may sometimes be separated by ; characters\ninstead, as in ?name=bob;job=hacker, though this form is less common.\nThese values are sometimes called URL query string parameters and are treated the\nsame as form inputs by scripts. Technically speaking, query parameters may have\nother structures (e.g., unnamed values separated by +), but we will ignore addi-\ntional options in this text; more on both parameters and input forms later in this\ntutorial.\nTo make sure we have a handle on URL syntax, let\u2019s pick apart another example that\nwe will be using later in this chapter. In the following HTTP protocol URL:\nhttp://localhost:80/cgi-bin/languages.py?language=All\nthe components uniquely identify a server script to be run as follows:\n\u2022 The server name localhost means the web server is running on the same machine\nas the client; as explained earlier, this is the configuration we\u2019re using for our\nexamples.\n\u2022 Port number 80 gives the socket port on which the web server is listening for con-\nnections (port 80 is the default if this part is omitted, so we will usually omit it).\n\u2022 The file path cgi-bin/languages.py gives the location of the file to be run on the\nserver machine, within the directory where the server looks for referenced files.\n\u2022 The query string ?language=All provides an input parameter to the referenced\nscript languages.py, as an alternative to user input in form fields (described later).\n1138 | Chapter 15:\u2002Server-Side ScriptingAlthough this covers most URLs you\u2019re likely to encounter in the wild, the full format\nof URLs is slightly richer:\nprotocol://networklocation/path;parameters?querystring#fragment\nFor instance, the fragment part may name a section within a page (e.g., #part1). More-\nover, each part can have formats of its own, and some are not used in all protocols.\nThe ;parameters part is omitted for HTTP, for instance (it gives an explicit file type for\nFTP), and the networklocation part may also specify optional user login parameters for\nsome protocol schemes (its full format is user:password@host:port for FTP and Telnet,\nbut just host:port for HTTP). We used a complex FTP URL in Chapter 13, for example,\nwhich included a username and password, as well as a binary file type (the server may\nguess if no type is given):\nftp://lutz:password@ftp.rmi.net/filename;type=i\nWe\u2019ll ignore additional URL formatting rules here. If you\u2019re interested in more details,\nyou might start by reading the urllib.parse module\u2019s entry in Python\u2019s library manual,\nas well as its source code in the Python standard library. You may also notice that a\nURL you type to access a page looks a bit different after the page is fetched (spaces\nbecome + characters, % characters are added, and so on). This is simply because brows-\ners must also generally follow URL escaping (i.e., translation) conventions, which we\u2019ll\nexplore later in this chapter.\nUsing minimal URLs\nBecause browsers remember the prior page\u2019s Internet address, URLs embedded in\nHTML files can often omit the protocol and server names, as well as the file\u2019s directory\npath. If missing, the browser simply uses these components\u2019 values from the last page\u2019s\naddress. This minimal syntax works for URLs embedded in hyperlinks and for form\nactions (we\u2019ll meet forms later in this tutorial). For example, within a page that was\nfetched from the directory dirpath on the server http://www.server.com, minimal hy-\nperlinks and form actions such as:\n<A HREF=\"more.html\">\n<FORM ACTION=\"next.py\"  ...>\nare treated exactly as if we had specified a complete URL with explicit server and path\ncomponents, like the following:\n<A HREF=\"http://www.server.com/dirpath/more.html\">\n<FORM ACTION=\"http://www.server.com/dirpath/next.py\"  ...>\nThe first minimal URL refers to the file more.html on the same server and in the same\ndirectory from which the page containing this hyperlink was fetched; it is expanded to\na complete URL within the browser. URLs can also employ Unix-style relative path\nsyntax in the file path component. A hyperlink tag like <A HREF=\"../spam.gif\">, for\ninstance, names a GIF file on the server machine and parent directory of the file that\ncontains this link\u2019s URL.\nClimbing the CGI Learning Curve | 1139Why all the fuss about shorter URLs? Besides extending the life of your keyboard and\neyesight, the main advantage of such minimal URLs is that they don\u2019t need to be\nchanged if you ever move your pages to a new directory or server\u2014the server and path\nare inferred when the page is used; they are not hardcoded into its HTML. The flipside\nof this can be fairly painful: examples that do include explicit site names and pathnames\nin URLs embedded within HTML code cannot be copied to other servers without\nsource code changes. Scripts and special HTML tags can help here, but editing source\ncode can be error-prone.\nThe downside of minimal URLs is that they don\u2019t trigger automatic Internet connec-\ntions when followed offline. This becomes apparent only when you load pages from\nlocal files on your computer. For example, we can generally open HTML pages without\nconnecting to the Internet at all by pointing a web browser to a page\u2019s file that lives on\nthe local machine (e.g., by clicking on its file icon). When browsing a page locally like\nthis, following a fully specified URL makes the browser automatically connect to the\nInternet to fetch the referenced page or script. Minimal URLs, though, are opened on\nthe local machine again; usually, the browser simply displays the referenced page or\nscript\u2019s source code.\nThe net effect is that minimal URLs are more portable, but they tend to work better\nwhen running all pages live on the Internet (or served up by a locally running web\nserver). To make them easier to work with, the examples in this book will often omit\nthe server and path components in URLs they contain. In this book, to derive a page\nor script\u2019s true URL from a minimal URL, imagine that the string:\nhttp://localhost/\nappears before the filename given by the URL. Your browser will, even if you don\u2019t.\nHTML file permission constraints\nOne install pointer before we move on: if you want to use a different server and machine,\nit may be necessary on some platforms to grant web page files and their directories\nworld-readable permission. That\u2019s because they are loaded by arbitrary people over the\nWeb (often by someone named \u201cnobody,\u201d who we\u2019ll introduce in a moment).\nAn appropriate chmod command can be used to change permissions on Unix-like ma-\nchines. For instance, a chmod 755 filename shell command usually suffices; it makes\nfilename readable and executable by everyone, and writable by you only.\u2020 These di-\nrectory and file permission details are typical, but they can vary from server to server.\nBe sure to find out about the local server\u2019s conventions if you upload HTML files to a\nremote site.\n\u2020 These are not necessarily magic numbers. On Unix machines, mode 755 is a bit mask. The first 7 simply\nmeans that you (the file\u2019s owner) can read, write, and execute the file (7 in binary is 111\u2014each bit enables\nan access mode). The two 5s (binary 101) say that everyone else (your group and others) can read and execute\n(but not write) the file. See your system\u2019s manpage on the chmod command for more details.\n1140 | Chapter 15:\u2002Server-Side ScriptingA First CGI Script\nThe HTML file we saw in the prior section is just that\u2014an HTML file, not a CGI script.\nWhen referenced by a browser, the remote web server simply sends back the file\u2019s text\nto produce a new page in the browser. To illustrate the nature of CGI scripts, let\u2019s\nrecode the example as a Python CGI program, as shown in Example 15-3.\nExample 15-3. PP4E\\Internet\\Web\\cgi-bin\\tutor0.py\n#!/usr/bin/python\n\"\"\"\nruns on the server, prints HTML to create a new page;\nurl=http://localhost/cgi-bin/tutor0.py\n\"\"\"\nprint('Content-type: text/html\\n')\nprint('<TITLE>CGI 101</TITLE>')\nprint('<H1>A First CGI Script</H1>')\nprint('<P>Hello, CGI World!</P>')\nThis file, tutor0.py, makes the same sort of page as Example 15-2 if you point your\nbrowser at it\u2014simply replace .html with .py in the URL, and add the cgi-bin subdir-\nectory name to the path to yield its address to enter in your browser\u2019s address field,\nhttp://localhost/cgi-bin/tutor0.py.\nBut this time it\u2019s a very different kind of animal\u2014it is an executable program that is run\non the server in response to your access request. It\u2019s also a completely legal Python\nprogram, in which the page\u2019s HTML is printed dynamically, instead of being precoded\nin a static file. In fact, little is CGI-specific about this Python program; if run from the\nsystem command line, it simply prints HTML instead of generating a browser page:\nC:\\...\\PP4E\\Internet\\Web\\cgi-bin> python tutor0.py\nContent-type: text/html\n<TITLE>CGI 101</TITLE>\n<H1>A First CGI Script</H1>\n<P>Hello, CGI World!</P>\nWhen run by the HTTP server program on a web server machine, however, the standard\noutput stream is tied to a socket read by the browser on the client machine. In this\ncontext, all the output is sent across the Internet to your web browser. As such, it must\nbe formatted per the browser\u2019s expectations.\nIn particular, when the script\u2019s output reaches your browser, the first printed line is\ninterpreted as a header, describing the text that follows. There can be more than one\nheader line in the printed response, but there must always be a blank line between the\nheaders and the start of the HTML code (or other data). As we\u2019ll see later, \u201ccookie\u201d\nstate retention directives show up in the header area as well, prior to the blank line.\nIn this script, the first header line tells the browser that the rest of the transmission is\nHTML text (text/html), and the newline character (\\n) at the end of the first print call\nClimbing the CGI Learning Curve | 1141statement generates an extra line feed in addition to the one that the print generates\nitself. The net effect is to insert a blank line after the header line. The rest of this pro-\ngram\u2019s output is standard HTML and is used by the browser to generate a web page\non a client, exactly as if the HTML lived in a static HTML file on the server.\u2021\nCGI scripts are accessed just like HTML files: you either type the full URL of this script\ninto your browser\u2019s address field or click on the tutor0.py link line in the examples root\npage of Figure 15-1 (which follows a minimal hyperlink that resolves to the script\u2019s full\nURL). Figure 15-3 shows the result page generated if you point your browser at this\nscript.\nFigure 15-3. A simple web page from a CGI script\nInstalling CGI scripts\nIf you are running the local web server described at the start of this chapter, no extra\ninstallation steps are required to make this example work, and you can safely skip most\nof this section. If you want to put CGI scripts on another server, though, there are a\nfew pragmatic details you may need to know about. This section provides a brief over-\nview of common CGI configuration details for reference.\nLike HTML files, CGI scripts are simple text files that you can either create on your\nlocal machine and upload to the server by FTP or write with a text editor running\ndirectly on the server machine (perhaps using a Telnet or SSH client). However, because\nCGI scripts are run as programs, they have some unique installation requirements that\ndiffer from simple HTML files. In particular, they usually must be stored and named\nspecially, and they must be configured as programs that are executable by arbitrary\nusers. Depending on your needs, CGI scripts also may require help finding imported\n\u2021 Notice that the script does not generate the enclosing <HEAD> and <BODY> tags included in the static HTML\nfile of the prior section. Strictly speaking, it should\u2014HTML without such tags is technically invalid. But\nbecause all commonly used browsers simply ignore the omission, we\u2019ll take some liberties with HTML syntax\nin this book. If you need to care about such things, consult HTML references for more formal details.\n1142 | Chapter 15:\u2002Server-Side Scriptingmodules and may need to be converted to the server platform\u2019s text file format after\nbeing uploaded. Let\u2019s look at each install constraint in more depth:\nDirectory and filename conventions\nFirst, CGI scripts need to be placed in a directory that your web server recognizes\nas a program directory, and they need to be given a name that your server recognizes\nas a CGI script. In the local web server we\u2019re using in this chapter, scripts need to\nbe placed in a special cgi-bin subdirectory and be named with a .py extension. On\nthe server used for this book\u2019s second edition, CGI scripts instead were stored in\nthe user\u2019s public_html directory just like HTML files, but they required a filename\nending in a .cgi, not a .py. Some servers may allow other suffixes and program\ndirectories; this varies widely and can sometimes be configured per server or per\nuser.\nExecution conventions\nBecause they must be executed by the web server on behalf of arbitrary users on\nthe Web, CGI script files may also need to be given executable file permissions to\nmark them as programs and be made executable by others. Again, a shell command\nchmod 0755 filename does the trick on most servers.\nUnder some servers, CGI scripts also need the special #! line at the top, to identify\nthe Python interpreter that runs the file\u2019s code. The text after the #! in the first line\nsimply gives the directory path to the Python executable on your server machine.\nSee Chapter 3 for more details on this special first line, and be sure to check your\nserver\u2019s conventions for more details on non-Unix platforms.\nSome servers may expect this line, even outside Unix. Most of the CGI scripts in\nthis book include the #! line just in case they will ever be run on Unix-like platforms;\nunder our locally running web server on Windows, this first line is simply ignored\nas a Python comment.\nOne subtlety worth noting: as we saw earlier in the book, the special first line in\nexecutable text files can normally contain either a hardcoded path to the Python\ninterpreter (e.g., #!/usr/bin/python) or an invocation of the env program (e.g.,\n#!/usr/bin/env python), which deduces where Python lives from environment var-\niable settings (i.e., your $PATH). The env trick is less useful in CGI scripts, though,\nbecause their environment settings may be those of the user \u201cnobody\u201d (not your\nown), as explained in the next paragraph.\nModule search path configuration (optional)\nSome HTTP servers may run CGI scripts with the username \u201cnobody\u201d for security\nreasons (this limits the user\u2019s access to the server machine). That\u2019s why files you\npublish on the Web must have special permission settings that make them acces-\nsible to other users. It also means that some CGI scripts can\u2019t rely on the Python\nmodule search path to be configured in any particular way. As you\u2019ve learned by\nnow, the module path is normally initialized from the user\u2019s PYTHONPATH setting\nand .pth files, plus defaults which normally include the current working directory.\nClimbing the CGI Learning Curve | 1143But because CGI scripts are run by the user \u201cnobody,\u201d PYTHONPATH may be arbitrary\nwhen a CGI script runs.\nBefore you puzzle over this too hard, you should know that this is often not a\nconcern in practice. Because Python usually searches the current directory for im-\nported modules by default, this is not an issue if all of your scripts and any modules\nand packages they use are stored in your web directory, and your web server\nlaunches CGI scripts in the directory in which they reside. But if the module lives\nelsewhere, you may need to modify the sys.path list in your scripts to adjust the\nsearch path manually before imports\u2014for instance, with sys.path.append(dir\nname) calls, index assignments, and so on.\nEnd-of-line conventions (optional)\nOn some Unix (and Linux) servers, you might also have to make sure that your\nscript text files follow the Unix end-of-line convention (\\n), not DOS (\\r\\n). This\nisn\u2019t an issue if you edit and debug right on the server (or on another Unix machine)\nor FTP files one by one in text mode. But if you edit and upload your scripts from\na PC to a Unix server in a tar file (or in FTP binary mode), you may need to convert\nend-of-lines after the upload. For instance, the server that was used for the second\nedition of this text returns a default error page for scripts whose end-of-lines are\nin DOS format. See Chapter 6 for techniques and a note on automated end-of-line\nconverter scripts.\nUnbuffered output streams (optional)\nUnder some servers, the print call statement may buffer its output. If you have a\nlong-running CGI script, to avoid making the user wait to see results, you may wish\nto manually flush your printed text (call sys.stdout.flush()) or run your Python\nscripts in unbuffered mode. Recall from Chapter 5 that you can make streams\nunbuffered by running with the -u command-line flag or by setting your\nPYTHONUNBUFFERED environment variable to a nonempty value.\nTo use -u in the CGI world, try using a first line on Unix-like platforms like #!/\nusr/bin/python -u. In typical usage, output buffering is not usually a factor. On\nsome servers and clients, though, this may be a resolution for empty reply pages,\nor premature end-of-script header errors\u2014the client may time out before the buf-\nfered output stream is sent (though more commonly, these cases reflect genuine\nprogram errors in your script).\nThis installation process may sound a bit complex at first glance, but much of it is\nserver-dependent, and it\u2019s not bad once you\u2019ve worked through it on your own. It\u2019s\nonly a concern at install time and can usually be automated to some extent with Python\nscripts run on the server. To summarize, most Python CGI scripts are text files of Python\ncode, which:\n\u2022 Are named according to your web server\u2019s conventions (e.g., file.py)\n\u2022 Are stored in a directory recognized by your web server (e.g., cgi-bin/)\n\u2022 Are given executable file permissions if required (e.g., chmod 755 file.py)\n1144 | Chapter 15:\u2002Server-Side Scripting\u2022 May require the special #!pythonpath line at the top for some servers\n\u2022 Configure sys.path only if needed to see modules in other directories\n\u2022 Use Unix end-of-line conventions if your server rejects DOS format\n\u2022 Flush output buffers if required, or to send portions of the reply periodically\nEven if you must use a server machine configured by someone else, most of the ma-\nchine\u2019s conventions should be easy to root out during a normal debugging cycle. As\nusual, you should consult the conventions for any machine to which you plan to copy\nthese example files.\nFinding Python on remote servers\nOne last install pointer: even though Python doesn\u2019t have to be installed on any cli-\nents in the context of a server-side web application, it does have to exist on the server\nmachine where your CGI scripts are expected to run. If you\u2019re running your own server\nwith either the webserver.py script we met earlier or an open source server such as\nApache, this is a nonissue.\nBut if you are using a web server that you did not configure yourself, you must be sure\nthat Python lives on that machine. Moreover, you need to find where it is on that\nmachine so that you can specify its path in the #! line at the top of your script. If you\nare not sure if or where Python lives on your server machine, here are some tips:\n\u2022 Especially on Unix systems, you should first assume that Python lives in a standard\nplace (e.g., /usr/local/bin/python): type python (or which python) in a shell window\nand see if it works. Chances are that Python already lives on such machines. If you\nhave Telnet or SSH access on your server, a Unix find command starting at /usr\nmay help.\n\u2022 If your server runs Linux, you\u2019re probably set to go. Python ships as a standard\npart of Linux distributions these days, and many websites and Internet Service\nProviders (ISPs) run the Linux operating system; at such sites, Python probably\nalready lives at /usr/bin/python.\n\u2022 In other environments where you cannot control the server machine yourself, it\nmay be harder to obtain access to an already installed Python. If so, you can relocate\nyour site to a server that does have Python installed, talk your ISP into installing\nPython on the machine you\u2019re trying to use, or install Python on the server machine\nyourself.\nIf your ISP is unsympathetic to your need for Python and you are willing to relocate\nyour site to one that is, you can find lists of Python-friendly ISPs by searching the Web.\nAnd if you choose to install Python on your server machine yourself, be sure to check\nout the Python world\u2019s support for frozen binaries\u2014with it, you can create a single\nexecutable program file that contains the entire Python interpreter, as well as all the\nstandard library modules. Assuming compatible machines, such a frozen interpreter\nmight be uploaded to your web account by FTP in a single step, and it won\u2019t require a\nClimbing the CGI Learning Curve | 1145full-blown Python installation on the server. The public domain PyInstaller and Py2Exe\nsystems can produce a frozen Python binary.\nFinally, to run this book\u2019s examples, make sure the Python you find or install is Python\n3.X, not Python 2.X. As mentioned earlier, many commercial ISPs support the latter\nbut not the former as I\u2019m writing this fourth edition, but this is expected to change over\ntime. If you do locate a commercial ISP with 3.X support, you should be able to upload\nyour files by FTP and work by SSH or Telnet. You may also be able to run this chapter\u2019s\nwebserver.py script on the remote machine, though you may need to avoid using the\nstandard port 80, depending on how much control your account affords.\nAdding Pictures and Generating Tables\nLet\u2019s get back to writing server-side code. As anyone who\u2019s ever surfed the Web knows,\nweb pages usually consist of more than simple text. Example 15-4 is a Python CGI\nscript that prints an <IMG> HTML tag in its output to produce a graphic image in the\nclient browser. This example isn\u2019t very Python-specific, but note that just as for simple\nHTML files, the image file (ppsmall.gif, one level up from the script file) lives on and is\ndownloaded from the server machine when the browser interprets the output of this\nscript to render the reply page (even if the server\u2019s machine is the same as the client\u2019s).\nExample 15-4. PP4E\\Internet\\Web\\cgi-bin\\tutor1.py\n#!/usr/bin/python\ntext = \"\"\"Content-type: text/html\n<TITLE>CGI 101</TITLE>\n<H1>A Second CGI Script</H1>\n<HR>\n<P>Hello, CGI World!</P>\n<IMG src=\"../ppsmall.gif\" BORDER=1 ALT=[image]>\n<HR>\n\"\"\"\nprint(text)\nNotice the use of the triple-quoted string block here; the entire HTML string is sent to\nthe browser in one fell swoop, with the print call statement at the end. Be sure that the\nblank line between the Content-type header and the first HTML is truly blank in the\nstring (it may fail in some browsers if you have any spaces or tabs on that line). If both\nclient and server are functional, a page that looks like Figure 15-4 will be generated\nwhen this script is referenced and run.\nSo far, our CGI scripts have been putting out canned HTML that could have just as\neasily been stored in an HTML file. But because CGI scripts are executable programs,\nthey can also be used to generate HTML on the fly, dynamically\u2014even, possibly, in\nresponse to a particular set of user inputs sent to the script. That\u2019s the whole purpose\n1146 | Chapter 15:\u2002Server-Side Scriptingof CGI scripts, after all. Let\u2019s start using this to better advantage now, and write a Python\nscript that builds up response HTML programmatically, listed in Example 15-5.\nExample 15-5. PP4E\\Internet\\Web\\cgi-bin\\tutor2.py\n#!/usr/bin/python\nprint(\"\"\"Content-type: text/html\n<TITLE>CGI 101</TITLE>\n<H1>A Third CGI Script</H1>\n<HR>\n<P>Hello, CGI World!</P>\n<table border=1>\n\"\"\")\nfor i in range(5):\n    print('<tr>')\n    for j in range(4):\n        print('<td>%d.%d</td>' % (i, j))\n    print('</tr>')\nprint(\"\"\"\n</table>\n<HR>\n\"\"\")\nDespite all the tags, this really is Python code\u2014the tutor2.py script uses triple-quoted\nstrings to embed blocks of HTML again. But this time, the script also uses nested Python\nFigure 15-4. A page with an image generated by tutor1.py\nClimbing the CGI Learning Curve | 1147for loops to dynamically generate part of the HTML that is sent to the browser. Spe-\ncifically, it emits HTML to lay out a two-dimensional table in the middle of a page, as\nshown in Figure 15-5.\nFigure 15-5. A page with a table generated by tutor2.py\nEach row in the table displays a \u201crow.column\u201d pair, as generated by the executing\nPython script. If you\u2019re curious how the generated HTML looks, select your browser\u2019s\nView Source option after you\u2019ve accessed this page. It\u2019s a single HTML page composed\nof the HTML generated by the first print in the script, then the for loops, and finally\nthe last print. In other words, the concatenation of this script\u2019s output is an HTML\ndocument with headers.\nTable tags\nThe script in Example 15-5 generates HTML table tags. Again, we\u2019re not out to learn\nHTML here, but we\u2019ll take a quick look just so that you can make sense of this book\u2019s\nexamples. Tables are declared by the text between <table> and </table> tags in HTML.\nTypically, a table\u2019s text in turn declares the contents of each table row between <tr>\nand </tr> tags and each column within a row between <td> and </td> tags. The loops\nin our script build up HTML to declare five rows of four columns each by printing the\nappropriate tags, with the current row and column number as column values.\nFor instance, here is part of the script\u2019s output, defining the first two rows (to see the\nfull output, run the script standalone from a system command line, or select your\nbrowser\u2019s View Source option):\n1148 | Chapter 15:\u2002Server-Side Scripting<table border=1>\n<tr>\n<td>0.0</td>\n<td>0.1</td>\n<td>0.2</td>\n<td>0.3</td>\n</tr>\n<tr>\n<td>1.0</td>\n<td>1.1</td>\n<td>1.2</td>\n<td>1.3</td>\n</tr>\n. . .\n</table>\nOther table tags and options let us specify a row title (<th>), lay out borders, and so\non. We\u2019ll use more table syntax to lay out forms in a uniform fashion later in this\ntutorial.\nAdding User Interaction\nCGI scripts are great at generating HTML on the fly like this, but they are also com-\nmonly used to implement interaction with a user typing at a web browser. As described\nearlier in this chapter, web interactions usually involve a two-step process and two\ndistinct web pages: you fill out an input form page and press Submit, and a reply page\neventually comes back. In between, a CGI script processes the form input.\nSubmission page\nThat description sounds simple enough, but the process of collecting user inputs re-\nquires an understanding of a special HTML tag, <form>. Let\u2019s look at the implementa-\ntion of a simple web interaction to see forms at work. First, we need to define a form\npage for the user to fill out, as shown in Example 15-6.\nExample 15-6. PP4E\\Internet\\Web\\tutor3.html\n<html>\n<title>CGI 101</title>\n<body>\n<H1>A first user interaction: forms</H1>\n<hr>\n<form method=POST action=\"http://localhost/cgi-bin/tutor3.py\">\n    <P><B>Enter your name:</B>\n    <P><input type=text name=user>\n    <P><input type=submit>\n</form>\n</body></html>\nClimbing the CGI Learning Curve | 1149tutor3.html is a simple HTML file, not a CGI script (though its contents could be printed\nfrom a script as well). When this file is accessed, all the text between its <form> and\n</form> tags generates the input fields and Submit button shown in Figure 15-6.\nFigure 15-6. A simple form page generated by tutor3.html\nMore on form tags\nWe won\u2019t go into all the details behind coding HTML forms, but a few highlights are\nworth underscoring. The following occurs within a form\u2019s HTML code:\nForm handler action\nThe form\u2019s action option gives the URL of a CGI script that will be invoked to\nprocess submitted form data. This is the link from a form to its handler program\u2014\nin this case, a program called tutor3.py in the cgi-bin subdirectory of the locally\nrunning server\u2019s working directory. The action option is the equivalent of\ncommand options in tkinter buttons\u2014it\u2019s where a callback handler (here, a remote\nhandler script) is registered to the browser and server.\nInput fields\nInput controls are specified with nested <input> tags. In this example, input tags\nhave two key options. The type option accepts values such as text for text fields\nand submit for a Submit button (which sends data to the server and is labeled\n\u201cSubmit Query\u201d by default). The name option is the hook used to identify the en-\ntered value by key, once all the form data reaches the server. For instance, the\nserver-side CGI script we\u2019ll see in a moment uses the string user as a key to get the\ndata typed into this form\u2019s text field.\nAs we\u2019ll see in later examples, other input tag options can specify initial values\n(value=X), display-only mode (readonly), and so on. As we\u2019ll also see later, other\n1150 | Chapter 15:\u2002Server-Side Scriptinginput type option values may transmit hidden data that embeds state information\nin pages (type=hidden), reinitializes fields (type=reset), or makes multiple-choice\nbuttons (type=checkbox).\nSubmission method: get and post\nForms also include a method option to specify the encoding style to be used to send\ndata over a socket to the target server machine. Here, we use the post style, which\ncontacts the server and then ships it a stream of user input data in a separate trans-\nmission over the socket.\nAn alternative get style ships input information to the server in a single transmis-\nsion step by appending user inputs to the query string at the end of the URL used\nto invoke the script, usually after a ? character. Query parameters were introduced\nearlier when we met URLs; we will put them to use later in this section.\nWith get, inputs typically show up on the server in environment variables or as\narguments in the command line used to start the script. With post, they must be\nread from standard input and decoded. Because the get method appends inputs to\nURLs, it allows users to bookmark actions with parameters for later submission\n(e.g., a link to a retail site, together with the name of a particular item); post is very\ngenerally meant for sending data that is to be submitted once (e.g., comment text).\nThe get method is usually considered more efficient, but it may be subject to length\nlimits in the operating system and is less secure (parameters may be recorded in\nserver logs, for instance). post can handle larger inputs and may be more secure in\nsome scenarios, but it requires an extra transmission. Luckily, Python\u2019s cgi module\ntransparently handles either encoding style, so our CGI scripts don\u2019t normally need\nto know or care which is used.\nNotice that the action URL in this example\u2019s form spells out the full address for illus-\ntration. Because the browser remembers where the enclosing HTML page came from,\nit works the same with just the script\u2019s filename, as shown in Example 15-7.\nExample 15-7. PP4E\\Internet\\Web\\tutor3-minimal.html\n<html>\n<title>CGI 101</title>\n<body>\n<H1>A first user interaction: forms</H1>\n<hr>\n<form method=POST action=\"cgi-bin/tutor3.py\">\n    <P><B>Enter your name:</B>\n    <P><input type=text name=user>\n    <P><input type=submit>\n</form>\n</body></html>\nIt may help to remember that URLs embedded in form action tags and hyperlinks are\ndirections to the browser first, not to the script. The tutor3.py script itself doesn\u2019t care\nwhich URL form is used to trigger it\u2014minimal or complete. In fact, all parts of a URL\nClimbing the CGI Learning Curve | 1151through the script filename (and up to URL query parameters) are used in the conver-\nsation between browser and HTTP server, before a CGI script is ever spawned. As long\nas the browser knows which server to contact, the URL will work.\nOn the other hand, URLs submitted outside of a page (e.g., typed into a browser\u2019s\naddress field or sent to the Python urllib.request module we\u2019ll revisit later) usually\nmust be completely specified, because there is no notion of a prior page.\nResponse script\nSo far, we\u2019ve created only a static page with an input field. But the Submit button on\nthis page is loaded to work magic. When pressed, it triggers the possibly remote pro-\ngram whose URL is listed in the form\u2019s action option, and passes this program the\ninput data typed by the user, according to the form\u2019s method encoding style option. On\nthe server, a Python script is started to handle the form\u2019s input data while the user waits\nfor a reply on the client; that script is shown in Example 15-8.\nExample 15-8. PP4E\\Internet\\Web\\cgi-bin\\tutor3.py\n#!/usr/bin/python\n\"\"\"\nruns on the server, reads form input, prints HTML;\nurl=http://server-name/cgi-bin/tutor3.py\n\"\"\"\nimport cgi\nform = cgi.FieldStorage()            # parse form data\nprint('Content-type: text/html')     # plus blank line\nhtml = \"\"\"\n<TITLE>tutor3.py</TITLE>\n<H1>Greetings</H1>\n<HR>\n<P>%s</P>\n<HR>\"\"\"\nif not 'user' in form:\n    print(html % 'Who are you?')\nelse:\n    print(html % ('Hello, %s.' % form['user'].value))\nAs before, this Python CGI script prints HTML to generate a response page in the\nclient\u2019s browser. But this script does a bit more: it also uses the standard cgi module\nto parse the input data entered by the user on the prior web page (see Figure 15-6).\nLuckily, this is automatic in Python: a call to the standard library cgi module\u2019s Field\nStorage class does all the work of extracting form data from the input stream and\nenvironment variables, regardless of how that data was passed\u2014in a post style stream\nor in get style parameters appended to the URL. Inputs sent in both styles look the\nsame to Python scripts.\n1152 | Chapter 15:\u2002Server-Side ScriptingScripts should call cgi.FieldStorage only once and before accessing any field values.\nWhen it is called, we get back an object that looks like a dictionary\u2014user input fields\nfrom the form (or URL) show up as values of keys in this object. For example, in the\nscript, form['user'] is an object whose value attribute is a string containing the text\ntyped into the form\u2019s text field. If you flip back to the form page\u2019s HTML, you\u2019ll notice\nthat the input field\u2019s name option was user\u2014the name in the form\u2019s HTML has become\na key we use to fetch the input\u2019s value from a dictionary. The object returned by\nFieldStorage supports other dictionary operations, too\u2014for instance, the in expres-\nsion may be used to check whether a field is present in the input data.\nBefore exiting, this script prints HTML to produce a result page that echoes back what\nthe user typed into the form. Two string-formatting expressions (%) are used to insert\nthe input text into a reply string, and the reply string into the triple-quoted HTML\nstring block. The body of the script\u2019s output looks like this:\n<TITLE>tutor3.py</TITLE>\n<H1>Greetings</H1>\n<HR>\n<P>Hello, King Arthur.</P>\n<HR>\nIn a browser, the output is rendered into a page like the one in Figure 15-7.\nFigure 15-7. tutor3.py result for parameters in a form\nPassing parameters in URLs\nNotice that the URL address of the script that generated this page shows up at the top\nof the browser. We didn\u2019t type this URL itself\u2014it came from the action tag of the prior\npage\u2019s form HTML. However, nothing is stopping us from typing the script\u2019s URL\nexplicitly in our browser\u2019s address field to invoke the script, just as we did for our earlier\nCGI script and HTML file examples.\nClimbing the CGI Learning Curve | 1153But there\u2019s a catch here: where does the input field\u2019s value come from if there is no form\npage? That is, if we type the CGI script\u2019s URL ourselves, how does the input field get\nfilled in? Earlier, when we talked about URL formats, I mentioned that the get encoding\nscheme tacks input parameters onto the end of URLs. When we type script addresses\nexplicitly, we can also append input values on the end of URLs, where they serve the\nsame purpose as <input> fields in forms. Moreover, the Python cgi module makes URL\nand form inputs look identical to scripts.\nFor instance, we can skip filling out the input form page completely and directly invoke\nour tutor3.py script by visiting a URL of this form (type this in your browser\u2019s address\nfield):\nhttp://localhost/cgi-bin/tutor3.py?user=Brian\nIn this URL, a value for the input named user is specified explicitly, as if the user had\nfilled out the input page. When called this way, the only constraint is that the parameter\nname user must match the name expected by the script (and hardcoded in the form\u2019s\nHTML). We use just one parameter here, but in general, URL parameters are typically\nintroduced with a ? and are followed by one or more name=value assignments, separated\nby & characters if there is more than one. Figure 15-8 shows the response page we get\nafter typing a URL with explicit inputs.\nFigure 15-8. tutor3.py result for parameters in a URL\nIn fact, HTML forms that specify the get encoding style also cause inputs to be added\nto URLs this way. Try changing Example 15-6 to use method=GET, and submit the form\u2014\nthe name input in the form shows up as a query parameter in the reply page address\nfield, just like the URL we manually entered in Figure 15-8. Forms can use the post or\nget style. Manually typed URLs with parameters use get.\nGenerally, any CGI script can be invoked either by filling out and submitting a form\npage or by passing inputs at the end of a URL. Although hand-coding parameters in\n1154 | Chapter 15:\u2002Server-Side ScriptingURLs can become difficult for scripts that expect many complex parameters, other\nprograms can automate the construction process.\nWhen CGI scripts are invoked with explicit input parameters this way, it\u2019s not too\ndifficult to see their similarity to functions, albeit ones that live remotely on the Net.\nPassing data to scripts in URLs is similar to keyword arguments in Python functions,\nboth operationally and syntactically. In fact, some advanced web frameworks such as\nZope make the relationship between URLs and Python function calls even more literal:\nURLs become more direct calls to Python functions.\nIncidentally, if you clear out the name input field in the form input page (i.e., make it\nempty) and press Submit, the user name field becomes empty. More accurately, the\nbrowser may not send this field along with the form data at all, even though it is listed\nin the form layout HTML. The CGI script detects such a missing field with the dic-\ntionary in expression and produces the page captured in Figure 15-9 in response.\nFigure 15-9. An empty name field producing an error page\nIn general, CGI scripts must check to see whether any inputs are missing, partly because\nthey might not be typed by a user in the form, but also because there may be no form\nat all\u2014input fields might not be tacked onto the end of an explicitly typed or con-\nstructed get-style URL. For instance, if we type the script\u2019s URL without any parameters\nat all\u2014by omitting the text from the ? and beyond, and visiting http://localhost/cgi-bin/\ntutor3.py with an explicitly entered URL\u2014we get this same error response page. Since\nwe can invoke any CGI through a form or URL, scripts must anticipate both scenarios.\nTesting outside browsers with the module urllib.request\nOnce we understand how to send inputs to forms as query string parameters at the end\nof URLs like this, the Python urllib.request module we met in Chapters 1 and 13\nbecomes even more useful. Recall that this module allows us to fetch the reply generated\nClimbing the CGI Learning Curve | 1155for any URL address. When the URL names a simple HTML file, we simply download\nits contents. But when it names a CGI script, the effect is to run the remote script and\nfetch its output. This notion opens the door to web services, which generate useful XML\nin response to input parameters; in simpler roles, this allows us to test remote scripts.\nFor example, we can trigger the script in Example 15-8 directly, without either going\nthrough the tutor3.html web page or typing a URL in a browser\u2019s address field:\nC:\\...\\PP4E\\Internet\\Web> python\n>>> from urllib.request import urlopen\n>>> reply = urlopen('http://localhost/cgi-bin/tutor3.py?user=Brian').read()\n>>> reply\nb'<TITLE>tutor3.py</TITLE>\\n<H1>Greetings</H1>\\n<HR>\\n<P>Hello, Brian.</P>\\n<HR>\\n'\n>>> print(reply.decode())\n<TITLE>tutor3.py</TITLE>\n<H1>Greetings</H1>\n<HR>\n<P>Hello, Brian.</P>\n<HR>\n>>> url   = 'http://localhost/cgi-bin/tutor3.py'\n>>> conn  = urlopen(url)\n>>> reply = conn.read()\n>>> print(reply.decode())\n<TITLE>tutor3.py</TITLE>\n<H1>Greetings</H1>\n<HR>\n<P>Who are you?</P>\n<HR>\nRecall from Chapter 13 that urllib.request.urlopen gives us a file object connected to\nthe generated reply stream. Reading this file\u2019s output returns the HTML that would\nnormally be intercepted by a web browser and rendered into a reply page. The reply\ncomes off of the underlying socket as bytes in 3.X, but can be decoded to str strings\nas needed.\nWhen fetched directly this way, the HTML reply can be parsed with Python text pro-\ncessing tools, including string methods like split and find, the re pattern-matching\nmodule, or the html.parser HTML parsing module\u2014all tools we\u2019ll explore in Chap-\nter 19. Extracting text from the reply like this is sometimes informally called screen\nscraping\u2014a way to use website content in other programs. Screen scraping is an alter-\nnative to more complex web services frameworks, though a brittle one: small changes\nin the page\u2019s format can often break scrapers that rely on it. The reply text can also be\nsimply inspected\u2014urllib.request allows us to test CGI scripts from the Python in-\nteractive prompt or other scripts, instead of a browser.\nMore generally, this technique allows us to use a server-side script as a sort of function\ncall. For instance, a client-side GUI can call the CGI script and parse the generated reply\npage. Similarly, a CGI script that updates a database may be invoked programmatically\nwith urllib.request, outside the context of an input form page. This also opens the\n1156 | Chapter 15:\u2002Server-Side Scriptingdoor to automated regression testing of CGI scripts\u2014we can invoke scripts on any\nremote machine, and compare their reply text to the expected output.\u00a7 We\u2019ll see url\nlib.request in action again in later examples.\nBefore we move on, here are a few advanced urllib.request usage notes. First, this\nmodule also supports proxies, alternative transmission modes, the client side of secure\nHTTPS, cookies, redirections, and more. For instance, proxies are supported trans-\nparently with environment variables or system settings, or by using ProxyHandler\nobjects in this module (see its documentation for details and examples).\nMoreover, although it normally doesn\u2019t make a difference to Python scripts, it is pos-\nsible to send parameters in both the get and the put submission modes described earlier\nwith urllib.request. The get mode, with parameters in the query string at the end of\na URL as shown in the prior listing, is used by default. To invoke post, pass parameters\nin as a separate argument:\n>>> from urllib.request import urlopen\n>>> from urllib.parse   import urlencode\n>>> params = urlencode({'user': 'Brian'})\n>>> params\n'user=Brian'\n>>>\n>>> print(urlopen('http://localhost/cgi-bin/tutor3.py', params).read().decode())\n<TITLE>tutor3.py</TITLE>\n<H1>Greetings</H1>\n<HR>\n<P>Hello, Brian.</P>\n<HR>\nFinally, if your web application depends on client-side cookies (discussed later) these\nare supported by urllib.request automatically, using Python\u2019s standard library cookie\nsupport to store cookies locally, and later return them to the server. It also supports\nredirection, authentication, and more; the client side of secure HTTP transmissions\n(HTTPS) is supported if your computer has secure sockets support available (most do).\nSee the Python library manual for details. We\u2019ll explore both cookies later in this chap-\nter, and introduce secure HTTPS in the next.\nUsing Tables to Lay Out Forms\nNow let\u2019s move on to something a bit more realistic. In most CGI applications, input\npages are composed of multiple fields. When there is more than one, input labels and\nfields are typically laid out in a table, to give the form a well-structured appearance.\nThe HTML file in Example 15-9 defines a form with two input fields.\n\u00a7 If your job description includes extensive testing of server-side scripts, you may also want to explore Twill,\na Python-based system that provides a little language for scripting the client-side interface to web applications.\nSearch the Web for details.\nClimbing the CGI Learning Curve | 1157Example 15-9. PP4E\\Internet\\Web\\tutor4.html\n<html>\n<title>CGI 101</title>\n<body>\n<H1>A second user interaction: tables\n</H1>\n<hr>\n<form method=POST action=\"cgi-bin/tutor4.py\">\n  <table>\n    <TR>\n      <TH align=right>Enter your name:\n      <TD><input type=text name=user>\n    <TR>\n      <TH align=right>Enter your age:\n      <TD><input type=text name=age>\n    <TR>\n      <TD colspan=2 align=center>\n      <input type=submit value=\"Send\">\n  </table>\n</form>\n</body></html>\nThe <TH> tag defines a column like <TD>, but also tags it as a header column, which \ngenerally means it is rendered in a bold font. By placing the input fields and labels in a \ntable like this, we get an input page like that shown in Figure 15-10. Labels and inputs \nare automatically lined up vertically in columns, much as they were by the tkinter GUI \ngeometry managers we met earlier in this book.\nFigure 15-10. A form laid out with table tags\n1158 | Chapter 15:\u2002Server-Side ScriptingWhen this form\u2019s Submit button (labeled \u201cSend\u201d by the page\u2019s HTML) is pressed, it\ncauses the script in Example 15-10 to be executed on the server machine, with the\ninputs typed by the user.\nExample 15-10. PP4E\\Internet\\Web\\cgi-bin\\tutor4.py\n#!/usr/bin/python\n\"\"\"\nruns on the server, reads form input, prints HTML;\nURL http://server-name/cgi-bin/tutor4.py\n\"\"\"\nimport cgi, sys\nsys.stderr = sys.stdout              # errors to browser\nform = cgi.FieldStorage()            # parse form data\nprint('Content-type: text/html\\n')   # plus blank line\n# class dummy:\n#     def __init__(self, s): self.value = s\n# form = {'user': dummy('bob'), 'age':dummy('10')}\nhtml = \"\"\"\n<TITLE>tutor4.py</TITLE>\n<H1>Greetings</H1>\n<HR>\n<H4>%s</H4>\n<H4>%s</H4>\n<H4>%s</H4>\n<HR>\"\"\"\nif not 'user' in form:\n    line1 = 'Who are you?'\nelse:\n    line1 = 'Hello, %s.' % form['user'].value\nline2 = \"You're talking to a %s server.\" % sys.platform\nline3 = \"\"\nif 'age' in form:\n    try:\n        line3 = \"Your age squared is %d!\" % (int(form['age'].value) ** 2)\n    except:\n        line3 = \"Sorry, I can't compute %s ** 2.\" % form['age'].value\nprint(html % (line1, line2, line3))\nThe table layout comes from the HTML file, not from this Python CGI script. In fact,\nthis script doesn\u2019t do much new\u2014it uses string formatting to plug input values into\nthe response page\u2019s HTML triple-quoted template string as before, this time with one\nline per input field. When this script is run by submitting the input form page, its output\nproduces the new reply page shown in Figure 15-11.\nClimbing the CGI Learning Curve | 1159Figure 15-11. Reply page generated by tutor4.py\nAs usual, we can pass parameters to this CGI script at the end of a URL, too. Fig-\nure 15-12 shows the page we get when passing a user and age explicitly in this URL:\nhttp://localhost/cgi-bin/tutor4.py?user=Joe+Blow&age=30\nFigure 15-12. Reply page from tutor4.py for parameters in URL\nNotice that we have two parameters after the ? this time; we separate them with &. Also\nnote that we\u2019ve specified a blank space in the user value with +. This is a common URL\nencoding convention. On the server side, the + is automatically replaced with a space\nagain. It\u2019s also part of the standard escape rule for URL strings, which we\u2019ll revisit later.\n1160 | Chapter 15:\u2002Server-Side ScriptingAlthough Example 15-10 doesn\u2019t introduce much that is new about CGI itself, it does\nhighlight a few new coding tricks worth noting, especially regarding CGI script de-\nbugging and security. Let\u2019s take a quick look.\nConverting strings in CGI scripts\nJust for fun, the script echoes back the name of the server platform by fetching\nsys.platform along with the square of the age input field. Notice that the age input\u2019s\nvalue must be converted to an integer with the built-in int function; in the CGI world,\nall inputs arrive as strings. We could also convert to an integer with the built-in eval\nfunction. Conversion (and other) errors are trapped gracefully in a try statement to\nyield an error line, instead of letting our script die.\nBut you should never use eval to convert strings that were sent over the\nInternet, like the age field in this example, unless you can be absolutely\nsure that the string does not contain even potentially malicious code.\nFor instance, if this example were available on the general Internet, it\u2019s\nnot impossible that someone could type a value into the age field (or\nappend an age parameter to the URL) with a value that invokes a system\nshell command. Given the appropriate context and process permissions,\nwhen passed to eval, such a string might delete all the files in your server\nscript directory, or worse!\nUnless you run CGI scripts in processes with limited permissions and\nmachine access, strings read off the Web can be dangerous to run as\ncode in CGI scripting. You should never pass them to dynamic coding\ntools like eval and exec, or to tools that run arbitrary shell commands\nsuch as os.popen and os.system, unless you can be sure that they are\nsafe. Always use simpler tools for numeric conversion like int and\nfloat, which recognize only numbers, not arbitrary Python code.\nDebugging CGI scripts\nErrors happen, even in the brave new world of the Internet. Generally speaking, de-\nbugging CGI scripts can be much more difficult than debugging programs that run on\nyour local machine. Not only do errors occur on a remote machine, but scripts generally\nwon\u2019t run without the context implied by the CGI model. The script in Exam-\nple 15-10 demonstrates the following two common debugging tricks:\nError message trapping\nThis script assigns sys.stderr to sys.stdout so that Python error messages wind\nup being displayed in the response page in the browser. Normally, Python error\nmessages are written to stderr, which generally causes them to show up in the web\nserver\u2019s console window or logfile. To route them to the browser, we must make\nstderr reference the same file object as stdout (which is connected to the browser\nin CGI scripts). If we don\u2019t do this assignment, Python errors, including program\nerrors in our script, never show up in the browser.\nClimbing the CGI Learning Curve | 1161Test case mock-up\nThe dummy class definition, commented out in this final version, was used to debug\nthe script before it was installed on the Net. Besides not seeing stderr messages by\ndefault, CGI scripts also assume an enclosing context that does not exist if they are\ntested outside the CGI environment. For instance, if run from the system command\nline, this script has no form input data. Uncomment this code to test from the\nsystem command line. The dummy class masquerades as a parsed form field object,\nand form is assigned a dictionary containing two form field objects. The net effect\nis that form will be plug-and-play compatible with the result of a\ncgi.FieldStorage call. As usual in Python, object interfaces, not datatypes, are all\nwe must adhere to.\nHere are a few general tips for debugging your server-side CGI scripts:\nRun the script from the command line\nIt probably won\u2019t generate HTML as is, but running it standalone will detect any\nsyntax errors in your code. Recall that a Python command line can run source code\nfiles regardless of their extension: for example, python somescript.cgi works fine.\nAssign sys.stderr to sys.stdout as early as possible in your script\nThis will generally make the text of Python error messages and stack dumps appear\nin your client browser when accessing the script, instead of the web server\u2019s console\nwindow or logs. Short of wading through server logs or manual exception handling,\nthis may be the only way to see the text of error messages after your script aborts.\nMock up inputs to simulate the enclosing CGI context\nFor instance, define classes that mimic the CGI inputs interface (as done with the\ndummy class in this script) to view the script\u2019s output for various test cases by running\nit from the system command line.\u2016 Setting environment variables to mimic form\nor URL inputs sometimes helps, too (we\u2019ll see how later in this chapter).\nCall utilities to display CGI context in the browser\nThe CGI module includes utility functions that send a formatted dump of CGI\nenvironment variables and input values to the browser, to view in a reply page. For\ninstance, cgi.print_form(form) prints all the input parameters sent from the client,\nand cgi.test() prints environment variables, the form, the directory, and more.\nSometimes this is enough to resolve connection or input problems. We\u2019ll use some\nof these in the webmail case study in the next chapter.\nShow exceptions you catch, print tracebacks\nIf you catch an exception that Python raises, the Python error message won\u2019t be\nprinted to stderr (that is normal behavior). In such cases, it\u2019s up to your script to\n\u2016 This technique isn\u2019t unique to CGI scripts, by the way. In Chapter 12, we briefly met systems that embed\nPython code inside HTML, such as Python Server Pages. There is no good way to test such code outside the\ncontext of the enclosing system without extracting the embedded Python code (perhaps by using the\nhtml.parser HTML parser that comes with Python, covered in Chapter 19) and running it with a passed-in\nmock-up of the API that it will eventually use.\n1162 | Chapter 15:\u2002Server-Side Scriptingdisplay the exception\u2019s name and value in the response page; exception details are\navailable in the built-in sys module, from sys.exc_info(). In addition, Python\u2019s\ntraceback module can be used to manually generate stack traces on your reply page\nfor errors; tracebacks show source-code lines active when an exception occurred.\nWe\u2019ll use this later in the error page in PyMailCGI (Chapter 16).\nAdd debugging prints\nYou can always insert tracing print statements in your code, just as in normal\nPython programs. Be sure you print the content-type header line first, though, or\nyour prints may not show up on the reply page. In the worst case, you can also\ngenerate debugging and trace messages by opening and writing to a local text file\non the server; provided you access that file later, this avoids having to format the\ntrace messages according to HTML reply stream conventions.\nRun it live\nOf course, once your script is at least half working, your best bet is likely to start\nrunning it live on the server, with real inputs coming from a browser. Running a\nserver locally on your machine, as we\u2019re doing in this chapter, can help by making\nchanges go faster as you test.\nAdding Common Input Devices\nSo far, we\u2019ve been typing inputs into text fields. HTML forms support a handful of\ninput controls (what we\u2019d call widgets in the traditional GUI world) for collecting user\ninputs. Let\u2019s look at a CGI program that shows all the common input controls at once.\nAs usual, we define both an HTML file to lay out the form page and a Python CGI script\nto process its inputs and generate a response. The HTML file is presented in\nExample 15-11.\nExample 15-11. PP4E\\Internet\\Web\\tutor5a.html\n<HTML><TITLE>CGI 101</TITLE>\n<BODY>\n<H1>Common input devices</H1>\n<HR>\n<FORM method=POST action=\"cgi-bin/tutor5.py\">\n  <H3>Please complete the following form and click Send</H3>\n  <P><TABLE>\n    <TR>\n      <TH align=right>Name:\n      <TD><input type=text name=name>\n    <TR>\n      <TH align=right>Shoe size:\n      <TD><table>\n      <td><input type=radio name=shoesize value=small>Small\n      <td><input type=radio name=shoesize value=medium>Medium\n      <td><input type=radio name=shoesize value=large>Large\n      </table>\n    <TR>\n      <TH align=right>Occupation:\nClimbing the CGI Learning Curve | 1163<TD><select name=job>\n        <option>Developer\n        <option>Manager\n        <option>Student\n        <option>Evangelist\n        <option>Other\n      </select>\n    <TR>\n      <TH align=right>Political affiliations:\n      <TD><table>\n      <td><input type=checkbox name=language value=Python>Pythonista\n      <td><input type=checkbox name=language value=Perl>Perlmonger\n      <td><input type=checkbox name=language value=Tcl>Tcler\n      </table>\n    <TR>\n      <TH align=right>Comments:\n      <TD><textarea name=comment cols=30 rows=2>Enter text here</textarea>\n    <TR>\n      <TD colspan=2 align=center>\n      <input type=submit value=\"Send\">\n  </TABLE>\n</FORM>\n<HR>\n</BODY></HTML>\nWhen rendered by a browser, the page in Figure 15-13 appears.\nFigure 15-13. Input form page generated by tutor5a.html\n1164 | Chapter 15:\u2002Server-Side ScriptingThis page contains a simple text field as before, but it also has radio buttons, a pull-\ndown selection list, a set of multiple-choice check buttons, and a multiple-line text\ninput area. All have a name option in the HTML file, which identifies their selected value\nin the data sent from client to server. When we fill out this form and click the Send\nsubmit button, the script in Example 15-12 runs on the server to process all the input\ndata typed or selected in the form.\nExample 15-12. PP4E\\Internet\\Web\\cgi-bin\\tutor5.py\n#!/usr/bin/python\n\"\"\"\nruns on the server, reads form input, prints HTML\n\"\"\"\nimport cgi, sys\nform = cgi.FieldStorage()            # parse form data\nprint(\"Content-type: text/html\")     # plus blank line\nhtml = \"\"\"\n<TITLE>tutor5.py</TITLE>\n<H1>Greetings</H1>\n<HR>\n<H4>Your name is %(name)s</H4>\n<H4>You wear rather %(shoesize)s shoes</H4>\n<H4>Your current job: %(job)s</H4>\n<H4>You program in %(language)s</H4>\n<H4>You also said:</H4>\n<P>%(comment)s</P>\n<HR>\"\"\"\ndata = {}\nfor field in ('name', 'shoesize', 'job', 'language', 'comment'):\n    if not field in form:\n        data[field] = '(unknown)'\n    else:\n        if not isinstance(form[field], list):\n            data[field] = form[field].value\n        else:\n            values = [x.value for x in form[field]]\n            data[field] = ' and '.join(values)\nprint(html % data)\nThis Python script doesn\u2019t do much; it mostly just copies form field information into\na dictionary called data so that it can be easily inserted into the triple-quoted response\ntemplate string. A few of its techniques merit explanation:\nField validation\nAs usual, we need to check all expected fields to see whether they really are present\nin the input data, using the dictionary in expression. Any or all of the input fields\nmay be missing if they weren\u2019t entered on the form or appended to an explicit URL.\nClimbing the CGI Learning Curve | 1165String formatting\nWe\u2019re using dictionary key references in the format string this time\u2014recall that %\n(name)s means pull out the value for the key name in the data dictionary and perform\na to-string conversion on its value.\nMultiple-choice fields\nWe\u2019re also testing the type of all the expected fields\u2019 values to see whether they\narrive as a list rather than the usual string. Values of multiple-choice input controls,\nlike the language choice field in this input page, are returned from\ncgi.FieldStorage as a list of objects with value attributes, rather than a simple\nsingle object with a value.\nThis script copies simple field values to the dictionary verbatim, but it uses a list\ncomprehension to collect the value fields of multiple-choice selections, and the\nstring join method to construct a single string with an and inserted between each\nselection value (e.g., Python and Tcl). The script\u2019s list comprehension is equivalent\nto the call map(lambda x: x.value, form[field]).\nNot shown here, the FieldStorage object\u2019s alternative methods getfirst and getlist\ncan also be used to treat fields as single and multiple items, whether they were sent that\nway or not (see Python\u2019s library manuals). And as we\u2019ll see later, besides simple strings\nand lists, a third type of form input object is returned for fields that specify file uploads.\nTo be robust, the script should really also escape the echoed text inserted into the\nHTML reply, lest it contain HTML operators; we will discuss escapes in detail later.\nWhen the form page is filled out and submitted, the script creates the response shown\nin Figure 15-14\u2014essentially just a formatted echo of what was sent.\nChanging Input Layouts\nSuppose that you\u2019ve written a system like that in the prior section, and your users,\nclients, and significant other start complaining that the input form is difficult to read.\nDon\u2019t worry. Because the CGI model naturally separates the user interface (the HTML\ninput page definition) from the processing logic (the CGI script), it\u2019s completely painless\nto change the form\u2019s layout. Simply modify the HTML file; there\u2019s no need to change\nthe CGI code at all. For instance, Example 15-13 contains a new definition of the input\nthat uses tables a bit differently to provide a nicer layout with borders.\nExample 15-13. PP4E\\Internet\\Web\\tutor5b.html\n<HTML><TITLE>CGI 101</TITLE>\n<BODY>\n<H1>Common input devices: alternative layout</H1>\n<P>Use the same tutor5.py server side script, but change the\nlayout of the form itself.  Notice the separation of user interface\nand processing logic here; the CGI script is independent of the\nHTML used to interact with the user/client.</P><HR>\n1166 | Chapter 15:\u2002Server-Side Scripting<FORM method=POST action=\"cgi-bin/tutor5.py\">\n  <H3>Please complete the following form and click Submit</H3>\n  <P><TABLE border cellpadding=3>\n    <TR>\n      <TH align=right>Name:\n      <TD><input type=text name=name>\n    <TR>\n      <TH align=right>Shoe size:\n      <TD><input type=radio name=shoesize value=small>Small\n          <input type=radio name=shoesize value=medium>Medium\n          <input type=radio name=shoesize value=large>Large\n    <TR>\n      <TH align=right>Occupation:\n      <TD><select name=job>\n        <option>Developer\n        <option>Manager\n        <option>Student\n        <option>Evangelist\n        <option>Other\n      </select>\n    <TR>\n      <TH align=right>Political affiliations:\n      <TD><P><input type=checkbox name=language value=Python>Pythonista\n          <P><input type=checkbox name=language value=Perl>Perlmonger\n          <P><input type=checkbox name=language value=Tcl>Tcler\n    <TR>\n      <TH align=right>Comments:\n      <TD><textarea name=comment cols=30 rows=2>Enter spam here</textarea>\n    <TR>\nFigure 15-14. Response page created by tutor5.py (1)\nClimbing the CGI Learning Curve | 1167<TD colspan=2 align=center>\n      <input type=submit value=\"Submit\">\n      <input type=reset  value=\"Reset\">\n  </TABLE>\n</FORM>\n</BODY></HTML>\nWhen we visit this alternative page with a browser, we get the interface shown in\nFigure 15-15.\nFigure 15-15. Form page created by tutor5b.html\nNow, before you go blind trying to detect the differences in this and the prior HTML\nfile, I should note that the HTML differences that produce this page are much less\nimportant for this book than the fact that the action fields in these two pages\u2019 forms\nreference identical URLs. Pressing this version\u2019s Submit button triggers the exact same\nand totally unchanged Python CGI script again, tutor5.py (Example 15-12).\nThat is, scripts are completely independent of both the transmission mode (URL query\nparameters of form fields) and the layout of the user interface used to send them in-\nformation. Changes in the response page require changing the script, of course, because\nthe HTML of the reply page is still embedded in the CGI script. But we can change the\ninput page\u2019s HTML as much as we like without affecting the server-side Python code.\nFigure 15-16 shows the response page produced by the script this time around.\n1168 | Chapter 15:\u2002Server-Side ScriptingFigure 15-16. Response page created by tutor5.py (2)\nKeeping display and logic separate\nIn fact, this illustrates an important point in the design of larger websites: if we are\ncareful to keep the HTML and script code separate, we get a useful division of display\nand logic\u2014each part can be worked on independently, by people with different skill\nsets. Web page designers, for example, can work on the display layout, while pro-\ngrammers can code business logic.\nAlthough this section\u2019s example is fairly small, it already benefits from this separation\nfor the input page. In some cases, the separation is harder to accomplish, because our\nexample scripts embed the HTML of reply pages. With just a little more work, though,\nwe can usually split the reply HTML off into separate files that can also be developed\nindependently of the script\u2019s logic. The html string in tutor5.py (Example 15-12), for\ninstance, might be stored in a text file and loaded by the script when run.\nIn larger systems, tools such as server-side HTML templating languages help make the\ndivision of display and logic even easier to achieve. The Python Server Pages system\nand frameworks such as Zope and Django, for instance, promote the separation of\ndisplay and logic by providing reply page description languages that are expanded to\ninclude portions generated by separate Python program logic. In a sense, server-side\ntemplating languages embed Python in HTML\u2014the opposite of CGI scripts that embed\nHTML in Python\u2014and may provide a cleaner division of labor, provided the Python\nClimbing the CGI Learning Curve | 1169code is separate components. Search the Web for more details. Similar techniques can\nbe used for separation of layout and login in the GUIs we studied earlier in this book,\nbut they also usually require larger frameworks or models to achieve.\nPassing Parameters in Hardcoded URLs\nEarlier, we passed parameters to CGI scripts by listing them at the end of a URL typed\ninto the browser\u2019s address field\u2014in the query string parameters part of the URL, after\nthe ?. But there\u2019s nothing sacred about the browser\u2019s address field. In particular, noth-\ning is stopping us from using the same URL syntax in hyperlinks that we hardcode or\ngenerate in web page definitions.\nFor example, the web page from Example 15-14 defines three hyperlinks (the text be-\ntween the <A> and </A> tags), which trigger our original tutor5.py script again (Exam-\nple 15-12), but with three different precoded sets of parameters.\nExample 15-14. PP4E\\Internet\\Web\\tutor5c.html\n<HTML><TITLE>CGI 101</TITLE>\n<BODY>\n<H1>Common input devices: URL parameters</H1>\n<P>This demo invokes the tutor5.py server-side script again,\nbut hardcodes input data to the end of the script's URL,\nwithin a simple hyperlink (instead of packaging up a form's\ninputs).  Click your browser's \"show page source\" button\nto view the links associated with each list item below.\n<P>This is really more about CGI than Python, but notice that\nPython's cgi module handles both this form of input (which is\nalso produced by GET form actions), as well as POST-ed forms;\nthey look the same to the Python CGI script.  In other words,\ncgi module users are independent of the method used to submit\ndata.\n<P>Also notice that URLs with appended input values like this\ncan be generated as part of the page output by another CGI script,\nto direct a next user click to the right place and context; together\nwith type 'hidden' input fields, they provide one way to\nsave state between clicks.\n</P><HR>\n<UL>\n<LI><A href=\"cgi-bin/tutor5.py?name=Bob&shoesize=small\">Send Bob, small</A>\n<LI><A href=\"cgi-bin/tutor5.py?name=Tom&language=Python\">Send Tom, Python</A>\n<LI><A href=\"http://localhost/cgi-bin/tutor5.py?job=Evangelist&comment=spam\">\nSend Evangelist, spam</A>\n</UL>\n<HR></BODY></HTML>\n1170 | Chapter 15:\u2002Server-Side ScriptingThis static HTML file defines three hyperlinks\u2014the first two are minimal and the third\nis fully specified, but all work similarly (again, the target script doesn\u2019t care). When we\nvisit this file\u2019s URL, we see the page shown in Figure 15-17. It\u2019s mostly just a page for\nlaunching canned calls to the CGI script. (I\u2019ve reduced the text font size here to fit in\nthis book: run this live if you have trouble reading it here.)\nFigure 15-17. Hyperlinks page created by tutor5c.html\nClicking on this page\u2019s second link creates the response page in Figure 15-18. This link\ninvokes the CGI script, with the name parameter set to \u201cTom\u201d and the language pa-\nrameter set to \u201cPython,\u201d simply because those parameters and values are hardcoded in\nthe URL listed in the HTML for the second hyperlink. As such, hyperlinks with pa-\nrameters like this are sometimes known as stateful links\u2014they automatically direct the\nnext script\u2019s operation. The net effect is exactly as if we had manually typed the line\nshown at the top of the browser in Figure 15-18.\nNotice that many fields are missing here; the tutor5.py script is smart enough to detect\nand handle missing fields and generate an unknown message in the reply page. It\u2019s also\nworth pointing out that we\u2019re reusing the Python CGI script again. The script itself is\ncompletely independent of both the user interface format of the submission page, as\nwell as the technique used to invoke it\u2014from a submitted form or a hardcoded URL\nwith query parameters. By separating such user interface details from processing logic,\nCGI scripts become reusable software components, at least within the context of the\nCGI environment.\nClimbing the CGI Learning Curve | 1171The query parameters in the URLs embedded in Example 15-14 were hardcoded in the\npage\u2019s HTML. But such URLs can also be generated automatically by a CGI script as\npart of a reply page in order to provide inputs to the script that implements a next step\nin user interaction. They are a simple way for web-based applications to \u201cremember\u201d\nthings for the duration of a session. Hidden form fields, up next, serve some of the same \npurposes.\nPassing Parameters in Hidden Form Fields\nSimilar in spirit to the prior section, inputs for scripts can also be hardcoded in a page\u2019s\nHTML as hidden input fields. Such fields are not displayed in the page, but are trans-\nmitted back to the server when the form is submitted. Example 15-15, for instance,\nallows a job field to be entered, but fills in name and language parameters automatically\nas hidden input fields.\nExample 15-15. PP4E\\Internet\\Web\\tutor5d.html\n<HTML><TITLE>CGI 101</TITLE>\n<BODY>\n<H1>Common input devices: hidden form fields</H1>\n<P>This demo invokes the tutor5.py server-side script again,\nbut hardcodes input data in the form itself as hidden input\nfields, instead of as parameters at the end of URL hyperlinks.\nAs before, the text of this form, including the hidden fields,\ncan be generated as part of the page output by another CGI\nFigure 15-18. Response page created by tutor5.py (3)\n1172 | Chapter 15:\u2002Server-Side Scriptingscript, to pass data on to the next script on submit; hidden\nform fields provide another way to save state between pages.\n</P><HR><p>\n<form method=post action=\"cgi-bin/tutor5.py\">\n    <input type=hidden name=name     value=Sue>\n    <input type=hidden name=language value=Python>\n    <input type=text   name=job      value=\"Enter job\">\n    <input type=submit value=\"Submit Sue\">\n</form>\n</p><HR></BODY></HTML>\nWhen Example 15-15 is opened in a browser, we get the input page in Figure 15-19.\nFigure 15-19. tutor5d.html input form page\nWhen submitting, we trigger our original tutor5.py script once again (Exam-\nple 15-12), but some of the inputs have been provided for us as hidden fields. The reply\npage is captured in Figure 15-20.\nMuch like the query parameters of the prior section, here again we\u2019ve hardcoded and\nembedded the next page\u2019s inputs in the input page\u2019s HTML itself. Unlike query pa-\nrameters, hidden input fields don\u2019t show up in the next page\u2019s address. Like query\nparameters, such input fields can also be generated on the fly as part of the reply from\na CGI script. When they are, they serve as inputs for the next page, and so are a sort of\nmemory\u2014session state passed from one script to the next. To fully understand how\nand why this is necessary, we need to next take a short diversion into state retention\nalternatives.\nClimbing the CGI Learning Curve | 1173Saving State Information in CGI Scripts\nOne of the most unusual aspects of the basic CGI model, and one of its starkest con-\ntrasts to the GUI programming techniques we studied in the prior part of this book, is\nthat CGI scripts are stateless\u2014each is a standalone program, normally run autono-\nmously, with no knowledge of any other scripts that may run before or after. There is\nno notion of things such as global variables or objects that outlive a single step of\ninteraction and retain context. Each script begins from scratch, with no memory of\nwhere the prior left off.\nThis makes web servers simple and robust\u2014a buggy CGI script won\u2019t interfere with\nthe server process. In fact, a flaw in a CGI script generally affects only the single page\nit implements, not the entire web-based application. But this is a very different model\nfrom callback-handler functions in a single process GUI, and it requires extra work to\nremember things longer than a single script\u2019s execution.\nLack of state retention hasn\u2019t mattered in our simple examples so far, but larger systems\nare usually composed of multiple user interaction steps and many scripts, and they\nneed a way to keep track of information gathered along the way. As suggested in the\nFigure 15-20. Response page created by tutor5.py (4)\n1174 | Chapter 15:\u2002Server-Side Scriptinglast two sections, generating query parameters on URL links and hidden form fields in\ninput pages sent as replies are two simple ways for a CGI script to pass data to the next\nscript in the application. When clicked or submitted, such parameters send\npreprogrammed selection or session information back to another server-side handler\nscript. In a sense, the content of the generated reply page itself becomes the memory\nspace of the application.\nFor example, a site that lets you read your email may present you with a list of viewable\nemail messages, implemented in HTML as a list of hyperlinks generated by another\nscript. Each hyperlink might include the name of the message viewer script, along with\nparameters identifying the selected message number, email server name, and so on\u2014\nas much data as is needed to fetch the message associated with a particular link. A retail\nsite may instead serve up a generated list of product links, each of which triggers a\nhardcoded hyperlink containing the product number, its price, and so on. Alternatively,\nthe purchase page at a retail site may embed the product selected in a prior page as\nhidden form fields.\nIn fact, one of the main reasons for showing the techniques in the last two sections is\nthat we\u2019re going to use them extensively in the larger case study in the next chapter.\nFor instance, we\u2019ll use generated stateful URLs with query parameters to implement\nlists of dynamically generated selections that \u201cknow\u201d what to do when clicked. Hidden\nform fields will also be deployed to pass user login data to the next page\u2019s script. From\na more general perspective, both techniques are ways to retain state information be-\ntween pages\u2014they can be used to direct the action of the next script to be run.\nGenerating URL parameters and hidden form fields works well for retaining state in-\nformation across pages during a single session of interaction. Some scenarios require\nmore, though. For instance, what if we want to remember a user\u2019s login name from\nsession to session? Or what if we need to keep track of pages at our site visited by a\nuser in the past? Because such information must be longer lived than the pages of a\nsingle session of interaction, query parameters and hidden form fields won\u2019t suffice. In\nsome cases, the required state information might also be too large to embed in a reply\npage\u2019s HTML.\nIn general, there are a variety of ways to pass or retain state information between CGI\nscript executions and across sessions of interaction:\nURL query parameters\nSession state embedded in generated reply pages\nHidden form fields\nSession state embedded in generated reply pages\nCookies\nSmaller information stored on the client that may span sessions\nServer-side databases\nLarger information that might span sessions\nSaving State Information in CGI Scripts | 1175CGI model extensions\nPersistent processes, session management, and so on\nWe\u2019ll explore most of these in later examples, but since this is a core idea in server-side\nscripting, let\u2019s take a brief look at each of these in turn.\nURL Query Parameters\nWe met these earlier in this chapter: hardcoded URL parameters in dynamically gen-\nerated hyperlinks embedded in input pages produced as replies. By including both a\nprocessing script name and input to it, such links direct the operation of the next page\nwhen selected. The parameters are transmitted from client to server automatically, as\npart of a GET-style request.\nCoding query parameters is straightforward\u2014print the correctly formatted URL to\nstandard output from your CGI script as part of the reply page (albeit following some\nescaping conventions we\u2019ll meet later in this chapter). Here\u2019s an example drawn from\nthe next chapter\u2019s webmail case study:\nscript = \"onViewListLink.py\"\nuser = 'bob'\nmnum = 66\npswd = 'xxx'\nsite = ' pop.myisp.net'\nprint('<a href=\"%s?user=%s&pswd=%s&mnum=%d&site=%s\">View %s</a>'\n              % (script, user, pswd, mnum, site, mnum))\nThe resulting URL will have enough information to direct the next script when clicked:\n<a href=\"onViewListLink.py?user=bob&pswd=xxx&mnum=66&site=pop.myisp.net\">View 66</a>\nQuery parameters serve as memory, and they pass information between pages. As such,\nthey are useful for retaining state across the pages of a single session of interaction.\nSince each generated URL may have different attached parameters, this scheme can\nprovide context per user-selectable action. Each link in a list of selectable alternatives,\nfor example, may have a different implied action coded as a different parameter value.\nMoreover, users can bookmark a link with parameters, in order to return to a specific\nstate in an interaction.\nBecause their state retention is lost when the page is abandoned, though, they are not\nuseful for remembering state from session to session. Moreover, the data appended as\nURL query parameters is generally visible to users and may appear in server logfiles; in\nsome applications, it may have to be manually encrypted to avoid display or forgery.\nHidden Form Input Fields\nWe met these in the prior section as well: hidden form input fields that are attached to\nform data and are embedded in reply web pages, but are not displayed in web pages or\ntheir URL addresses. When the form is submitted, all the hidden fields are transmitted\n1176 | Chapter 15:\u2002Server-Side Scriptingto the next script along with any real inputs, to serve as context. The net effect provides\ncontext for an entire input form, not a particular hyperlink. An already entered user-\nname, password, or selection, for instance, can be implied by the values of hidden fields\nin subsequently generated pages.\nIn terms of code, hidden fields are generated by server-side scripts as part of the reply\npage\u2019s HTML and are later returned by the client with all of the form\u2019s input data.\nPreviewing the next chapter\u2019s usage again:\nprint('<form method=post action=\"%s/onViewSubmit.py\">' % urlroot)\nprint('<input type=hidden name=mnum value=\"%s\">' % msgnum)\nprint('<input type=hidden name=user value=\"%s\">' % user)\nprint('<input type=hidden name=site value=\"%s\">' % site)\nprint('<input type=hidden name=pswd value=\"%s\">' % pswd)\nLike query parameters, hidden form fields can also serve as a sort of memory, retaining\nstate information from page to page. Also like query parameters, because this kind of\nmemory is embedded in the page itself, hidden fields are useful for state retention\namong the pages of a single session of interaction, but not for data that spans multiple\nsessions.\nAnd like both query parameters and cookies (up next), hidden form fields may be visible\nto users\u2014though hidden in rendered pages and URLs, their values still are displayed\nif the page\u2019s raw HTML source code is displayed. As a result, hidden form fields are\nnot secure; encryption of the embedded data may again be required in some contexts\nto avoid display on the client or forgery in form submissions.\nHTTP \u201cCookies\u201d\nCookies, an oextension to the HTTP protocol underlying the web model, are a way for\nserver-side applications to directly store information on the client computer. Because\nthis information is not embedded in the HTML of web pages, it outlives the pages of\na single session. As such, cookies are ideal for remembering things that must span\nsessions.\nThings like usernames and preferences, for example, are prime cookie candidates\u2014\nthey will be available the next time the client visits our site. However, because cookies\nmay have space limitations, are seen by some as intrusive, and can be disabled by users\non the client, they are not always well suited to general data storage needs. They are\noften best used for small pieces of noncritical cross-session state information, and\nwebsites that aim for broad usage should generally still be able to operate if cookies are\nunavailable.\nOperationally, HTTP cookies are strings of information stored on the client machine\nand transferred between client and server in HTTP message headers. Server-side scripts\ngenerate HTTP headers to request that a cookie be stored on the client as part of the\nscript\u2019s reply stream. Later, the client web browser generates HTTP headers that send\nback all the cookies matching the server and page being contacted. In effect, cookie\nSaving State Information in CGI Scripts | 1177data is embedded in the data streams much like query parameters and form fields, but\nit is contained in HTTP headers, not in a page\u2019s HTML. Moreover, cookie data can be\nstored permanently on the client, and so it outlives both pages and interactive sessions.\nFor web application developers, Python\u2019s standard library includes tools that simplify\nthe task of sending and receiving: http.cookiejar does cookie handling for HTTP cli-\nents that talk to web servers, and the module http.cookies simplifies the task of creating\nand receiving cookies in server-side scripts. Moreover, the module urllib.request \nwe\u2019ve studied earlier has support for opening URLs with automatic cookie handling.\nCreating a cookie\nWeb browsers such as Firefox and Internet Explorer generally handle the client side of\nthis protocol, storing and sending cookie data. For the purpose of this chapter, we are\nmainly interested in cookie processing on the server. Cookies are created by sending\nspecial HTTP headers at the start of the reply stream:\nContent-type: text/html\nSet-Cookie: foo=bar;\n<HTML>...\nThe full format of a cookie\u2019s header is as follows:\nSet-Cookie: name=value; expires=date; path=pathname; domain=domainname; secure\nThe domain defaults to the hostname of the server that set the cookie, and the path\ndefaults to the path of the document or script that set the cookie\u2014these are later\nmatched by the client to know when to send a cookie\u2019s value back to the server. In\nPython, cookie creation is simple; the following in a CGI script stores a last-visited time\ncookie:\nimport http.cookies, time\ncook = http.cookies.SimpleCookie()\ncook['visited'] = str(time.time())     # a dictionary\nprint(cook.output())                   # prints \"Set-Cookie: visited=1276623053.89\"\nprint('Content-type: text/html\\n')\nThe SimpleCookie call here creates a dictionary-like cookie object whose keys are strings\n(the names of the cookies), and whose values are \u201cMorsel\u201d objects (describing the\ncookie\u2019s value). Morsels in turn are also dictionary-like objects with one key per cookie\nproperty: path and domain, expires to give the cookie an expiration date (the default is\nthe duration of the browser session), and so on. Morsels also have attributes\u2014for in-\nstance, key and value give the name and value of the cookie, respectively. Assigning a\nstring to a cookie key automatically creates a Morsel from the string, and the cookie\nobject\u2019s output method returns a string suitable for use as an HTTP header; printing\nthe object directly has the same effect, due to its __str__ operator overloading. Here is\na more comprehensive example of the interface in action:\n>>> import http.cookies, time\n>>> cooks = http.cookies.SimpleCookie()\n1178 | Chapter 15:\u2002Server-Side Scripting>>> cooks['visited']  = time.asctime()\n>>> cooks['username'] = 'Bob'\n>>> cooks['username']['path'] = '/myscript'\n>>> cooks['visited'].value\n'Tue Jun 15 13:35:20 2010'\n>>> print(cooks['visited'])\nSet-Cookie: visited=\"Tue Jun 15 13:35:20 2010\"\n>>> print(cooks)\nSet-Cookie: username=Bob; Path=/myscript\nSet-Cookie: visited=\"Tue Jun 15 13:35:20 2010\"\nReceiving a cookie\nNow, when the client visits the page again in the future, the cookie\u2019s data is sent back\nfrom the browser to the server in HTTP headers again, in the form \u201cCookie:\nname1=value1; name2=value2 ...\u201d. For example:\nCookie: visited=1276623053.89\nRoughly, the browser client returns all cookies that match the requested server\u2019s do-\nmain name and path. In the CGI script on the server, the environment variable\nHTTP_COOKIE contains the raw cookie data headers string uploaded from the client; it\ncan be extracted in Python as follows:\nimport os, http.cookies\ncooks = http.cookies.SimpleCookie(os.environ.get(\"HTTP_COOKIE\"))\nvcook = cooks.get(\"visited\")     # a Morsel dictionary\nif vcook != None:\n    time = vcook.value\nHere, the SimpleCookie constructor call automatically parses the passed-in cookie data\nstring into a dictionary of Morsel objects; as usual, the dictionary get method returns\na default None if a key is absent, and we use the Morsel object\u2019s value attribute to extract\nthe cookie\u2019s value string if sent.\nUsing cookies in CGI scripts\nTo help put these pieces together, Example 15-16 lists a CGI script that stores a client-\nside cookie when first visited and receives and displays it on subsequent visits.\nExample 15-16. PP4E\\Internet\\Web\\cgi-bin\\cookies.py\n\"\"\"\ncreate or use a client-side cookie storing username;\nthere is no input form data to parse in this example\n\"\"\"\nimport http.cookies, os\ncookstr  = os.environ.get(\"HTTP_COOKIE\")\ncookies  = http.cookies.SimpleCookie(cookstr)\nusercook = cookies.get(\"user\")                     # fetch if sent\nif usercook == None:                               # create first time\nSaving State Information in CGI Scripts | 1179cookies = http.cookies.SimpleCookie()          # print Set-cookie hdr\n    cookies['user']  = 'Brian'\n    print(cookies)\n    greeting = '<p>His name shall be... %s</p>' % cookies['user']\nelse:\n    greeting = '<p>Welcome back, %s</p>' % usercook.value\nprint('Content-type: text/html\\n')                 # plus blank line now\nprint(greeting)                                    # and the actual html\nAssuming you are running this chapter\u2019s local web server from Example 15-1, you can\ninvoke this script with a URL such as http://localhost/cgi-bin/cookies.py (type this in\nyour browser\u2019s address field, or submit it interactively with the module url\nlib.request). The first time you visit the script, the script sets the cookie within its\nreply\u2019s headers, and you\u2019ll see a reply page with this message:\nHis name shall be... Set-Cookie: user=Brian\nThereafter, revisiting the script\u2019s URL in the same browser session (use your browser\u2019s\nreload button) produces a reply page with this message:\nWelcome back, Brian\nThis occurs because the client is sending the previously stored cookie value back to the\nscript, at least until you kill and restart your web browser\u2014the default expiration of a\ncookie is the end of a browsing session. In a realistic program, this sort of structure\nmight be used by the login page of a web application; a user would need to enter his\nname only once per browser session.\nHandling cookies with the urllib.request module\nAs mentioned earlier, the urllib.request module provides an interface for reading the\nreply from a URL, but it uses the http.cookiejar module to also support storing and\nsending cookies on the client. However, it does not support cookies \u201cout of the box.\u201d\nFor example, here it is in action testing the last section\u2019s cookie-savvy script\u2014cookies\nare not echoed back to the server when a script is revisited:\n>>> from urllib.request import urlopen\n>>> reply = urlopen('http://localhost/cgi-bin/cookies.py').read()\n>>> print(reply)\nb'<p>His name shall be... Set-Cookie: user=Brian</p>\\n'\n>>> reply = urlopen('http://localhost/cgi-bin/cookies.py').read()\n>>> print(reply)\nb'<p>His name shall be... Set-Cookie: user=Brian</p>\\n'\nTo support cookies with this module properly, we simply need to enable the cookie-\nhandler class; the same is true for other optional extensions in this module. Again,\ncontacting the prior section\u2019s script:\n>>> import urllib.request as urllib\n>>> opener = urllib.build_opener(urllib.HTTPCookieProcessor())\n>>> urllib.install_opener(opener)\n1180 | Chapter 15:\u2002Server-Side Scripting>>>\n>>> reply = urllib.urlopen('http://localhost/cgi-bin/cookies.py').read()\n>>> print(reply)\nb'<p>His name shall be... Set-Cookie: user=Brian</p>\\n'\n>>> reply = urllib.urlopen('http://localhost/cgi-bin/cookies.py').read()\n>>> print(reply)\nb'<p>Welcome back, Brian</p>\\n'\n>>> reply = urllib.urlopen('http://localhost/cgi-bin/cookies.py').read()\n>>> print(reply)\nb'<p>Welcome back, Brian</p>\\n'\nThis works because urllib.request mimics the cookie behavior of a web browser on\nthe client\u2014it stores the cookie when so requested in the headers of a script\u2019s reply, and\nadds it to headers sent back to the same script on subsequent visits. Also just as in a\nbrowser, the cookie is deleted if you exit Python and start a new session to rerun this\ncode. See the library manual for more on this module\u2019s interfaces.\nAlthough easy to use, cookies have potential downsides. For one, they may be subject\nto size limitations (4 KB per cookie, 300 total, and 20 per domain are one common\nlimit). For another, users can disable cookies in most browsers, making them less suited\nto critical data. Some even see them as intrusive, because they can be abused to track\nuser behavior. (Many sites simply require cookies to be turned on, finessing the issue\ncompletely.) Finally, because cookies are transmitted over the network between client\nand server, they are still only as secure as the transmission stream itself; this may be an\nissue for sensitive data if the page is not using secure HTTP transmissions between\nclient and server. We\u2019ll explore secure cookies and server concepts in the next chapter.\nFor more details on the cookie modules and the cookie protocol in general, see Python\u2019s\nlibrary manual, and search the Web for resources. It\u2019s not impossible that future mu-\ntations of HTML may provide similar storage solutions.\nServer-Side Databases\nFor more industrial-strength state retention, Python scripts can employ full-blown da-\ntabase solutions in the server. We will study these options in depth in Chapter 17.\nPython scripts have access to a variety of server-side data stores, including flat files,\npersistent object pickles and shelves, object-oriented databases such as ZODB, and\nrelational SQL-based databases such as MySQL, PostgreSQL, Oracle, and SQLite. Be-\nsides data storage, such systems may provide advanced tools such as transaction com-\nmits and rollbacks, concurrent update synchronization, and more.\nFull-blown databases are the ultimate storage solution. They can be used to represent\nstate both between the pages of a single session (by tagging the data with generated\nper-session keys) and across multiple sessions (by storing data under per-user keys).\nGiven a user\u2019s login name, for example, CGI scripts can fetch all of the context we have\ngathered in the past about that user from the server-side database. Server-side databases\nSaving State Information in CGI Scripts | 1181are ideal for storing more complex cross-session information; a shopping cart applica-\ntion, for instance, can record items added in the past in a server-side database.\nDatabases outlive both pages and sessions. Because data is kept explicitly, there is no\nneed to embed it within the query parameters or hidden form fields of reply pages.\nBecause the data is kept on the server, there is no need to store it on the client in cookies.\nAnd because such schemes employ general-purpose databases, they are not subject to\nthe size constraints or optional nature of cookies.\nIn exchange for their added utility, full-blown databases require more in terms of in-\nstallation, administration, and coding. As we\u2019ll see in Chapter 17, luckily the extra\ncoding part of that trade-off is remarkably simple in Python. Moreover, Python\u2019s da-\ntabase interfaces may be used in any application, web-based or otherwise.\nExtensions to the CGI Model\nFinally, there are more advanced protocols and frameworks for retaining state on the\nserver, which we won\u2019t cover in this book. For instance, the Zope web application\nframework, discussed briefly in Chapter 12, provides a product interface, which allows\nfor the construction of web-based objects that are automatically persistent.\nOther schemes, such as FastCGI, as well as server-specific extensions such as\nmod_python for Apache, may attempt to work around the autonomous, one-shot nature\nof CGI scripts, or otherwise extend the basic CGI model to support long-lived memory\nstores. For example:\n\u2022 FastCGI allows web applications to run as persistent processes, which receive input\ndata from and send reply streams to the HTTP web server over Inter-Process Com-\nmunication (IPC) mechanisms such as sockets. This differs from normal CGI,\nwhich communicates inputs and outputs with environment variables, standard\nstreams, and command-line arguments, and assumes scripts run to completion on\neach request. Because a FastCGI process may outlive a single page, it can retain\nstate information from page to page, and avoids startup performance costs.\n\u2022 mod_python extends the open source Apache web server by embedding the Python\ninterpreter within Apache. Python code is executed directly within the Apache\nserver, eliminating the need to spawn external processes. This package also sup-\nports the concept of sessions, which can be used to store data between pages.\nSession data is locked for concurrent access and can be stored in files or in memory,\ndepending on whether Apache is running in multiprocess or multithreaded mode.\nmod_python also includes web development tools, such as the Python Server Pages \n(PSP) server-side templating language for HTML generation mentioned in Chap-\nter 12 and earlier in this chapter.\nSuch models are not universally supported, though, and may come with some added\ncost in complexity\u2014for example, to synchronize access to persistent data with locks.\nMoreover, a failure in a FastCGI-style web application impacts the entire application,\n1182 | Chapter 15:\u2002Server-Side Scriptingnot just a single page, and things like memory leaks become much more costly. For\nmore on persistent CGI models, and support in Python for things such as FastCGI,\nsearch the Web or consult web-specific resources.\nCombining Techniques\nNaturally, these techniques may be combined to achieve a variety of memory strategies,\nboth for interaction sessions and for more permanent storage needs. For example:\n\u2022 A web application may use cookies to store a per-user or per-session key on the\nclient, and later use that key to index into a server-side database to retrieve the\nuser\u2019s or session\u2019s full state information.\n\u2022 Even for short-lived session information, URL query parameters or hidden form\nfields may similarly be used to pass a key identifying the session from page to page,\nto be used by the next script to index a server-side database.\n\u2022 Moreover, URL query parameters and hidden fields may be generated for tempo-\nrary state memory that spans pages, even though cookies and databases are used\nfor retention that must span sessions.\nThe choice of technique is driven by the application\u2019s storage needs. Although not as\nstraightforward as the in-memory variables and objects of single process GUI programs\nrunning on a client, with creativity, CGI script state retention is entirely possible.\nThe Hello World Selector\nLet\u2019s get back to writing some code again. It\u2019s time for something a bit more useful than\nthe examples we\u2019ve seen so far (well, more entertaining, at least). This section presents\na program that displays the basic syntax required by various programming languages\nto print the string \u201cHello World,\u201d the classic language benchmark.\nTo keep it simple, this example assumes that the string is printed to the standard output\nstream in the selected language, not to a GUI or web page. It also gives just the output\ncommand itself, not complete programs. The Python version happens to be a complete\nprogram, but we won\u2019t hold that against its competitors here.\nStructurally, the first cut of this example consists of a main page HTML file, along with\na Python-coded CGI script that is invoked by a form in the main HTML page. Because\nno state or database data is stored between user clicks, this is still a fairly simple\nexample. In fact, the main HTML page implemented by Example 15-17 is mostly just\none big pull-down selection list within a form.\nExample 15-17. PP4E\\Internet\\Web\\languages.html\n<html><title>Languages</title>\n<body>\n<h1>Hello World selector</h1>\nThe Hello World Selector | 1183<P>This demo shows how to display a \"hello world\" message in various\nprogramming languages' syntax.  To keep this simple, only the output command\nis shown (it takes more code to make a complete program in some of these\nlanguages), and only text-based solutions are given (no GUI or HTML\nconstruction logic is included). This page is a simple HTML file; the one\nyou see after pressing the button below is generated by a Python CGI script\nwhich runs on the server. Pointers:\n<UL>\n<LI>To see this page's HTML, use the 'View Source' command in your browser.\n<LI>To view the Python CGI script on the server,\n    <A HREF=\"cgi-bin/languages-src.py\">click here</A> or\n    <A HREF=\"cgi-bin/getfile.py?filename=cgi-bin\\languages.py\">here</A>.\n<LI>To see an alternative version that generates this page dynamically,\n    <A HREF=\"cgi-bin/languages2.py\">click here</A>.\n</UL></P>\n<hr>\n<form method=POST action=\"cgi-bin/languages.py\">\n    <P><B>Select a programming language:</B>\n    <P><select name=language>\n        <option>All\n        <option>Python\n        <option>Python2\n        <option>Perl\n        <option>Tcl\n        <option>Scheme\n        <option>SmallTalk\n        <option>Java\n        <option>C\n        <option>C++\n        <option>Basic\n        <option>Fortran\n        <option>Pascal\n        <option>Other\n    </select>\n    <P><input type=Submit>\n</form>\n</body></html>\nFor the moment, let\u2019s ignore some of the hyperlinks near the middle of this file; they\nintroduce bigger concepts like file transfers and maintainability that we will explore in\nthe next two sections. When visited with a browser, this HTML file is downloaded to\nthe client and is rendered into the new browser page shown in Figure 15-21.\nThat widget above the Submit button is a pull-down selection list that lets you choose\none of the <option> tag values in the HTML file. As usual, selecting one of these language\nnames and pressing the Submit button at the bottom (or pressing your Enter key) sends\nthe selected language name to an instance of the server-side CGI script program named\nin the form\u2019s action option. Example 15-18 contains the Python script that is run by\nthe web server upon submission.\n1184 | Chapter 15:\u2002Server-Side ScriptingExample 15-18. PP4E\\Internet\\Web\\cgi-bin\\languages.py\n#!/usr/bin/python\n\"\"\"\nshow hello world syntax for input language name; note that it uses r'...'\nraw strings so that '\\n' in the table are left intact, and cgi.escape()\non the string so that things like '<<' don't confuse browsers--they are\ntranslated to valid HTML code; any language name can arrive at this script,\nsince explicit URLs \"http://servername/cgi-bin/languages.py?language=Cobol\"\ncan be typed in a web browser or sent by a script (urllib.request.urlopen).\ncaveats: the languages list appears in both the CGI and HTML files--could\nimport from single file if selection list generated by a CGI script too;\n\"\"\"\ndebugme  = False                                 # True=test from cmd line\ninputkey = 'language'                            # input parameter name\nhellos = {\n    'Python':    r\" print('Hello World')               \",\n    'Python2':   r\" print 'Hello World'                \",\n    'Perl':      r' print \"Hello World\\n\";             ',\n    'Tcl':       r' puts \"Hello World\"                 ',\n    'Scheme':    r' (display \"Hello World\") (newline)  ',\n    'SmallTalk': r\" 'Hello World' print.               \",\n    'Java':      r' System.out.println(\"Hello World\"); ',\n    'C':         r' printf(\"Hello World\\n\");           ',\n    'C++':       r' cout << \"Hello World\" << endl;     ',\n    'Basic':     r' 10 PRINT \"Hello World\"             ',\n    'Fortran':   r\" print *, 'Hello World'             \",\n    'Pascal':    r\" WriteLn('Hello World');            \"\n}\nFigure 15-21. The \u201cHello World\u201d main page\nThe Hello World Selector | 1185class dummy:                                       # mocked-up input obj\n    def __init__(self, str): self.value = str\nimport cgi, sys\nif debugme:\n    form = {inputkey: dummy(sys.argv[1])}          # name on cmd line\nelse:\n    form = cgi.FieldStorage()                      # parse real inputs\nprint('Content-type: text/html\\n')                 # adds blank line\nprint('<TITLE>Languages</TITLE>')\nprint('<H1>Syntax</H1><HR>')\ndef showHello(form):                               # HTML for one language\n    choice = form[inputkey].value\n    print('<H3>%s</H3><P><PRE>' % choice)\n    try:\n        print(cgi.escape(hellos[choice]))\n    except KeyError:\n        print(\"Sorry--I don't know that language\")\n    print('</PRE></P><BR>')\nif not inputkey in form or form[inputkey].value == 'All':\n    for lang in hellos.keys():\n        mock = {inputkey: dummy(lang)}\n        showHello(mock)\nelse:\n    showHello(form)\nprint('<HR>')\nAnd as usual, this script prints HTML code to the standard output stream to produce\na response page in the client\u2019s browser. Not much is new to speak of in this script, but\nit employs a few techniques that merit special focus:\nRaw strings and quotes\nNotice the use of raw strings (string constants preceded by an \u201cr\u201d character) in the\nlanguage syntax dictionary. Recall that raw strings retain \\ backslash characters in\nthe string literally, instead of interpreting them as string escape-code introductions.\nWithout them, the \\n newline character sequences in some of the language\u2019s code\nsnippets would be interpreted by Python as line feeds, instead of being printed in\nthe HTML reply as \\n. The code also uses double quotes for strings that embed an\nunescaped single-quote character, per Python\u2019s normal string rules.\nEscaping text embedded in HTML and URLs\nThis script takes care to format the text of each language\u2019s code snippet with the\ncgi.escape utility function. This standard Python utility automatically translates\ncharacters that are special in HTML into HTML escape code sequences, so that\nthey are not treated as HTML operators by browsers. Formally, cgi.escape trans-\nlates characters to escape code sequences, according to the standard HTML\nconvention: <, >, and & become &lt;, &gt;, and &amp;. If you pass a second true\nargument, the double-quote character (\") is translated to &quot;.\n1186 | Chapter 15:\u2002Server-Side ScriptingFor example, the << left-shift operator in the C++ entry is translated to &lt;&lt;\u2014\na pair of HTML escape codes. Because printing each code snippet effectively em-\nbeds it in the HTML response stream, we must escape any special HTML characters\nit contains. HTML parsers (including Python\u2019s standard html.parser module pre-\nsented in Chapter 19) translate escape codes back to the original characters when\na page is rendered.\nMore generally, because CGI is based upon the notion of passing formatted strings\nacross the Net, escaping special characters is a ubiquitous operation. CGI scripts\nalmost always need to escape text generated as part of the reply to be safe. For\ninstance, if we send back arbitrary text input from a user or read from a data source\non the server, we usually can\u2019t be sure whether it will contain HTML characters,\nso we must escape it just in case.\nIn later examples, we\u2019ll also find that characters inserted into URL address strings\ngenerated by our scripts may need to be escaped as well. A literal & in a URL is\nspecial, for example, and must be escaped if it appears embedded in text we insert\ninto a URL. However, URL syntax reserves different special characters than HTML\ncode, and so different escaping conventions and tools must be used. As we\u2019ll see\nlater in this chapter, cgi.escape implements escape translations in HTML code,\nbut urllib.parse.quote (and its relatives) escapes characters in URL strings.\nMocking up form inputs\nHere again, form inputs are \u201cmocked up\u201d (simulated), both for debugging and for\nresponding to a request for all languages in the table. If the script\u2019s global\ndebugme variable is set to a true value, for instance, the script creates a dictionary\nthat is plug-and-play compatible with the result of a cgi.FieldStorage call\u2014its\n\u201clanguages\u201d key references an instance of the dummy mock-up class. This class in\nturn creates an object that has the same interface as the contents of a cgi.Field\nStorage result\u2014it makes an object with a value attribute set to a passed-in string.\nThe net effect is that we can test this script by running it from the system command\nline: the generated dictionary fools the script into thinking it was invoked by a\nbrowser over the Net. Similarly, if the requested language name is \u201cAll,\u201d the script\niterates over all entries in the languages table, making a mocked-up form dictionary\nfor each (as though the user had requested each language in turn).\nThis lets us reuse the existing showHello logic to display each language\u2019s code in a\nsingle page. As always in Python, object interfaces and protocols are what we\nusually code for, not specific datatypes. The showHello function will happily proc-\ness any object that responds to the syntax form['language'].value.# Notice that\n#If you are reading closely, you might notice that this is the second time we\u2019ve used mock-ups in this chapter\n(see the earlier tutor4.cgi example). If you find this technique generally useful, it would probably make sense\nto put the dummy class, along with a function for populating a form dictionary on demand, into a module so\nthat it can be reused. In fact, we will do that in the next section. Even for two-line classes like this, typing the\nsame code the third time around will do much to convince you of the power of code reuse.\nThe Hello World Selector | 1187we could achieve similar results with a default argument in showHello, albeit at the\ncost of introducing a special case in its code.\nNow back to interacting with this program. If we select a particular language, our CGI\nscript generates an HTML reply of the following sort (along with the required content-\ntype header and blank line preamble). Use your browser\u2019s View Source option to see:\n<TITLE>Languages</TITLE>\n<H1>Syntax</H1><HR>\n<H3>Scheme</H3><P><PRE>\n (display \"Hello World\") (newline)\n</PRE></P><BR>\n<HR>\nProgram code is marked with a <PRE> tag to specify preformatted text (the browser\nwon\u2019t reformat it like a normal text paragraph). This reply code shows what we get\nwhen we pick Scheme. Figure 15-22 shows the page served up by the script after se-\nlecting \u201cPython\u201d in the pull-down selection list (which, for the purposes of both this\nedition and the expected future at large, of course, really means Python 3.X).\nFigure 15-22. Response page created by languages.py\nOur script also accepts a language name of \u201cAll\u201d and interprets it as a request to display\nthe syntax for every language it knows about. For example, here is the HTML that is\ngenerated if we set the global variable debugme to True and run from the system com-\nmand line with a single argument, All. This output is the same as what is printed to\nthe client\u2019s web browser in response to an \u201cAll\u201d selection*:\n* We also get the \u201cAll\u201d reply if debugme is set to False when we run the script from the command line. Instead\nof throwing an exception, the cgi.FieldStorage call returns an empty dictionary if called outside the CGI\nenvironment, so the test for a missing key kicks in. It\u2019s likely safer to not rely on this behavior, however.\n1188 | Chapter 15:\u2002Server-Side ScriptingC:\\...\\PP4E\\Internet\\Web\\cgi-bin> python languages.py All\nContent-type: text/html\n<TITLE>Languages</TITLE>\n<H1>Syntax</H1><HR>\n<H3>C</H3><P><PRE>\n printf(\"Hello World\\n\");\n</PRE></P><BR>\n<H3>Java</H3><P><PRE>\n System.out.println(\"Hello World\");\n</PRE></P><BR>\n<H3>C++</H3><P><PRE>\n cout &lt;&lt; \"Hello World\" &lt;&lt; endl;\n</PRE></P><BR>\n<H3>Perl</H3><P><PRE>\n print \"Hello World\\n\";\n</PRE></P><BR>\n<H3>Fortran</H3><P><PRE>\n print *, 'Hello World'\n</PRE></P><BR>\n<H3>Basic</H3><P><PRE>\n 10 PRINT \"Hello World\"\n</PRE></P><BR>\n<H3>Scheme</H3><P><PRE>\n (display \"Hello World\") (newline)\n</PRE></P><BR>\n<H3>SmallTalk</H3><P><PRE>\n 'Hello World' print.\n</PRE></P><BR>\n<H3>Python</H3><P><PRE>\n print('Hello World')\n</PRE></P><BR>\n<H3>Pascal</H3><P><PRE>\n WriteLn('Hello World');\n</PRE></P><BR>\n<H3>Tcl</H3><P><PRE>\n puts \"Hello World\"\n</PRE></P><BR>\n<H3>Python2</H3><P><PRE>\n print 'Hello World'\n</PRE></P><BR>\n<HR>\nEach language is represented here with the same code pattern\u2014the showHello function\nis called for each table entry, along with a mocked-up form object. Notice the way that\nC++ code is escaped for embedding inside the HTML stream; this is the cgi.escape\ncall\u2019s handiwork. Your web browser translates the &lt; escapes to < characters when\nthe page is rendered. When viewed with a browser, the \u201cAll\u201d response page is rendered\nas shown in Figure 15-23; the order in which languages are listed is pseudorandom,\nbecause the dictionary used to record them is not a sequence.\nThe Hello World Selector | 1189Figure 15-23. Response page for \u201cAll\u201d languages choice\nChecking for Missing and Invalid Inputs\nSo far, we\u2019ve been triggering the CGI script by selecting a language name from the pull-\ndown list in the main HTML page. In this context, we can be fairly sure that the script\nwill receive valid inputs. Notice, though, that there is nothing to prevent a client from\npassing the requested language name at the end of the CGI script\u2019s URL as an explicit\nquery parameter, instead of using the HTML page form. For instance, a URL of the\nfollowing kind typed into a browser\u2019s address field or submitted with the module\nurllib.request:\nhttp://localhost/cgi-bin/languages.py?language=Python\nyields the same \u201cPython\u201d response page shown in Figure 15-22. However, because it\u2019s\nalways possible for a user to bypass the HTML file and use an explicit URL, a user could\ninvoke our script with an unknown language name, one that is not in the HTML file\u2019s\npull-down list (and so not in our script\u2019s table). In fact, the script might be triggered\nwith no language input at all if someone explicitly submits its URL with no language\nparameter (or no parameter value) at the end. Such an erroneous URL could be entered\ninto a browser\u2019s address field or be sent by another script using the urllib.request\nmodule techniques described earlier in this chapter. For instance, valid requests work\nnormally:\n1190 | Chapter 15:\u2002Server-Side Scripting>>> from urllib.request import urlopen\n>>> request = 'http://localhost/cgi-bin/languages.py?language=Python'\n>>> reply = urlopen(request).read()\n>>> print(reply.decode())\n<TITLE>Languages</TITLE>\n<H1>Syntax</H1><HR>\n<H3>Python</H3><P><PRE>\n print('Hello World')\n</PRE></P><BR>\n<HR>\nTo be robust, though, the script also checks for both error cases explicitly, as all CGI\nscripts generally should. Here is the HTML generated in response to a request for the\nfictitious language GuiDO (again, you can also see this by selecting your browser\u2019s\nView Source option after typing the URL manually into your browser\u2019s address field):\n>>> request = 'http://localhost/cgi-bin/languages.py?language=GuiDO'\n>>> reply = urlopen(request).read()\n>>> print(reply.decode())\n<TITLE>Languages</TITLE>\n<H1>Syntax</H1><HR>\n<H3>GuiDO</H3><P><PRE>\nSorry--I don't know that language\n</PRE></P><BR>\n<HR>\nIf the script doesn\u2019t receive any language name input, it simply defaults to the \u201cAll\u201d\ncase (this case is also triggered if the URL ends with just ?language= and no language\nname value):\n>>> reply = urlopen('http://localhost/cgi-bin/languages.py').read()\n>>> print(reply.decode())\n<TITLE>Languages</TITLE>\n<H1>Syntax</H1><HR>\n<H3>C</H3><P><PRE>\n printf(\"Hello World\\n\");\n</PRE></P><BR>\n<H3>Java</H3><P><PRE>\n System.out.println(\"Hello World\");\n</PRE></P><BR>\n<H3>C++</H3><P><PRE>\n cout &lt;&lt; \"Hello World\" &lt;&lt; endl;\n</PRE></P><BR>\n...more...\nIf we didn\u2019t detect these cases, chances are that our script would silently die on a Python\nexception and leave the user with a mostly useless half-complete page or with a default\nerror page (we didn\u2019t assign stderr to stdout here, so no Python error message would\nbe displayed). Figure 15-24 shows the page generated and rendered by a browser if the\nscript is invoked with an explicit URL like this:\nhttp://localhost/cgi-bin/languages.py?language=COBOL\nThe Hello World Selector | 1191To test this error case interactively, the pull-down list includes an \u201cOther\u201d name, which\nproduces a similar error page reply. Adding code to the script\u2019s table for the COBOL\n\u201cHello World\u201d program (and other languages you might recall from your sordid de-\nvelopment past) is left as an exercise for the reader.\nFor more example invocations of our languages.py script, turn back to its role in the\nexamples near the end of Chapter 13. There, we used it to test script invocation from\nraw HTTP and urllib client-side scripts, but you should now have a better idea of what\nthose scripts invoke on the server.\nRefactoring Code for Maintainability\nLet\u2019s step back from coding details for just a moment to gain some design perspective.\nAs we\u2019ve seen, Python code, by and large, automatically lends itself to systems that are\neasy to read and maintain; it has a simple syntax that cuts much of the clutter of other\ntools. On the other hand, coding styles and program design can often affect maintain-\nability as much as syntax. For example, the \u201cHello World\u201d selector pages of the pre-\nceding section work as advertised and were very easy and fast to throw together. But\nas currently coded, the languages selector suffers from substantial maintainability\nflaws.\nImagine, for instance, that you actually take me up on that challenge posed at the end\nof the last section, and attempt to add another entry for COBOL. If you add COBOL\nto the CGI script\u2019s table, you\u2019re only half done: the list of supported languages lives\nredundantly in two places\u2014in the HTML for the main page as well as in the script\u2019s\nsyntax dictionary. Changing one does not change the other. In fact, this is something\nI witnessed firsthand when adding \u201cPython2\u201d in this edition (and initially forgot to\nFigure 15-24. Response page for unknown language\n1192 | Chapter 15:\u2002Server-Side Scriptingupdate the HTML, too). More generally, there are a handful of ways that this program\nmight fail the scrutiny of a rigorous code review:\nSelection list\nAs just mentioned, the list of languages supported by this program lives in two\nplaces: the HTML file and the CGI script\u2019s table, and redundancy is a killer for\nmaintenance work.\nField name\nThe field name of the input parameter, language, is hardcoded into both files as\nwell. You might remember to change it in the other if you change it in one, but you\nmight not.\nForm mock-ups\nWe\u2019ve redundantly coded classes to mock-up form field inputs twice in this chapter\nalready; the \u201cdummy\u201d class here is clearly a mechanism worth reusing.\nHTML code\nHTML embedded in and generated by the script is sprinkled throughout the pro-\ngram in print call statements, making it difficult to implement broad web page\nlayout changes or delegate web page design to nonprogrammers.\nThis is a short example, of course, but issues of redundancy and reuse become more\nacute as your scripts grow larger. As a rule of thumb, if you find yourself changing\nmultiple source files to modify a single behavior, or if you notice that you\u2019ve taken to\nwriting programs by cut-and-paste copying of existing code, it\u2019s probably time to think\nabout more rational program structures. To illustrate coding styles and practices that\nare friendlier to maintainers, let\u2019s rewrite (that is, refactor) this example to fix all of\nthese weaknesses in a single mutation.\nStep 1: Sharing Objects Between Pages\u2014A New Input Form\nWe can remove the first two maintenance problems listed earlier with a simple trans-\nformation; the trick is to generate the main page dynamically, from an executable script,\nrather than from a precoded HTML file. Within a script, we can import the input field\nname and selection list values from a common Python module file, shared by the main\nand reply page generation scripts. Changing the selection list or field name in the com-\nmon module changes both clients automatically. First, we move shared objects to a\ncommon module file, as shown in Example 15-19.\nExample 15-19. PP4E\\Internet\\Web\\cgi-bin\\languages2common.py\n\"\"\"\ncommon objects shared by main and reply page scripts;\nneed change only this file to add a new language.\n\"\"\"\ninputkey = 'language'                            # input parameter name\nRefactoring Code for Maintainability | 1193hellos = {\n    'Python':    r\" print('Hello World')               \",\n    'Python2':   r\" print 'Hello World'                \",\n    'Perl':      r' print \"Hello World\\n\";             ',\n    'Tcl':       r' puts \"Hello World\"                 ',\n    'Scheme':    r' (display \"Hello World\") (newline)  ',\n    'SmallTalk': r\" 'Hello World' print.               \",\n    'Java':      r' System.out.println(\"Hello World\"); ',\n    'C':         r' printf(\"Hello World\\n\");           ',\n    'C++':       r' cout << \"Hello World\" << endl;     ',\n    'Basic':     r' 10 PRINT \"Hello World\"             ',\n    'Fortran':   r\" print *, 'Hello World'             \",\n    'Pascal':    r\" WriteLn('Hello World');            \"\n}\nThe module languages2common contains all the data that needs to agree between pages:\nthe field name as well as the syntax dictionary. The hellos syntax dictionary isn\u2019t quite\nHTML code, but its keys list can be used to generate HTML for the selection list on\nthe main page dynamically.\nNotice that this module is stored in the same cgi-bin directory as the CGI scripts that\nwill use it; this makes import search paths simple\u2014the module will be found in the\nscript\u2019s current working directory, without path configuration. In general, external ref-\nerences in CGI scripts are resolved as follows:\n\u2022 Module imports will be relative to the CGI script\u2019s current working directory (cgi-\nbin), plus any custom path setting in place when the script runs.\n\u2022 When using minimal URLs, referenced pages and scripts in links and form actions\nwithin generated HTML are relative to the prior page\u2019s location as usual. For a CGI\nscript, such minimal URLs are relative to the location of the generating script itself.\n\u2022 Filenames referenced in query parameters and passed into scripts are normally rel-\native to the directory containing the CGI script (cgi-bin). However, on some plat-\nforms and servers they may be relative to the web server\u2019s directory instead. For\nour local web server, the latter case applies.\nTo prove some of these points to yourself, see and run the CGI script in the examples\npackage identified by URL http://localhost/cgi-bin/test-context.py: when run on Win-\ndows with our local web server, it\u2019s able to import modules in its own directory, but\nfilenames are relative to the parent directory where the web server is running (newly\ncreated files appear there). Here is this script\u2019s code, if you need to gauge how paths\nare mapped for your server and platform; this server-specific treatment of relative file-\nnames may not be idea for portability, but this is just one of many details that can vary\nper server:\nimport languages2common                      # from my dir\nf = open('test-context-output.txt', 'w')     # in .. server dir\nf.write(languages2common.inputkey)\nf.close()\nprint('context-type: text/html\\n\\nDone.\\n')\n1194 | Chapter 15:\u2002Server-Side ScriptingNext, in Example 15-20, we recode the main page as an executable script and populate\nthe response HTML with values imported from the common module file in the previous\nexample.\nExample 15-20. PP4E\\Internet\\Web\\cgi-bin\\languages2.py\n#!/usr/bin/python\n\"\"\"\ngenerate HTML for main page dynamically from an executable Python script,\nnot a precoded HTML file; this lets us import the expected input field name\nand the selection table values from a common Python module file; changes in\neither now only have to be made in one place, the Python module file;\n\"\"\"\nREPLY = \"\"\"Content-type: text/html\n<html><title>Languages2</title>\n<body>\n<h1>Hello World selector</h1>\n<P>Similar to file <a href=\"../languages.html\">languages.html</a>, but\nthis page is dynamically generated by a Python CGI script, using\nselection list and input field names imported from a common Python\nmodule on the server. Only the common module must be maintained as\nnew languages are added, because it is shared with the reply script.\nTo see the code that generates this page and the reply, click\n<a href=\"getfile.py?filename=cgi-bin\\languages2.py\">here</a>,\n<a href=\"getfile.py?filename=cgi-bin\\languages2reply.py\">here</a>,\n<a href=\"getfile.py?filename=cgi-bin\\languages2common.py\">here</a>, and\n<a href=\"getfile.py?filename=cgi-bin\\\\formMockup.py\">here</a>.</P>\n<hr>\n<form method=POST action=\"languages2reply.py\">\n    <P><B>Select a programming language:</B>\n    <P><select name=%s>\n        <option>All\n        %s\n        <option>Other\n    </select>\n    <P><input type=Submit>\n</form>\n</body></html>\n\"\"\"\nfrom languages2common import hellos, inputkey\noptions = []\nfor lang in hellos:                        # we could sort keys too\n    options.append('<option>' + lang)      # wrap table keys in HTML code\noptions = '\\n\\t'.join(options)\nprint(REPLY % (inputkey, options))         # field name and values from module\nAgain, ignore the getfile hyperlinks in this file for now; we\u2019ll learn what they mean in\na later section. You should notice, though, that the HTML page definition becomes a\nprinted Python string here (named REPLY), with %s format targets where we plug in\nRefactoring Code for Maintainability | 1195values imported from the common module. It\u2019s otherwise similar to the original HTML\nfile\u2019s code; when we visit this script\u2019s URL, we get a similar page, shown in Fig-\nure 15-25. But this time, the page is generated by running a script on the server that\npopulates the pull-down selection list from the keys list of the common syntax table.\nUse your browser\u2019s View Source option to see the HTML generated; it\u2019s nearly identical\nto the HTML file in Example 15-17, though the order of languages in the list may differ\ndue to the behavior of dictionary keys.\nFigure 15-25. Alternative main page made by languages2.py\nOne maintenance note here: the content of the REPLY HTML code template string in\nExample 15-20 could be loaded from an external text file so that it could be worked on\nindependently of the Python program logic. In general, though, external text files are\nno more easily changed than Python scripts. In fact, Python scripts are text files, and\nthis is a major feature of the language\u2014it\u2019s easy to change the Python scripts of an\ninstalled system on site, without recompile or relink steps. However, external HTML\nfiles could be checked out separately in a source-control system, if this matters in your \nenvironment.\nStep 2: A Reusable Form Mock-Up Utility\nMoving the languages table and input field name to a module file solves the first two\nmaintenance problems we noted. But if we want to avoid writing a dummy field mock-\nup class in every CGI script we write, we need to do something more. Again, it\u2019s merely\na matter of exploiting the Python module\u2019s affinity for code reuse: let\u2019s move the\ndummy class to a utility module, as in Example 15-21.\n1196 | Chapter 15:\u2002Server-Side ScriptingExample 15-21. PP4E\\Internet\\Web\\cgi-bin\\formMockup.py\n\"\"\"\nTools for simulating the result of a cgi.FieldStorage()\ncall; useful for testing CGI scripts outside the Web\n\"\"\"\nclass FieldMockup:                                   # mocked-up input object\n    def __init__(self, str):\n        self.value = str\ndef formMockup(**kwargs):                            # pass field=value args\n    mockup = {}                                      # multichoice: [value,...]\n    for (key, value) in kwargs.items():\n        if type(value) != list:                      # simple fields have .value\n            mockup[key] = FieldMockup(str(value))\n        else:                                        # multichoice have list\n            mockup[key] = []                         # to do: file upload fields\n            for pick in value:\n                mockup[key].append(FieldMockup(pick))\n    return mockup\ndef selftest():\n    # use this form if fields can be hardcoded\n    form = formMockup(name='Bob', job='hacker', food=['Spam', 'eggs', 'ham'])\n    print(form['name'].value)\n    print(form['job'].value)\n    for item in form['food']:\n        print(item.value, end=' ')\n    # use real dict if keys are in variables or computed\n    print()\n    form = {'name': FieldMockup('Brian'), 'age': FieldMockup(38)}    # or dict()\n    for key in form.keys():\n        print(form[key].value)\nif __name__ == '__main__': selftest()\nWhen we place our mock-up class in the module formMockup.py, it automatically\nbecomes a reusable tool and may be imported by any script we care to write.\u2020 For\nreadability, the dummy field simulation class has been renamed FieldMockup here. For\nconvenience, we\u2019ve also added a formMockup utility function that builds up an entire\nform dictionary from passed-in keyword arguments. Assuming you can hardcode the\nnames of the form to be faked, the mock-up can be created in a single call. This module\nincludes a self-test function invoked when the file is run from the command line, which\ndemonstrates how its exports are used. Here is its test output, generated by making\nand querying two form mock-up objects:\n\u2020 Assuming, of course, that this module can be found on the Python module search path when those scripts\nare run. Since Python searches the current directory for imported modules by default, this generally works\nwithout sys.path changes if all of our files are in our main web directory. For other applications, we may\nneed to add this directory to PYTHONPATH or use package (directory path) imports.\nRefactoring Code for Maintainability | 1197C:\\...\\PP4E\\Internet\\Web\\cgi-bin> python formMockup.py\nBob\nhacker\nSpam eggs ham\n38\nBrian\nSince the mock-up now lives in a module, we can reuse it anytime we want to test a\nCGI script offline. To illustrate, the script in Example 15-22 is a rewrite of the\ntutor5.py example we saw earlier, using the form mock-up utility to simulate field in-\nputs. If we had planned ahead, we could have tested the script like this without even\nneeding to connect to the Net.\nExample 15-22. PP4E\\Internet\\Web\\cgi-bin\\tutor5_mockup.py\n#!/usr/bin/python\n\"\"\"\nrun tutor5 logic with formMockup instead of cgi.FieldStorage()\nto test: python tutor5_mockup.py > temp.html, and open temp.html\n\"\"\"\nfrom formMockup import formMockup\nform = formMockup(name='Bob',\n                  shoesize='Small',\n                  language=['Python', 'C++', 'HTML'],\n                  comment='ni, Ni, NI')\n# rest same as original, less form assignment\nRunning this script from a simple command line shows us what the HTML response\nstream will look like:\nC:\\...\\PP4E\\Internet\\Web\\cgi-bin> python tutor5_mockup.py\nContent-type: text/html\n<TITLE>tutor5.py</TITLE>\n<H1>Greetings</H1>\n<HR>\n<H4>Your name is Bob</H4>\n<H4>You wear rather Small shoes</H4>\n<H4>Your current job: (unknown)</H4>\n<H4>You program in Python and C++ and HTML</H4>\n<H4>You also said:</H4>\n<P>ni, Ni, NI</P>\n<HR>\nRunning it live yields the page in Figure 15-26. Field inputs are hardcoded, similar in\nspirit to the tutor5 extension that embedded input parameters at the end of hyperlink\nURLs. Here, they come from form mock-up objects created in the reply script that\ncannot be changed without editing the script. Because Python code runs immediately,\nthough, modifying a Python script during the debug cycle goes as quickly as you can\ntype.\n1198 | Chapter 15:\u2002Server-Side ScriptingStep 3: Putting It All Together\u2014A New Reply Script\nThere\u2019s one last step on our path to software maintenance nirvana: we must recode the\nreply page script itself to import data that was factored out to the common module and\nimport the reusable form mock-up module\u2019s tools. While we\u2019re at it, we move code\ninto functions (in case we ever put things in this file that we\u2019d like to import in another\nscript), and all HTML code to triple-quoted string blocks. The result is Exam-\nple 15-23. Changing HTML is generally easier when it has been isolated in single strings\nlike this, instead of being sprinkled throughout a program.\nExample 15-23. PP4E\\Internet\\Web\\cgi-bin\\languages2reply.py\n#!/usr/bin/python\n\"\"\"\nSame, but for easier maintenance, use HTML template strings, get the\nLanguage table and input key from common module file, and get reusable\nform field mockup utilities module for testing.\n\"\"\"\nimport cgi, sys\nfrom formMockup import FieldMockup                   # input field simulator\nfrom languages2common import hellos, inputkey        # get common table, name\ndebugme = False\nhdrhtml = \"\"\"Content-type: text/html\\n\n<TITLE>Languages</TITLE>\nFigure 15-26. A response page with simulated inputs\nRefactoring Code for Maintainability | 1199<H1>Syntax</H1><HR>\"\"\"\nlanghtml = \"\"\"\n<H3>%s</H3><P><PRE>\n%s\n</PRE></P><BR>\"\"\"\ndef showHello(form):                                 # HTML for one language\n    choice = form[inputkey].value                    # escape lang name too\n    try:\n        print(langhtml % (cgi.escape(choice),\n                          cgi.escape(hellos[choice])))\n    except KeyError:\n        print(langhtml % (cgi.escape(choice),\n                         \"Sorry--I don't know that language\"))\ndef main():\n    if debugme:\n        form = {inputkey: FieldMockup(sys.argv[1])}  # name on cmd line\n    else:\n        form = cgi.FieldStorage()                    # parse real inputs\n    print(hdrhtml)\n    if not inputkey in form or form[inputkey].value == 'All':\n        for lang in hellos.keys():\n            mock = {inputkey: FieldMockup(lang)}     # not dict(n=v) here!\n            showHello(mock)\n    else:\n        showHello(form)\n    print('<HR>')\nif __name__ == '__main__': main()\nWhen global debugme is set to True, the script can be tested offline from a simple com-\nmand line as before:\nC:\\...\\PP4E\\Internet\\Web\\cgi-bin> python languages2reply.py Python\nContent-type: text/html\n<TITLE>Languages</TITLE>\n<H1>Syntax</H1><HR>\n<H3>Python</H3><P><PRE>\n print('Hello World')\n</PRE></P><BR>\n<HR>\nWhen run online using either the page in Figure 15-25 or an explicitly typed URL with\nquery parameters, we get the same reply pages we saw for the original version of this\nexample (we won\u2019t repeat them here again). This transformation changed the pro-\ngram\u2019s architecture, not its user interface. Architecturally, though, both the input and\nreply pages are now created by Python CGI scripts, not static HTML files.\n1200 | Chapter 15:\u2002Server-Side ScriptingMost of the code changes in this version of the reply script are straightforward. If you\ntest-drive these pages, the only differences you\u2019ll find are the URLs at the top of your\nbrowser (they\u2019re different files, after all), extra blank lines in the generated HTML\n(ignored by the browser), and a potentially different ordering of language names in the\nmain page\u2019s pull-down selection list.\nAgain, this selection list ordering difference arises because this version relies on the\norder of the Python dictionary\u2019s keys list, not on a hardcoded list in an HTML file.\nDictionaries, you\u2019ll recall, arbitrarily order entries for fast fetches; if you want the se-\nlection list to be more predictable, simply sort the keys list before iterating over it using\nthe list sort method or the sorted function introduced in Python 2.4:\n  for lang in sorted(hellos):               # dict iterator instead of .keys()\n      mock = {inputkey: FieldMockup(lang)}\nFaking Inputs with Shell Variables\nIf you\u2019re familiar with shells, you might also be able to test CGI scripts from the com-\nmand line on some platforms by setting the same environment variables that HTTP\nservers set, and then launching your script. For example, we might be able to pretend\nto be a web server by storing input parameters in the QUERY_STRING environment vari-\nable, using the same syntax we employ at the end of a URL string after the ?:\n$ setenv QUERY_STRING \"name=Mel&job=trainer,+writer\"\n$ python tutor5.py\nContent-type: text/html\n<TITLE>tutor5.py<?TITLE>\n<H1>Greetings</H1>\n<HR>\n<H4>Your name is Mel</H4>\n<H4>You wear rather (unknown) shoes</H4>\n<H4>Your current job: trainer, writer</H4>\n<H4>You program in (unknown)</H4>\n<H4>You also said:</H4>\n<P>(unknown)</P>\n<HR>\nHere, we mimic the effects of a GET style form submission or explicit URL. HTTP servers\nplace the query string (parameters) in the shell variable QUERY_STRING. Python\u2019s cgi\nmodule finds them there as though they were sent by a browser. POST-style inputs can\nbe simulated with shell variables too, but it\u2019s more complex\u2014so much so that you may\nbe better off not bothering to learn how. In fact, it may be more robust in general to\nmock up inputs with Python objects (e.g., as in formMockup.py). But some CGI scripts\nmay have additional environment or testing constraints that merit unique treatment.\nMore on HTML and URL Escapes\nPerhaps the subtlest change in the last section\u2019s rewrite is that, for robustness, this\nversion\u2019s reply script (Example 15-23) also calls cgi.escape for the language name, not\nMore on HTML and URL Escapes | 1201just for the language\u2019s code snippet. This wasn\u2019t required in languages2.py (Exam-\nple 15-20) for the known language names in our selection list table. However, it is not\nimpossible that someone could pass the script a language name with an embedded\nHTML character as a query parameter. For example, a URL such as:\nhttp://localhost/cgi-bin/languages2reply.py?language=a<b\nembeds a < in the language name parameter (the name is a<b). When submitted, this\nversion uses cgi.escape to properly translate the < for use in the reply HTML, according\nto the standard HTML escape conventions discussed earlier; here is the reply text\ngenerated:\n<TITLE>Languages</TITLE>\n<H1>Syntax</H1><HR>\n<H3>a&lt;b</H3><P><PRE>\nSorry--I don't know that language\n</PRE></P><BR>\n<HR>\nThe original version in Example 15-18 doesn\u2019t escape the language name, such that the\nembedded <b is interpreted as an HTML tag (which makes the rest of the page render\nin bold font!). As you can probably tell by now, text escapes are pervasive in CGI\nscripting\u2014even text that you may think is safe must generally be escaped before being\ninserted into the HTML code in the reply stream.\nIn fact, because the Web is a text-based medium that combines multiple language\nsyntaxes, multiple formatting rules may apply: one for URLs and another for HTML.\nWe met HTML escapes earlier in this chapter; URLs, and combinations of HTML and\nURLs, merit a few additional words.\nURL Escape Code Conventions\nNotice that in the prior section, although it\u2019s wrong to embed an unescaped < in the\nHTML code reply, it\u2019s perfectly all right to include it literally in the URL string used to\ntrigger the reply. In fact, HTML and URLs define completely different characters as\nspecial. For instance, although & must be escaped as &amp; inside HTML code, we have\nto use other escaping schemes to code a literal & within a URL string (where it normally\nseparates parameters). To pass a language name like a&b to our script, we have to type\nthe following URL:\nhttp://localhost/cgi-bin/languages2reply.py?language=a%26b\nHere, %26 represents &\u2014the & is replaced with a % followed by the hexadecimal value\n(0x26) of its ASCII code value (38). Similarly, as we suggested at the end of Chap-\nter 13, to name C++ as a query parameter in an explicit URL, + must be escaped as %2b:\nhttp://localhost/cgi-bin/languages2reply.py?language=C%2b%2b\nSending C++ unescaped will not work, because + is special in URL syntax\u2014it represents\na space. By URL standards, most nonalphanumeric characters are supposed to be\n1202 | Chapter 15:\u2002Server-Side Scriptingtranslated to such escape sequences, and spaces are replaced by + signs. Technically,\nthis convention is known as the application/x-www-form-urlencoded query string for-\nmat, and it\u2019s part of the magic behind those bizarre URLs you often see at the top of\nyour browser as you surf the Web.\nPython HTML and URL Escape Tools\nIf you\u2019re like me, you probably don\u2019t have the hexadecimal value of the ASCII code for\n& committed to memory (though Python\u2019s hex(ord(c)) can help). Luckily, Python pro-\nvides tools that automatically implement URL escapes, just as cgi.escape does for\nHTML escapes. The main thing to keep in mind is that HTML code and URL strings\nare written with entirely different syntax, and so employ distinct escaping conventions.\nWeb users don\u2019t generally care, unless they need to type complex URLs explicitly\u2014\nbrowsers handle most escape code details internally. But if you write scripts that must\ngenerate HTML or URLs, you need to be careful to escape characters that are reserved\nin either syntax.\nBecause HTML and URLs have different syntaxes, Python provides two distinct sets\nof tools for escaping their text. In the standard Python library:\n\u2022 cgi.escape escapes text to be embedded in HTML.\n\u2022 urllib.parse.quote and quote_plus escape text to be embedded in URLs.\nThe urllib.parse module also has tools for undoing URL escapes (unquote,\nunquote_plus), but HTML escapes are undone during HTML parsing at large (e.g., by\nPython\u2019s html.parser module). To illustrate the two escape conventions and tools, let\u2019s\napply each tool set to a few simple examples.\nSomewhat inexplicably, Python 3.2 developers have opted to move and\nrename the cgi.escape function used throughout this book to\nhtml.escape, to make use of its longstanding original name deprecated,\nand to alter its quoting behavior slightly. This is despite the fact that this\nfunction has been around for ages and is used in almost every Python\nCGI-based web script: a glaring case of a small group\u2019s notion of aes-\nthetics trouncing widespread practice in 3.X and breaking working code\nin the process. You may need to use the new html.escape name in a\nfuture Python version; that is, unless Python users complain loudly\nenough (yes, hint!).\nEscaping HTML Code\nAs we saw earlier, cgi.escape translates code for inclusion within HTML. We normally\ncall this utility from a CGI script, but it\u2019s just as easy to explore its behavior interactively:\n>>> import cgi\n>>> cgi.escape('a < b > c & d \"spam\"', 1)\nMore on HTML and URL Escapes | 1203'a &lt; b &gt; c &amp; d &quot;spam&quot;'\n>>> s = cgi.escape(\"1<2 <b>hello</b>\")\n>>> s\n'1&lt;2 &lt;b&gt;hello&lt;/b&gt;'\nPython\u2019s cgi module automatically converts characters that are special in HTML syntax\naccording to the HTML convention. It translates <, >, and & with an extra true argument,\n\", into escape sequences of the form &X;, where the X is a mnemonic that denotes the\noriginal character. For instance, &lt; stands for the \u201cless than\u201d operator (<) and\n&amp; denotes a literal ampersand (&).\nThere is no unescaping tool in the CGI module, because HTML escape code sequences\nare recognized within the context of an HTML parser, like the one used by your web\nbrowser when a page is downloaded. Python comes with a full HTML parser, too, in\nthe form of the standard module html.parser. We won\u2019t go into details on the HTML\nparsing tools here (they\u2019re covered in Chapter 19 in conjunction with text processing),\nbut to illustrate how escape codes are eventually undone, here is the HTML parser\nmodule at work reading back the preceding output:\n>>> import cgi, html.parser\n>>> s = cgi.escape(\"1<2 <b>hello</b>\")\n>>> s\n'1&lt;2 &lt;b&gt;hello&lt;/b&gt;'\n>>>\n>>> html.parser.HTMLParser().unescape(s)\n'1<2 <b>hello</b>'\nThis uses a utility method on the HTML parser class to unquote. In Chapter 19, we\u2019ll\nsee that using this class for more substantial work involves subclassing to override\nmethods run as callbacks during the parse upon detection of tags, data, entities, and\nmore. For more on full-blown HTML parsing, watch for the rest of this story in\nChapter 19.\nEscaping URLs\nBy contrast, URLs reserve other characters as special and must adhere to different es-\ncape conventions. As a result, we use different Python library tools to escape URLs for\ntransmission. Python\u2019s urllib.parse module provides two tools that do the translation\nwork for us: quote, which implements the standard %XX hexadecimal URL escape code\nsequences for most nonalphanumeric characters, and quote_plus, which additionally\ntranslates spaces to + signs. The urllib.parse module also provides functions for un-\nescaping quoted characters in a URL string: unquote undoes %XX escapes, and\nunquote_plus also changes plus signs back to spaces. Here is the module at work, at the\ninteractive prompt:\n>>> import urllib.parse\n>>> urllib.parse.quote(\"a & b #! c\")\n'a%20%26%20b%20%23%21%20c'\n1204 | Chapter 15:\u2002Server-Side Scripting>>> urllib.parse.quote_plus(\"C:\\stuff\\spam.txt\")\n'C%3A%5Cstuff%5Cspam.txt'\n>>> x = urllib.parse.quote_plus(\"a & b #! c\")\n>>> x\n'a+%26+b+%23%21+c'\n>>> urllib.parse.unquote_plus(x)\n'a & b #! c'\nURL escape sequences embed the hexadecimal values of nonsafe characters following\na % sign (this is usually their ASCII codes). In urllib.parse, nonsafe characters are\nusually taken to include everything except letters, digits, and a handful of safe special\ncharacters (any in '_.-'), but the two tools differ on forward slashes, and you can\nextend the set of safe characters by passing an extra string argument to the quote calls\nto customize the translations:\n>>> urllib.parse.quote_plus(\"uploads/index.txt\")\n'uploads%2Findex.txt'\n>>> urllib.parse.quote(\"uploads/index.txt\")\n'uploads/index.txt'\n>>>\n>>> urllib.parse.quote_plus(\"uploads/index.txt\", '/')\n'uploads/index.txt'\n>>> urllib.parse.quote(\"uploads/index.txt\", '/')\n'uploads/index.txt'\n>>> urllib.parse.quote(\"uploads/index.txt\", '')\n'uploads%2Findex.txt'\n>>>\n>>> urllib.parse.quote_plus(\"uploads\\index.txt\")\n'uploads%5Cindex.txt'\n>>> urllib.parse.quote(\"uploads\\index.txt\")\n'uploads%5Cindex.txt'\n>>> urllib.parse.quote_plus(\"uploads\\index.txt\", '\\\\')\n'uploads\\\\index.txt'\nNote that Python\u2019s cgi module also translates URL escape sequences back to their\noriginal characters and changes + signs to spaces during the process of extracting input\ninformation. Internally, cgi.FieldStorage automatically calls urllib.parse tools which\nunquote if needed to parse and unescape parameters passed at the end of URLs. The\nupshot is that CGI scripts get back the original, unescaped URL strings, and don\u2019t need\nto unquote values on their own. As we\u2019ve seen, CGI scripts don\u2019t even need to know\nthat inputs came from a URL at all.\nEscaping URLs Embedded in HTML Code\nWe\u2019ve seen how to escape text inserted into both HTML and URLs. But what do we\ndo for URLs inside HTML? That is, how do we escape when we generate and embed\ntext inside a URL, which is itself embedded inside generated HTML code? Some of our\nearlier examples used hardcoded URLs with appended input parameters inside\nMore on HTML and URL Escapes | 1205<A HREF> hyperlink tags; the file languages2.py, for instance, prints HTML that includes\na URL:\n<a href=\"getfile.py?filename=cgi-bin\\languages2.py\">\nBecause the URL here is embedded in HTML, it must at least be escaped according to\nHTML conventions (e.g., any < characters must become &lt;), and any spaces should\nbe translated to + signs per URL conventions. A cgi.escape(url) call followed by the\nstring url.replace(\" \", \"+\") would take us this far, and would probably suffice for\nmost cases.\nThat approach is not quite enough in general, though, because HTML escaping con-\nventions are not the same as URL conventions. To robustly escape URLs embedded in\nHTML code, you should instead call urllib.parse.quote_plus on the URL string, or\nat least most of its components, before adding it to the HTML text. The escaped result\nalso satisfies HTML escape conventions, because urllib.parse translates more char-\nacters than cgi.escape, and the % in URL escapes is not special to HTML.\nHTML and URL conflicts: &\nBut there is one more astonishingly subtle (and thankfully rare) wrinkle: you may also\nhave to be careful with & characters in URL strings that are embedded in HTML code\n(e.g., within <A> hyperlink tags). The & symbol is both a query parameter separator in\nURLs (?a=1&b=2) and the start of escape codes in HTML (&lt;). Consequently, there is\na potential for collision if a query parameter name happens to be the same as an HTML\nescape sequence code. The query parameter name amp, for instance, that shows up as\n&amp=1 in parameters two and beyond on the URL may be treated as an HTML escape\nby some HTML parsers, and translated to &=1.\nEven if parts of the URL string are URL-escaped, when more than one parameter is\nseparated by a &, the & separator might also have to be escaped as &amp; according to\nHTML conventions. To see why, consider the following HTML hyperlink tag with\nquery parameter names name, job, amp, sect, and lt:\n<A HREF=\"file.py?name=a&job=b&amp=c&sect=d&lt=e\">hello</a>\nWhen rendered in most browsers tested, including Internet Explorer on Windows 7,\nthis URL link winds up looking incorrectly like this (the S character in the first of these\nis really a non-ASCII section marker):\nfile.py?name=a&job=b&=cS=d<=e             result in IE\nfile.py?name=a&job=b&=c%A7=d%3C=e         result in Chrome (0x3C is <)\nThe first two parameters are retained as expected (name=a, job=b), because name is not\npreceded with an & and &job is not recognized as a valid HTML character escape code.\nHowever, the &amp, &sect, and &lt parts are interpreted as special characters because\nthey do name valid HTML escape codes, even without a trailing semicolon.\nTo see this for yourself, open the example package\u2019s test-escapes.html file in your\nbrowser, and highlight or select its link; the query names may be taken as HTML\n1206 | Chapter 15:\u2002Server-Side Scriptingescapes. This text appears to parse correctly in Python\u2019s own HTML parser module\ndescribed earlier (unless the parts in question also end in a semicolon); that might help\nfor replies fetched manually with urllib.request, but not when rendered in browsers:\n>>> from html.parser import HTMLParser\n>>> html = open('test-escapes.html').read()\n>>> HTMLParser().unescape(html)\n'<HTML>\\n<A HREF=\"file.py?name=a&job=b&amp=c&sect=d&lt=e\">hello</a>\\n</HTML>'\nAvoiding conflicts\nWhat to do then? To make this work as expected in all cases, the & separators should\ngenerally be escaped if your parameter names may clash with an HTML escape code:\n<A HREF=\"file.py?name=a&amp;job=b&amp;amp=c&amp;sect=d&amp;lt=e\">hello</a>\nBrowsers render this fully escaped link as expected (open test-escapes2.html to test),\nand Python\u2019s HTML parser does the right thing as well:\nfile.py?name=a&job=b&amp=c&sect=d&lt=e       result in both IE and Chrome\n>>> h = '<A HREF=\"file.py?name=a&amp;job=b&amp;amp=c&amp;sect=d&amp;lt=e\">hello</a>'\n>>> HTMLParser().unescape(h)\n'<A HREF=\"file.py?name=a&job=b&amp=c&sect=d&lt=e\">hello</a>'\nBecause of this conflict between HTML and URL syntax, most server tools (including\nPython\u2019s urlib.parse query-parameter parsing tools employed by Python\u2019s cgi mod-\nule) also allow a semicolon to be used as a separator instead of &. The following link,\nfor example, works the same as the fully escaped URL, but does not require an extra\nHTML escaping step (at least not for the ;):\nfile.py?name=a;job=b;amp=c;sect=d;lt=e\nPython\u2019s html.parser unescape tool allows the semicolons to pass unchanged, too,\nsimply because they are not significant in HTML code. To fully test all three of these\nlink forms for yourself at once, place them in an HTML file, open the file in your browser\nusing its http://localhost/badlink.html URL, and view the links when followed. The\nHTML file in Example 15-24 will suffice.\nExample 15-24. PP4E\\Internet\\Web\\badlink.html\n<HTML><BODY>\n<p><A HREF=\n\"cgi-bin/badlink.py?name=a&job=b&amp=c&sect=d&lt=e\">unescaped</a>\n<p><A HREF=\n\"cgi-bin/badlink.py?name=a&amp;job=b&amp;amp=c&amp;sect=d&amp;lt=e\">escaped</a>\n<p><A HREF=\n\"cgi-bin/badlink.py?name=a;job=b;amp=c;sect=d;lt=e\">alternative</a>\n</BODY></HTML>\nMore on HTML and URL Escapes | 1207When these links are clicked, they invoke the simple CGI script in Example 15-25. This \nscript displays the inputs sent from the client on the standard error stream to avoid any \nadditional translations (for our locally running web server in Example 15-1, this routes \nthe printed text to the server\u2019s console window).\nExample 15-25. PP4E\\Internet\\Web\\cgi-bin\\badlink.py \nimport cgi, sys\nform = cgi.FieldStorage()      # print all inputs to stderr; stodout=reply page\nfor name in form.keys():\n    print('[%s:%s]' % (name, form[name].value), end=' ', file=sys.stderr)\nFollowing is the (edited for space) output we get in our local Python-coded web server\u2019s \nconsole window for following each of the three links in the HTML page in turn using \nInternet Explorer. The second and third yield the correct parameters set on the server \nas a result of the HTML escaping or URL conventions employed, but the accidental \nHTML escapes cause serious issues for the first unescaped link\u2014the client\u2019s HTML \nparser translates these in unintended ways (results are similar under Chrome, but the \nfirst link displays the non-ASCII section mark character with a different escape \nsequence):\nmark-VAIO - - [16/Jun/2010 10:43:24] b'[:c\\xa7=d<=e] [job:b] [name:a] '\nmark-VAIO - - [16/Jun/2010 10:43:24] CGI script exited OK\nmark-VAIO - - [16/Jun/2010 10:43:27] b'[amp:c] [job:b] [lt:e] [name:a] [sect:d]'\nmark-VAIO - - [16/Jun/2010 10:43:27] CGI script exited OK\nmark-VAIO - - [16/Jun/2010 10:43:30] b'[amp:c] [job:b] [lt:e] [name:a] [sect:d]'\nmark-VAIO - - [16/Jun/2010 10:43:30] CGI script exited OK\nThe moral of this story is that unless you can be sure that the names of all but the \nleftmost URL query parameters embedded in HTML are not the same as the name of \nany HTML character escape code like amp, you should generally either use a semicolon \nas a separator, if supported by your tools, or run the entire URL through cgi.escape\nafter escaping its parameter names and values with urllib.parse.quote_plus:\n>>> link = 'file.py?name=a&job=b&amp=c&sect=d&lt=e'\n# escape for HTML \n>>> import cgi\n>>> cgi.escape(link)\n'file.py?name=a&amp;job=b&amp;amp=c&amp;sect=d&amp;lt=e'\n# escape for URL \n>>> import urllib.parse\n>>> elink = urllib.parse.quote_plus(link)\n>>> elink\n'file.py%3Fname%3Da%26job%3Db%26amp%3Dc%26sect%3Dd%26lt%3De'\n# URL satisfies HTML too: same \n>>> cgi.escape(elink)\n'file.py%3Fname%3Da%26job%3Db%26amp%3Dc%26sect%3Dd%26lt%3De'\n1208 | Chapter 15:\u2002Server-Side ScriptingHaving said that, I should add that some examples in this book do not escape & URL\nseparators embedded within HTML simply because their URL parameter names are\nknown not to conflict with HTML escapes. In fact, this concern is likely to be rare in\npractice, since your program usually controls the set of parameter names it expects.\nThis is not, however, the most general solution, especially if parameter names may be\ndriven by a dynamic database; when in doubt, escape much and often.\n\u201cHow I Learned to Stop Worrying and Love the Web\u201d\nLest the HTML and URL formatting rules sound too clumsy (and send you screaming\ninto the night!), note that the HTML and URL escaping conventions are imposed by\nthe Internet itself, not by Python. (As you\u2019ve learned by now, Python has a different\nmechanism for escaping special characters in string constants with backslashes.) These\nrules stem from the fact that the Web is based on the notion of shipping formatted text\nstrings around the planet, and are almost surely influenced by the tendency of different\ninterest groups to develop very different notations.\nYou can take heart, though, in the fact that you often don\u2019t need to think in such cryptic\nterms; when you do, Python automates the translation process with library tools. Just\nkeep in mind that any script that generates HTML or URLs dynamically probably needs\nto call Python\u2019s escaping tools to be robust. We\u2019ll see both the HTML and the URL\nescape tool sets employed frequently in later examples in this chapter and the next.\nMoreover, web development frameworks and tools such as Zope and others aim to get\nrid of some of the low-level complexities that CGI scripters face. And as usual in pro-\ngramming, there is no substitute for brains; amazing technologies like the Internet come\nat an inevitable cost in complexity.\nTransferring Files to Clients and Servers\nIt\u2019s time to explain a bit of HTML code that\u2019s been lurking in the shadows. Did you\nnotice those hyperlinks on the language selector examples\u2019 main pages for showing the\nCGI script\u2019s source code (the links I told you to ignore)? Normally, we can\u2019t see such\nscript source code, because accessing a CGI script makes it execute\u2014we can see only\nits HTML output, generated to make the new page. The script in Example 15-26, ref-\nerenced by a hyperlink in the main language.html page, works around that by opening\nthe source file and sending its text as part of the HTML response. The text is marked\nwith <PRE> as preformatted text and is escaped for transmission inside HTML with\ncgi.escape.\nExample 15-26. PP4E\\Internet\\Web\\cgi-bin\\languages-src.py\n#!/usr/bin/python\n\"Display languages.py script code without running it.\"\nimport cgi\nfilename = 'cgi-bin/languages.py'\nTransferring Files to Clients and Servers | 1209print('Content-type: text/html\\n')          # wrap up in HTML\nprint('<TITLE>Languages</TITLE>')\nprint(\"<H1>Source code: '%s'</H1>\" % filename)\nprint('<HR><PRE>')\nprint(cgi.escape(open(filename).read()))    # decode per platform default\nprint('</PRE><HR>')\nHere again, the filename is relative to the server\u2019s directory for our web server on Win-\ndows (see the prior discussion of this, and delete the cgi-bin portion of its path on\nother platforms). When we visit this script on the Web via the first source hyperlink in\nExample 15-17 or a manually typed URL, the script delivers a response to the client\nthat includes the text of the CGI script source file. It\u2019s captured in Figure 15-27.\nFigure 15-27. Source code viewer page\nNote that here, too, it\u2019s crucial to format the text of the file with cgi.escape, because\nit is embedded in the HTML code of the reply. If we don\u2019t, any characters in the text\nthat mean something in HTML code are interpreted as HTML tags. For example, the\nC++ < operator character within this file\u2019s text may yield bizarre results if not properly\nescaped. The cgi.escape utility converts it to the standard sequence &lt; for safe\nembedding.\n1210 | Chapter 15:\u2002Server-Side ScriptingDisplaying Arbitrary Server Files on the Client\nAlmost immediately after writing the languages source code viewer script in the pre-\nceding example, it occurred to me that it wouldn\u2019t be much more work, and would be\nmuch more useful, to write a generic version\u2014one that could use a passed-in filename\nto display any file on the site. It\u2019s a straightforward mutation on the server side; we\nmerely need to allow a filename to be passed in as an input. The getfile.py Python script\nin Example 15-27 implements this generalization. It assumes the filename is either\ntyped into a web page form or appended to the end of the URL as a parameter. Re-\nmember that Python\u2019s cgi module handles both cases transparently, so there is no code\nin this script that notices any difference.\nExample 15-27. PP4E\\Internet\\Web\\cgi-bin\\getfile.py\n#!/usr/bin/python\n\"\"\"\n##################################################################################\nDisplay any CGI (or other) server-side file without running it. The filename can\nbe passed in a URL param or form field (use \"localhost\" as the server if local):\n    http://servername/cgi-bin/getfile.py?filename=somefile.html\n    http://servername/cgi-bin/getfile.py?filename=cgi-bin\\somefile.py\n    http://servername/cgi-bin/getfile.py?filename=cgi-bin%2Fsomefile.py\nUsers can cut-and-paste or \"View Source\" to save file locally.  On IE, running the\ntext/plain version (formatted=False) sometimes pops up Notepad, but end-lines are\nnot always in DOS format;  Netscape shows the text correctly in the browser page\ninstead.  Sending the file in text/HTML mode works on both browsers--text is\ndisplayed in the browser response page correctly. We also check the filename here\nto try to avoid showing private files; this may or may not prevent access to such\nfiles in general: don't install this script if you can't otherwise secure source!\n##################################################################################\n\"\"\"\nimport cgi, os, sys\nformatted = True                                  # True=wrap text in HTML\nprivates  = ['PyMailCgi/cgi-bin/secret.py']       # don't show these\ntry:\n    samefile = os.path.samefile                   # checks device, inode numbers\nexcept:\n    def samefile(path1, path2):                   # not available on Windows\n        apath1 = os.path.abspath(path1).lower()   # do close approximation\n        apath2 = os.path.abspath(path2).lower()   # normalizes path, same case\n        return apath1 == apath2\nhtml = \"\"\"\n<html><title>Getfile response</title>\n<h1>Source code for: '%s'</h1>\n<hr>\n<pre>%s</pre>\n<hr></html>\"\"\"\nTransferring Files to Clients and Servers | 1211def restricted(filename):\n    for path in privates:\n        if samefile(path, filename):           # unify all paths by os.stat\n            return True                        # else returns None=false\ntry:\n    form = cgi.FieldStorage()\n    filename = form['filename'].value          # URL param or form field\nexcept:\n    filename = 'cgi-bin\\getfile.py'            # else default filename\ntry:\n    assert not restricted(filename)            # load unless private\n    filetext = open(filename).read()           # platform unicode encoding\nexcept AssertionError:\n    filetext = '(File access denied)'\nexcept:\n    filetext = '(Error opening file: %s)' % sys.exc_info()[1]\nif not formatted:\n    print('Content-type: text/plain\\n')        # send plain text\n    print(filetext)                            # works on NS, not IE?\nelse:\n    print('Content-type: text/html\\n')         # wrap up in HTML\n    print(html % (filename, cgi.escape(filetext)))\nThis Python server-side script simply extracts the filename from the parsed CGI inputs\nobject and reads and prints the text of the file to send it to the client browser. Depending\non the formatted global variable setting, it sends the file in either plain text mode (using\ntext/plain in the response header) or wrapped up in an HTML page definition (text/\nhtml).\nBoth modes (and others) work in general under most browsers, but Internet Explorer\ndoesn\u2019t handle the plain text mode as gracefully as Netscape does\u2014during testing, it\npopped up the Notepad text editor to view the downloaded text, but end-of-line char-\nacters in Unix format made the file appear as one long line. (Netscape instead displays\nthe text correctly in the body of the response web page itself.) HTML display mode\nworks more portably with current browsers. More on this script\u2019s restricted file logic\nin a moment.\nLet\u2019s launch this script by typing its URL at the top of a browser, along with a desired\nfilename appended after the script\u2019s name. Figure 15-28 shows the page we get by\nvisiting the following URL (the second source link in the language selector page of\nExample 15-17 has a similar effect but a different file):\nhttp://localhost/cgi-bin/getfile.py?filename=cgi-bin\\languages-src.py\nThe body of this page shows the text of the server-side file whose name we passed at\nthe end of the URL; once it arrives, we can view its text, cut-and-paste to save it in a\nfile on the client, and so on. In fact, now that we have this generalized source code\n1212 | Chapter 15:\u2002Server-Side Scriptingviewer, we could replace the hyperlink to the script languages-src.py in\nlanguage.html, with a URL of this form (I included both for illustration):\nhttp://localhost/cgi-bin/getfile.py?filename=cgi-bin\\languages.py\nSubtle thing: notice that the query parameter in this URL and others in this book use\na backslash as the Windows directory separator. On Windows, and using both the local\nPython web server of Example 15-1 and Internet Explorer, we can also use the two\nURL-escaped forms at the start of the following, but the literal forward slash of the last\nin following fails (in URL escapes, %5C is \\ and %2F is /):\nhttp://localhost/cgi-bin/getfile.py?filename=cgi-bin%5Clanguages.py     OK too\nhttp://localhost/cgi-bin/getfile.py?filename=cgi-bin%2Flanguages.py     OK too\nhttp://localhost/cgi-bin/getfile.py?filename=cgi-bin/languages.py       fails\nThis reflects a change since the prior edition of this book (which used the last of these\nfor portability), and may or may not be ideal behavior (though like working directory\ncontexts, this is one of a set of server and platform differences you\u2019re likely to encounter\nwhen working on the Web). It seems to stem from the fact that the urllib.parse mod-\nule\u2019s quote considers / safe, but quote_plus no longer does. If you care about URL\nportability in this context, the second of the preceding forms may be better, though\narguably cryptic to remember if you have to type it manually (escaping tools can au-\ntomate this). If not, you may have to double-up on backslashes to avoid clashes with\nother string escapes, because of the way URL parameter data is handled; see the links\nto this script in Example 15-20 for an example involving \\f.\nFigure 15-28. Generic source code viewer page\nTransferring Files to Clients and Servers | 1213From a higher perspective, URLs like these are really direct calls (albeit across the Web)\nto our Python script, with filename parameters passed explicitly\u2014we\u2019re using the script\nmuch like a subroutine located elsewhere in cyberspace which returns the text of a file\nwe wish to view. As we\u2019ve seen, parameters passed in URLs are treated the same as field\ninputs in forms; for convenience, let\u2019s also write a simple web page that allows the\ndesired file to be typed directly into a form, as shown in Example 15-28.\nExample 15-28. PP4E\\Internet\\Web\\getfile.html\n<html><title>Getfile: download page</title>\n<body>\n<form method=get action=\"cgi-bin/getfile.py\">\n  <h1>Type name of server file to be viewed</h1>\n  <p><input type=text size=50 name=filename>\n  <p><input type=submit value=Download>\n</form>\n<hr><a href=\"cgi-bin/getfile.py?filename=cgi-bin\\getfile.py\">View script code</a>\n</body></html>\nFigure 15-29 shows the page we receive when we visit this file\u2019s URL. We need to type\nonly the filename in this page, not the full CGI script address; notice that I can use\nforward slashes here because the browser will escape on transmission and Python\u2019s\nopen allows either type of slash on Windows (in query parameters created manually,\nit\u2019s up to coders or generators to do the right thing).\nFigure 15-29. Source code viewer selection page\nWhen we press this page\u2019s Download button to submit the form, the filename is trans-\nmitted to the server, and we get back the same page as before, when the filename was\nappended to the URL (it\u2019s the same as Figure 15-28, albeit with a different directory\nseparator slash). In fact, the filename will be appended to the URL here, too; the get\nmethod in the form\u2019s HTML instructs the browser to append the filename to the URL,\n1214 | Chapter 15:\u2002Server-Side Scriptingexactly as if we had done so manually. It shows up at the end of the URL in the response\npage\u2019s address field, even though we really typed it into a form. Clicking the link at the\nbottom of Figure 15-29 opens the file-getter script\u2019s source in the same way, though\nthe URL is explicit.\u2021\nHandling private files and errors\nAs long as CGI scripts have permission to open the desired server-side file, this script\ncan be used to view and locally save any file on the server. For instance, Figure 15-30\nshows the page we\u2019re served after asking for the file path PyMailCgi/pymailcgi.html\u2014\nan HTML text file in another application\u2019s subdirectory, nested within the parent di-\nrectory of this script (we explore PyMailCGI in the next chapter). Users can specify\nboth relative and absolute paths to reach a file\u2014any path syntax the server understands\nwill do.\nFigure 15-30. Viewing files with relative paths\nMore generally, this script will display any file path for which the username under which\nthe CGI script runs has read access. On some servers, this is often the user \u201cnobody\u201d\u2014\na predefined username with limited permissions. Just about every server-side file used\nin web applications will be accessible, though, or else they couldn\u2019t be referenced from\nbrowsers in the first place. When running our local web server, every file on the com-\nputer can be inspected: C:\\Users\\mark\\Stuff\\Websites\\public_html\\index.html works\nfine when entered in the form of Figure 15-29 on my laptop, for example.\n\u2021 You may notice another difference in the response pages produced by the form and an explicitly typed URL:\nfor the form, the value of the \u201cfilename\u201d parameter at the end of the URL in the response may contain URL\nescape codes for some characters in the file path you typed. Browsers automatically translate some non-ASCII\ncharacters into URL escapes (just like urllib.parse.quote). URL escapes were discussed earlier in this\nchapter; we\u2019ll see an example of this automatic browser escaping at work in an upcoming screenshot.\nTransferring Files to Clients and Servers | 1215That makes for a flexible tool, but it\u2019s also potentially dangerous if you are running a\nserver on a remote machine. What if we don\u2019t want users to be able to view some files\non the server? For example, in the next chapter, we will implement an encryption\nmodule for email account passwords. On our server, it is in fact addressable as\nPyMailCgi/cgi-bin/secret.py. Allowing users to view that module\u2019s source code would\nmake encrypted passwords shipped over the Net much more vulnerable to cracking.\nTo minimize this potential, the getfile script keeps a list, privates, of restricted file-\nnames, and uses the os.path.samefile built-in to check whether a requested filename\npath points to one of the names on privates. The samefile call checks to see whether\nthe os.stat built-in returns the same identifying information (device and inode num-\nbers) for both file paths. As a result, pathnames that look different syntactically but\nreference the same file are treated as identical. For example, on the server used for this\nbook\u2019s second edition, the following paths to the encryptor module were different\nstrings, but yielded a true result from os.path.samefile:\n../PyMailCgi/secret.py\n/home/crew/lutz/public_html/PyMailCgi/secret.py\nUnfortunately, the os.path.samefile call is supported on Unix, Linux, and Macs, but\nnot on Windows. To emulate its behavior in Windows, we expand file paths to be\nabsolute, convert to a common case, and compare (I shortened paths in the following\nwith ... for display here):\n>>> import os\n>>> os.path.samefile\nAttributeError: 'module' object has no attribute 'samefile'\n>>> os.getcwd()\n'C:\\\\...\\\\PP4E\\\\dev\\\\Examples\\\\PP4E\\\\Internet\\\\Web'\n>>>\n>>> x = os.path.abspath('../Web/PYMailCgi/cgi-bin/secret.py').lower()\n>>> y = os.path.abspath('PyMailCgi/cgi-bin/secret.py').lower()\n>>> z = os.path.abspath('./PYMailCGI/cgi-bin/../cgi-bin/SECRET.py').lower()\n>>> x\n'c:\\\\...\\\\pp4e\\\\dev\\\\examples\\\\pp4e\\\\internet\\\\web\\\\pymailcgi\\\\cgi-bin\\\\secret.py'\n>>> y\n'c:\\\\...\\\\pp4e\\\\dev\\\\examples\\\\pp4e\\\\internet\\\\web\\\\pymailcgi\\\\cgi-bin\\\\secret.py'\n>>> z\n'c:\\\\...\\\\pp4e\\\\dev\\\\examples\\\\pp4e\\\\internet\\\\web\\\\pymailcgi\\\\cgi-bin\\\\secret.py'\n>>>\n>>> x == y, y == z\n(True, True)\nAccessing any of the three paths expanded here generates an error page like that in\nFigure 15-31. Notice how the names of secret files are global data in this module, on\nthe assumption that they pertain to files viewable across an entire site; though we could\nallow for customization per site, changing the script\u2019s globals per site is likely just as\nconvenient as changing a per-site customization files.\nAlso notice that bona fide file errors are handled differently. Permission problems and\nattempts to access nonexistent files, for example, are trapped by a different exception\n1216 | Chapter 15:\u2002Server-Side Scriptinghandler clause, and they display the exception\u2019s message\u2014fetched using Python\u2019s\nsys.exc_info\u2014to give additional context. Figure 15-32 shows one such error page.\nFigure 15-31. Accessing private files\nFigure 15-32. File errors display\nAs a general rule of thumb, file-processing exceptions should always be reported in\ndetail, especially during script debugging. If we catch such exceptions in our scripts,\nit\u2019s up to us to display the details (assigning sys.stderr to sys.stdout won\u2019t help if\nPython doesn\u2019t print an error message). The current exception\u2019s type, data, and trace-\nback objects are always available in the sys module for manual display.\nDo not install the getfile.py script if you truly wish to keep your files\nprivate! The private files list check it uses attempts to prevent the en-\ncryption module from being viewed directly with this script, but it may\nor may not handle all possible attempts, especially on Windows. This\nbook isn\u2019t about security, so we won\u2019t go into further details here, except\nto say that on the Internet, a little paranoia is often a good thing. Espe-\ncially for systems installed on the general Internet at large, you should\ngenerally assume that the worst case scenario might eventually happen.\nTransferring Files to Clients and Servers | 1217Uploading Client Files to the Server\nThe getfile script lets us view server files on the client, but in some sense, it is a general-\npurpose file download tool. Although not as direct as fetching a file by FTP or over raw\nsockets, it serves similar purposes. Users of the script can either cut-and-paste the dis-\nplayed code right off the web page or use their browser\u2019s View Source option to view\nand cut. As described earlier, scripts that contact the script with urllib can also extract\nthe file\u2019s text with Python\u2019s HTML parser module.\nBut what about going the other way\u2014uploading a file from the client machine to the\nserver? For instance, suppose you are writing a web-based email system, and you need\na way to allow users to upload mail attachments. This is not an entirely hypothetical\nscenario; we will actually implement this idea in the next chapter, when we develop\nthe PyMailCGI webmail site.\nAs we saw in Chapter 13, uploads are easy enough to accomplish with a client-side\nscript that uses Python\u2019s FTP support module. Yet such a solution doesn\u2019t really apply\nin the context of a web browser; we can\u2019t usually ask all of our program\u2019s clients to\nstart up a Python FTP script in another window to accomplish an upload. Moreover,\nthere is no simple way for the server-side script to request the upload explicitly, unless\nan FTP server happens to be running on the client machine (not at all the usual case).\nUsers can email files separately, but this can be inconvenient, especially for email\nattachments.\nSo is there no way to write a web-based program that lets its users upload files to a\ncommon server? In fact, there is, though it has more to do with HTML than with Python\nitself. HTML <input> tags also support a type=file option, which produces an input\nfield, along with a button that pops up a file-selection dialog. The name of the client-\nside file to be uploaded can either be typed into the control or selected with the pop-\nup dialog. To demonstrate, the HTML file in Example 15-29 defines a page that allows\nany client-side file to be selected and uploaded to the server-side script named in the\nform\u2019s action option.\nExample 15-29. PP4E\\Internet\\Web\\putfile.html\n<html><title>Putfile: upload page</title>\n<body>\n<form enctype=\"multipart/form-data\"\n      method=post\n      action=\"cgi-bin/putfile.py\">\n  <h1>Select client file to be uploaded</h1>\n  <p><input type=file size=50 name=clientfile>\n  <p><input type=submit value=Upload>\n</form>\n<hr><a href=\"cgi-bin/getfile.py?filename=cgi-bin\\putfile.py\">View script code</a>\n</body></html>\nOne constraint worth noting: forms that use file type inputs should also specify a\nmultipart/form-data encoding type and the post submission method, as shown in this\n1218 | Chapter 15:\u2002Server-Side Scriptingfile; get-style URLs don\u2019t work for uploading files (adding their contents to the end of\nthe URL doesn\u2019t make sense). When we visit this HTML file, the page shown in Fig-\nure 15-33 is delivered. Pressing its Browse button opens a standard file-selection dialog,\nwhile Upload sends the file.\nFigure 15-33. File upload selection page\nOn the client side, when we press this page\u2019s Upload button, the browser opens and\nreads the selected file and packages its contents with the rest of the form\u2019s input fields\n(if any). When this information reaches the server, the Python script named in the form\naction tag is run as always, as listed in Example 15-30.\nExample 15-30. PP4E\\Internet\\Web\\cgi-bin\\putfile.py\n#!/usr/bin/python\n\"\"\"\n##################################################################################\nextract file uploaded by HTTP from web browser;  users visit putfile.html to\nget the upload form page, which then triggers this script on server;  this is\nvery powerful, and very dangerous: you will usually want to check the filename,\netc;  this may only work if file or dir is writable: a Unix 'chmod 777 uploads'\nmay suffice;  file pathnames may arrive in client's path format: handle here;\ncaveat: could open output file in text mode to wite receiving platform's line\nends since file content always str from the cgi module, but this is a temporary\nsolution anyhow--the cgi module doesn't handle binary file uploads in 3.1 at all;\n##################################################################################\n\"\"\"\nimport cgi, os, sys\nimport posixpath, ntpath, macpath      # for client paths\ndebugmode    = False                   # True=print form info\nTransferring Files to Clients and Servers | 1219loadtextauto = False                   # True=read file at once\nuploaddir    = './uploads'             # dir to store files\nsys.stderr = sys.stdout                # show error msgs\nform = cgi.FieldStorage()              # parse form data\nprint(\"Content-type: text/html\\n\")     # with blank line\nif debugmode: cgi.print_form(form)     # print form fields\n# html templates\nhtml = \"\"\"\n<html><title>Putfile response page</title>\n<body>\n<h1>Putfile response page</h1>\n%s\n</body></html>\"\"\"\ngoodhtml = html % \"\"\"\n<p>Your file, '%s', has been saved on the server as '%s'.\n<p>An echo of the file's contents received and saved appears below.\n</p><hr>\n<p><pre>%s</pre>\n</p><hr>\n\"\"\"\n# process form data\ndef splitpath(origpath):                              # get file at end\n    for pathmodule in [posixpath, ntpath, macpath]:   # try all clients\n        basename = pathmodule.split(origpath)[1]      # may be any server\n        if basename != origpath:\n            return basename                           # lets spaces pass\n    return origpath                                   # failed or no dirs\ndef saveonserver(fileinfo):                           # use file input form data\n    basename = splitpath(fileinfo.filename)           # name without dir path\n    srvrname = os.path.join(uploaddir, basename)      # store in a dir if set\n    srvrfile = open(srvrname, 'wb')                   # always write bytes here\n    if loadtextauto:\n        filetext = fileinfo.value                     # reads text into string\n        if isinstance(filetext, str):                 # Python 3.1 hack\n            filedata = filetext.encode()\n        srvrfile.write(filedata)                      # save in server file\n    else:                                             # else read line by line\n        numlines, filetext = 0, ''                    # e.g., for huge files\n        while True:                                   # content always str here\n            line = fileinfo.file.readline()           # or for loop and iterator\n            if not line: break\n            if isinstance(line, str):                 # Python 3.1 hack\n                line = line.encode()\n            srvrfile.write(line)\n            filetext += line.decode()                 # ditto\n            numlines += 1\n        filetext = ('[Lines=%d]\\n' % numlines) + filetext\n    srvrfile.close()\n1220 | Chapter 15:\u2002Server-Side Scriptingos.chmod(srvrname, 0o666)   # make writable: owned by 'nobody'\n    return filetext, srvrname\ndef main():\n    if not 'clientfile' in form:\n        print(html % 'Error: no file was received')\n    elif not form['clientfile'].filename:\n        print(html % 'Error: filename is missing')\n    else:\n        fileinfo = form['clientfile']\n        try:\n            filetext, srvrname = saveonserver(fileinfo)\n        except:\n            errmsg = '<h2>Error</h2><p>%s<p>%s' % tuple(sys.exc_info()[:2])\n            print(html % errmsg)\n        else:\n            print(goodhtml % (cgi.escape(fileinfo.filename),\n                              cgi.escape(srvrname),\n                              cgi.escape(filetext)))\nmain()\nWithin this script, the Python-specific interfaces for handling uploaded files are em-\nployed. They aren\u2019t very new, really; the file comes into the script as an entry in the\nparsed form object returned by cgi.FieldStorage, as usual; its key is clientfile, the\ninput control\u2019s name in the HTML page\u2019s code.\nThis time, though, the entry has additional attributes for the file\u2019s name on the client.\nMoreover, accessing the value attribute of an uploaded file input object will automat-\nically read the file\u2019s contents all at once into a string on the server. For very large files,\nwe can instead read line by line (or in chunks of bytes) to avoid overflowing memory\nspace. Internally, Python\u2019s cgi module stores uploaded files in temporary files auto-\nmatically; reading them in our script simply reads from that temporary file. If they are\nvery large, though, they may be too long to store as a single string in memory all at once.\nFor illustration purposes, the script implements either scheme: based on the setting of\nthe loadtextauto global variable, it either asks for the file contents as a string or reads\nit line by line. In general, the CGI module gives us back objects with the following\nattributes for file upload controls:\nfilename\nThe name of the file as specified on the client\nfile\nA file object from which the uploaded file\u2019s contents can be read\nvalue\nThe contents of the uploaded file (read from the file on attribute access)\nAdditional attributes are not used by our script. Files represent a third input field object;\nas we\u2019ve also seen, the value attribute is a string for simple input fields, and we may\nreceive a list of objects for multiple-selection controls.\nTransferring Files to Clients and Servers | 1221For uploads to be saved on the server, CGI scripts (run by the user \u201cnobody\u201d on some\nservers) must have write access to the enclosing directory if the file doesn\u2019t yet exist, or\nto the file itself if it does. To help isolate uploads, the script stores all uploads in what-\never server directory is named in the uploaddir global. On one Linux server, I had to\ngive this directory a mode of 777 (universal read/write/execute permissions) with\nchmod to make uploads work in general. This is a nonissue with the local web server\nused in this chapter, but your mileage may vary; be sure to check permissions if this\nscript fails.\nThe script also calls os.chmod to set the permission on the server file such that it can be\nread and written by everyone. If it is created anew by an upload, the file\u2019s owner will\nbe \u201cnobody\u201d on some servers, which means anyone out in cyberspace can view and\nupload the file. On one Linux server, though, the file will also be writable only by the\nuser \u201cnobody\u201d by default, which might be inconvenient when it comes time to change\nthat file outside the Web (naturally, the degree of pain can vary per file operation).\nIsolating client-side file uploads by placing them in a single directory on\nthe server helps minimize security risks: existing files can\u2019t be overwrit-\nten arbitrarily. But it may require you to copy files on the server after\nthey are uploaded, and it still doesn\u2019t prevent all security risks\u2014\nmischievous clients can still upload huge files, which we would need to\ntrap with additional logic not present in this script as is. Such traps may\nbe needed only in scripts open to the Internet at large.\nIf both client and server do their parts, the CGI script presents us with the response\npage shown in Figure 15-34, after it has stored the contents of the client file in a new\nor existing file on the server. For verification, the response gives the client and server\nfile paths, as well as an echo of the uploaded file, with a line count in line-by-line reader\nmode.\nNotice that this echo display assumes that the file\u2019s content is text. It turns out that this\nis a safe assumption to make, because the cgi module always returns file content as\nstr strings, not bytes. Less happily, this also stems from the fact that binary file uploads\nare not supported in the cgi module in 3.1 (more on this limitation in an upcoming\nnote).\nThis file uploaded and saved in the uploads directory is identical to the original (run\nan fc command on Windows to verify this). Incidentally, we can also verify the upload\nwith the getfile program we wrote in the prior section. Simply access the selection\npage to type the pathname of the file on the server, as shown in Figure 15-35.\nIf the file upload is successful, the resulting viewer page we will obtain looks like\nFigure 15-36. Since the user \u201cnobody\u201d (CGI scripts) was able to write the file, \u201cnobody\u201d\nshould be able to view it as well (bad grammar perhaps, but true nonetheless).\n1222 | Chapter 15:\u2002Server-Side ScriptingNotice the URL in this page\u2019s address field\u2014the browser translated the / character we\ntyped into the selection page to a %2F hexadecimal escape code before adding it to the\nend of the URL as a parameter. We met URL escape codes like this earlier in this chapter.\nIn this case, the browser did the translation for us, but the end result is as if we had\nmanually called one of the urllib.parse quoting functions on the file path string.\nTechnically, the %2F escape code here represents the standard URL translation for non-\nASCII characters, under the default encoding scheme browsers employ. Spaces are\nFigure 15-34. Putfile response page\nFigure 15-35. Verifying putfile with getfile\u2014selection\nTransferring Files to Clients and Servers | 1223usually translated to + characters as well. We can often get away without manually\ntranslating most non-ASCII characters when sending paths explicitly (in typed URLs).\nBut as we saw earlier, we sometimes need to be careful to escape characters (e.g., &)\nthat have special meaning within URL strings with urllib.parse tools.\nHandling client path formats\nIn the end, the putfile.py script stores the uploaded file on the server within a hardcoded\nuploaddir directory, under the filename at the end of the file\u2019s path on the client (i.e.,\nless its client-side directory path). Notice, though, that the splitpath function in this\nscript needs to do extra work to extract the base name of the file on the right. Some\nbrowsers may send up the filename in the directory path format used on the client\nmachine; this path format may not be the same as that used on the server where the\nCGI script runs. This can vary per browser, but it should be addressed for portability.\nThe standard way to split up paths, os.path.split, knows how to extract the base\nname, but only recognizes path separator characters used on the platform on which it\nis running. That is, if we run this CGI script on a Unix machine, os.path.split chops\nup paths around a / separator. If a user uploads from a DOS or Windows machine,\nhowever, the separator in the passed filename is \\, not /. Browsers running on some\nMacintosh platforms may send a path that is more different still.\nTo handle client paths generically, this script imports platform-specific path-processing\nmodules from the Python library for each client it wishes to support, and tries to split\nthe path with each until a filename on the right is found. For instance, posixpath handles\npaths sent from Unix-style platforms, and ntpath recognizes DOS and Windows client\npaths. We usually don\u2019t import these modules directly since os.path.split is auto-\nmatically loaded with the correct one for the underlying platform, but in this case, we\nFigure 15-36. Verifying putfile with getfile\u2014response\n1224 | Chapter 15:\u2002Server-Side Scriptingneed to be specific since the path comes from another machine. Note that we could\nhave instead coded the path splitter logic like this to avoid some split calls:\ndef splitpath(origpath):                                    # get name at end\n    basename = os.path.split(origpath)[1]                   # try server paths\n    if basename == origpath:                                # didn't change it?\n        if '\\\\' in origpath:\n            basename = origpath.split('\\\\')[-1]             # try DOS clients\n        elif '/' in origpath:\n            basename = origpath.split('/')[-1]              # try Unix clients\n    return basename\nBut this alternative version may fail for some path formats (e.g., DOS paths with a drive\nbut no backslashes). As is, both options waste time if the filename is already a base\nname (i.e., has no directory paths on the left), but we need to allow for the more complex\ncases generically.\nThis upload script works as planned, but a few caveats are worth pointing out before\nwe close the book on this example:\n\u2022 Firstly, putfile doesn\u2019t do anything about cross-platform incompatibilities in\nfilenames themselves. For instance, spaces in a filename shipped from a DOS client\nare not translated to nonspace characters; they will wind up as spaces in the server-\nside file\u2019s name, which may be legal but are difficult to process in some scenarios.\n\u2022 Secondly, reading line by line means that this CGI script is biased toward uploading\ntext files, not binary datafiles. It uses a wb output open mode to retain the binary\ncontent of the uploaded file, but it assumes the data is text in other places, including\nthe reply page. See Chapter 4 for more about binary file modes. This is all largely\na moot point in Python 3.1, though, as binary file uploads do not work at all (see\n\u201cCGI File Upload Limitations in 3.1\u201d); in future release, though, this would need\nto be addressed.\nIf you run into any of these limitations, you will have crossed over into the domain of\nsuggested exercises.\nCGI File Upload Limitations in 3.1\nRegrettably, I need to document the fact that Python\u2019s standard library support for CGI\nfile uploads is partially broken in Python 3.1, the version used for this edition. In short,\nthe cgi module\u2019s internal parsing step fails today with an exception if any binary file\ndata or incompatible text file data is uploaded. This exception occurs before the script\nhas a chance to intervene, making simple workarounds nonviable. CGI uploads worked\nin Python 2.X because strings handled bytes, but fail in 3.X today.\nThis regression stems in part from the fact that the cgi module uses the email package\u2019s\nparser to extract incoming multipart data for files, and is thus crippled by some of the\nvery same email package issues we explored in detail in Chapter 13\u2014its email parser\nrequires str for the full text of a message to be parsed, but this is invalid for some CGI\nupload data. As mentioned in Chapter 13, the data transmitted for CGI file uploads\nmight have mixed text and binary data\u2014including raw binary data that is not\nTransferring Files to Clients and Servers | 1225MIME-encoded, text of any encoding, and even arbitrary combinations of these. The\ncurrent email package\u2019s requirement to decode this to str for parsing is utterly incom-\npatible, though the cgi module\u2019s own code seems suspect for some cases as well.\nIf you want to see for yourself how data is actually uploaded by browsers, see and run\nthe HTML and Python files named test-cgiu-uploads-bug* in the examples package to\nupload text, binary, and mixed type files:\n\u2022 test-cgi-uploads-bug.html/py attempts to parse normally, which works for some\ntext files but always fails for binary files with a Unicode decoding error\n\u2022 test-cgi-uploads-bug0.html/py tries binary mode for the input stream, but always\nfails with type errors for both text and binary because of email\u2019s str requirement\n\u2022 test-cgi-uploads-bug1.html/py saves the input stream for a single file\n\u2022 test-cgi-uploads-bug.html/py saves the input stream for multiple files\nThe last two of these scripts simply read the data in binary mode and save it in binary\nmode to a file for inspection, and display two headers passed in environment variables\nwhich are used for parsing (a \u201cmultipart/form-data\u201d content type and boundary, along\nwith a content length). Trying to parse the saved input data with the cgi module fails\nunless the data is entirely text that is compatible with that module\u2019s encoding assump-\ntions. Really, because the data can mix text and raw binary arbitrarily, a correct parser\nwill need to read it as bytes and switch between text and binary processing freely.\nIt seems likely that this will be improved in the future, but perhaps not until Python\n3.3 or later. Nearly two years after 3.0\u2019s release, though, this book project has found\nitself playing the role of beta tester more often than it probably should. This primarily\nderives from the fact that implications of the Python 3.X str/bytes dichotomy were not\nfully resolved in Python\u2019s own libraries prior to release. This isn\u2019t meant to disparage\npeople who have contributed much time and effort to 3.X already, of course. As some-\none who remembers 0.X, though, this situation seems less than ideal.\nWriting a replacement for the cgi module and the email package code it uses\u2014the only\ntrue viable workaround\u2014is not practical given this book project\u2019s constraints. For now,\nthe CGI scripts that perform file uploads in this book will only work with text files, and\nthen only with text files of compatible encodings. This extends to email attachments\nuploaded to the PyMailCGI webmail case study of the next chapter\u2014yet another reason\nwhy that example was not expanded with new functionality in this edition as much as\nthe preceding chapter\u2019s PyMailGUI. Being unable to attach images to emails this way\nis a severe functional limitation, which limits scope in general.\nFor updates on the probable fix for this issue in the future, watch this book\u2019s website\n(described in the Preface). A fix seems likely to be incompatible with current library\nmodule APIs, but short of writing every new system from scratch, such is reality in the\nreal world of software development. (And no, \u201crunning away more\u201d is not an option\u2026)\n1226 | Chapter 15:\u2002Server-Side ScriptingMore Than One Way to Push Bits over the Net\nFinally, let\u2019s discuss some context. We\u2019ve seen three getfile scripts at this point in the\nbook. The one in this chapter is different from the other two we wrote in earlier chap-\nters, but it accomplishes a similar goal:\n\u2022 This chapter\u2019s getfile is a server-side CGI script that displays files over the HTTP\nprotocol (on port 80).\n\u2022 In Chapter 12, we built a client- and server-side getfile to transfer with raw sockets\n(on port 50001).\n\u2022 In Chapter 13, we implemented a client-side getfile to ship over FTP (on port 21).\nReally, the getfile CGI script in this chapter simply displays files only, but it can be\nconsidered a download tool when augmented with cut-and-paste operations in a web\nbrowser. Moreover, the CGI- and HTTP-based putfile script here is also different from\nthe FTP-based putfile in Chapter 13, but it can be considered an alternative to both\nsocket and FTP uploads.\nThe point to notice is that there are a variety of ways to ship files around the Internet\u2014\nsockets, FTP, and HTTP (web pages) can move files between computers. Technically\nspeaking, we can transfer files with other techniques and protocols, too\u2014Post Office\nProtocol (POP) email, Network News Transfer Protocol (NNTP) news, Telnet, and\nso on.\nEach technique has unique properties but does similar work in the end: moving bits\nover the Net. All ultimately run over sockets on a particular port, but protocols like\nFTP and HTTP add additional structure to the socket layer, and application models\nlike CGI add both structure and programmability.\nIn the next chapter, we\u2019re going to use what we\u2019ve learned here to build a more sub-\nstantial application that runs entirely on the Web\u2014PyMailCGI, a web-based email\ntool, which allows us to send and view emails in a browser, process email attachments,\nand more. At the end of the day, though, it\u2019s mostly just bytes over sockets, with a user \ninterface.\nTransferring Files to Clients and Servers | 1227CGI Downloads: Forcing the Issue\nIn Example 15-27, we wrote a script named getfile.py, a Python CGI program designed\nto display any public server-side file, within a web browser (or other recipient) on the\nrequesting client machine. It uses a Content type of text/plain or text/html to make\nthe requested file\u2019s text show up properly inside a browser. In the description, we\ncompared getfile.py to a generalized CGI download tool, when augmented with cut-\nand-paste or save-as interactions.\nWhile true, getfile.py was intended to mostly be a file display tool only, not a CGI\ndownload demo. If you want to truly and directly download a file by CGI (instead of\ndisplaying it in a browser or opening it with an application), you can usually force the\nbrowser to pop up a Save As dialog for the file on the client by supplying the appropriate\nContent-type line in the CGI reply.\nBrowsers decide what to do with a file using either the file\u2019s suffix (e.g., xxx.jpg is\ninterpreted as an image), or the Content-type line (e.g., text/html is HTML code). By\nusing various MIME header line settings, you can make the datatype unknown and\neffectively render the browser clueless about data handling. For instance, a Content\ntype of application/octet-stream in the CGI reply generally triggers the standard Save\nAs dialog box in a browser.\nThis strategy is sometimes frowned on, though, because it leaves the true nature of the\nfile\u2019s data ambiguous\u2014it\u2019s usually better to let the user/client decide how to handle\ndownloaded data, rather than force the Save As behavior. It also has very little to do\nwith Python; for more details, consult a CGI-specific text, or try a web search on \u201cCGI\ndownload.\u201d\n1228 | Chapter 15:\u2002Server-Side Scripting", "16": "CHAPTER 16\nThe PyMailCGI Server\n\u201cThings to Do When Visiting Chicago\u201d\nThis chapter is the fifth in our survey of Python Internet programming, and it continues \nChapter 15\u2019s discussion. There, we explored the fundamentals of server-side Common \nGateway Interface (CGI) scripting in Python. Armed with that knowledge, this chapter \nmoves on to a larger case study that underscores advanced CGI and server-side web \nscripting topics.\nThis chapter presents PyMailCGI\u2014a \u201cwebmail\u201d website for reading and sending email \nthat illustrates security concepts, hidden form fields, URL generation, and more. Be-\ncause this system is similar in spirit to the PyMailGUI program we studied in Chap-\nter 14, this example also serves as a comparison of the web and nonweb application \nmodels. This case study is founded on basic CGI scripting, but it implements a complete \nwebsite that does something more useful than Chapter 15\u2019s examples.\nAs usual in this book, this chapter splits its focus between application-level details and \nPython programming concepts. For instance, because this is a fairly large case study, \nit illustrates system design concepts that are important in actual projects. It also says \nmore about CGI scripts in general: PyMailCGI expands on the notions of state retention \nand security concerns and encryption.\nThe system presented here is neither particularly flashy nor feature rich as websites go \n(in fact, the initial cut of PyMailCGI was thrown together during a layover at Chicago\u2019s \nO\u2019Hare airport). Alas, you will find neither dancing bears nor blinking lights at this \nsite. On the other hand, it was written to serve a real purpose, speaks more to us about \nCGI scripting, and hints at just how far Python server-side programs can take us. As \noutlined at the start of this part of the book, there are higher-level frameworks, systems, \nand tools that build upon ideas we will apply here. For now, let\u2019s have some fun with \nPython on the Web.\n1229The PyMailCGI Website\nIn Chapter 14, we built a program called PyMailGUI that implements a complete\nPython+tkinter email client GUI (if you didn\u2019t read that chapter, you may want to take\na quick glance at it now). Here, we\u2019re going to do something of the same, but on the\nWeb: the system presented in this section, PyMailCGI, is a collection of CGI scripts\nthat implement a simple web-based interface for sending and reading email in any\nbrowser. In effect, it is a webmail system\u2014though not as powerful as what may be\navailable from your Internet Service Provider (ISP), its scriptability gives you control\nover its operation and future evolution.\nOur goal in studying this system is partly to learn a few more CGI tricks, partly to learn\na bit about designing larger Python systems in general, and partly to underscore the\ntrade-offs between systems implemented for the Web (the PyMailCGI server) and sys-\ntems written to run locally (the PyMailGUI client). This chapter hints at some of these\ntrade-offs along the way and returns to explore them in more depth after the presen-\ntation of this system.\nImplementation Overview\nAt the top level, PyMailCGI allows users to view incoming email with the Post Office\nProtocol (POP) interface and to send new mail by Simple Mail Transfer Protocol\n(SMTP). Users also have the option of replying to, forwarding, or deleting an incoming\nemail while viewing it. As implemented, anyone can send email from a PyMailCGI site,\nbut to view your email, you generally have to install PyMailCGI on your own computer\nor web server account, with your own mail server information (due to security concerns\ndescribed later).\nViewing and sending email sounds simple enough, and we\u2019ve already coded this a few\ntimes in this book. But the required interaction involves a number of distinct web pages,\neach requiring a CGI script or HTML file of its own. In fact, PyMailCGI is a fairly\nlinear system\u2014in the most complex user interaction scenario, there are six states (and\nhence six web pages) from start to finish. Because each page is usually generated by a\ndistinct file in the CGI world, that also implies six source files.\nTechnically, PyMailCGI could also be described as a state machine, though very little\nstate is transferred from state to state. Scripts pass user and message information to the\nnext script in hidden form fields and query parameters, but there are no client-side\ncookies or server-side databases in the current version. Still, along the way we\u2019ll en-\ncounter situations where more advanced state retention tools could be an advantage.\nTo help keep track of how all of PyMailCGI\u2019s source files fit into the overall system, I\njotted down the file in Example 16-1 before starting any real programming. It informally\nsketches the user\u2019s flow through the system and the files invoked along the way. You\ncan certainly use more formal notations to describe the flow of control and information\n1230 | Chapter 16:\u2002The PyMailCGI Serverthrough states such as web pages (e.g., dataflow diagrams), but for this simple example,\nthis file gets the job done.\nExample 16-1. PP4E\\Internet\\Web\\PyMailCgi\\pageflow.txt\nfile or script                           creates\n--------------                           -------\n[pymailcgi.html]                         Root window\n => [onRootViewLink.py]                  Pop password window\n     => [onViewPswdSubmit.py]            List window (loads all pop mail)\n         => [onViewListLink.py]          View Window + pick=del|reply|fwd (fetch)\n             => [onViewPageAction.py]    Edit window, or delete+confirm (del)\n                 => [onEditPageSend.py]  Confirmation (sends smtp mail)\n                     => back to root\n => [onRootSendLink.py]                  Edit Window\n     => [onEditPageSend.py]              Confirmation (sends smtp mail)\n         => back to root\nThis file simply lists all the source files in the system, using => and indentation to denote\nthe scripts they trigger.\nFor instance, links on the pymailcgi.html root page invoke onRootViewLink.py and\nonRootSendLink.py, both executable scripts. The script onRootViewLink.py generates\na password page, whose Submit button in turn triggers onViewPswdSubmit.py, and so\non. Notice that both the view and the send actions can wind up triggering\nonEditPageSend.py to send a new mail; view operations get there after the user chooses\nto reply to or forward an incoming mail.\nIn a system such as this, CGI scripts make little sense in isolation, so it\u2019s a good idea\nto keep the overall page flow in mind; refer to this file if you get lost. For additional\ncontext, Figure 16-1 shows the overall contents of this site, viewed as directory listings\nunder Cygwin on Windows in a shell window.\nWhen you install this site, all the files you see here are uploaded to a PyMailCgi sub-\ndirectory of your web directory on your server\u2019s machine. Besides the page-flow HTML\nand CGI script files invoked by user interaction, PyMailCGI uses a handful of utility\nmodules:\ncommonhtml.py\nProvides a library of HTML tools\nexterns.py\nIsolates access to modules imported from other places\nloadmail.py\nEncapsulates mailbox fetches for future expansion\nsecret.py\nImplements configurable password encryption\nThe PyMailCGI Website | 1231PyMailCGI also reuses parts of the mailtools module package and mailconfig.py \nmodule we wrote in Chapter 13. The former of these is accessible to imports from\nthe PP4E package root, and the latter is largely copied by a local version in the\nPyMailCgi directory so that it can differ between PyMailGUI and PyMailCGI. The\nexterns.py module is intended to hide these modules\u2019 actual locations, in case\nthe install structure varies on some machines.\nIn fact, this system again demonstrates the powers of code reuse in a practical way. In\nthis edition, it gets a great deal of logic for free from the new mailtools package of\nChapter 13\u2014message loading, sending, deleting, parsing, composing, decoding and\nencoding, and attachments\u2014even though that package\u2019s modules were originally de-\nveloped for the PyMailGUI program. When it came time to update PyMailCGI later,\ntools for handling complex things such as attachments and message text searches were\nalready in place. See Chapter 13 for mailtools source code.\nAs usual, PyMailCGI also uses a variety of standard library modules: smtplib, poplib,\nemail.*, cgi, urllib.*, and the like. Thanks to the reuse of both custom and standard\nlibrary code, this system achieves much in a minimal amount of code. All told, Py-\nMailCGI consists of just 846 lines of new code, including whitespace, comments, and\nthe top-level HTML file (see file linecounts.xls in this system\u2019s source directory for\ndetails; the prior edition\u2019s version claimed to be some 835 new lines).\nThis compares favorably to the size of the PyMailGUI client-side \u201cdesktop\u201d program\nin Chapter 14, but most of this difference owes to the vastly more limited functionality\nin PyMailCGI\u2014there are no local save files, no transfer thread overlap, no message\ncaching, no inbox synchronization tests or recovery, no multiple-message selections,\nno raw mail text views, and so on. Moreover, as the next section describes, PyMailCGI\u2019s\nUnicode policies are substantially more limited in this release, and although arbitrary\nFigure 16-1. PyMailCGI contents\n1232 | Chapter 16:\u2002The PyMailCGI Serverattachments can be viewed, sending binary and some text attachments is not supported\nin the current version because of a Python 3.1 issue.\nIn other words, PyMailCGI is really something of a prototype, designed to illustrate\nweb scripting and system design concepts in this book, and serve as a springboard for\nfuture work. As is, it\u2019s nowhere near as far along the software evolutionary scale as\nPyMailGUI. Still, we\u2019ll see that PyMailCGI\u2019s code factoring and reuse of existing mod-\nules allow it to implement much in a surprisingly small amount of code.\nNew in This Fourth Edition (Version 3.0)\nIn this fourth edition, PyMailCGI has been ported to run under Python 3.X. In addition,\nthis version inherits and employs a variety of new features from the mailtools module,\nincluding mail header decoding and encoding, main mail text encoding, the ability to\nlimit mail headers fetched, and more. Notably, there is new support for Unicode and\nInternationalized character sets as follows:\n\u2022 For display, both a mail\u2019s main text and its headers are decoded prior to viewing,\nper email, MIME, and Unicode standards; text is decoded per mail headers and\nheaders are decoded per their content.\n\u2022 For sends, a mail\u2019s main text, text attachments, and headers are all encoded per\nthe same standards, using UTF-8 as the default encoding if required.\n\u2022 For replies and forwards, headers copied into the quoted message text are also\ndecoded for display.\nNote that this version relies upon web browsers\u2019 ability to display arbitrary kinds of\nUnicode text. It does not emit any sort of \u201cmeta\u201d tag to declare encodings in the HTML\nreply pages generated for mail view and composition. For instance, a properly formed\nHTML document can often declare its encoding this way:\n<HTML><HEAD>\n<META http-equiv=Content-Type content=\"text/html; charset=windows-1251\">\n</HEAD>\nSuch headers are omitted here. This is in part due to the fact that the mail might have\narbitrary and even mixed types of text among is message and headers, which might also\nclash with encoding in the HTML of the reply itself. Consider a mail index list page\nthat displays headers of multiple mails; because each mail\u2019s Subject and From might\nbe encoding in a different character set (one Russian, one Chinese, and so on), a single\nencoding declaration won\u2019t suffice (though UTF-8\u2019s generality can often come to the\nrescue). Resolving such mixed character set cases is left to the browser, which may\nultimately require assistance from the user in the form of encoding choices. Such dis-\nplays work in PyMailGUI because we pass decoded Unicode text to the tkinter Text\nwidget, which handles arbitrary Unicode code points well. In PyMailCGI, we\u2019re largely\nfinessing this issue to keep this example short.\nThe PyMailCGI Website | 1233Moreover, both text and binary attachments of fetched mails are simply saved in binary\nform and opened by filename in browsers when their links are clicked, relying again on\nbrowsers to do the right thing. Text attachments for sends are also subject to the CGI\nupload limitations described in the note just ahead. Beyond all this, Python 3.1 appears\nto have an issue printing some types of Unicode text to the standard output stream in\nthe CGI context, which necessitates a workaround in the main utilities module here\nthat opens stdout in binary mode and writes text as encoded bytes (see the code for\nmore details).\nThis Unicode/i18n support is substantially less rich than that in PyMailGUI. However,\ngiven that we can\u2019t prompt for encodings here, and given that this book is running short\non time and space in general, improving this for cases and browsers where it might\nmatter is left as a suggested exercise.\nFor more on specific 3.0 fourth-edition changes made, see the comments marked with\n\u201c3.0\u201d in the program code files listed ahead. In addition, all the features added for the\nprior edition are still here, as described in the next section.\nLimitation on Sending Attachments in This Edition\nIf you haven\u2019t already done so, see \u201cCGI File Upload Limitations in\n3.1\u201d on page 1225. In brief, in Python 3.1 the cgi module, as well as the email package\u2019s\nparser which it uses, fail with exceptions when requests submitted by web browsers\ninclude raw binary data or incompatibly encoded text added for uploaded files. Un-\nfortunately, because this chapter\u2019s PyMailCGI system relies on CGI uploads for at-\ntachments, this limitation means that this system does not currently support sending\nemails with binary email attachments such as images and audio files. It did support this\nin the prior edition under Python 2.X.\nSuch sent attachments still work in Chapter 14\u2019s PyMailGUI desktop application, sim-\nply because attachment file data can be read directly from local files (using binary mode\nif required, and MIME encoding if needed for inclusion in email). Because the Py-\nMailCGI webmail system here relies on CGI uploads to transfer attachments to the\nserver as an extra first step, though, it\u2019s fully at the mercy of the currently broken cgi\nmodule\u2019s upload support. Coding a cgi replacement is far too ambitious a goal for this\nbook.\nA fix is expected for this in the future, and may be present by the time you read these\nwords. Being based on Python 3.1, though, this edition\u2019s PyMailCGI simply cannot\nsupport sending such attachments, though they can still be freely viewed in mails\nfetched. In fact, although this edition\u2019s PyMailCGI inherits some new features from\nmailtools such as i18n header decoding and encoding, this attachment send limitation\nis severe enough to preclude expanding this system\u2019s feature set to the same degree as\nthis edition\u2019s PyMailGUI. For example, Unicode policies are simple here, if not naive.\nIt\u2019s possible that some client-side scripting techniques such as AJAX may be able to\ntransfer attachment files independently, and thus avoid CGI uploads altogether. How-\never, such techniques would also require deploying frameworks and technologies\n1234 | Chapter 16:\u2002The PyMailCGI Serveroutside this book\u2019s scope, would imply a radically different and more complex program\nstructure, and should probably not be necessitated by a regression in Python 3.X in any\nevent. A rewrite (PyMailRIA?) will have to await a final verdict on Python 3.X CGI\nsupport fixes.\nNew in the Prior Edition (Version 2.0)\nIn the third edition, PyMailCGI was upgraded to use the new mailtools module pack-\nage of Chapter 13, employ the PyCrypto package for passwords if it is installed, support\nviewing and sending message attachments, and run more efficiently. All these are in-\nherited by version 3.0 as well.\nWe\u2019ll meet these new features along the way, but the last two of these merit a few words\nup front. Attachments are supported in a simplistic but usable fashion and use existing\nmailtools package code for much of their operation:\n\u2022 For viewing attachments, message parts are split off the message and saved in local\nfiles on the server. Message view pages are then augmented with hyperlinks point-\ning to the temporary files; when clicked, they open in whatever way your web\nbrowser opens the selected part\u2019s file type.\n\u2022 For sending attachments, we use the HTML upload techniques presented near the\nend of Chapter 15. Mail edit pages now have file-upload controls, to allow a max-\nimum of three attachments. Selected files are uploaded to the server by the browser\nwith the rest of the page as usual, saved in temporary files on the server, and added\nto the outgoing mail from the local files on the server by mailtools. As described\nin the note in the preceding section, sent attachments can only be compatibly en-\ncoded text in version 3.0, not binary, though this includes encodable HTML files.\nBoth schemes would fail for multiple simultaneous users, but since PyMailCGI\u2019s\nconfiguration file scheme (described later in this chapter) already limits it to a single\nusername, this is a reasonable constraint. The links to temporary files generated for\nattachment viewing also apply only to the last message selected, but this works if the\npage flow is followed normally. Improving this for a multiuser scenario, as well as\nadding additional features such as PyMailGUI\u2019s local file save and open options, are\nleft as exercises.\nFor efficiency, this version of PyMailCGI also avoids repeated exhaustive mail down-\nloads. In the prior version, the full text of all messages in an inbox was downloaded\nevery time you visited the list page and every time you selected a single message to view.\nIn this version, the list page downloads only the header text portion of each message,\nand only a single message\u2019s full text is downloaded when one is selected for viewing.\nIn addition, the headers fetch limits added to mailtools in the fourth edition of this\nbook are applied automatically to limit download time (earlier mails outside the set\u2019s\nsize are ignored).\nThe PyMailCGI Website | 1235Even so, the list page\u2019s headers-only download can be slow if you have many messages\nin your inbox (and as I confessed in Chapter 14, I have thousands in one of mine). A\nbetter solution would somehow cache mails to limit reloads, at least for the duration\nof a browser session. For example, we might load headers of only newly arrived mes-\nsages, and cache headers of mails already fetched, as done in the PyMailGUI client of\nChapter 14.\nDue to the lack of state retention in CGI scripts, though, this would likely require some\nsort of server-side database. We might, for instance, store already fetched message\nheaders under a generated key that identifies the session (e.g., with process number\nand time) and pass that key between pages as a cookie, hidden form field, or URL query\nparameter. Each page would use the key to fetch cached mail stored directly on the web\nserver, instead of loading it from the email server again. Presumably, loading from a\nlocal cache file would be faster than loading from a network connection to the mail\nserver.\nThis would make for an interesting exercise, too, if you wish to extend this system on\nyour own, but it would also result in more pages than this chapter has to spend (frankly,\nI ran out of time for this project and real estate in this chapter long before I ran out of\npotential enhancements).\nPresentation Overview\nMuch of the \u201caction\u201d in PyMailCGI is encapsulated in shared utility modules, especially\none called commonhtml.py. As you\u2019ll see in a moment, the CGI scripts that implement\nuser interaction don\u2019t do much by themselves because of this. This architecture was\nchosen deliberately, to make scripts simple, avoid code redundancy, and implement a\ncommon look-and-feel in shared code. But it means you must jump between files to\nunderstand how the whole system works.\nTo make this example easier to digest, we\u2019re going to explore its code in two chunks:\npage scripts first, and then the utility modules. First, we\u2019ll study screenshots of the\nmajor web pages served up by the system and the HTML files and top-level Python\nCGI scripts used to generate them. We begin by following a send mail interaction, and\nthen trace how existing email is read and then processed. Most implementation details\nwill be presented in these sections, but be sure to flip ahead to the utility modules listed\nlater to understand what the scripts are really doing.\nI should also point out that this is a fairly complex system, and I won\u2019t describe it in\nexhaustive detail; as for PyMailGUI and Chapter 14, be sure to read the source code\nalong the way for details not made explicit in the narrative. All of the system\u2019s source\ncode appears in this chapter, as well as in the book\u2019s examples distribution package,\nand we will study its key concepts here. But as usual with case studies in this book, I\nassume that you can read Python code by now and that you will consult the example\u2019s\nsource code for more details. Because Python\u2019s syntax is so close to \u201cexecutable\n1236 | Chapter 16:\u2002The PyMailCGI Serverpseudocode,\u201d systems are sometimes better described in Python than in English once\nyou have the overall design in mind.\nRunning This Chapter\u2019s Examples\nThe HTML pages and CGI scripts of PyMailCGI can be installed on any web server to\nwhich you have access. To keep things simple for this book, though, we\u2019re going to use\nthe same policy as in Chapter 15\u2014we\u2019ll be running the Python-coded webserver.py\nscript from Example 16-1 locally, on the same machine as the web browser client. As\nwe learned at the start of the prior chapter, that means we\u2019ll be using the server domain\nname \u201clocalhost\u201d (or the equivalent IP address, \u201c127.0.0.1\u201d) to access this system\u2019s\npages in our browser, as well as in the urllib.request module.\nStart this server script on your own machine to test-drive the program. Ultimately, this\nsystem must generally contact a mail server over the Internet to fetch or send messages,\nbut the web page server will be running locally on your computer.\nOne minor twist here: PyMailCGI\u2019s code is located in a directory of its own, one level\ndown from the webserver.py script. Because of that, we\u2019ll start the web server here with\nan explicit directory and port number in the command line used to launch it:\nC:\\...\\PP4E\\Internet\\Web> webserver.py PyMailCgi 8000\nType this sort of command into a command prompt window on Windows or into your\nsystem shell prompt on Unix-like platforms. When run this way, the server will listen\nfor URL requests on machine \u201clocalhost\u201d and socket port number 8000. It will serve\nup pages from the PyMailCgi subdirectory one level below the script\u2019s location, and it\nwill run CGI scripts located in the PyMailCgi\\cgi-bin directory below that. This works\nbecause the script changes its current working directory to the one you name when it\nstarts up.\nSubtle point: because we specify a unique port number on the command line this way,\nit\u2019s OK if you simultaneously run another instance of the script to serve up the prior\nchapter\u2019s examples one directory up; that server instance will accept connections on\nport 80, and our new instance will handle requests on port 8000. In fact, you can contact\neither server from the same browser by specifying the desired server\u2019s port number. If\nyou have two instances of the server running in the two different chapters\u2019 directories,\nto access pages and scripts of the prior chapter, use a URL of this form:\nhttp://localhost/languages.html\nhttp://localhost/cgi-bin/languages.py?language=All\nAnd to run this chapter\u2019s pages and scripts, simply use URLs of this form:\nhttp://localhost:8000/pymailcgi.html\nhttp://localhost:8000/cgi-bin/onRootSendLink.py\nYou\u2019ll see that the HTTP and CGI log messages appear in the window of the server\nyou\u2019re contacting. For more background on why this works as it does, see the\nThe PyMailCGI Website | 1237introduction to network socket addresses in Chapter 12 and the discussion of URLs in\nChapter 15.\nIf you do install this example\u2019s code on a different server, simply replace the \u201clocalhost:\n8000/cgi-bin\u201d part of the URLs we\u2019ll use here with your server\u2019s name, port, and path\ndetails. In practice, a system such as PyMailCGI would be much more useful if it were\ninstalled on a remote server, to allow mail processing from any web client.*\nAs with PyMailGUI, you\u2019ll have to edit the mailconfig.py module\u2019s settings to use this\nsystem to read your own email. As provided, the email server information is not useful\nfor reading email of your own; more on this in a moment.\nCarry-On Software\nPyMailCGI works as planned and illustrates more CGI and email concepts, but I want\nto point out a few caveats up front. This application was initially written during a two-\nhour layover in Chicago\u2019s O\u2019Hare airport (though debugging took a few hours more).\nI wrote it to meet a specific need\u2014to be able to read and send email from any web\nbrowser while traveling around the world teaching Python classes. I didn\u2019t design it to\nbe aesthetically pleasing to others and didn\u2019t spend much time focusing on its efficiency.\nI also kept this example intentionally simple for this book. For example, PyMailCGI\ndoesn\u2019t provide nearly as many features as the PyMailGUI program in Chapter 14, and\nit reloads email more than it probably should. Because of this, its performance can be\nvery poor if you keep your inbox large.\nIn fact, this system almost cries out for more advanced state retention options. As is,\nuser and message details are passed in generated pages as hidden fields and query pa-\nrameters, but we could avoid reloading mail by also using server-side deployment of\nthe database techniques described in Chapter 17. Such extensions might eventually\nbring PyMailCGI up to the functionality of PyMailGUI, albeit at some cost in code\ncomplexity. Even so, this system also suffers from the Python 3.1 attachments limitation\ndescribed earlier, which would need to be addressed as well.\nAgain, you should consider this system a prototype and a work in progress; it\u2019s not yet\nsoftware worth selling, and not something that you\u2019ll generally want to use as is for\nmail that\u2019s critical to you. On the other hand, it does what it was intended to do, and\nyou can customize it by tweaking its Python source code\u2014something that can\u2019t be said\nof all software sold.\n* One downside to running a local webserver.py script that I noticed during development for this chapter is\nthat on platforms where CGI scripts are run in the same process as the server, you\u2019ll need to stop and restart\nthe server every time you change an imported module. Otherwise, a subsequent import in a CGI script will\nhave no effect: the module has already been imported in the process. This is not an issue on Windows today\nor on other platforms that run the CGI as a separate, new process. The server\u2019s classes\u2019 implementation varies\nover time, but if changes to your CGI scripts have no effect, your platform my fall into this category: try\nstopping and restarting the locally running web server.\n1238 | Chapter 16:\u2002The PyMailCGI ServerThe Root Page\nLet\u2019s start off by implementing a main page for this example. The file shown in Exam-\nple 16-2 is primarily used to publish links to the Send and View functions\u2019 pages. It is\ncoded as a static HTML file, because there is nothing to generate on the fly here.\nExample 16-2. PP4E\\Internet\\Web\\PyMailCgi\\pymailcgi.html\n<HTML>\n<TITLE>PyMailCGI Main Page</TITLE>\n<BODY>\n<H1 align=center>PyMailCGI</H1>\n<H2 align=center>A POP/SMTP Web Email Interface</H2>\n<P align=center><I>Version 3.0 June 2010 (2.0 January 2006)</I></P>\n<table>\n<tr><td><hr>\n<h2>Actions</h2>\n<P>\n<UL>\n<LI><a href=\"cgi-bin/onRootViewLink.py\">View, Reply, Forward, Delete POP mail</a>\n<LI><a href=\"cgi-bin/onRootSendLink.py\">Send a new email message by SMTP</a>\n</UL></P>\n<tr><td><hr>\n<h2>Overview</h2>\n<P>\n<A href=\"http://rmi.net/~lutz/about-pp.html\">\n<IMG src=\"ppsmall.gif\" align=left\nalt=\"[Book Cover]\" border=1 hspace=10></A>\nThis site implements a simple web-browser interface to POP/SMTP email\naccounts.  Anyone can send email with this interface, but for security\nreasons, you cannot view email unless you install the scripts with your\nown email account information, in your own server account directory.\nPyMailCgi is implemented as a number of Python-coded CGI scripts that run on\na server machine (not your local computer), and generate HTML to interact\nwith the client/browser.  See the book <I>Programming Python, 4th Edition</I>\nfor more details.</P>\n<tr><td><hr>\n<h2>Notes</h2>\n<P>Caveats: PyMailCgi 1.0 was initially written during a 2-hour layover at\nChicago's O'Hare airport.  This release is not nearly as fast or complete\nas PyMailGUI (e.g., each click requires an Internet transaction, there\nis no save operation or multithreading, and there is no caching of email\nheaders or already-viewed messages).  On the other hand, PyMailCgi runs on\nany web browser, whether you have Python (and Tk) installed on your machine\nor not.\n<P>Also note that if you use these scripts to read your own email, PyMailCgi\ndoes not guarantee security for your account password. See the notes in the\nView action page as well as the book for more information on security policies.\nThe Root Page | 1239<p><I><U>New in Version 2</U></I>: PyMailCGI now supports viewing and sending\nEmail attachments for a single user, and avoids some of the prior version's\nexhaustive mail downloads. It only fetches message headers for the list page,\nand only downloads the full text of the single message selected for viewing.\n<p><I><U>New in Version 3</U></I>: PyMailCGI now runs on Python 3.X (only),\nand employs many of the new features of the mailtools package: decoding and\nencoding of Internationalized headers, decoding of main mail text, and so on.\nDue to a regression in Python 3.1's cgi and email support, version 3.0 does\nnot support sending of binary or incompatibly-encoded text attachments, though\nattachments on fetched mails can always be viewed (see Chapter 15 and 16).\n<p>Also see:\n<UL>\n<li>The <I>PyMailGUI</I> program in the Internet directory, which\n        implements a more complete client-side Python+Tk email GUI\n<li>The <I>pymail.py</I> program in the Email directory, which\n        provides a simple console command-line email interface\n<li>The Python imaplib module which supports the IMAP email protocol\n        instead of POP\n</UL></P>\n</table><hr>\n<A href=\"http://www.python.org\">\n<IMG SRC=\"PythonPoweredSmall.gif\" ALIGN=left\nALT=\"[Python Logo]\" border=0 hspace=15></A>\n<A href=\"http://rmi.net/~lutz/about-pp.html\">[Book]</a>\n<A href=\"http://www.oreilly.com\">[O'Reilly]</a>\n</BODY></HTML>\nThe file pymailcgi.html is the system\u2019s root page and lives in a PyMailCgi subdirectory\nwhich is dedicated to this application and helps keep its files separate from other ex-\namples. To access this system, start your locally running web server as described in the\npreceding section and then point your browser to the following URL (or do the right\nthing for whatever other web server you may be using):\nhttp://localhost:8000/pymailcgi.html\nIf you do, the server will ship back a page such as that captured in Figure 16-2, shown\nrendered in the Google Chrome web browser client on Windows 7. I\u2019m using Chrome\ninstead of Internet Explorer throughout this chapter for variety, and because it tends\nto yield a concise page which shows more details legibly. Open this in your own browser\nto see it live\u2014this system is as portable as the Web, HTML, and Python-coded CGI\nscripts.\nConfiguring PyMailCGI\nNow, before you click on the \u201cView\u2026\u201d link in Figure 16-2 expecting to read your own\nemail, I should point out that by default, PyMailCGI allows anybody to send email\nfrom this page with the Send link (as we learned earlier, there are no passwords in\nSMTP). It does not, however, allow arbitrary users on the Web to read their email\n1240 | Chapter 16:\u2002The PyMailCGI Serveraccounts without either typing an explicit and unsafe URL or doing a bit of installation\nand configuration.\nThis is on purpose, and it has to do with security constraints; as we\u2019ll see later,\nPyMailCGI is written such that it never associates your email username and password\ntogether without encryption. This isn\u2019t an issue if your web server is running locally,\nof course, but this policy is in place in case you ever run this system remotely across\nthe Web.\nBy default, then, this page is set up to read the email account shown in this book\u2014\naddress PP4E@learning-python.com\u2014and requires that account\u2019s POP password to\ndo so. Since you probably can\u2019t guess the password (and wouldn\u2019t find its email all that\ninteresting if you could!), PyMailCGI is not incredibly useful as shipped. To use it to\nread your email instead, you\u2019ll want to change its mailconfig.py mail configuration file\nto reflect your mail account\u2019s details. We\u2019ll see this file later; for now, the examples\nhere will use the book\u2019s POP email account; it works the same way, regardless of which\naccount it accesses.\nSending Mail by SMTP\nPyMailCGI supports two main functions, as links on the root page: composing and\nsending new mail to others, and viewing incoming mail. The View function leads to\nFigure 16-2. PyMailCGI main page\nSending Mail by SMTP | 1241pages that let users read, reply to, forward, and delete existing email. Since the Send\nfunction is the simplest, let\u2019s start with its pages and scripts first.\nThe Message Composition Page\nThe root page Send function steps users through two other pages: one to edit a message\nand one to confirm delivery. When you click on the Send link on the main page in\nFigure 16-2, the Python CGI script in Example 16-3 runs on the web server.\nExample 16-3. PP4E\\Internet\\Web\\PyMailCgi\\cgi-bin\\onRootSendLink.py\n#!/usr/bin/python\n\"\"\"\n################################################################################\nOn 'send' click in main root window: display composition page\n################################################################################\n\"\"\"\nimport commonhtml\nfrom externs import mailconfig\ncommonhtml.editpage(kind='Write', headers={'From': mailconfig.myaddress})\nNo, this file wasn\u2019t truncated; there\u2019s not much to see in this script because all the\naction has been encapsulated in the commonhtml and externs modules. All that we can\ntell here is that the script calls something named editpage to generate a reply, passing\nin something called myaddress for its \u201cFrom\u201d header.\nThat\u2019s by design\u2014by hiding details in shared utility modules we make top-level scripts\nsuch as this much easier to read and write, avoid code redundancy, and achieve a\ncommon look-and-feel to all our pages. There are no inputs to this script either; when\nrun, it produces a page for composing a new message, as shown in Figure 16-3.\nMost of the composition page is self-explanatory\u2014fill in headers and the main text of\nthe message (a \u201cFrom\u201d header and standard signature line are initialized from settings\nin the mailconfig module, discussed further ahead). The Choose File buttons open file\nselector dialogs, for picking an attachment. This page\u2019s interface looks very different\nfrom the PyMailGUI client program in Chapter 14, but it is functionally very similar.\nAlso notice the top and bottom of this page\u2014for reasons explained in the next section,\nthey are going to look the same in all the pages of our system.\nThe Send Mail Script\nAs usual, the HTML of the edit page in Figure 16-3 names its handler script. When we\nclick its Send button, Example 16-4 runs on the server to process our inputs and send\nthe mail message.\n1242 | Chapter 16:\u2002The PyMailCGI ServerExample 16-4. PP4E\\Internet\\Web\\PyMailCgi\\cgi-bin\\onEditPageSend.py\n#!/usr/bin/python\n\"\"\"\n################################################################################\nOn submit in edit window: finish a write, reply, or forward;\nin 2.0+, we reuse the send tools in mailtools to construct and send the message,\ninstead of older manual string scheme;  we also inherit attachment structure\ncomposition and MIME encoding for sent mails from that module;\n3.0: CGI uploads fail in the py3.1 cgi module for binary and incompatibly-encoded\ntext, so we simply use the platform default here (cgi's parser does no better);\n3.0: use simple Unicode encoding rules for main text and attachments too;\n################################################################################\n\"\"\"\nimport cgi, sys, commonhtml, os\nfrom externs import mailtools\nsavedir = 'partsupload'\nif not os.path.exists(savedir):\nFigure 16-3. PyMailCGI send (write) page\nSending Mail by SMTP | 1243os.mkdir(savedir)\ndef saveAttachments(form, maxattach=3, savedir=savedir):\n    \"\"\"\n    save uploaded attachment files in local files on server from\n    which mailtools will add to mail;  the 3.1 FieldStorage parser\n    and other parts of cgi module can fail for many upload types,\n    so we don't try very hard to handle Unicode encodings here;\n    \"\"\"\n    partnames = []\n    for i in range(1, maxattach+1):\n        fieldname = 'attach%d' % i\n        if fieldname in form and form[fieldname].filename:\n            fileinfo = form[fieldname]                     # sent and filled?\n            filedata = fileinfo.value                      # read into string\n            filename = fileinfo.filename                   # client's pathname\n            if '\\\\' in filename:\n                basename = filename.split('\\\\')[-1]        # try DOS clients\n            elif '/' in filename:\n                basename = filename.split('/')[-1]         # try Unix clients\n            else:\n                basename = filename                        # assume dir stripped\n            pathname = os.path.join(savedir, basename)\n            if isinstance(filedata, str):                  # 3.0: rb needs bytes\n                filedata = filedata.encode()               # 3.0: use encoding?\n            savefile = open(pathname, 'wb')\n            savefile.write(filedata)                       # or a with statement\n            savefile.close()                               # but EIBTI still\n            os.chmod(pathname, 0o666)                      # need for some srvrs\n            partnames.append(pathname)                     # list of local paths\n    return partnames                                       # gets type from name\n#commonhtml.dumpstatepage(0)\nform = cgi.FieldStorage()                      # parse form input data\nattaches = saveAttachments(form)               # cgi.print_form(form) to see\n# server name from module or get-style URL\nsmtpservername = commonhtml.getstandardsmtpfields(form)\n# parms assumed to be in form or URL here\nfrom commonhtml import getfield                # fetch value attributes\nFrom = getfield(form, 'From')                  # empty fields may not be sent\nTo   = getfield(form, 'To')\nCc   = getfield(form, 'Cc')\nSubj = getfield(form, 'Subject')\ntext = getfield(form, 'text')\nif Cc == '?': Cc = ''\n# 3.0: headers encoded per utf8 within mailtools if non-ascii\nparser = mailtools.MailParser()\nTos = parser.splitAddresses(To)                # multiple recip lists: ',' sept\nCcs = (Cc and parser.splitAddresses(Cc)) or ''\nextraHdrs = [('Cc', Ccs), ('X-Mailer', 'PyMailCGI 3.0')]\n# 3.0: resolve main text and text attachment encodings; default=ascii in mailtools\n1244 | Chapter 16:\u2002The PyMailCGI Serverbodyencoding = 'ascii'\ntry:\n    text.encode(bodyencoding)          # try ascii first (or latin-1?)\nexcept (UnicodeError, LookupError):    # else use tuf8 as fallback (or config?)\n    bodyencoding = 'utf-8'             # tbd: this is more limited than PyMailGUI\n# 3.0: use utf8 for all attachments; we can't ask here\nattachencodings = ['utf-8'] * len(attaches)    # ignored for non-text parts\n# encode and send\nsender = mailtools.SilentMailSender(smtpservername)\ntry:\n    sender.sendMessage(From, Tos, Subj, extraHdrs, text, attaches,\n                                           bodytextEncoding=bodyencoding,\n                                           attachesEncodings=attachencodings)\nexcept:\n    commonhtml.errorpage('Send mail error')\nelse:\n    commonhtml.confirmationpage('Send mail')\nThis script gets mail header and text input information from the edit page\u2019s form (or\nfrom query parameters in an explicit URL) and sends the message off using Python\u2019s\nstandard smtplib module, courtesy of the mailtools package. We studied mailtools in\nChapter 13, so I won\u2019t say much more about it now. Note, though, that because we\nare reusing its send call, sent mail is automatically saved in a sentmail.txt file on the\nserver; there are no tools for viewing this in PyMailCGI itself, but it serves as a log.\nNew in version 2.0, the saveAttachments function grabs any part files sent from the\nbrowser and stores them in temporary local files on the server from which they will be\nadded to the mail when sent. We covered CGI upload in detail at the end of Chap-\nter 15; see that discussion for more on how the code here works (as well as its limitations\nin Python 3.1 and this edition\u2014we\u2019re attaching simple text here to accommodate). The\nbusiness of attaching the files to the mail itself is automatic in mailtools.\nA utility in commonhtml ultimately fetches the name of the SMTP server to receive the\nmessage from either the mailconfig module or the script\u2019s inputs (in a form field or\nURL query parameter). If all goes well, we\u2019re presented with a generated confirmation\npage, as captured in Figure 16-4.\nOpen file sentmail.txt in PyMailCGI\u2019s source directory if you want to see what the\nresulting mail\u2019s raw text looks like when sent (or fetch the message in an email client\nwith a raw text view, such as PyMailGUI). In this version, each attachment part is MIME\nencoded per Base64 with UTF-8 Unicode encoding in the multipart message, but the\nmain text part is sent as simple ASCII if it works as such.\nAs we\u2019ll see, this send mail script is also used to deliver reply and forward messages for\nincoming POP mail. The user interface for those operations is slightly different for\ncomposing new email from scratch, but as in PyMailGUI, the submission handler logic\nhas been factored into the same, shared code\u2014replies and forwards are really just mail\nsend operations with quoted text and preset header fields.\nSending Mail by SMTP | 1245Notice that there are no usernames or passwords to be found here; as we saw in Chap-\nter 13, SMTP usually requires only a server that listens on the SMTP port, not a user\naccount or password. As we also saw in that chapter, SMTP send operations that fail\neither raise a Python exception (e.g., if the server host can\u2019t be reached) or return a\ndictionary of failed recipients; our mailtools package modules insulate us from these\ndetails by always raising an exception in either case.\nError Pages\nIf there is a problem during mail delivery, we get an error page such as the one shown\nin Figure 16-5. This page reflects a failed recipient and includes a stack trace generated\nby the standard library\u2019s traceback module. On errors Python detects, the Python error\nmessage and extra details would be displayed.\nIt\u2019s also worth pointing out that the commonhtml module encapsulates the generation of\nboth the confirmation and the error pages so that all such pages look the same in\nPyMailCGI no matter where and when they are produced. Logic that generates the mail\nedit page in commonhtml is reused by the reply and forward actions, too (but with dif-\nferent mail headers).\nCommon Look-and-Feel\nIn fact, commonhtml makes all pages look similar\u2014it also provides common page\nheader (top) and footer (bottom) generation functions, which are used everywhere in\nthe system. You may have already noticed that all the pages so far follow the same\npattern: they start with a title and horizontal rule, have something unique in the middle,\nand end with another rule, followed by a Python icon and link at the bottom. This\ncommon look-and-feel is the product of shared code in commonhtml; it generates every-\nthing but the middle section for every page in the system (except the root page, a static\nHTML file).\nFigure 16-4. PyMailCGI send confirmation page\n1246 | Chapter 16:\u2002The PyMailCGI ServerMost important, if we ever change the header and footer format functions in the\ncommonhtml module, all our page\u2019s headers and footers will automatically be updated.\nIf you are interested in seeing how this encapsulated logic works right now, flip ahead\nto Example 16-14. We\u2019ll explore its code after we study the rest of the mail site\u2019s pages.\nUsing the Send Mail Script Outside a Browser\nI initially wrote the send script to be used only within PyMailCGI using values typed\ninto the mail edit form. But as we\u2019ve seen, inputs can be sent in either form fields or\nURL query parameters. Because the send mail script checks for inputs in CGI inputs\nbefore importing from the mailconfig module, it\u2019s also possible to call this script outside\nthe edit page to send email\u2014for instance, explicitly typing a URL of this nature into\nyour browser\u2019s address field (but all on one line and with no intervening spaces):\nhttp://localhost:8000/cgi-bin/\n               onEditPageSend.py?site=smtp.rmi.net&\n                                 From=lutz@rmi.net&\n                                 To=lutz@rmi.net&\n                                 Subject=test+url&\n                                 text=Hello+Mark;this+is+Mark\nFigure 16-5. PyMailCGI send error page\nSending Mail by SMTP | 1247will indeed send an email message as specified by the input parameters at the end. That\nURL string is a lot to type into a browser\u2019s address field, of course, but it might be useful\nif generated automatically by another script. As we saw in Chapters 13 and 15, the\nmodule urllib.request can then be used to submit such a URL string to the server from\nwithin a Python program. Example 16-5 shows one way to automate this.\nExample 16-5. PP4E\\Internet\\Web\\PyMailCgi\\sendurl.py\n\"\"\"\n####################################################################\nSend email by building a URL like this from inputs:\nhttp://servername/pathname/\n          onEditPageSend.py?site=smtp.rmi.net&\n                            From=lutz@rmi.net&\n                            To=lutz@rmi.net&\n                            Subject=test+url&\n                            text=Hello+Mark;this+is+Mark\n####################################################################\n\"\"\"\nfrom urllib.request import urlopen\nfrom urllib.parse   import quote_plus\nurl = 'http://localhost:8000/cgi-bin/onEditPageSend.py'\nurl += '?site=%s'    % quote_plus(input('Site>'))\nurl += '&From=%s'    % quote_plus(input('From>'))\nurl += '&To=%s'      % quote_plus(input('To  >'))\nurl += '&Subject=%s' % quote_plus(input('Subj>'))\nurl += '&text=%s'    % quote_plus(input('text>'))    # or input loop\nprint('Reply html:')\nprint(urlopen(url).read().decode())   # confirmation or error page HTML\nRunning this script from the system command line is yet another way to send an email\nmessage\u2014this time, by contacting our CGI script on a web server machine to do all\nthe work. The script sendurl.py runs on any machine with Python and sockets, lets us\ninput mail parameters interactively, and invokes another Python script that lives on a\npossibly remote machine. It prints HTML returned by our CGI script:\nC:\\...\\PP4E\\Internet\\Web\\PyMailCgi> sendurl.py\nSite>smtpout.secureserver.net\nFrom>PP4E@learning-python.com\nTo  >lutz@learning-python.com\nSubj>testing sendurl.py\ntext>But sir, it's only wafer-thin...\nReply html:\n<html><head><title>PyMailCGI: Confirmation page (PP4E)</title></head>\n<body bgcolor=\"#FFFFFF\"><h1>PyMailCGI Confirmation</h1><hr>\n<h2>Send mail operation was successful</h2>\n<p>Press the link below to return to the main page.</p>\n</p><hr><a href=\"http://www.python.org\">\n<img src=\"../PythonPoweredSmall.gif\"\nalign=left alt=\"[Python Logo]\" border=0 hspace=15></a>\n1248 | Chapter 16:\u2002The PyMailCGI Server<a href=\"../pymailcgi.html\">Back to root page</a>\n</body></html>\nThe HTML reply printed by this script would normally be rendered into a new web\npage if caught by a browser. Such cryptic output might be less than ideal, but you could\neasily search the reply string for its components to determine the result (e.g., using the\nstring find method or an in membership test to look for \u201csuccessful\u201d), parse out its\ncomponents with Python\u2019s standard html.parse or re modules (covered in\nChapter 19), and so on. The resulting mail message\u2014viewed, for variety, with\nChapter 14\u2019s PyMailGUI program\u2014shows up in this book\u2019s email account as seen in\nFigure 16-6 (it\u2019s a single text-part message).\nFigure 16-6. sendurl.py result\nOf course, there are other, less remote ways to send email from a client machine. For\ninstance, the Python smtplib module (used by mailtools) itself depends only upon the\nclient and SMTP server connections being operational, whereas this script also depends\non the web server machine and CGI script (requests go from client to web server to\nCGI script to SMTP server). Because our CGI script supports general URLs, though, it\ncan do more than a mailto: HTML tag and can be invoked with urllib.request outside\nthe context of a running web browser. For instance, as discussed in Chapter 15, scripts\nlike sendurl.py can be used to invoke and test server-side programs.\nReading POP Email\nSo far, we\u2019ve stepped through the path the system follows to send new mail. Let\u2019s now\nsee what happens when we try to view incoming POP mail.\nReading POP Email | 1249The POP Password Page\nIf you flip back to the main page in Figure 16-2, you\u2019ll see a View link; pressing it triggers\nthe script in Example 16-6 to run on the server.\nExample 16-6. PP4E\\Internet\\Web\\PyMailCgi\\cgi-bin\\onRootViewLink.py\n#!/usr/bin/python\n\"\"\"\n################################################################################\nOn view link click on main/root HTML page: make POP password input page;\nthis could almost be an HTML file because there are likely no input params yet,\nbut I wanted to use standard header/footer functions and display the site/user\nnames which must be fetched;  on submission, does not send the user along with\npassword here, and only ever sends both as URL params or hidden fields after the\npassword has been encrypted by a user-uploadable encryption module;\n################################################################################\n\"\"\"\n# page template\npswdhtml = \"\"\"\n<form method=post action=%sonViewPswdSubmit.py>\n<p>\nPlease enter POP account password below, for user \"%s\" and site \"%s\".\n<p><input name=pswd type=password>\n<input type=submit value=\"Submit\"></form></p>\n<hr><p><i>Security note</i>: The password you enter above will be transmitted\nover the Internet to the server machine, but is not displayed, is never\ntransmitted in combination with a username unless it is encrypted or obfuscated,\nand is never stored anywhere: not on the server (it is only passed along as hidden\nfields in subsequent pages), and not on the client (no cookies are generated).\nThis is still not guaranteed to be totally safe; use your browser's back button\nto back out of PyMailCgi at any time.</p>\n\"\"\"\n# generate the password input page\nimport commonhtml                                         # usual parms case:\nuser, pswd, site = commonhtml.getstandardpopfields({})    # from module here,\ncommonhtml.pageheader(kind='POP password input')          # from html|url later\nprint(pswdhtml % (commonhtml.urlroot, user, site))\ncommonhtml.pagefooter()\nThis script is almost all embedded HTML: the triple-quoted pswdhtml string is printed,\nwith string formatting to insert values, in a single step. But because we need to fetch\nthe username and server name to display on the generated page, this is coded as an\nexecutable script, not as a static HTML file. The module commonhtml either loads user-\nnames and server names from script inputs (e.g., appended as query parameters to the\nscript\u2019s URL) or imports them from the mailconfig file; either way, we don\u2019t want to\nhardcode them into this script or its HTML, so a simple HTML file won\u2019t do. Again,\nin the CGI world, we embed HTML code in Python code and fill in its values this way\n1250 | Chapter 16:\u2002The PyMailCGI Server(in server-side templating tools such as PSP the effect is similar, but Python code is\nembedded in HTML code instead and run to produce values).\nSince this is a script, we can also use the commonhtml page header and footer routines to\nrender the generated reply page with a common look-and-feel, as shown in Figure 16-7.\nFigure 16-7. PyMailCGI view password login page\nAt this page, the user is expected to enter the password for the POP email account of\nthe user and server displayed. Notice that the actual password isn\u2019t displayed; the input\nfield\u2019s HTML specifies type=password, which works just like a normal text field, but\nshows typed input as stars. (See also the pymail program in Chapter 13 for doing this\nat a console and PyMailGUI in Chapter 14 for doing this in a tkinter GUI.)\nThe Mail Selection List Page\nAfter you fill out the last page\u2019s password field and press its Submit button, the pass-\nword is shipped off to the script shown in Example 16-7.\nExample 16-7. PP4E\\Internet\\Web\\PyMailCgi\\cgi-bin\\onViewPswdSubmit.py\n#!/usr/bin/python\n\"\"\"\n################################################################################\nOn submit in POP password input window: make mail list view page;\nin 2.0+ we only fetch mail headers here, and fetch 1 full message later upon\nrequest; we still fetch all headers each time the index page is made: caching\nMessages would require a server-side(?) database and session key, or other;\n3.0: decode headers for list display, though printer and browser must handle;\n################################################################################\nReading POP Email | 1251\"\"\"\nimport cgi\nimport loadmail, commonhtml\nfrom   externs import mailtools\nfrom   secret  import encode       # user-defined encoder module\nMaxHdr = 35                        # max length of email hdrs in list\n# only pswd comes from page here, rest usually in module\nformdata = cgi.FieldStorage()\nmailuser, mailpswd, mailsite = commonhtml.getstandardpopfields(formdata)\nparser = mailtools.MailParser()\ntry:\n    newmails = loadmail.loadmailhdrs(mailsite, mailuser, mailpswd)\n    mailnum  = 1\n    maillist = []                                           # or use enumerate()\n    for mail in newmails:                                   # list of hdr text\n        msginfo = []\n        hdrs = parser.parseHeaders(mail)                    # email.message.Message\n        addrhdrs = ('From', 'To', 'Cc', 'Bcc')              # decode names only\n        for key in ('Subject', 'From', 'Date'):\n            rawhdr = hdrs.get(key, '?')\n            if key not in addrhdrs:\n                dechdr = parser.decodeHeader(rawhdr)        # 3.0: decode for display\n            else:                                           # encoded on sends\n                dechdr = parser.decodeAddrHeader(rawhdr)    # email names only\n            msginfo.append(dechdr[:MaxHdr])\n        msginfo = ' | '.join(msginfo)\n        maillist.append((msginfo, commonhtml.urlroot + 'onViewListLink.py',\n                                      {'mnum': mailnum,\n                                       'user': mailuser,          # data params\n                                       'pswd': encode(mailpswd),  # pass in URL\n                                       'site': mailsite}))        # not inputs\n        mailnum += 1\n    commonhtml.listpage(maillist, 'mail selection list')\nexcept:\n    commonhtml.errorpage('Error loading mail index')\nThis script\u2019s main purpose is to generate a selection list page for the user\u2019s email ac-\ncount, using the password typed into the prior page (or passed in a URL). As usual with\nencapsulation, most of the details are hidden in other files:\nloadmail.loadmailhdrs\nReuses the mailtools module package from Chapter 13 to fetch email with the POP\nprotocol; we need a message count and mail headers here to display an index list.\nIn this version, the software fetches only mail header text to save time, not full mail\nmessages (provided your server supports the TOP command of the POP interface,\nand most do\u2014if not, see mailconfig to disable this).\n1252 | Chapter 16:\u2002The PyMailCGI Servercommonhtml.listpage\nGenerates HTML to display a passed-in list of tuples (text, URL, parameter-\ndictionary) as a list of hyperlinks in the reply page; parameter values show up as\nquery parameters at the end of URLs in the response.\nThe maillist list built here is used to create the body of the next page\u2014a clickable\nemail message selection list. Each generated hyperlink in the list page references a con-\nstructed URL that contains enough information for the next script to fetch and display\na particular email message. As we learned in the preceding chapter, this is a simple kind\nof state retention between pages and scripts.\nIf all goes well, the mail selection list page HTML generated by this script is rendered\nas in Figure 16-8. If your inbox is as large as some of mine, you\u2019ll probably need to\nscroll down to see the end of this page. This page follows the common look-and-feel\nfor all PyMailCGI pages, thanks to commonhtml.\nFigure 16-8. PyMailCGI view selection list page, top\nIf the script can\u2019t access your email account (e.g., because you typed the wrong pass-\nword), its try statement handler instead produces a commonly formatted error page.\nReading POP Email | 1253Figure 16-9 shows one that gives the Python exception and details as part of the reply\nafter a Python-raised exception is caught; as usual, the exception details are fetched\nfrom sys.exc_info, and Python\u2019s traceback module is used to generate a stack trace.\nPassing State Information in URL Link Parameters\nThe central mechanism at work in Example 16-7 is the generation of URLs that embed\nmessage numbers and mail account information. Clicking on any of the View links in\nthe selection list triggers another script, which uses information in the link\u2019s URL pa-\nrameters to fetch and display the selected email. As mentioned in Chapter 15, because\nthe list\u2019s links are programmed to \u201cknow\u201d how to load a particular message, they ef-\nfectively remember what to do next. Figure 16-10 shows part of the HTML generated\nby this script (use your web browser View Source option to see this for yourself\u2014I did\na Save As and then opened the result which invoked Internet Explorer\u2019s source viewer\non my laptop).\nDid you get all the details in Figure 16-10? You may not be able to read generated HTML\nlike this, but your browser can. For the sake of readers afflicted with human-parsing\nFigure 16-9. PyMailCGI login error page\n1254 | Chapter 16:\u2002The PyMailCGI Serverlimitations, here is what one of those link lines looks like, reformatted with line breaks\nand spaces to make it easier to understand:\n<tr><th><a href=\"onViewListLink.py?\n                    pswd=wtGmpsjeb7359&\n                    mnum=5&\n                    user=PP4E%40learning-python.com&\n                    site=pop.secureserver.net\">View</a>\n<td>Among our weapons are these | Cardinal@hotmail.com | Fri, 07 May 2010 20:32...\nPyMailCGI generates relative minimal URLs (server and pathname values come from\nthe prior page, unless set in commonhtml). Clicking on the word View in the hyperlink\nrendered from this HTML code triggers the onViewListLink script as usual, passing it\nall the parameters embedded at the end of the URL: the POP username, the POP mes-\nsage number of the message associated with this link, and the POP password and site\ninformation. These values will be available in the object returned by\ncgi.FieldStorage in the next script run. Note that the mnum POP message number pa-\nrameter differs in each link because each opens a different message when clicked and\nthat the text after <td> comes from message headers extracted by the mailtools package,\nusing the email package.\nThe commonhtml module escapes all of the link parameters with the urllib.parse mod-\nule, not cgi.escape, because they are part of a URL. This can matter in the pswd pass-\nword parameter\u2014its value might be encrypted and arbitrary bytes, but urllib.parse \nadditionally escapes nonsafe characters in the encrypted string per URL convention (it\ntranslates to %xx character sequences). It\u2019s OK if the encryptor yields odd\u2014even non-\nprintable\u2014characters because URL encoding makes them legible for transmission.\nWhen the password reaches the next script, cgi.FieldStorage undoes URL escape se-\nquences, leaving the encrypted password string without % escapes.\nIt\u2019s instructive to see how commonhtml builds up the stateful link parameters. Earlier, we\nlearned how to use the urllib.parse.quote_plus call to escape a string for inclusion in\nURLs:\nFigure 16-10. PyMailCGI view list, generated HTML\nReading POP Email | 1255>>> import urllib.parse\n>>> urllib.parse.quote_plus(\"There's bugger all down here on Earth\")\n'There%27s+bugger+all+down+here+on+Earth'\nThe module commonhtml, though, calls the higher-level urllib.parse.urlencode func-\ntion, which translates a dictionary of name:value pairs into a complete URL query pa-\nrameter string, ready to add after a ? marker in a URL. For instance, here is\nurlencode in action at the interactive prompt:\n>>> parmdict = {'user': 'Brian',\n...             'pswd': '#!/spam',\n...             'text': 'Say no more, squire!'}\n>>> urllib.parse.urlencode(parmdict)\n'text=Say+no+more%2C+squire%21&pswd=%23%21%2Fspam&user=Brian'\n>>> \"%s?%s\" % (\"http://scriptname.py\", urllib.parse.urlencode(parmdict))\n'http://scriptname.py?text=Say+no+more%2C+squire%21&pswd=%23%21%2Fspam&user=Brian'\nInternally, urlencode passes each name and value in the dictionary to the built-in str\nfunction (to make sure they are strings), and then runs each one through url\nlib.parse.quote_plus as they are added to the result. The CGI script builds up a list of\nsimilar dictionaries and passes it to commonhtml to be formatted into a selection list\npage.\u2020\nIn broader terms, generating URLs with parameters like this is one way to pass state\ninformation to the next script (along with cookies, hidden form input fields, and server\ndatabases, discussed in Chapter 15). Without such state information, users would have\nto reenter the username, password, and site name on every page they visit along the way.\nIncidentally, the list generated by this script is not radically different in functionality\nfrom what we built in the PyMailGUI program in Chapter 14, though the two differ\ncosmetically. Figure 16-11 shows this strictly client-side GUI\u2019s view on the same email\nlist displayed in Figure 16-8.\nIt\u2019s important to keep in mind that PyMailGUI uses the tkinter GUI library to build up\na user interface instead of sending HTML to a browser. It also runs entirely on the client\nand talks directly to email servers, downloading mail from the POP server to the client\nmachine over sockets on demand. Because it retains memory for the duration of the\nsession, PyMailGUI can easily minimize mail server access. After the initial header load,\nit needs to load only newly arrived email headers on subsequent load requests. More-\nover, it can update its email index in-memory on deletions instead of reloading anew\nfrom the server, and it has enough state to perform safe deletions of messages that check\nfor server inbox matches. PyMailGUI also remembers emails you\u2019ve already viewed\u2014\nthey need not be reloaded again while the program runs.\n\u2020 Technically, again, you should generally escape & separators in generated URL links by running the URL\nthrough cgi.escape, if any parameter\u2019s name could be the same as that of an HTML character escape code\n(e.g., &amp=high). See Chapter 15 for more details; they aren\u2019t escaped here because there are no clashes\nbetween URL and HTML.\n1256 | Chapter 16:\u2002The PyMailCGI ServerIn contrast, PyMailCGI runs on the web server machine and simply displays mail text\non the client\u2019s browser\u2014mail is downloaded from the POP server machine to the web\nserver, where CGI scripts are run. Due to the autonomous nature of CGI scripts,\nPyMailCGI by itself has no automatic memory that spans pages and may need to reload\nheaders and already viewed messages during a single session. These architecture dif-\nferences have some important ramifications, which we\u2019ll discuss later in this chapter.\nSecurity Protocols\nIn onViewPswdSubmit\u2019s source code (Example 16-7), notice that password inputs are\npassed to an encode function as they are added to the parameters dictionary; this causes\nthem to show up encrypted or otherwise obfuscated in hyperlinked URLs. They are\nalso URL encoded for transmission (with % escapes if needed) and are later decoded\nand decrypted within other scripts as needed to access the POP account. The password\nencryption step, encode, is at the heart of PyMailCGI\u2019s security policy.\nIn Python today, the standard library\u2019s ssl module supports Secure Sockets Layer\n(SSL) with its socket wrapper call, if the required library is built into your Python. SSL\nautomatically encrypts transmitted data to make it safe to pass over the Net. Unfortu-\nnately, for reasons we\u2019ll discuss when we reach the secret.py module later in this\nchapter (see Example 16-13), this wasn\u2019t a universal solution for PyMailCGI\u2019s password\ndata. In short, the Python-coded web server we\u2019re using doesn\u2019t directly support its end\nof a secure HTTP encrypted dialog, HTTPS. Because of that, an alternative scheme was\nFigure 16-11. PyMailGUI displaying the same view list\nReading POP Email | 1257devised to minimize the chance that email account information could be stolen off the \nNet in transit.\nHere\u2019s how it works. When this script is invoked by the password input page\u2019s form, \nit gets only one input parameter: the password typed into the form. The username is \nimported from a mailconfig module installed on the server; it is not transmitted to-\ngether with the unencrypted password because such a combination could be harmful \nif intercepted.\nTo pass the POP username and password to the next page as state information, this \nscript adds them to the end of the mail selection list URLs, but only after the password \nhas been encrypted or obfuscated by secret.encode\u2014a function in a module that lives \non the server and may vary in every location that PyMailCGI is installed. In fact, \nPyMailCGI was written to not have to know about the password encryptor at all; be-\ncause the encoder is a separate module, you can provide any flavor you like. Unless you \nalso publish your encoder module, the encoded password shipped with the username \nwon\u2019t mean much if seen.\nThe upshot is that normally PyMailCGI never sends or receives both username and \npassword values together in a single transaction, unless the password is encrypted or \nobfuscated with an encryptor of your choice. This limits its utility somewhat (since \nonly a single account username can be installed on the server), but the alternative of \npopping up two pages\u2014one for password entry and one for username\u2014seems even \nless friendly. In general, if you want to read your mail with the system as coded, you \nhave to install its files on your server, edit its mailconfig.py to reflect your account \ndetails, and change its secret.py encoder and decoder as desired.\nReading mail with direct URLs\nOne exception: since any CGI script can be invoked with parameters in an explicit URL \ninstead of form field values, and since commonhtml tries to fetch inputs from the form \nobject before importing them from mailconfig, it is possible for any person to use this \nscript if installed at an accessible address to check his or her mail without installing and \nconfiguring a copy of PyMailCGI of their own. For example, a URL such as the fol-\nlowing typed into your browser\u2019s address field or submitted with tools such as url\nlib.request (but without the line break used to make it fit here):\nhttp://localhost:8000/cgi-bin/\n  onViewPswdSubmit.py?user=lutz&pswd=guess&site=pop.earthlink.net\nwill actually load email into a selection list page such as that in Figure 16-8, using \nwhatever user, password, and mail site names are appended to the URL. From the \nselection list, you may then view, reply, forward, and delete email.\nNotice that at this point in the interaction, the password you send in a URL of this form \nis not encrypted. Later scripts expect that the password inputs will be sent encrypted, \nthough, which makes it more difficult to use them with explicit URLs (you would need \nto match the encrypted or obfuscated form produced by the secret module on the\n1258 | Chapter 16:\u2002The PyMailCGI Serverserver). Passwords are encoded as they are added to links in the reply page\u2019s selection\nlist, and they remain encoded in URLs and hidden form fields thereafter.\nBut you shouldn\u2019t use a URL like this, unless you don\u2019t care about ex-\nposing your email password. Sending your unencrypted mail user ID\nand password strings across the Net in a URL such as this is unsafe and\nopen to interception. In fact, it\u2019s like giving away your email\u2014anyone\nwho intercepts this URL or views it in a server logfile will have complete\naccess to your email account. It is made even more treacherous by the\nfact that this URL format appears in a book that will be distributed all\naround the world.\nIf you care about security and want to use PyMailCGI on a remote server,\ninstall it on your server and configure mailconfig and secret. That\nshould at least guarantee that both your user and password information\nwill never be transmitted unencrypted in a single transaction. This\nscheme still may not be foolproof, so be careful out there. Without se-\ncure HTTP and sockets, the Internet is a \u201cuse at your own risk\u201d medium.\nThe Message View Page\nBack to our page flow; at this point, we are still viewing the message selection list in\nFigure 16-8. When we click on one of its generated hyperlinks, the stateful URL invokes\nthe script in Example 16-8 on the server, sending the selected message number and\nmail account information (user, password, and site) as parameters on the end of the\nscript\u2019s URL.\nExample 16-8. PP4E\\Internet\\Web\\PyMailCgi\\cgi-bin\\onViewListLink.py\n#!/usr/bin/python\n\"\"\"\n################################################################################\nOn user click of message link in main selection list: make mail view page;\ncgi.FieldStorage undoes any urllib.parse escapes in link's input parameters\n(%xx and '+' for spaces already undone);  in 2.0+ we only fetch 1 mail here, not\nthe entire list again;  in 2.0+ we also find mail's main text part intelligently\ninstead of blindly displaying full text (with any attachments), and we generate\nlinks to attachment files saved on the server;  saved attachment files only work\nfor 1 user and 1 message;  most 2.0 enhancements inherited from mailtools pkg;\n3.0: mailtools decodes the message's full-text bytes prior to email parsing;\n3.0: for display, mailtools decodes main text, commonhtml decodes message hdrs;\n################################################################################\n\"\"\"\nimport cgi\nimport commonhtml, secret\nfrom externs import mailtools\n#commonhtml.dumpstatepage(0)\nReading POP Email | 1259def saveAttachments(message, parser, savedir='partsdownload'):\n    \"\"\"\n    save fetched email's parts to files on\n    server to be viewed in user's web browser\n    \"\"\"\n    import os\n    if not os.path.exists(savedir):            # in CGI script's cwd on server\n        os.mkdir(savedir)                      # will open per your browser\n    for filename in os.listdir(savedir):       # clean up last message: temp!\n        dirpath = os.path.join(savedir, filename)\n        os.remove(dirpath)\n    typesAndNames = parser.saveParts(savedir, message)\n    filenames = [fname for (ctype, fname) in typesAndNames]\n    for filename in filenames:\n        os.chmod(filename, 0o666)              # some srvrs may need read/write\n    return filenames\nform = cgi.FieldStorage()\nuser, pswd, site = commonhtml.getstandardpopfields(form)\npswd = secret.decode(pswd)\ntry:\n    msgnum   = form['mnum'].value                               # from URL link\n    parser   = mailtools.MailParser()\n    fetcher  = mailtools.SilentMailFetcher(site, user, pswd)\n    fulltext = fetcher.downloadMessage(int(msgnum))             # don't eval!\n    message  = parser.parseMessage(fulltext)                    # email pkg Message\n    parts    = saveAttachments(message, parser)                 # for URL links\n    mtype, content = parser.findMainText(message)               # first txt part\n    commonhtml.viewpage(msgnum, message, content, form, parts)  # encoded pswd\nexcept:\n    commonhtml.errorpage('Error loading message')\nAgain, much of the work here happens in the commonhtml module, listed later in this\nsection (see Example 16-14). This script adds logic to decode the input password (using\nthe configurable secret encryption module) and extract the selected mail\u2019s headers and\ntext using the mailtools module package from Chapter 13 again. The full text of the\nselected message is ultimately fetched, parsed, and decoded by mailtools, using the\nstandard library\u2019s poplib module and email package. Although we\u2019ll have to refetch\nthis message if viewed again, version 2.0 and later do not grab all mails to get just the\none selected.\u2021\nAlso new in version 2.0, the saveAttachments function in this script splits off the parts\nof a fetched message and stores them in a directory on the web server machine. This\nwas discussed earlier in this chapter\u2014the view page is then augmented with URL links\nthat point at the saved part files. Your web browser will open them according to their\nfilenames and content. All the work of part extraction, decoding, and naming is\n\u2021 Notice that the message number arrives as a string and must be converted to an integer in order to be used\nto fetch the message. But we\u2019re careful not to convert with eval here, since this is a string passed over the Net\nand could have arrived embedded at the end of an arbitrary URL (remember that earlier warning?).\n1260 | Chapter 16:\u2002The PyMailCGI Serverinherited from mailtools. Part files are kept temporarily; they are deleted when the next\nmessage is fetched. They are also currently stored in a single directory and so apply to\nonly a single user.\nIf the message can be loaded and parsed successfully, the result page, shown in Fig-\nure 16-12, allows us to view, but not edit, the mail\u2019s text. The function commonhtml.view\npage generates a \u201cread-only\u201d HTML option for all the text widgets in this page. If you\nlook closely, you\u2019ll notice that this is the mail we sent to ourselves in Figure 16-3 and\nwhich showed up at the end of the list in Figure 16-8.\nFigure 16-12. PyMailCGI view page\nView pages like this have a pull-down action selection list near the bottom; if you want\nto do more, use this list to pick an action (Reply, Forward, or Delete) and click on the\nNext button to proceed to the next screen. If you\u2019re just in a browsing frame of mind,\nclick the \u201cBack to root page\u201d link at the bottom to return to the main page, or use your\nbrowser\u2019s Back button to return to the selection list page.\nAs mentioned, Figure 16-12 displays the mail we sent earlier in this chapter, being\nviewed after being fetched. Notice its \u201cParts:\u201d links\u2014when clicked, they trigger URLs\nthat open the temporary part files on the server, according to your browser\u2019s rules for\nReading POP Email | 1261the file type. For instance, clicking on the \u201c.txt\u201d file will likely open it in either the\nbrowser or a text editor. In other mails, clicking on \u201c.jpg\u201d files may open an image\nviewer, \u201c.pdf\u201d may open Adobe Reader, and so on. Figure 16-13 shows the result of\nclicking the \u201c.py\u201d attachment part of Figure 16-12\u2019s message in Chrome.\nPassing State Information in HTML Hidden Input Fields\nWhat you don\u2019t see on the view page in Figure 16-12 is just as important as what you\ndo see. We need to defer to Example 16-14 for coding details, but something new is\ngoing on here. The original message number, as well as the POP user and (still encoded)\npassword information sent to this script as part of the stateful link\u2019s URL, wind up\nbeing copied into the HTML used to create this view page, as the values of hidden input\nfields in the form. The hidden field generation code in commonhtml looks like this:\n    print('<form method=post action=\"%s/onViewPageAction.py\">' % urlroot)\n    print('<input type=hidden name=mnum value=\"%s\">' % msgnum)\n    print('<input type=hidden name=user value=\"%s\">' % user)    # from page|url\n    print('<input type=hidden name=site value=\"%s\">' % site)    # for deletes\n    print('<input type=hidden name=pswd value=\"%s\">' % pswd)    # pswd encoded\nAs we\u2019ve learned, much like parameters in generated hyperlink URLs, hidden fields in\na page\u2019s HTML allow us to embed state information inside this web page itself. Unless\nyou view that page\u2019s source, you can\u2019t see this state information because hidden fields\nare never displayed. But when this form\u2019s Submit button is clicked, hidden field values\nare automatically transmitted to the next script along with the visible fields on the form.\nFigure 16-13. Attached part file link display\n1262 | Chapter 16:\u2002The PyMailCGI ServerFigure 16-14 shows part of the source code generated for another message\u2019s view page;\nthe hidden input fields used to pass selected mail state information are embedded near\nthe top.\nThe net effect is that hidden input fields in HTML, just like parameters at the end of\ngenerated URLs, act like temporary storage areas and retain state between pages and\nuser interaction steps. Both are the Web\u2019s simplest equivalent to programming\nlanguage variables. They come in handy anytime your application needs to remember\nsomething between pages.\nHidden fields are especially useful if you cannot invoke the next script from a generated\nURL hyperlink with parameters. For instance, the next action in our script is a form\nsubmit button (Next), not a hyperlink, so hidden fields are used to pass state. As before,\nwithout these hidden fields, users would need to reenter POP account details some-\nwhere on the view page if they were needed by the next script (in our example, they are\nrequired if the next action is Delete).\nFigure 16-14. PyMailCGI view page, generated HTML\nReading POP Email | 1263Escaping Mail Text and Passwords in HTML\nNotice that everything you see on the message view page\u2019s HTML in Figure 16-14 is\nescaped with cgi.escape. Header fields and the text of the mail itself might contain\ncharacters that are special to HTML and must be translated as usual. For instance,\nbecause some mailers allow you to send messages in HTML format, it\u2019s possible that\nan email\u2019s text could contain a </textarea> tag, which might throw the reply page\nhopelessly out of sync if not escaped.\nOne subtlety here: HTML escapes are important only when text is sent to the browser\ninitially by the CGI script. If that text is later sent out again to another script (e.g., by\nsending a reply mail), the text will be back in its original, nonescaped format when\nreceived again on the server. The browser parses out escape codes and does not put\nthem back again when uploading form data, so we don\u2019t need to undo escapes later.\nFor example, here is part of the escaped text area sent to a browser during a Reply\ntransaction (use your browser\u2019s View Source option to see this live):\n<tr><th align=right>Text:\n<td><textarea name=text cols=80 rows=10 readonly>\nmore stuff\n--Mark Lutz  (http://rmi.net/~lutz)  [PyMailCgi 2.0]\n&gt; -----Original Message-----\n&gt; From: lutz@rmi.net\n&gt; To: lutz@rmi.net\n&gt; Date: Tue May  2 18:28:41 2000\n&gt;\n&gt; &lt;table&gt;&lt;textarea&gt;\n&gt; &lt;/textarea&gt;&lt;/table&gt;\n&gt; --Mark Lutz  (http://rmi.net/~lutz)  [PyMailCgi 2.0]\n&gt;\n&gt;\n&gt; &gt; -----Original Message-----\nAfter this reply is delivered, its text looks as it did before escapes (and exactly as it\nappeared to the user in the message edit web page):\nmore stuff\n--Mark Lutz  (http://rmi.net/~lutz)  [PyMailCgi 2.0]\n> -----Original Message-----\n> From: lutz@rmi.net\n> To: lutz@rmi.net\n> Date: Tue May  2 18:28:41 2000\n>\n> <table><textarea>\n> </textarea></table>\n> --Mark Lutz  (http://rmi.net/~lutz)  [PyMailCgi 2.0]\n>\n1264 | Chapter 16:\u2002The PyMailCGI Server>\n> > -----Original Message-----\nBeyond the normal text, the password gets special HTML escapes treatment as well.\nThough not shown in our examples, the hidden password field of the generated HTML\nscreenshot (Figure 16-14) can look downright bizarre when encryption is applied. It\nturns out that the POP password is still encrypted when placed in hidden fields of the\nHTML. For security, they have to be. Values of a page\u2019s hidden fields can be seen with\na browser\u2019s View Source option, and it\u2019s not impossible that the text of this page could\nbe saved to a file or intercepted off the Net.\nThe password is no longer URL encoded when put in the hidden field, however, even\nthough it was when it appeared as a query parameter at the end of a stateful URL in\nthe mail list page. Depending on your encryption module, the password might now\ncontain nonprintable characters when generated as a hidden field value here; the\nbrowser doesn\u2019t care, as long as the field is run through cgi.escape like everything else\nadded to the HTML reply stream. The commonhtml module is careful to route all text\nand headers through cgi.escape as the view page is constructed.\nAs a comparison, Figure 16-15 shows what the mail message captured in Fig-\nure 16-12 looks like when viewed in PyMailGUI, the client-side \u201cdesktop\u201d tkinter-based\nemail tool from Chapter 14. In that program, message parts are listed with the Parts\nbutton and are extracted, saved, and opened with the Split button; we also get quick-\naccess buttons to parts and attachments just below the message headers. The net effect\nis similar from an end user\u2019s perspective.\nFigure 16-15. PyMailGUI viewer, same message as Figure 16-12\nReading POP Email | 1265In terms of implementation, though, the model is very different. PyMailGUI doesn\u2019t\nneed to care about things such as passing state in URLs or hidden fields (it saves state\nin Python in-process variables and memory), and there\u2019s no notion of escaping HTML\nand URL strings (there are no browsers, and no network transmission steps once mail\nis downloaded). It also doesn\u2019t have to rely on temporary server file links to give access\nto message parts\u2014the message is retained in memory attached to a window object and\nlives on between interactions. On the other hand, PyMailGUI does require Python to\nbe installed on the client, but we\u2019ll return to that in a few pages.\nProcessing Fetched Mail\nAt this point in our PyMailCGI web interaction, we are viewing an email message\n(Figure 16-12) that was chosen from the selection list page. On the message view page,\nselecting an action from the pull-down list and clicking the Next button invokes the\nscript in Example 16-9 on the server to perform a reply, forward, or delete operation\nfor the selected message viewed.\nExample 16-9. PP4E\\Internet\\Web\\PyMailCgi\\cgi-bin\\onViewPageAction.py\n#!/usr/bin/python\n\"\"\"\n################################################################################\nOn submit in mail view window: action selected=(fwd, reply, delete);\nin 2.0+, we reuse the mailtools delete logic originally coded for PyMailGUI;\n################################################################################\n\"\"\"\nimport cgi, commonhtml, secret\nfrom externs import mailtools, mailconfig\nfrom commonhtml import getfield\ndef quotetext(form):\n    \"\"\"\n    note that headers come from the prior page's form here,\n    not from parsing the mail message again; that means that\n    commonhtml.viewpage must pass along date as a hidden field\n    \"\"\"\n    parser = mailtools.MailParser()\n    addrhdrs = ('From', 'To', 'Cc', 'Bcc')              # decode name only\n    quoted = '\\n-----Original Message-----\\n'\n    for hdr in ('From', 'To', 'Date'):\n        rawhdr = getfield(form, hdr)\n        if hdr not in addrhdrs:\n            dechdr = parser.decodeHeader(rawhdr)        # 3.0: decode for display\n        else:                                           # encoded on sends\n            dechdr = parser.decodeAddrHeader(rawhdr)    # email names only\n        quoted += '%s: %s\\n' % (hdr, dechdr)\n    quoted += '\\n' + getfield(form, 'text')\n    quoted =  '\\n' + quoted.replace('\\n', '\\n> ')\n    return quoted\n1266 | Chapter 16:\u2002The PyMailCGI Serverform = cgi.FieldStorage()  # parse form or URL data\nuser, pswd, site = commonhtml.getstandardpopfields(form)\npswd = secret.decode(pswd)\ntry:\n    if form['action'].value   == 'Reply':\n        headers = {'From':    mailconfig.myaddress,    # 3.0: commonhtml decodes\n                   'To':      getfield(form, 'From'),\n                   'Cc':      mailconfig.myaddress,\n                   'Subject': 'Re: ' + getfield(form, 'Subject')}\n        commonhtml.editpage('Reply', headers, quotetext(form))\n    elif form['action'].value == 'Forward':\n        headers = {'From':    mailconfig.myaddress,    # 3.0: commonhtml decodes\n                   'To':      '',\n                   'Cc':      mailconfig.myaddress,\n                   'Subject': 'Fwd: ' + getfield(form, 'Subject')}\n        commonhtml.editpage('Forward', headers, quotetext(form))\n    elif form['action'].value == 'Delete':     # mnum field is required here\n        msgnum  = int(form['mnum'].value)      # but not eval(): may be code\n        fetcher = mailtools.SilentMailFetcher(site, user, pswd)\n        fetcher.deleteMessages([msgnum])\n        commonhtml.confirmationpage('Delete')\n    else:\n       assert False, 'Invalid view action requested'\nexcept:\n    commonhtml.errorpage('Cannot process view action')\nThis script receives all information about the selected message as form input field data\n(some hidden and possibly encrypted, some not) along with the selected action\u2019s name.\nThe next step in the interaction depends upon the action selected:\nReply and Forward actions\nGenerate a message edit page with the original message\u2019s lines automatically quo-\nted with a leading >.\nDelete actions\nTrigger immediate deletion of the email being viewed, using a tool imported from\nthe mailtools module package from Chapter 13.\nAll these actions use data passed in from the prior page\u2019s form, but only the Delete\naction cares about the POP username and password and must decode the password\nreceived (it arrives here from hidden form input fields generated in the prior page\u2019s\nHTML).\nReply and Forward\nIf you select Reply as the next action, the message edit page in Figure 16-16 is generated\nby the script. Text on this page is editable, and pressing this page\u2019s Send button again\ntriggers the send mail script we saw in Example 16-4. If all goes well, we\u2019ll receive the\nProcessing Fetched Mail | 1267same confirmation page we got earlier when writing new mail from scratch\n(Figure 16-4).\nForward operations are virtually the same, except for a few email header differences.\nAll of this busy-ness comes \u201cfor free,\u201d because Reply and Forward pages are generated\nby calling commonhtml.editpage, the same utility used to create a new mail composition\npage. Here, we simply pass preformatted header line strings to the utility (e.g., replies\nadd \u201cRe:\u201d to the subject text). We applied the same sort of reuse trick in PyMailGUI,\nbut in a different context. In PyMailCGI, one script handles three pages; in PyMailGUI,\none superclass and callback method handles three buttons, but the architecture is sim-\nilar in spirit.\nDelete\nSelecting the Delete action on a message view page and pressing Next will cause the\nonViewPageAction script to immediately delete the message being viewed. Deletions are\nperformed by calling a reusable delete utility function coded in Chapter 13\u2019s mail\nFigure 16-16. PyMailCGI reply page\n1268 | Chapter 16:\u2002The PyMailCGI Servertools package. In a prior version, the call to the utility was wrapped in a commonhtml.run\nsilent call that prevents print call statements in the utility from showing up in the\nHTML reply stream (they are just status messages, not HTML code). In this version,\nwe get the same capability from the \u201cSilent\u201d classes in mailtools. Figure 16-17 shows\na Delete operation in action.\nFigure 16-17. PyMailCGI view page, Delete selected\nBy the way, notice the varied type of attachment parts on the mail\u2019s page in Fig-\nure 16-17. In version 3.0 we can send only text attachments due to the Python 3.1 CGI\nuploads parsing regression described earlier, but we can still view arbitrary attachment\ntypes in fetched mails received from other senders. This includes images and PDFs.\nSuch attachments open according to your browser\u2019s conventions; Figure 16-18 shows\nhow Chrome handles a click on the monkeys.jpg link at the bottom of the PyMailCGI\npage in Figure 16-17\u2014it\u2019s the same image we sent by FTP in Chapter 13 and via Py-\nMailGUI in Chapter 14, but here it has been extracted by a PyMailCGI CGI script and\nis being returned by a locally running web server.\nBack to our pending deletion. As mentioned, Delete is the only action that uses the\nPOP account information (user, password, and site) that was passed in from hidden\nfields on the prior message view page. By contrast, the Reply and Forward actions\nProcessing Fetched Mail | 1269format an edit page, which ultimately sends a message to the SMTP server; no POP\ninformation is needed or passed.\nBut at this point in the interaction, the POP password has racked up more than a few\nfrequent flyer miles. In fact, it may have crossed phone lines, satellite links, and conti-\nnents on its journey from machine to machine. Let\u2019s trace through the voyage:\n1. Input (client): The password starts life by being typed into the login page on the\nclient (or being embedded in an explicit URL), unencrypted. If typed into the input\nform in a web browser, each character is displayed as a star (*).\n2. Fetch index (client to CGI server to POP server): It is next passed from the client\nto the CGI script on the server, which sends it on to your POP server in order to\nload a mail index. The client sends only the password, unencrypted.\n3. List page URLs (CGI server to client): To direct the next script\u2019s behavior, the\npassword is embedded in the mail selection list web page itself as hyperlink URL\nquery parameters, encrypted (or otherwise obfuscated) and URL encoded.\n4. Fetch message (client to CGI server to POP server): When an email is selected from\nthe list, the password is sent to the next script named within the link\u2019s URL; the\nCGI script decodes it and passes it on to the POP server to fetch the selected\nmessage.\nFigure 16-18. Image attachment part selected in PyMailCGI\n1270 | Chapter 16:\u2002The PyMailCGI Server5. View page fields (CGI server to client): To direct the next script\u2019s behavior, the\npassword is embedded in the view page itself as HTML hidden input fields, en-\ncrypted or obfuscated, and HTML escaped.\n6. Delete message (client to CGI server to POP server): Finally, the password is again\npassed from client to CGI server, this time as hidden form field values; the CGI\nscript decodes it and passes it to the POP server to delete.\nAlong the way, scripts have passed the password between pages as both a URL query\nparameter and an HTML hidden input field; either way, they have always passed its\nencrypted or obfuscated string and have never passed an unencoded password and\nusername together in any transaction. Upon a Delete request, the password must be\ndecoded here using the secret module before passing it to the POP server. If the script\ncan access the POP server again and delete the selected message, another confirmation\npage appears, as shown in Figure 16-19 (there is currently no verification for the delete,\nso be careful).\nFigure 16-19. PyMailCGI delete confirmation\nOne subtlety for replies and forwards: the onViewPageAction mail action script builds\nup a >-quoted representation of the original message, with original \u201cFrom:\u201d, \u201cTo:\u201d, and\n\u201cDate:\u201d header lines prepended to the mail\u2019s original text. Notice, though, that the\noriginal message\u2019s headers are fetched from the CGI form input, not by reparsing the\noriginal mail (the mail is not readily available at this point). In other words, the script\ngets mail header values from the form input fields of the view page. Because there is no\n\u201cDate\u201d field on the view page, the original message\u2019s date is also passed along to the\naction script as a hidden input field to avoid reloading the message. Try tracing through\nthe code in this chapter\u2019s listings ahead to see whether you can follow dates from page\nto page.\nProcessing Fetched Mail | 1271Deletions and POP Message Numbers\nNote that you probably should click the \u201cBack to root page\u201d link in Figure 16-19 after\na successful deletion\u2014don\u2019t use your browser\u2019s Back button to return to the message\nselection list at this point because the delete has changed the relative numbers of some\nmessages in the list. The PyMailGUI client program worked around this problem by\nautomatically updating its in-memory message cache and refreshing the index list on\ndeletions, but PyMailCGI doesn\u2019t currently have a way to mark older pages as obsolete.\nIf your browser reruns server-side scripts as you press your Back button, you\u2019ll regen-\nerate and hence refresh the list anyhow. If your browser displays cached pages as you\ngo back, though, you might see the deleted message still present in the list. Worse,\nclicking on a view link in an old selection list page may not bring up the message you\nthink it should, if it appears in the list after a message that was deleted.\nThis is a property of POP email in general, which we have discussed before in this book:\nincoming mail simply adds to the mail list with higher message numbers, but deletions\nremove mail from arbitrary locations in the list and hence change message numbers for\nall mail following the ones deleted.\nInbox synchronization error potential\nAs we saw in Chapter 14, even the PyMailGUI client has the potential to get some\nmessage numbers wrong if mail is deleted by another program while the GUI is open\u2014\nin a second PyMailGUI instance, for example, or in a simultaneously running\nPyMailCGI server session. This can also occur if the email server automatically deletes\na message after the mail list has been loaded\u2014for instance, moving it from inbox to\nundeliverable on errors.\nThis is why PyMailGUI went out of its way to detect server inbox synchronization errors\non loads and deletes, using mailtools package utilities. Its deletions, for instance, match\nsaved email headers with those for the corresponding message number in the server\u2019s\ninbox, to ensure accuracy. A similar test is performed on loads. On mismatches, the\nmail index is automatically reloaded and updated. Unfortunately, without additional\nstate information, PyMailCGI cannot detect such errors: it has no email list to compare\nagainst when messages are viewed or deleted, only the message number in a link or\nhidden form field.\nIn the worst case, PyMailCGI cannot guarantee that deletes remove the intended mail\u2014\nit\u2019s unlikely but not impossible that a mail earlier in the list may have been deleted\nbetween the time message numbers were fetched and a mail is deleted at the server.\nWithout extra state information on the server, PyMailCGI cannot use the safe deletion\nor synchronization error checks in the mailtools modules to check whether subject\nmessage numbers are still valid.\nTo guarantee safe deletes, PyMailCGI would require state retention, which maps mes-\nsage numbers passed in pages to saved mail headers fetched when the numbers were\n1272 | Chapter 16:\u2002The PyMailCGI Serverlast determined, or a broader policy, which sidesteps the issue completely. The next\nthree sections outline suggested improvements and potential exercises.\nAlternative: Passing header text in hidden input fields (PyMailCGI_2.1)\nPerhaps the simplest way to guarantee accurate deletions is to embed the displayed\nmessage\u2019s full header text in the message view page itself, as hidden form fields, using\nthe following scheme:\nonViewListLink.py\nEmbed the header text in hidden form fields, escaped per HTML conventions with\ncgi.escape (with its quote argument set to True to translate any nested quotes in\nthe header text).\nonViewPageAction.py\nRetrieve the embedded header text from the form\u2019s input fields, and pass it along\nto the safe deletion call in mailtools for header matching.\nThis would be a small code change, but it might require an extra headers fetch in the\nfirst of these scripts (it currently loads the full mail text), and it would require building\na phony list to represent all mails\u2019 headers (we would have headers for and delete only\none mail here). Alternatively, the header text could be extracted from the fetched full\nmail text, by splitting on the blank line that separates headers and message body text.\nMoreover, this would increase the size of the data transmitted both from client and\nserver\u2014mail header text is commonly greater than 1 KB in size, and it may be larger.\nThis is a small amount of extra data in modern terms, but it\u2019s possible that this may\nrun up against size limitations in some client or server systems.\nAnd really, this scheme is incomplete. It addresses only deletion accuracy and does\nnothing about other synchronization errors in general. For example, the system still\nmay fetch and display the wrong message from a message list page, after deletions of\nmails earlier in the inbox performed elsewhere. In fact, this technique guarantees only\nthat the message displayed in a view window will be the one deleted for that view\nwindow\u2019s delete action. It does not ensure that the mail displayed or deleted in the view\nwindow corresponds to the selection made by the user in the mail index list.\nMore specifically, because this scheme embeds headers in the HTML of view windows,\nits header matching on deletion is useful only if messages earlier in the inbox are deleted\nelsewhere after a mail has already been opened for viewing. If the inbox is changed\nelsewhere before a mail is opened in a view window, the wrong mail may be fetched\nfrom the index page. In that event, this scheme avoids deleting a mail other than the\none displayed in a view window, but it assumes the user will catch the mistake and\navoid deleting if the wrong mail is loaded from the index page. Though such cases are\nrare, this behavior is less than user friendly.\nEven though it is incomplete, this change does at least avoid deleting the wrong email\nif the server\u2019s inbox changes while a message is being viewed\u2014the mail displayed will\nProcessing Fetched Mail | 1273be the only one deleted. A working but tentative implementation of this scheme is\nimplemented in the following directory of the book\u2019s examples distribution:\nPP4E\\Internet\\Web\\dev\\PyMailCGI_2.1\nWhen developed, it worked under the Firefox web browser and it requires just more\nthan 10 lines of code changes among three source files, listed here (search for\n\u201c#EXPERIMENTAL\u201d to find the changes made in the source files yourself):\n# onViewListLink.py\n    . . .\n    hdrstext = fulltext.split('\\n\\n')[0]                        # use blank line\n    commonhtml.viewpage(                                        # encodes passwd\n               msgnum, message, content, form, hdrstext, parts)\n# commonhtml.py\n    . . .\n    def viewpage(msgnum, headers, text, form, hdrstext, parts=[]):\n        . . .\n        # delete needs hdrs text for inbox sync tests: can be multi-K large\n        hdrstext = cgi.escape(hdrstext, quote=True)   # escape '\"' too\n        print('<input type=hidden name=Hdrstext value=\"%s\">' % hdrstext)\n# onViewPageAction.py\n    . . .\n    fetcher = mailtools.SilentMailFetcher(site, user, pswd)\n    #fetcher.deleteMessages([msgnum])\n    hdrstext = getfield(form, 'Hdrstext') + '\\n'\n    hdrstext = hdrstext.replace('\\r\\n', '\\n')             # get \\n from top\n    dummyhdrslist = [None] * msgnum                       # only one msg hdr\n    dummyhdrslist[msgnum-1] = hdrstext                    # in hidden field\n    fetcher.deleteMessagesSafely([msgnum], dummyhdrslist) # exc on sync err\n    commonhtml.confirmationpage('Delete')\nTo run this version locally, run the webserver script from Example 15-1 (in Chap-\nter 15) with the dev subdirectory name, and a unique port number if you want to run\nboth the original and the experimental versions. For instance:\nC:\\...\\PP4E\\Internet\\Web> webserver.py dev\\PyMailCGI_2.1 9000    command line\nhttp://localhost:9000/pymailcgi.html                             web browser URL\nAlthough this version works on browsers tested, it is considered tentative (and was not\nused for this chapter, and not updated for Python 3.X in this edition) because it is an\nincomplete solution. In those rare cases where the server\u2019s inbox changes in ways that\ninvalidate message numbers after server fetches, this version avoids inaccurate dele-\ntions, but index lists may still become out of sync. Messages fetches may still be inac-\ncurate, and addressing this likely entails more sophisticated state retention options.\nNote that in most cases, the message-id header would be sufficient for matching against\nmails to be deleted in the inbox, and it might be all that is required to pass from page\nto page. However, because this field is optional and can be forged to have any value,\nthis might not always be a reliable way to identify matched messages; full header\n1274 | Chapter 16:\u2002The PyMailCGI Servermatching is necessary to be robust. See the discussion of mailtools in Chapter 13 for\nmore details.\nAlternative: Server-side files for headers\nThe main limitation of the prior section\u2019s technique is that it addressed only deletions\nof already fetched emails. To catch other kinds of inbox synchronization errors, we\nwould have to also record headers fetched when the index list page was constructed.\nSince the index list page uses URL query parameters to record state, adding large header\ntexts as an additional parameter on the URLs is not likely a viable option. In principle,\nthe header text of all mails in the list could be embedded in the index page as a single\nhidden field, but this might add prohibitive size and transmission overheads.\nAs a perhaps more complete approach, each time the mail index list page is generated\nin onViewPswdSubmit.py, fetched headers of all messages could be saved in a flat file on\nthe server, with a generated unique name (possibly from time, process ID, and user-\nname). That file\u2019s name could be passed along with message numbers in pages as an\nextra hidden field or query parameter.\nOn deletions, the header\u2019s filename could be used by onViewPageAction.py to load the\nsaved headers from the flat file, to be passed to the safe delete call in mailtools. On\nfetches, the header file could also be used for general synchronization tests to avoid\nloading and displaying the wrong mail. Some sort of aging scheme would be required\nto delete the header save files eventually (the index page script might clean up old files),\nand we might also have to consider multiuser issues.\nThis scheme essentially uses server-side files to emulate PyMailGUI\u2019s in-process mem-\nory, though it is complicated by the fact that users may back up in their browser\u2014\ndeleting from view pages fetched with earlier list pages, attempting to refetch from an\nearlier list page and so on. In general, it may be necessary to analyze all possible forward\nand backward flows through pages (it is essentially a state machine). Header save files\nmight also be used to detect synchronization errors on fetches and may be removed on\ndeletions to effectively disable actions in prior page states, though header matching\nmay suffice to ensure deletion accuracy.\nAlternative: Delete on load\nAs a final alternative, mail clients could delete all email off the server as soon as it is\ndownloaded, such that deletions wouldn\u2019t impact POP identifiers (Microsoft Outlook\nmay use this scheme by default, for instance). However, this requires additional mech-\nanisms for storing deleted email persistently for later access, and it means you can view\nfetched mail only on the machine to which it was downloaded. Since both PyMailGUI\nand PyMailCGI are intended to be used on a variety of machines, mail is kept on the\nPOP server by default.\nProcessing Fetched Mail | 1275Because of the current lack of inbox synchronization error checks in\nPyMailCGI, you should not delete mails with it in an important account,\nunless you employ one of the solution schemes described or you use\nother tools to save mails to be deleted before deletion. Adding state\nretention to ensure general inbox synchronization may make an inter-\nesting exercise, but would also add more code than we have space for\nhere, especially if generalized for multiple simultaneous site users.\nUtility Modules\nThis section presents the source code of the utility modules imported and used by the\npage scripts shown earlier. As installed, all of these modules live in the same directory\nas the CGI scripts, to make imports simple\u2014they are found in the current working\ndirectory. There aren\u2019t any new screenshots to see here because these are utilities, not\nCGI scripts. Moreover, these modules aren\u2019t all that useful to study in isolation and are\nincluded here primarily to be referenced as you go through the CGI scripts\u2019 code listed\npreviously. See earlier in this chapter for additional details not repeated here.\nExternal Components and Configuration\nWhen running PyMailCGI out of its own directory in the book examples distribution\ntree, it relies on a number of external modules that are potentially located elsewhere.\nBecause all of these are accessible from the PP4E package root, they can be imported\nwith dotted-path names as usual, relative to the root. In case this setup ever changes,\nthough, the module in Example 16-10 encapsulates the location of all external de-\npendencies; if they ever move, this is the only file that must be changed.\nExample 16-10. PP4E\\Internet\\Web\\PyMailCgi\\cgi-bin\\externs.py\n\"\"\"\nisolate all imports of modules that live outside of the PyMailCgi\ndirectory, so that their location must only be changed here if moved;\nwe reuse the mailconfig settings that were used for pymailgui2 in ch13;\nPP4E/'s container must be on sys.path to use the last import here;\n\"\"\"\nimport sys\n#sys.path.insert(0, r'C:\\Users\\mark\\Stuff\\Books\\4E\\PP4E\\dev\\Examples')\nsys.path.insert(0, r'..\\..\\..\\..')                       # relative to script dir\nimport mailconfig                                        # local version\nfrom PP4E.Internet.Email import mailtools                # mailtools package\nThis module simply preimports all external names needed by PyMailCGI into its own\nnamespace. See Chapter 13 for more on the mailtools package modules\u2019 source code\nimported and reused here; as for PyMailGUI, much of the magic behind PyMailCGI is\nactually implemented in mailtools.\n1276 | Chapter 16:\u2002The PyMailCGI ServerThis version of PyMailCGI has its own local copy of the mailconfig module we coded\nin Chapter 13 and expanded in Chapter 14, but it simply loads all attributes from the\nversion we wrote in Chapter 13 to avoid redundancy, and customizes as desired; the\nlocal version is listed in Example 16-11.\nExample 16-11. PP4E\\Internet\\Email\\PyMailCgi\\cgi-bin\\mailconfig.py\n\"\"\"\nuser configuration settings for various email programs (PyMailCGI version);\nemail scripts get their server names and other email config options from\nthis module: change me to reflect your machine names, sig, and preferences;\n\"\"\"\nfrom PP4E.Internet.Email.mailconfig import *     # reuse ch13 configs\nfetchlimit = 50    # 4E: maximum number headers/emails to fetch on loads (dflt=25)\nPOP Mail Interface\nOur next utility module, the loadmail file in Example 16-12, depends on external files\nand encapsulates access to mail on the remote POP server machine. It currently exports\none function, loadmailhdrs, which returns a list of the header text (only) of all mail in\nthe specified POP account; callers are unaware of whether this mail is fetched over the\nNet, lives in memory, or is loaded from a persistent storage medium on the CGI server\nmachine. That is by design\u2014because loadmail changes won\u2019t impact its clients, it is\nmostly a hook for future expansion.\nExample 16-12. PP4E\\Internet\\Web\\PyMailCgi\\cgi-bin\\loadmail.py\n\"\"\"\nmail list loader; future--change me to save mail list between CGI script runs,\nto avoid reloading all mail each time;  this won't impact clients that use the\ninterfaces here if done well;  for now, to keep this simple, reloads all mail\nfor each list page;  2.0+: we now only load message headers (via TOP), not full\nmsg, but still fetch all hdrs for each index list--in-memory caches don't work\nin a stateless CGI script, and require a real (likely server-side) database;\n\"\"\"\nfrom commonhtml import runsilent         # suppress prints (no verbose flag)\nfrom externs    import mailtools         # shared with PyMailGUI\n# load all mail from number 1 up\n# this may trigger an exception\nimport sys\ndef progress(*args):  # not used\n    sys.stderr.write(str(args) + '\\n')\ndef loadmailhdrs(mailserver, mailuser, mailpswd):\n    fetcher = mailtools.SilentMailFetcher(mailserver, mailuser, mailpswd)\n    hdrs, sizes, full = fetcher.downloadAllHeaders()     # get list of hdr text\n    return hdrs\nUtility Modules | 1277This module is not much to look at\u2014just an interface and calls to other modules. The\nmailtools.SilentMailFetcher class (reused here from Chapter 13) uses the Python\npoplib module to fetch mail over sockets. The silent class prevents mailtools print call\nstatements from going to the HTML reply stream (although any exceptions are allowed\nto propagate there normally).\nIn this version, loadmail loads just the header text portions of all incoming email to\ngenerate the selection list page. However, it still reloads headers every time you refetch\nthe selection list page. As mentioned earlier, this scheme is better than the prior version,\nbut it can still be slow if you have lots of email sitting on your server. Server-side da-\ntabase techniques, combined with a scheme for invalidating message lists on deletions\nand new receipts, might alleviate some of this bottleneck. Because the interface expor-\nted by loadmail would likely not need to change to introduce a caching mechanism,\nclients of this module would likely still work unchanged.\nPOP Password Encryption\nWe discussed PyMailCGI\u2019s security protocols in the abstract earlier in this chapter.\nHere, we look at their concrete implementation. PyMailCGI passes user and password\nstate information from page to page using hidden form fields and URL query parameters\nembedded in HTML reply pages. We studied these techniques in the prior chapter.\nSuch data is transmitted as simple text over network sockets\u2014within the HTML reply\nstream from the server, and as parameters in the request from the client. As such, it is\nsubject to security issues.\nThis isn\u2019t a concern if you are running a local web server on your machine, as all our\nexamples do. The data is being shipped back and forth between two programs running\non your computer, and it is not accessible to the outside world. If you want to install\nPyMailCGI on a remote web server machine, though, this can be an issue. Because this\ndata is sensitive, we\u2019d ideally like some way to hide it in transit and prevent it from\nbeing viewed in server logs. The policies used to address this have varied across this\nbook\u2019s lifespan, as options have come and gone:\n\u2022 The second edition of this book developed a custom encryption module using the\nstandard library\u2019s rotor encryption module. This module was used to encrypt data\ninserted into the server\u2019s reply stream, and then to later decrypt it when it was\nreturned as a parameter from the client. Unfortunately, in Python 2.4 and later,\nthe rotor module is no longer available in the standard library; it was withdrawn\ndue to security concerns. This seems a somewhat extreme measure (rotor was\nadequate for simpler applications), but rotor is no longer a usable solution in recent\nreleases.\n\u2022 The third edition of this book extended the model of the second, by adding support\nfor encrypting passwords with the third-party and open source PyCrypto system.\nRegrettably, this system is available for Python 2.X but still not for 3.X as I write\nthese words for the fourth edition in mid-2010 (though some progress on a 3.X\n1278 | Chapter 16:\u2002The PyMailCGI Serverport has been made). Moreover, the Python web server classes used by the locally\nrunning server deployed for this book still does not support HTTPS in Python 3.1\u2014\nthe ultimate solution to web security, which I\u2019ll say more about in a moment.\n\u2022 Because of all the foregoing, this fourth edition has legacy support for both rotor\nand PyCrypto if they are installed, but falls back on a simplistic password obfus-\ncator which may be different at each PyMailCGI installation. Since this release is\nsomething of a prototype in general, further refinement of this model, including\nsupport for HTTPS under more robust web servers, is left as exercise.\nIn general, there are a variety of approaches to encrypting information transferred back\nand forth between client and server. Unfortunately again, none is easily implemented\nfor this chapter\u2019s example, none is universally applicable, and most involve tools or\ntechniques that are well beyond the scope and size constraints of this text. To sample\nsome of the available options, though, the sections that follow contain a brief rundown\nof some of the common techniques in this domain.\nManual data encryption: rotor (defunct)\nIn principle, CGI scripts can manually encrypt any sensitive data they insert into reply\nstreams, as PyMailCGI did in this book\u2019s second edition. With the removal of the\nrotor module, though, Python 2.4\u2019s standard library has no encryption tools for this\ntask. Moreover, using the original rotor module\u2019s code is not advisable from a main-\ntenance perspective and would not be straightforward, since it was coded in the C\nlanguage (it\u2019s not a simple matter of copying a .py file from a prior release). Unless you\nare using an older version of Python, rotor is not a real option.\nMostly for historical interest and comparison today, this module was used as follows.\nIt was based on an Enigma-style encryption scheme: we make a new rotor object with\na key (and optionally, a rotor count) and call methods to encrypt and decrypt:\n>>> import rotor\n>>> r = rotor.newrotor('pymailcgi')        # (key, [,numrotors])\n>>> r.encrypt('abc123')                    # may return nonprintable chars\n' \\323an\\021\\224'\n>>> x = r.encrypt('spam123')               # result is same len as input\n>>> x\n'* _\\344\\011pY'\n>>> len(x)\n7\n>>> r.decrypt(x)\n'spam123'\nNotice that the same rotor object can encrypt multiple strings, that the result may\ncontain nonprintable characters (printed as \\ascii escape codes when displayed), and\nthat the result is always the same length as the original string. Most important, a string\nencrypted with rotor can be decrypted in a different process (e.g., in a later CGI script)\nif we re-create the rotor object:\nUtility Modules | 1279>>> import rotor\n>>> r = rotor.newrotor('pymailcgi')        # can be decrypted in new process\n>>> r.decrypt('* _\\344\\011pY')             # use \"\\ascii\" escapes for two chars\n'spam123'\nOur secret module by default simply used rotor to encrypt and did no additional\nencoding of its own. It relies on URL encoding when the password is embedded in a\nURL parameter and on HTML escaping when the password is embedded in hidden\nform fields. For URLs, the following sorts of calls occur:\n>>> from secret import encode, decode\n>>> x = encode('abc$#<>&+')                 # CGI scripts do this\n>>> x\n' \\323a\\016\\317\\326\\023\\0163'\n>>> import urllib.parse                     # urlencode does this\n>>> y = urllib.parse.quote_plus(x)\n>>> y\n'+%d3a%0e%cf%d6%13%0e3'\n>>> a = urllib.parse.unquote_plus(y)        # cgi.FieldStorage does this\n>>> a\n' \\323a\\016\\317\\326\\023\\0163'\n>>> decode(a)                               # CGI scripts do this\n'abc$#<>&+'\nAlthough rotor itself is not a widely viable option today, these same techniques can be\nused with other encryption schemes.\nManual data encryption: PyCrypto\nA variety of encryption tools are available in the third-party public domain, including\nthe popular Python Cryptography Toolkit, also known as PyCrypto. This package adds\nbuilt-in modules for private and public key algorithms such as AES, DES, IDEA, and\nRSA encryption, provides a Python module for reading and decrypting PGP files, and\nmuch more. Here is an example of using AES encryption, run after installing PyCrypto\non my machine with a Windows self-installer:\n>>> from Crypto.Cipher import AES>>> AES.block_size16\n>>> mykey   = 'pymailcgi'.ljust(16, '-')      # key must be 16, 24, or 32 bytes\n>>> mykey\n'pymailcgi-------'\n>>>\n>>> password   = 'Already got one.'           # length must be multiple of 16\n>>> aesobj1    = AES.new(mykey, AES.MODE_ECB)\n>>> cyphertext = aesobj1.encrypt(password)\n>>> cyphertext\n'\\xfez\\x95\\xb7\\x07_\"\\xd4\\xb6\\xe3r\\x07g~X]'\n>>>\n>>> aesobj2  = AES.new(mykey, AES.MODE_ECB)\n>>> aesobj2.decrypt(cyphertext)\n'Already got one.'\n1280 | Chapter 16:\u2002The PyMailCGI ServerThis interface is similar to that of the original rotor module, but it uses better encryption\nalgorithms. AES is a popular private key encryption algorithm. It requires a fixed length\nkey and a data string to have a length that is a multiple of 16 bytes.\nUnfortunately, this is not part of standard Python, may be subject to U.S. (and other\ncountries\u2019) export controls in binary form at this writing, and is too large and complex\na topic for us to address in this text. This makes it less than universally applicable; at\nthe least, shipping its binary installer with this book\u2019s examples package may require\nlegal expertise. And since data encryption is a core requirement of PyMailCGI, this\nseems too strong an external dependency.\nThe real showstopper for this book\u2019s fourth edition, though, is that PyCrypto is a 2.X-\nonly system not yet available for Python 3.X today; this makes it unusable with the\nexamples in this book. Still, if you are able to install and learn PyCrypto, this can be a\npowerful solution. For more details, search for PyCrypto on the Web.\nHTTPS: Secure HTTP transmissions\nProvided you are using a server that supports secure HTTP, you can simply write HTML\nand delegate the encryption to the web server and browser. As long as both ends of the\ntransmission support this protocol, it is probably the ultimate encrypting solution for\nweb security. In fact, it is used by most e-commerce sites on the Web today.\nSecure HTTP (HTTPS) is designated in URLs by using the protocol name https://\nrather than http://. Under HTTPS, data is still sent with the usual HTTP protocol, but\nit is encrypted with the SSL secure sockets layer. HTTPS is supported by most web\nbrowsers and can be configured in most web servers, including Apache and the\nwebserver.py script that we are running locally in this chapter. If SSL support is com-\npiled into your Python, Python sockets support it with ssl module socket wrappers,\nand the client-side module urllib.request we met in Chapter 13 supports HTTPS.\nUnfortunately, enabling secure HTTP in a web server requires more configuration and\nbackground knowledge than we can cover here, and it may require installing tools\noutside the standard Python release. If you want to explore this issue further, search\nthe Web for resources on setting up a Python-coded HTTPS server that supports SSL\nsecure communications. As one possible lead, see the third-party M2Crypto package\u2019s\nOpenSSL wrapper support for password encryption, HTTPS in urllib, and more; this\ncould be a viable alternative to manual encryption, but it is not yet available for Python\n3.X at this writing.\nAlso see the Web for more details on HTTPS in general. It is not impossible that some\nof the HTTPS extensions for Python\u2019s standard web server classes may make their way\ninto the Python standard library in the future, but they have not in recent years, perhaps\nreflecting the classes\u2019 intended roles\u2014they provide limited functionality for use in lo-\ncally running servers oriented toward testing, not deployment.\nUtility Modules | 1281Secure cookies\nIt\u2019s possible to replace the form fields and query parameter PyMailCGI currently gen-\nerates with client-side cookies marked as secure. Such cookies are automatically en-\ncrypted when sent. Unfortunately again, marking a cookie as secure simply means that\nit can be transmitted only if the communications channel with the host is secure. It\ndoes not provide any additional encryption. Because of this, this option really just begs\nthe question; it still requires an HTTPS server.\nThe secret.py module\nAs you can probably tell, web security is a larger topic than we have time to address\nhere. Because of that, the secret.py module in Example 16-13 finesses the issue, by\ntrying a variety of approaches in turn:\n\u2022 If you are able to fetch and install the third-party PyCrypto system described earlier,\nthe module will use that package\u2019s AES tools to manually encrypt password data\nwhen transmitted together with a username.\n\u2022 If not, it will try rotor next, if you\u2019re able to find and install the original rotor\nmodule in the version of Python that you\u2019re using.\n\u2022 And finally, it falls back on a very simplistic default character code shuffling ob-\nfuscation scheme, which you can replace with one of your own if you install this\nprogram on the Internet at large.\nSee Example 16-13 for more details; it uses function definitions nested in if statements\nto generate the selected encryption scheme\u2019s functions at run time.\nExample 16-13. PP4E\\Internet\\Web\\PyMailCgi\\cgi-bin\\secret.py\n\"\"\"\n###############################################################################\nPyMailCGI encodes the POP password whenever it is sent to/from client over\nthe Net with a username, as hidden text fields or explicit URL params; uses\nencode/decode functions in this module to encrypt the pswd--upload your own\nversion of this module to use a different encryption mechanism or key; pymail\ndoesn't save the password on the server, and doesn't echo pswd as typed,\nbut this isn't 100% safe--this module file itself might be vulnerable;\nHTTPS may be better and simpler but Python web server classes don't support;\n###############################################################################\n\"\"\"\nimport sys, time\ndayofweek = time.localtime(time.time())[6]    # for custom schemes\nforceReadablePassword = False\n###############################################################################\n# string encoding schemes\n###############################################################################\n1282 | Chapter 16:\u2002The PyMailCGI Serverif not forceReadablePassword:\n    ###########################################################\n    # don't do anything by default: the urllib.parse.quote\n    # or cgi.escape calls in commonhtml.py will escape the\n    # password as needed to embed in URL or HTML; the\n    # cgi module undoes escapes automatically for us;\n    ###########################################################\n    def stringify(old):   return old\n    def unstringify(old): return old\nelse:\n    ###########################################################\n    # convert encoded string to/from a string of digit chars,\n    # to avoid problems with some special/nonprintable chars,\n    # but still leave the result semi-readable (but encrypted);\n    # some browsers had problems with escaped ampersands, etc.;\n    ###########################################################\n    separator = '-'\n    def stringify(old):\n        new = ''\n        for char in old:\n            ascii = str(ord(char))\n            new   = new + separator + ascii       # '-ascii-ascii-ascii'\n        return new\n    def unstringify(old):\n        new = ''\n        for ascii in old.split(separator)[1:]:\n            new = new + chr(int(ascii))\n        return new\n###############################################################################\n# encryption schemes: try PyCrypto, then rotor, then simple/custom scheme\n###############################################################################\nuseCrypto = useRotor = True\ntry:\n   import Crypto\nexcept:\n    useCrypto = False\n    try:\n        import rotor\n    except:\n        useRotor = False\nif useCrypto:\n    #######################################################\n    # use third-party pycrypto package's AES algorithm\n    # assumes pswd has no '\\0' on the right: used to pad\n    # change the private key here if you install this\n    #######################################################\nUtility Modules | 1283sys.stderr.write('using PyCrypto\\n')\n    from Crypto.Cipher import AES\n    mykey = 'pymailcgi3'.ljust(16, '-')       # key must be 16, 24, or 32 bytes\n    def do_encode(pswd):\n        over = len(pswd) % 16\n        if over: pswd += '\\0' * (16-over)     # pad: len must be multiple of 16\n        aesobj = AES.new(mykey, AES.MODE_ECB)\n        return aesobj.encrypt(pswd)\n    def do_decode(pswd):\n        aesobj = AES.new(mykey, AES.MODE_ECB)\n        pswd   = aesobj.decrypt(pswd)\n        return pswd.rstrip('\\0')\nelif useRotor:\n    #######################################################\n    # use the standard lib's rotor module to encode pswd\n    # this does a better job of encryption than code above\n    # unfortunately, it is no longer available in Py 2.4+\n    #######################################################\n    sys.stderr.write('using rotor\\n')\n    import rotor\n    mykey = 'pymailcgi3'\n    def do_encode(pswd):\n        robj = rotor.newrotor(mykey)              # use enigma encryption\n        return robj.encrypt(pswd)\n    def do_decode(pswd):\n        robj = rotor.newrotor(mykey)\n        return robj.decrypt(pswd)\nelse:\n    #######################################################\n    # use our own custom scheme as a last resort\n    # shuffle characters in some reversible fashion\n    # caveat: very simple -- replace with one of your own\n    #######################################################\n    sys.stderr.write('using simple\\n')\n    adder = 1\n    def do_encode(pswd):\n        pswd = 'vs' + pswd + '48'\n        res = ''\n        for char in pswd:\n            res += chr(ord(char) + adder)    # inc each ASCII code\n        return str(res)\n    def do_decode(pswd):\n        pswd = pswd[2:-2]\n        res = ''\n        for char in pswd:\n1284 | Chapter 16:\u2002The PyMailCGI Serverres += chr(ord(char) - adder)\n        return res\n###############################################################################\n# top-level entry points\n###############################################################################\ndef encode(pswd):\n    return stringify(do_encode(pswd))       # encrypt plus string encode\ndef decode(pswd):\n    return do_decode(unstringify(pswd))\nIn addition to encryption, this module also implements an encoding method for already\nencrypted strings, which transforms them to and from printable characters. By default,\nthe encoding functions do nothing, and the system relies on straight URL or HTML\nencoding of the encrypted string. An optional encoding scheme translates the encrypted\nstring to a string of ASCII code digits separated by dashes. Either encoding method\nmakes nonprintable characters in the encrypted string printable.\nTo illustrate, let\u2019s test this module\u2019s tools interactively. For this test, we set\nforceReadablePassword to True. The top-level entry points encode and decode into\nprintable characters (for illustration purposes, this test reflects a Python 2.X installation\nwhere PyCrypto is installed):\n>>> from secret import *\nusing PyCrypto\n>>> data = encode('spam@123+')\n>>> data\n'-47-248-2-170-107-242-175-18-227-249-53-130-14-140-163-107'\n>>> decode(data)\n'spam@123+'\nBut there are actually two steps to this\u2014encryption and printable encoding:\n>>> raw = do_encode('spam@123+')\n>>> raw\n'/\\xf8\\x02\\xaak\\xf2\\xaf\\x12\\xe3\\xf95\\x82\\x0e\\x8c\\xa3k'\n>>> text = stringify(raw)\n>>> text\n'-47-248-2-170-107-242-175-18-227-249-53-130-14-140-163-107'\n>>> len(raw), len(text)\n(16, 58)\nHere\u2019s what the encoding looks like without the extra printable encoding:\n>>> raw = do_encode('spam@123+')\n>>> raw\n'/\\xf8\\x02\\xaak\\xf2\\xaf\\x12\\xe3\\xf95\\x82\\x0e\\x8c\\xa3k'\n>>> do_decode(raw)\n'spam@123+'\nUtility Modules | 1285Rolling your own encryptor\nAs is, PyMailCGI avoids ever passing the POP account username and password across\nthe Net together in a single transaction, unless the password is encrypted or obfuscated\naccording to the module secret.py on the server. This module can be different every-\nwhere PyMailCGI is installed, and it can be uploaded anew in the future\u2014encrypted\npasswords aren\u2019t persistent and live only for the duration of one mail-processing in-\nteraction session. Provided you don\u2019t publish your encryption code or its private keys,\nyour data will be as secure as the custom encryption module you provide on your own\nserver.\nIf you wish to use this system on the general Internet, you\u2019ll want to tailor this code.\nIdeally, you\u2019ll install PyCrypto and change the private key string. Barring that, replace\nExample 16-13 with a custom encryption coding scheme of your own or deploy one of\nthe general techniques mentioned earlier, such as an HTTPS-capable web server. In\nany event, this software makes no guarantees; the security of your password is ulti-\nmately up to you to ensure.\nFor additional information on security tools and techniques, search the Web and con-\nsult books geared exclusively toward web programming techniques. As this system is\na prototype at large, security is just one of a handful of limitations which would have\nto be more fully addressed in a robust production-grade version.\nBecause the encryption schemes used by PyMailCGI are reversible, it is\npossible to reconstruct my email account\u2019s password if you happen to\nsee its encrypted form in a screenshot, unless the private key listed in\nsecret.py was different when the tests shown were run. To sidestep this\nissue, the email account used in all of this book\u2019s examples is temporary\nand will be deleted by the time you read these words. Please use an email\naccount of your own to test-drive the system.\nCommon Utilities Module\nFinally, the file commonhtml.py in Example 16-14 is the Grand Central Station of this\napplication\u2014its code is used and reused by just about every other file in the system.\nMost of it is self-explanatory, and we\u2019ve already met most of its core idea earlier, in\nconjunction with the CGI scripts that use it.\nI haven\u2019t talked about its debugging support, though. Notice that this module assigns\nsys.stderr to sys.stdout, in an attempt to force the text of Python error messages to\nshow up in the client\u2019s browser (remember, uncaught exceptions print details to\nsys.stderr). That works sometimes in PyMailCGI, but not always\u2014the error text\nshows up in a web page only if a page_header call has already printed a response pre-\namble. If you want to see all error messages, make sure you call page_header (or print\nContent-type: lines manually) before any other processing.\n1286 | Chapter 16:\u2002The PyMailCGI ServerThis module also defines functions that dump raw CGI environment information to\nthe browser (dumpstatepage), and that wrap calls to functions that print status messages\nso that their output isn\u2019t added to the HTML stream (runsilent). A version 3.0 addition\nalso attempts to work around the fact that built-in print calls can fail in Python 3.1 for\nsome types of Unicode text (e.g., non-ASCII character sets in Internationalized head-\ners), by forcing binary mode and bytes for the output stream (print).\nI\u2019ll leave the discovery of any remaining magic in the code in Example 16-14 up to you,\nthe reader. You are hereby admonished to go forth and read, refer, and reuse.\nExample 16-14. PP4E\\Internet\\Web\\PyMailCgi\\cgi-bin\\commonhtml.py\n#!/usr/bin/python\n\"\"\"\n##################################################################################\ngenerate standard page header, list, and footer HTML;  isolates HTML generation\nrelated details in this file;  text printed here goes over a socket to the client,\nto create parts of a new web page in the web browser;  uses one print per line,\ninstead of string blocks;  uses urllib to escape params in URL links auto from a\ndict, but cgi.escape to put them in HTML hidden fields;  some tools here may be\nuseful outside pymailcgi;  could also return the HTML generated here instead of\nprinting it, so it could be included in other pages;  could also structure as a\nsingle CGI script that gets and tests a next action name as a hidden form field;\ncaveat: this system works, but was largely written during a two-hour layover at\nthe Chicago O'Hare airport: there is much room for improvement and optimization;\n##################################################################################\n\"\"\"\nimport cgi, urllib.parse, sys, os\n# 3.0: Python 3.1 has issues printing some decoded str as text to stdout\nimport builtins\nbstdout = open(sys.stdout.fileno(), 'wb')\ndef print(*args, end='\\n'):\n    try:\n        builtins.print(*args, end=end)\n        sys.stdout.flush()\n    except:\n        for arg in args:\n            bstdout.write(str(arg).encode('utf-8'))\n        if end: bstdout.write(end.encode('utf-8'))\n        bstdout.flush()\nsys.stderr = sys.stdout           # show error messages in browser\nfrom externs import mailconfig    # from a package somewhere on server\nfrom externs import mailtools     # need parser for header decoding\nparser = mailtools.MailParser()   # one per process in this module\n# my cgi address root\n#urlroot = 'http://starship.python.net/~lutz/PyMailCgi/'\n#urlroot = 'http://localhost:8000/cgi-bin/'\nurlroot  = ''  # use minimal, relative paths\nUtility Modules | 1287def pageheader(app='PyMailCGI', color='#FFFFFF', kind='main', info=''):\n    print('Content-type: text/html\\n')\n    print('<html><head><title>%s: %s page (PP4E)</title></head>' % (app, kind))\n    print('<body bgcolor=\"%s\"><h1>%s %s</h1><hr>' % (color, app, (info or kind)))\ndef pagefooter(root='pymailcgi.html'):\n    print('</p><hr><a href=\"http://www.python.org\">')\n    print('<img src=\"../PythonPoweredSmall.gif\" ')\n    print('align=left alt=\"[Python Logo]\" border=0 hspace=15></a>')\n    print('<a href=\"../%s\">Back to root page</a>' % root)\n    print('</body></html>')\ndef formatlink(cgiurl, parmdict):\n    \"\"\"\n    make \"%url?key=val&key=val\" query link from a dictionary;\n    escapes str() of all key and val with %xx, changes ' ' to +\n    note that URL escapes are different from HTML (cgi.escape)\n    \"\"\"\n    parmtext = urllib.parse.urlencode(parmdict)     # calls parse.quote_plus\n    return '%s?%s' % (cgiurl, parmtext)             # urllib does all the work\ndef pagelistsimple(linklist):                       # show simple ordered list\n    print('<ol>')\n    for (text, cgiurl, parmdict) in linklist:\n        link = formatlink(cgiurl, parmdict)\n        text = cgi.escape(text)\n        print('<li><a href=\"%s\">\\n    %s</a>' % (link, text))\n    print('</ol>')\ndef pagelisttable(linklist):                        # show list in a table\n    print('<p><table border>')                      # escape text to be safe\n    for (text, cgiurl, parmdict) in linklist:\n        link = formatlink(cgiurl, parmdict)\n        text = cgi.escape(text)\n        print('<tr><th><a href=\"%s\">View</a><td>\\n %s' % (link, text))\n    print('</table>')\ndef listpage(linkslist, kind='selection list'):\n    pageheader(kind=kind)\n    pagelisttable(linkslist)         # [('text', 'cgiurl', {'parm':'value'})]\n    pagefooter()\ndef messagearea(headers, text, extra=''):               # extra for readonly\n    addrhdrs = ('From', 'To', 'Cc', 'Bcc')              # decode names only\n    print('<table border cellpadding=3>')\n    for hdr in ('From', 'To', 'Cc', 'Subject'):\n        rawhdr = headers.get(hdr, '?')\n        if hdr not in addrhdrs:\n            dechdr = parser.decodeHeader(rawhdr)        # 3.0: decode for display\n        else:                                           # encoded on sends\n            dechdr = parser.decodeAddrHeader(rawhdr)    # email names only\n        val = cgi.escape(dechdr, quote=1)\n        print('<tr><th align=right>%s:' % hdr)\n        print('    <td><input type=text ')\n        print('    name=%s value=\"%s\" %s size=60>' % (hdr, val, extra))\n1288 | Chapter 16:\u2002The PyMailCGI Serverprint('<tr><th align=right>Text:')\n    print('<td><textarea name=text cols=80 rows=10 %s>' % extra)\n    print('%s\\n</textarea></table>' % (cgi.escape(text) or '?'))  # if has </>s\ndef viewattachmentlinks(partnames):\n    \"\"\"\n    create hyperlinks to locally saved part/attachment files\n    when clicked, user's web browser will handle opening\n    assumes just one user, only valid while viewing 1 msg\n    \"\"\"\n    print('<hr><table border cellpadding=3><tr><th>Parts:')\n    for filename in partnames:\n        basename = os.path.basename(filename)\n        filename  = filename.replace('\\\\', '/') # Windows hack\n        print('<td><a href=../%s>%s</a>' % (filename, basename))\n    print('</table><hr>')\ndef viewpage(msgnum, headers, text, form, parts=[]):\n    \"\"\"\n    on View + select (generated link click)\n    very subtle thing: at this point, pswd was URL encoded in the\n    link, and then unencoded by CGI input parser; it's being embedded\n    in HTML here, so we use cgi.escape; this usually sends nonprintable\n    chars in the hidden field's HTML, but works on ie and ns anyhow:\n    in url:  ?user=lutz&mnum=3&pswd=%8cg%c2P%1e%f0%5b%c5J%1c%f3&...\n    in html: <input type=hidden name=pswd value=\"...nonprintables..\">\n    could urllib.parse.quote html field here too, but must urllib.parse.unquote\n    in next script (which precludes passing the inputs in a URL instead\n    of the form); can also fall back on numeric string fmt in secret.py\n    \"\"\"\n    pageheader(kind='View')\n    user, pswd, site = list(map(cgi.escape, getstandardpopfields(form)))\n    print('<form method=post action=\"%sonViewPageAction.py\">' % urlroot)\n    print('<input type=hidden name=mnum value=\"%s\">' % msgnum)\n    print('<input type=hidden name=user value=\"%s\">' % user)    # from page|url\n    print('<input type=hidden name=site value=\"%s\">' % site)    # for deletes\n    print('<input type=hidden name=pswd value=\"%s\">' % pswd)    # pswd encoded\n    messagearea(headers, text, 'readonly')\n    if parts: viewattachmentlinks(parts)\n    # onViewPageAction.quotetext needs date passed in page\n    print('<input type=hidden name=Date value=\"%s\">' % headers.get('Date','?'))\n    print('<table><tr><th align=right>Action:')\n    print('<td><select name=action>')\n    print('    <option>Reply<option>Forward<option>Delete</select>')\n    print('<input type=submit value=\"Next\">')\n    print('</table></form>')                     # no 'reset' needed here\n    pagefooter()\ndef sendattachmentwidgets(maxattach=3):\n    print('<p><b>Attach:</b><br>')\n    for i in range(1, maxattach+1):\n        print('<input size=80 type=file name=attach%d><br>' % i)\n    print('</p>')\nUtility Modules | 1289def editpage(kind, headers={}, text=''):\n    # on Send, View+select+Reply, View+select+Fwd\n    pageheader(kind=kind)\n    print('<p><form enctype=\"multipart/form-data\" method=post', end=' ')\n    print('action=\"%sonEditPageSend.py\">' % urlroot)\n    if mailconfig.mysignature:\n        text = '\\n%s\\n%s' % (mailconfig.mysignature, text)\n    messagearea(headers, text)\n    sendattachmentwidgets()\n    print('<input type=submit value=\"Send\">')\n    print('<input type=reset  value=\"Reset\">')\n    print('</form>')\n    pagefooter()\ndef errorpage(message, stacktrace=True):\n    pageheader(kind='Error')                        # was sys.exc_type/exc_value\n    exc_type, exc_value, exc_tb = sys.exc_info()\n    print('<h2>Error Description</h2><p>', message)\n    print('<h2>Python Exception</h2><p>',  cgi.escape(str(exc_type)))\n    print('<h2>Exception details</h2><p>', cgi.escape(str(exc_value)))\n    if stacktrace:\n        print('<h2>Exception traceback</h2><p><pre>')\n        import traceback\n        traceback.print_tb(exc_tb, None, sys.stdout)\n        print('</pre>')\n    pagefooter()\ndef confirmationpage(kind):\n    pageheader(kind='Confirmation')\n    print('<h2>%s operation was successful</h2>' % kind)\n    print('<p>Press the link below to return to the main page.</p>')\n    pagefooter()\ndef getfield(form, field, default=''):\n    # emulate dictionary get method\n    return (field in form and form[field].value) or default\ndef getstandardpopfields(form):\n    \"\"\"\n    fields can arrive missing or '' or with a real value\n    hardcoded in a URL; default to mailconfig settings\n    \"\"\"\n    return (getfield(form, 'user', mailconfig.popusername),\n            getfield(form, 'pswd', '?'),\n            getfield(form, 'site', mailconfig.popservername))\ndef getstandardsmtpfields(form):\n    return  getfield(form, 'site', mailconfig.smtpservername)\ndef runsilent(func, args):\n    \"\"\"\n    run a function without writing stdout\n    ex: suppress print's in imported tools\n    else they go to the client/browser\n    \"\"\"\n1290 | Chapter 16:\u2002The PyMailCGI Serverclass Silent:\n        def write(self, line): pass\n    save_stdout = sys.stdout\n    sys.stdout  = Silent()                        # send print to dummy object\n    try:                                          # which has a write method\n        result = func(*args)                      # try to return func result\n    finally:                                      # but always restore stdout\n        sys.stdout = save_stdout\n    return result\ndef dumpstatepage(exhaustive=0):\n    \"\"\"\n    for debugging: call me at top of a CGI to\n    generate a new page with CGI state details\n    \"\"\"\n    if exhaustive:\n        cgi.test()                       # show page with form, environ, etc.\n    else:\n        pageheader(kind='state dump')\n        form = cgi.FieldStorage()        # show just form fields names/values\n        cgi.print_form(form)\n        pagefooter()\n    sys.exit()\ndef selftest(showastable=False):                    # make phony web page\n    links = [                                       # [(text, url, {parms})]\n        ('text1', urlroot + 'page1.cgi', {'a':1}),\n        ('text2', urlroot + 'page1.cgi', {'a':2, 'b':'3'}),\n        ('text3', urlroot + 'page2.cgi', {'x':'a b', 'y':'a<b&c', 'z':'?'}),\n        ('te<>4', urlroot + 'page2.cgi', {'<x>':'', 'y':'<a>', 'z':None})]\n    pageheader(kind='View')\n    if showastable:\n        pagelisttable(links)\n    else:\n        pagelistsimple(links)\n    pagefooter()\nif __name__ == '__main__':                          # when run, not imported\n    selftest(len(sys.argv) > 1)                     # HTML goes to stdout\nWeb Scripting Trade-Offs\nAs shown in this chapter, PyMailCGI is still something of a system in the making, but\nit does work as advertised: when it is installed on a remote server machine, by pointing\na browser at the main page\u2019s URL, I can check and send email from anywhere I happen\nto be, as long as I can find a machine with a web browser (and can live with the limi-\ntations of a prototype). In fact, any machine and browser will do: Python doesn\u2019t have\nto be installed anew, and I don\u2019t need POP or SMTP access on the client machine itself.\nThat\u2019s not the case with the PyMailGUI client-side program we wrote in Chapter 14.\nThis property is especially useful at sites that allow web access but restrict more direct\nprotocols such as POP email.\nWeb Scripting Trade-Offs | 1291But before we all jump on the collective Internet bandwagon and utterly abandon tra-\nditional desktop APIs such as tkinter, a few words of larger context may be in order in\nconclusion.\nPyMailCGI Versus PyMailGUI\nBesides illustrating larger CGI applications in general, the PyMailGUI and PyMailCGI\nexamples were chosen for this book on purpose to underscore some of the trade-offs\nyou run into when building applications to run on the Web. PyMailGUI and PyMailCGI\ndo roughly the same things but are radically different in implementation:\nPyMailGUI\nThis is a traditional \u201cdesktop\u201d user-interface program: it runs entirely on the local\nmachine, calls out to an in-process GUI API library to implement interfaces, and\ntalks to the Internet through sockets only when it has to (e.g., to load or send email\non demand). User requests are routed immediately to callback handler method\nfunctions running locally and in-process, with shared variables and memory that\nautomatically retain state between requests. As mentioned, because its memory is\nretained between events, PyMailGUI can cache messages in memory\u2014it loads\nemail headers and selected mails only once, fetches only newly arrived message\nheaders on future loads, and has enough information to perform general inbox\nsynchronization checks. On deletions, PyMailGUI can simply refresh its memory\ncache of loaded headers without having to reload from the server. Moreover, be-\ncause PyMailGUI runs as a single process on the local machine, it can leverage tools\nsuch as multithreading to allow mail transfers to overlap in time (you can send\nwhile a load is in progress), and it can more easily support extra functionality such\nas local mail file saves and opens.\nPyMailCGI\nLike all CGI systems, PyMailCGI consists of scripts that reside and run on a server\nmachine and generate HTML to interact with a user\u2019s web browser on the client\nmachine. It runs only in the context of a web browser or other HTML-aware client,\nand it handles user requests by running CGI scripts on the web server. Without\nmanually managed state retention techniques such as a server-side database sys-\ntem, there is no equivalent to the persistent memory of PyMailGUI\u2014each request\nhandler runs autonomously, with no memory except that which is explicitly passed\nalong by prior states as hidden form fields, URL query parameters, and so on.\nBecause of that, PyMailCGI currently must reload all email headers whenever it\nneeds to display the selection list, naively reloads messages already fetched earlier\nin the session, and cannot perform general inbox synchronization tests. This can\nbe improved by more advanced state-retention schemes such as cookies and server-\nside databases, but none is as straightforward as the persistent in-process memory\nof PyMailGUI.\n1292 | Chapter 16:\u2002The PyMailCGI ServerThe Web Versus the Desktop\nOf course, these systems\u2019 specific functionality isn\u2019t exactly the same\u2014PyMailCGI is\nroughly a functional subset of PyMailGUI\u2014but they are close enough to capture com-\nmon trade-offs. On a basic level, both of these systems use the Python POP and SMTP\nmodules to fetch and send email through sockets. The implementation alternatives they\nrepresent, though, have some critical ramifications that you should consider when\nevaluating the prospect of delivering systems on the Web:\nPerformance costs\nNetworks are slower than CPUs. As implemented, PyMailCGI isn\u2019t nearly as fast\nor as complete as PyMailGUI. In PyMailCGI, every time the user clicks a Submit\nbutton, the request goes across the network (it\u2019s routed to another program on the\nsame machine for \u201clocalhost,\u201d but this setup is for testing, not deployment). More\nspecifically, every user request incurs a network transfer overhead, every callback\nhandler may take the form of a newly spawned process or thread on most servers,\nparameters come in as text strings that must be parsed out, and the lack of state\ninformation on the server between pages means that either mail needs to be\nreloaded often or state retention options must be employed which are slower and\nmore complex than shared process memory.\nIn contrast, user clicks in PyMailGUI trigger in-process function calls rather than\nnetwork traffic and program executions, and state is easily saved as Python in-\nprocess variables. Even with an ultra-fast Internet connection, a server-side CGI\nsystem is slower than a client-side program. To be fair, some tkinter operations are\nsent to the underlying Tcl library as strings, too, which must be parsed. This may\nchange in time, but the contrast here is with CGI scripts versus GUI libraries in\ngeneral. Function calls will probably always beat network transfers.\nSome of these bottlenecks may be designed away at the cost of extra program\ncomplexity. For instance, some web servers use threads and process pools to min-\nimize process creation for CGI scripts. Moreover, as we\u2019ve seen, some state infor-\nmation can be manually passed along from page to page in hidden form fields,\ngenerated URL parameters, and client-side cookies, and state can be saved between\npages in a concurrently accessible database to minimize mail reloads. But there\u2019s\nno getting past the fact that routing events and data over a network to scripts is\nslower than calling a Python function directly. Not every application must care,\nbut some do.\nComplexity costs\nHTML isn\u2019t pretty. Because PyMailCGI must generate HTML to interact with the\nuser in a web browser, it is also more complex (or at least, less readable) than\nPyMailGUI. In some sense, CGI scripts embed HTML code in Python; templating\nsystems such as PSP often take the opposite approach. Either way, because the end\nresult of this is a mixture of two very different languages, creating an interface with\nWeb Scripting Trade-Offs | 1293HTML in a CGI script can be much less straightforward than making calls to a\nGUI API such as tkinter.\nWitness, for example, all the care we\u2019ve taken to escape HTML and URLs in this\nchapter\u2019s examples; such constraints are grounded in the nature of HTML. Fur-\nthermore, changing the system to retain loaded-mail list state in a database between\npages would introduce further complexities to the CGI-based solution (and, most\nlikely, yet another language such as SQL, even if it only appears near the bottom\nof the software stack). And secure HTTP would eliminate the manual encryption\ncomplexity but would introduce new server configuration complexity.\nFunctionality limitations\nHTML can say only so much. HTML is a portable way to specify simple pages and\nforms, but it is poor to useless when it comes to describing more complex user\ninterfaces. Because CGI scripts create user interfaces by writing HTML back to a\nbrowser, they are highly limited in terms of user-interface constructs. For example,\nconsider implementing an image-processing and animation program as CGI\nscripts: HTML doesn\u2019t easily apply once we leave the domain of fill-out forms and\nsimple interactions.\nIt is possible to generate graphics in CGI scripts. They may be created and stored\nin temporary files on the server, with per-session filenames referenced in image tags\nin the generated HTML reply. For browsers that support the notion, graphic images\nmay also be in-lined in HTML image tags, encoded in Base64 format or similar.\nEither technique is substantially more complex than using an image in the tkinter\nGUI library, though. Moreover, responsive animation and drawing applications\nare beyond the scope of a protocol such as CGI, which requires a network trans-\naction per interaction. The interactive drawing and animation scripts we wrote at\nthe end of Chapter 9, for example, could not be implemented as normal server-\nside scripts.\nThis is precisely the limitation that Java applets were designed to address\u2014\nprograms that are stored on a server but are pulled down to run on a client on\ndemand and are given access to a full-featured GUI API for creating richer user\ninterfaces. Nevertheless, strictly server-side programs are inherently limited by the\nconstraints of HTML.\nBeyond HTML\u2019s limitations, client-side programs such as PyMailGUI also have\naccess to tools such as multithreading which are difficult to emulate in a CGI-based\napplication (threads spawned by a CGI script cannot outlive the CGI script itself,\nor augment its reply once sent). Persistent process models for web applications\nsuch as FastCGI may provide options here, but the picture is not as clear-cut as on\nthe client.\nAlthough web developers make noble efforts at emulating client-side capabilities\u2014\nsee the discussion of RIAs and HTML 5 ahead\u2014such efforts add additional com-\nplexity, can stretch the server-side programming model nearly to its breaking point,\nand account for much of the plethora of divergent web techniques.\n1294 | Chapter 16:\u2002The PyMailCGI ServerPortability benefits\nAll you need is a browser on clients. On the upside, because PyMailCGI runs over\nthe Web, it can be run on any machine with a web browser, whether that machine\nhas Python and tkinter installed or not. That is, Python needs to be installed on\nonly one computer\u2014the web server machine where the scripts actually live and\nrun. In fact, this is probably the most compelling benefit to the web application\nmodel. As long as you know that the users of your system have an Internet browser,\ninstallation is simple. You still need Python on the server, but that\u2019s easier to\nguarantee.\nPython and tkinter, you will recall, are very portable, too\u2014they run on all major\nwindow systems (X11, Windows, Mac)\u2014but to run a client-side Python/tkinter\nprogram such as PyMailGUI, you need Python and tkinter on the client machine\nitself. Not so with an application built as CGI scripts: it will work on Macintosh,\nLinux, Windows, and any other machine that can somehow render HTML web\npages. In this sense, HTML becomes a sort of portable GUI API language in web\nscripts, interpreted by your web browser, which is itself a kind of generalized GUI\nfor rendering GUIs. You don\u2019t even need the source code or bytecode for the CGI\nscripts themselves\u2014they run on a remote server that exists somewhere else on the\nNet, not on the machine running the browser.\nExecution requirements\nBut you do need a browser. That is, the very nature of web-enabled systems can\nrender them useless in some environments. Despite the pervasiveness of the Inter-\nnet, many applications still run in settings that don\u2019t have web browsers or Internet\naccess. Consider, for instance, embedded systems, real-time systems, and secure\ngovernment applications. While an intranet (a local network without external con-\nnections) can sometimes make web applications feasible in some such environ-\nments, I have worked at more than one company whose client sites had no web\nbrowsers to speak of. On the other hand, such clients may be more open to instal-\nling systems like Python on local machines, as opposed to supporting an internal\nor external network.\nAdministration requirements\nYou really need a server, too. You can\u2019t write CGI-based systems at all without\naccess to a web server. Further, keeping programs on a centralized server creates\nsome fairly critical administrative overheads. Simply put, in a pure client/server\narchitecture, clients are simpler, but the server becomes a critical path resource\nand a potential performance bottleneck. If the centralized server goes down, you,\nyour employees, and your customers may be knocked out of commission. More-\nover, if enough clients use a shared server at the same time, the speed costs of web-\nbased systems become even more pronounced. In production systems, advanced\ntechniques such as load balancing and fail-over servers help, but they add new\nrequirements.\nWeb Scripting Trade-Offs | 1295In fact, one could make the argument that moving toward a web server architecture\nis akin to stepping backward in time\u2014to the time of centralized mainframes and\ndumb terminals. Some would include the emerging cloud computing model in this\nanalysis, arguably in part a throwback to older computing models. Whichever way\nwe step, offloading and distributing processing to client machines at least partially\navoids this processing bottleneck.\nOther Approaches\nSo what\u2019s the best way to build applications for the Internet\u2014as client-side programs\nthat talk to the Net or as server-side programs that live and breathe on the Net? Natu-\nrally, there is no one answer to that question, since it depends upon each application\u2019s\nunique constraints. Moreover, there are more possible answers to it than have been\ndisclosed so far. Although the client and server programming models do imply trade-\noffs, many of the common web and CGI drawbacks already have common proposed\nsolutions. For example:\nClient-side solutions\nClient- and server-side programs can be mixed in many ways. For instance, applet\nprograms live on a server but are downloaded to and run as client-side programs\nwith access to rich GUI libraries.\nOther technologies, such as embedding JavaScript or Python directly in HTML\ncode, also support client-side execution and richer GUI possibilities. Such scripts\nlive in HTML on the server but run on the client when downloaded and access\nbrowser components through an exposed object model to customize pages.\nThe Dynamic HTML (DHTML) extensions provide yet another client-side script-\ning option for changing web pages after they have been constructed. And the newly\nemerging AJAX model offers additional ways to add interactivity and responsive-\nness to web pages, and is at the heart of the RIA model noted ahead. All of these\nclient-side technologies add extra complexities all their own, but they ease some\nof the limitations imposed by straight HTML.\nState retention solutions\nWe discussed general state retention options in detail in the prior chapter, and we\nwill study full-scale database systems for Python in Chapter 17. Some web appli-\ncation servers (e.g., Zope) naturally support state retention between pages by pro-\nviding concurrently accessible object databases. Some of these systems have an\nexplicit underlying database component (e.g., Oracle and MySQL); others may use\nflat files or Python persistent shelves with appropriate locking. In addition, object\nrelational mappers (ORMs) such as SQLObject allow relational databases to be\nprocessed as Python classes.\nScripts can also pass state information around in hidden form fields and generated\nURL parameters, as done in PyMailCGI, or they can store it on the client machine\nitself using the standard cookie protocol. As we learned in Chapter 15, cookies are\n1296 | Chapter 16:\u2002The PyMailCGI Serverstrings of information that are stored on the client upon request from the server,\nand that are transferred back to the server when a page is revisited (data is sent\nback and forth in HTTP header lines). Cookies are more complex than program\nvariables and are somewhat controversial and optional, but they can offload some\nsimple state retention tasks.\nAlternative models such as FastCGI and mod_python offer additional persistence\noptions\u2014where supported, FastCGI applications may retain context in long-lived\nprocesses, and mod_python provides session data within Apache.\nHTML generation solutions\nThird-party extensions can also take some of the complexity out of embedding\nHTML in Python CGI scripts, albeit at some cost to execution speed. For instance,\nthe HTMLgen system and its relatives let programs build pages as trees of Python\nobjects that \u201cknow\u201d how to produce HTML. Other frameworks prove an object-\nbased interface to reply-stream generation (e.g., a reply object with methods).\nWhen a system like this is employed, Python scripts deal only with objects, not\nwith the syntax of HTML itself.\nFor instance, systems such as PHP, Python Server Pages (PSP), Zope\u2019s DTML and\nZPT, and Active Server Pages provide server-side templating languages, which al-\nlow scripting language code to be embedded in HTML and executed on the server,\nto dynamically generate or determine part of the HTML that is sent back to a client\nin response to requests. The net result can cleanly insulate Python code from the\ncomplexity of HTML code and promote the separation of display format and busi-\nness logic, but may add complexities of its own due to the mixture of different\nlanguages.\nGeneralized user interface development\nTo cover both bases, some systems attempt to separate logic from display so much\nas to make the choice almost irrelevant\u2014by completely encapsulating display de-\ntails, a single program can, in principle, render its user interface as either a tradi-\ntional GUI or an HTML-based web page. Due to the vastly different architectures,\nthough, this ideal is difficult to achieve well and does not address larger disparities\nbetween the client and server platforms. Issues such as state retention and network\ninterfaces are much more significant than generation of windows and controls, and\nmay impact code more.\nOther systems may try to achieve similar goals by abstracting the display repre-\nsentation\u2014a common XML representation, for instance, might lend itself to both\na GUI and an HTML rendering. Again, though, this addresses only the rendering\nof the display, not the fundamental architectural differences of client- and server-\nside approaches.\nEmerging technologies: RIAs and HTML 5\nFinally, higher-level approaches such as the RIA (Rich Internet Application) tool-\nkits introduced in Chapters 7 and 12 can offer additional functionality that HTML\nlacks and can approach the utility on GUI toolkits. On the other hand, they can\nWeb Scripting Trade-Offs | 1297also complicate the web development story even further, and add yet additional\nlanguages to the mix. Though this can vary, the net result is often something of a\nWeb-hosted Tower of Babel, whose development might require simultaneously\nprogramming in Python, HTML, SQL, JavaScript, a server-side templating lan-\nguage, an object-relational mapping API, and more, and even nested and embed-\nded combinations of these. The resulting software stack can be more complex than\nPython and a GUI toolkit.\nMoreover, RIAs today inherit the inherent speed degradation of network-based\nsystems in general; although AJAX can add interactivity to web pages, it still implies\nnetwork access instead of in-process function calls. Ironically, much like desktop\napplications, RIAs may also still require installation of a browser plug-in on the\nclient to be used at all. The emerging HTML 5 standard may address the plug-in\nconstraint and ease the complexity somewhat, but it brings along with it a grab\nbag of new complexities all its own which we won\u2019t describe here.\nClearly, Internet technology does come with some compromises, and it is still evolving\nrapidly. It is nevertheless an appropriate delivery context for many, though not all,\napplications. As with every design choice, you must be the judge. While delivering\nsystems on the Web may have some costs in terms of performance, functionality, and\ncomplexity, it is likely that the significance of those overheads will continue to diminish\nwith time. See the start of Chapter 12 for more on some systems that promise such\nchange, and watch the Web for the ever-changing Internet story to unfold.\nSuggested Reading: The PyErrata System\nNow that I\u2019ve told you all the reasons you might not want to design systems for the\nWeb, I\u2019m going to completely contradict myself and refer you to a system that almost\nrequires a web-based implementation. The second edition of this book included a\nchapter that presented the PyErrata website\u2014a Python program that lets arbitrary\npeople on arbitrary machines submit book comments and bug reports (usually called\nerrata) over the Web, using just a web browser. Such a system must store information\non a server, so it can be read by arbitrary clients.\nBecause of space concerns, that chapter was cut in this book\u2019s third edition. However,\nwe\u2019re making its original content available as optional, supplemental reading. You can\nfind this example\u2019s code, as well as the original chapter\u2019s file in the directory PP4E\n\\Internet\\Web\\PyErrata of the book examples distribution tree (see the Preface for more\non the examples distribution).\nPyErrata is in some ways simpler than the PyMailCGI case study presented in this\nchapter. From a user\u2019s perspective, PyErrata is more hierarchical than linear: user in-\nteractions are shorter and spawn fewer pages. There is also little state retention in the\nweb pages themselves in PyErrata\u2014URL parameters pass state in only one isolated\ncase, and no hidden form fields are generated.\nOn the other hand, PyErrata introduces an entirely new dimension: persistent data\nstorage. State (error and comment reports) is stored permanently by this system on the\n1298 | Chapter 16:\u2002The PyMailCGI Serverserver, either in flat pickle files or in a shelve-based database. Both raise the specter of\nconcurrent updates, since any number of users out in cyberspace may be accessing the\nsite at the same time, so PyErrata also introduces file-locking techniques along the way.\nI no longer maintain the website described by this extra chapter, and the material itself\nis slightly out of date in some ways. For instance, the os.open call is preferred for file\nlocking now; I would probably use a different data storage system today, such as ZODB;\nthe code and its chapter may still be in Python 2.X form in the examples package; and\nthis site might be better implemented as a blog or wiki, concepts and labels that arose\nafter the site was developed.\nStill, PyErrata provides an additional Python website case study, and it more closely\nreflects websites that must store information on the server.\nWeb Scripting Trade-Offs | 1299PART V\nTools and Techniques\nThis part of the book presents a collection of additional Python application topics. \nMost of the tools presented along the way can be used in a wide variety of application \ndomains. You\u2019ll find the following chapters here:\nChapter 17 \nThis chapter covers commonly used and advanced Python techniques for storing \ninformation between program executions\u2014DBM files, object pickling, object \nshelves, and Python\u2019s SQL database API\u2014and briefly introduces full-blown \nOODBs such as ZODB, as well as ORMs such as SQLObject and SQLAlchemy. \nThe Python standard library\u2019s SQLite support is used for the SQL examples, but \nthe API is portable to enterprise-level systems such as MySQL.\nChapter 18 \nThis chapter explores techniques for implementing more advanced data structures \nin Python\u2014stacks, sets, binary search trees, graphs, and the like. In Python, these \ntake the form of object implementations.\nChapter 19 \nThis chapter addresses Python tools and techniques for parsing text-based infor-\nmation\u2014string splits and joins, regular expression matching, XML parsing, re-\ncursive descent parsing, and more advanced language-based topics.\nChapter 20 \nThis chapter introduces integration techniques\u2014both extending Python with \ncompiled libraries and embedding Python code in other applications. While the \nmain focus here is on linking Python with compiled C code, we\u2019ll also investigate \nintegration with Java, .NET, and more. This chapter assumes that you know how \nto read C programs, and it is intended mostly for developers responsible for im-\nplementing application integration layers.\nThis is the last technical part of the book, and it makes heavy use of tools presented \nearlier in the text to help underscore the notion of code reuse. For instance, a calculator \nGUI (PyCalc) serves to demonstrate language processing and code reuse concepts.", "17": "CHAPTER 17\nDatabases and Persistence\n\u201cGive Me an Order of Persistence, but Hold the Pickles\u201d\nSo far in this book, we\u2019ve used Python in the system programming, GUI development,\nand Internet scripting domains\u2014three of Python\u2019s most common applications, and\nrepresentative of its use as an application programming language at large. In the next\nfour chapters, we\u2019re going to take a quick look at other major Python programming\ntopics: persistent data, data structure techniques, text and language processing, and\nPython/C integration.\nThese four topics are not really application areas themselves, but they are techniques\nthat span domains. The database topics in this chapter, for instance, can be applied on\nthe Web, in desktop GUI applications, and so on. Text processing is a similarly general\ntool. Moreover, none of these final four topics is covered exhaustively (each could easily\nfill a book alone), but we\u2019ll sample Python in action in these domains and highlight\ntheir core concepts and tools. If any of these chapters spark your interest, additional\nresources are readily available in the Python world.\nPersistence Options in Python\nIn this chapter, our focus is on persistent data\u2014the kind that outlives a program that\ncreates it. That\u2019s not true by default for objects a script constructs, of course; things\nlike lists, dictionaries, and even class instance objects live in your computer\u2019s memory\nand are lost as soon as the script ends. To make data live longer, we need to do some-\nthing special. In Python programming, there are today at least six traditional ways to\nsave information in between program executions:\nFlat files\nText and bytes stored directly on your computer\nDBM keyed files\nKeyed access to strings stored in dictionary-like files\n1303Pickled objects\nSerialized Python objects saved to files and streams\nShelve files\nPickled Python objects saved in DBM keyed files\nObject-oriented databases (OODBs)\nPersistent Python objects stored in persistent dictionaries (ZODB, Durus)\nSQL relational databases (RDBMSs)\nTable-based storage that supports SQL queries (SQLite, MySQL, PostGreSQL,\netc.)\nObject relational mappers (ORMs)\nMediators that map Python classes to relational tables (SQLObject, SQLAlchemy)\nIn some sense, Python\u2019s interfaces to network-based object transmission protocols such\nas SOAP, XML-RPC, and CORBA also offer persistence options, but they are beyond\nthe scope of this chapter. Here, our interest is in techniques that allow a program to\nstore its data directly and, usually, on the local machine. Although some database\nservers may operate on a physically remote machine on a network, this is largely trans-\nparent to most of the techniques we\u2019ll study here.\nWe studied Python\u2019s simple (or \u201cflat\u201d) file interfaces in earnest in Chapter 4, and we\nhave been using them ever since. Python provides standard access to both the stdio\nfilesystem (through the built-in open function), as well as lower-level descriptor-based\nfiles (with the built-in os module). For simple data storage tasks, these are all that many\nscripts need. To save for use in a future program run, simply write data out to a newly\nopened file on your computer in text or binary mode, and read it back from that file\nlater. As we\u2019ve seen, for more advanced tasks, Python also supports other file-like\ninterfaces such as pipes, fifos, and sockets.\nSince we\u2019ve already explored flat files, I won\u2019t say more about them here. The rest of\nthis chapter introduces the remaining topics on the preceding list. At the end, we\u2019ll also\nmeet a GUI program for browsing the contents of things such as shelves and DBM files.\nBefore that, though, we need to learn what manner of beast these are.\nFourth edition coverage note: The prior edition of this book used the\nmysql-python interface to the MySQL relational database system, as well\nas the ZODB object database system. As I update this chapter in June\n2010, neither of these is yet available for Python 3.X, the version of\nPython used in this edition. Because of that, most ZODB information\nhas been trimmed, and the SQL database examples here were changed\nto use the SQLite in-process database system that ships with Python 3.X\nas part of its standard library. The prior edition\u2019s ZODB and MySQL\nexamples and overviews are still available in the examples package, as\ndescribed later. Because Python\u2019s SQL database API is portable, though,\nthe SQLite code here should work largely unchanged on most other\nsystems.\n1304 | Chapter 17:\u2002Databases and PersistenceDBM Files\nFlat files are handy for simple persistence tasks, but they are generally geared toward\na sequential processing mode. Although it is possible to jump around to arbitrary lo-\ncations with seek calls, flat files don\u2019t provide much structure to data beyond the notion\nof bytes and text lines.\nDBM files, a standard tool in the Python library for database management, improve on\nthat by providing key-based access to stored text strings. They implement a random-\naccess, single-key view on stored data. For instance, information related to objects can\nbe stored in a DBM file using a unique key per object and later can be fetched back\ndirectly with the same key. DBM files are implemented by a variety of underlying mod-\nules (including one coded in Python), but if you have Python, you have a DBM.\nUsing DBM Files\nAlthough DBM filesystems have to do a bit of work to map chunks of stored data to\nkeys for fast retrieval (technically, they generally use a technique called hashing to store\ndata in files), your scripts don\u2019t need to care about the action going on behind the\nscenes. In fact, DBM is one of the easiest ways to save information in Python\u2014DBM\nfiles behave so much like in-memory dictionaries that you may forget you\u2019re actually\ndealing with a file at all. For instance, given a DBM file object:\n\u2022 Indexing by key fetches data from the file.\n\u2022 Assigning to an index stores data in the file.\nDBM file objects also support common dictionary methods such as keys-list fetches\nand tests and key deletions. The DBM library itself is hidden behind this simple model.\nSince it is so simple, let\u2019s jump right into an interactive example that creates a DBM\nfile and shows how the interface works:\nC:\\...\\PP4E\\Dbase> python\n>>> import dbm                              # get interface: bsddb, gnu, ndbm, dumb\n>>> file = dbm.open('movie', 'c')           # make a DBM file called 'movie'\n>>> file['Batman'] = 'Pow!'                 # store a string under key 'Batman'\n>>> file.keys()                             # get the file's key directory\n[b'Batman']\n>>> file['Batman']                          # fetch value for key 'Batman'\nb'Pow!'\n>>> who  = ['Robin', 'Cat-woman', 'Joker']\n>>> what = ['Bang!', 'Splat!', 'Wham!']\n>>> for i in range(len(who)):\n...     file[who[i]] = what[i]              # add 3 more \"records\"\n...\n>>> file.keys()\n[b'Cat-woman', b'Batman', b'Joker', b'Robin']\n>>> len(file), 'Robin' in file, file['Joker']\nDBM Files | 1305(4, True, b'Wham!')\n>>> file.close()                            # close sometimes required\nInternally, importing the dbm standard library module automatically loads whatever\nDBM interface is available in your Python interpreter (attempting alternatives in a fixed\norder), and opening the new DBM file creates one or more external files with names\nthat start with the string 'movie' (more on the details in a moment). But after the import\nand open, a DBM file is virtually indistinguishable from a dictionary.\nIn effect, the object called file here can be thought of as a dictionary mapped to an\nexternal file called movie; the only obvious differences are that keys must be strings (not\narbitrary immutables), and we need to remember to open to access and close after\nchanges.\nUnlike normal dictionaries, though, the contents of file are retained between Python\nprogram runs. If we come back later and restart Python, our dictionary is still available.\nAgain, DBM files are like dictionaries that must be opened:\nC:\\...\\PP4E\\Dbase> python\n>>> import dbm\n>>> file = dbm.open('movie', 'c')           # open existing DBM file\n>>> file['Batman']\nb'Pow!'\n>>> file.keys()                             # keys gives an index list\n[b'Cat-woman', b'Batman', b'Joker', b'Robin']\n>>> for key in file.keys(): print(key, file[key])\n...\nb'Cat-woman' b'Splat!'\nb'Batman' b'Pow!'\nb'Joker' b'Wham!'\nb'Robin' b'Bang!'\nNotice how DBM files return a real list for the keys call; not shown here, their values\nmethod instead returns an iterable view like dictionaries. Further, DBM files always\nstore both keys and values as bytes objects; interpretation as arbitrary types of Unicode\ntext is left to the client application. We can use either bytes or str strings in our code\nwhen accessing or storing keys and values\u2014using bytes allows your keys and values\nto retain arbitrary Unicode encodings, but str objects in our code will be encoded to\nbytes internally using the UTF-8 Unicode encoding by Python\u2019s DBM implementation.\nStill, we can always decode to Unicode str strings to display in a more friendly fashion\nif desired, and DBM files have a keys iterator just like dictionaries. Moreover, assigning\nand deleting keys updates the DBM file, and we should close after making changes (this\nensure that changes are flushed to disk):\n>>> for key in file: print(key.decode(), file[key].decode())\n...\nCat-woman Splat!\nBatman Pow!\nJoker Wham!\n1306 | Chapter 17:\u2002Databases and PersistenceRobin Bang!\n>>> file['Batman'] = 'Ka-Boom!'               # change Batman slot\n>>> del file['Robin']                         # delete the Robin entry\n>>> file.close()                              # close it after changes\nApart from having to import the interface and open and close the DBM file, Python\nprograms don\u2019t have to know anything about DBM itself. DBM modules achieve this\nintegration by overloading the indexing operations and routing them to more primitive\nlibrary tools. But you\u2019d never know that from looking at this Python code\u2014DBM files\nlook like normal Python dictionaries, stored on external files. Changes made to them\nare retained indefinitely:\nC:\\...\\PP4E\\Dbase> python\n>>> import dbm                              # open DBM file again\n>>> file = dbm.open('movie', 'c')\n>>> for key in file: print(key.decode(), file[key].decode())\n...\nCat-woman Splat!\nBatman Ka-Boom!\nJoker Wham!\nAs you can see, this is about as simple as it can be. Table 17-1 lists the most commonly\nused DBM file operations. Once such a file is opened, it is processed just as though it\nwere an in-memory Python dictionary. Items are fetched by indexing the file object by\nkey and are stored by assigning to a key.\nTable 17-1. DBM file operations\nPython code\nAction\nDescription\nimport dbm\nImport\nGet DBM implementation\nfile=dbm.open('filename', 'c')\nOpen\nCreate or open an existing DBM file for I/O\nfile['key'] = 'value'\nStore\nCreate or change the entry for key\nvalue = file['key']\nFetch\nLoad the value for the entry key\ncount = len(file)\nSize\nReturn the number of entries stored\nindex = file.keys()\nIndex\nFetch the stored keys list (not a view)\nfound = 'key' in file\nQuery\nSee if there\u2019s an entry for key\ndel file['key']\nDelete\nRemove the entry for key\nfor key in file:\nIterate\nIterate over stored keys\nfile.close()\nClose\nManual close, not always needed\nDBM Files | 1307DBM Details: Files, Portability, and Close\nDespite the dictionary-like interface, DBM files really do map to one or more external \nfiles. For instance, the underlying default dbm interface used by Python 3.1 on Windows \nwrites two files\u2014movie.dir and movie.dat\u2014when a DBM file called movie is made, and \nsaves a movie.bak on later opens. If your Python has access to a different underlying \nkeyed-file interface, different external files might show up on your computer.\nTechnically, the module dbm is really an interface to whatever DBM-like filesystem you \nhave available in your Python:\n\u2022 When opening an already existing DBM file, dbm tries to determine the system that \ncreated it with the dbm.whichdb function instead. This determination is based upon \nthe content of the database itself.\n\u2022 When creating a new file, dbm today tries a set of keyed-file interface modules in a \nfixed order. According to its documentation, it attempts to import the interfaces \ndbm.bsd, dbm.gnu, dbm.ndbm, or dbm.dumb, and uses the first that succeeds. Pythons \nwithout any of these automatically fall back on an all-Python and always-present \nimplementation called dbm.dumb, which is not really \u201cdumb,\u201d or course, but may \nnot be as fast or robust as other options.\nFuture Pythons are free to change this selection order, and may even add additional \nalternatives to it. You normally don\u2019t need to care about any of this, though, unless you \ndelete any of the files your DBM creates, or transfer them between machines with dif-\nferent configurations\u2014if you need to care about the portability of your DBM files (and \nas we\u2019ll see later, by proxy, that of your shelve files), you should configure machines \nsuch that all have the same DBM interface installed or rely upon the dumb fallback. For \nexample, the Berkeley DB package (a.k.a. bsddb) used by dbm.bsd is widely available \nand portable.\nNote that DBM files may or may not need to be explicitly closed, per the last entry in \nTable 17-1. Some DBM files don\u2019t require a close call, but some depend on it to flush \nchanges out to disk. On such systems, your file may be corrupted if you omit the close \ncall. Unfortunately, the default DBM in some older Windows Pythons, dbhash (a.k.a. \nbsddb), is one of the DBM systems that requires a close call to avoid data loss. As a rule \nof thumb, always close your DBM files explicitly after making changes and before your \nprogram exits to avoid potential problems; it\u2019s essential a \u201ccommit\u201d operation for these \nfiles. This rule extends by proxy to shelves, a topic we\u2019ll meet later in this chapter.\n1308 | Chapter 17:\u2002Databases and PersistenceRecent changes: Be sure to also pass a string 'c' as a second argument\nwhen calling dbm.open, to force Python to create the file if it does not yet\nexist and to simply open it for reads and writes otherwise. This used to\nbe the default behavior but is no longer. You do not need the 'c' argu-\nment when opening shelves discussed ahead\u2014they still use an \u201copen or\ncreate\u201d 'c' mode by default if passed no open mode argument. Other\nopen mode strings can be passed to dbm, including n to always create the\nfile, and r for read-only of an existing file\u2014the new default. See the\nPython library manual for more details.\nIn addition, Python 3.X stores both key and value strings as bytes in-\nstead of str as we\u2019ve seen (which turns out to be convenient for pickled\ndata in shelves, discussed ahead) and no longer ships with bsddb as a\nstandard component\u2014it\u2019s available independently on the Web as a\nthird-party extension, but in its absence Python falls back on its own\nDBM file implementation. Since the underlying DBM implementation\nrules are prone to change with time, you should always consult Python\u2019s\nlibrary manuals as well as the dbm module\u2019s standard library source code\nfor more information.\nPickled Objects\nProbably the biggest limitation of DBM keyed files is in what they can store: data stored\nunder a key must be a simple string. If you want to store Python objects in a DBM file,\nyou can sometimes manually convert them to and from strings on writes and reads\n(e.g., with str and eval calls), but this takes you only so far. For arbitrarily complex\nPython objects such as class instances and nested data structures, you need something\nmore. Class instance objects, for example, cannot usually be later re-created from their\nstandard string representations. Moreover, custom to-string conversions and from-\nstring parsers are error prone and not general.\nThe Python pickle module, a standard part of the Python system, provides the con-\nversion step needed. It\u2019s a sort of super general data formatting and de-formatting\ntool\u2014pickle converts nearly arbitrary Python in-memory objects to and from a single\nlinear string format, suitable for storing in flat files, shipping across network sockets\nbetween trusted sources, and so on. This conversion from object to string is often\ncalled serialization\u2014arbitrary data structures in memory are mapped to a serial string\nform.\nThe string representation used for objects is also sometimes referred to as a byte stream,\ndue to its linear format. It retains all the content and references structure of the original\nin-memory object. When the object is later re-created from its byte string, it will be a\nnew in-memory object identical in structure and value to the original, though located\nat a different memory address.\nThe net effect is that the re-created object is effectively a copy of the original; in Python-\nspeak, the two will be == but not is. Since the recreation typically happens in an entirely\nPickled Objects | 1309new process, this difference is often irrelevant (though as we saw in Chapter 5, this\ngenerally precludes using pickled objects directly as cross-process shared state).\nPickling works on almost any Python datatype\u2014numbers, lists, dictionaries, class in-\nstances, nested structures, and more\u2014and so is a general way to store data. Because\npickles contain native Python objects, there is almost no database API to be found; the\nobjects stored with pickling are processed with normal Python syntax when they are\nlater retrieved.\nUsing Object Pickling\nPickling may sound complicated the first time you encounter it, but the good news is\nthat Python hides all the complexity of object-to-string conversion. In fact, the pickle\nmodule \u2019s interfaces are incredibly simple to use. For example, to pickle an object into\na serialized string, we can either make a pickler and call its methods or use convenience\nfunctions in the module to achieve the same effect:\nP = pickle.Pickler(file)\nMake a new pickler for pickling to an open output file object file.\nP.dump(object )\nWrite an object onto the pickler\u2019s file/stream.\npickle.dump(object, file)\nSame as the last two calls combined: pickle an object onto an open file.\nstring = pickle.dumps(object)\nReturn the pickled representation of object as a character string.\nUnpickling from a serialized string back to the original object is similar\u2014both object\nand convenience function interfaces are available:\nU = pickle.Unpickler(file)\nMake an unpickler for unpickling from an open input file object file.\nobject = U.load()\nRead an object from the unpickler\u2019s file/stream.\nobject = pickle.load(file)\nSame as the last two calls combined: unpickle an object from an open file.\nobject = pickle.loads(string)\nRead an object from a character string rather than a file.\nPickler and Unpickler are exported classes. In all of the preceding cases, file is either\nan open file object or any object that implements the same attributes as file objects:\n\u2022 Pickler calls the file\u2019s write method with a string argument.\n\u2022 Unpickler calls the file\u2019s read method with a byte count, and readline without\narguments.\n1310 | Chapter 17:\u2002Databases and PersistenceAny object that provides these attributes can be passed in to the file parameters. In\nparticular, file can be an instance of a Python class that provides the read/write meth-\nods (i.e., the expected file-like interface). This lets you map pickled streams to in-\nmemory objects with classes, for arbitrary use. For instance, the io.BytesIO class in the\nstandard library discussed in Chapter 3 provides an interface that maps file calls to and\nfrom in-memory byte strings and is an alternative to the pickler\u2019s dumps/loads string\ncalls.\nThis hook also lets you ship Python objects across a network, by providing sockets\nwrapped to look like files in pickle calls at the sender, and unpickle calls at the receiver\n(see \u201cMaking Sockets Look Like Files and Streams\u201d on page 827 for more details). In\nfact, for some, pickling Python objects across a trusted network serves as a simpler\nalternative to network transport protocols such as SOAP and XML-RPC, provided that\nPython is on both ends of the communication (pickled objects are represented with a\nPython-specific format, not with XML text).\nRecent changes: In Python 3.X, pickled objects are always represented\nas bytes, not str, regardless of the protocol level which you request\n(even the oldest ASCII protocol yields bytes). Because of this, files used\nto store pickled Python objects should always be opened in binary mode.\nMoreover, in 3.X an optimized _pickle implementation module is also\nselected and used automatically if present. More on both topics later.\nPickling in Action\nAlthough pickled objects can be shipped in exotic ways, in more typical use, to pickle\nan object to a flat file, we just open the file in write mode and call the dump function:\nC:\\...\\PP4E\\Dbase> python\n>>> table = {'a': [1, 2, 3],\n             'b': ['spam', 'eggs'],\n             'c': {'name':'bob'}}\n>>>\n>>> import pickle\n>>> mydb  = open('dbase', 'wb')\n>>> pickle.dump(table, mydb)\nNotice the nesting in the object pickled here\u2014the pickler handles arbitrary structures.\nAlso note that we\u2019re using binary mode files here; in Python 3.X, we really must, because\nthe pickled representation of an object is always a bytes object in all cases. To unpickle\nlater in another session or program run, simply reopen the file and call load:\nC:\\...\\PP4E\\Dbase> python\n>>> import pickle\n>>> mydb  = open('dbase', 'rb')\n>>> table = pickle.load(mydb)\n>>> table\n{'a': [1, 2, 3], 'c': {'name': 'bob'}, 'b': ['spam', 'eggs']}\nPickled Objects | 1311The object you get back from unpickling has the same value and reference structure as\nthe original, but it is located at a different address in memory. This is true whether the\nobject is unpickled in the same or a future process. Again, the unpickled object is ==\nbut is not is:\nC:\\...\\PP4E\\Dbase> python\n>>> import pickle\n>>> f = open('temp', 'wb')\n>>> x = ['Hello', ('pickle', 'world')]          # list with nested tuple\n>>> pickle.dump(x, f)\n>>> f.close()                                   # close to flush changes\n>>>\n>>> f = open('temp', 'rb')\n>>> y = pickle.load(f)\n>>> y\n['Hello', ('pickle', 'world')]\n>>>\n>>> x == y, x is y                              # same value, diff objects\n(True, False)\nTo make this process simpler still, the module in Example 17-1 wraps pickling and\nunpickling calls in functions that also open the files where the serialized form of the\nobject is stored.\nExample 17-1. PP4E\\Dbase\\filepickle.py\n\"Pickle to/from flat file utilities\"\nimport pickle\ndef saveDbase(filename, object):\n    \"save object to file\"\n    file = open(filename, 'wb')\n    pickle.dump(object, file)        # pickle to binary file\n    file.close()                     # any file-like object will do\ndef loadDbase(filename):\n    \"load object from file\"\n    file = open(filename, 'rb')\n    object = pickle.load(file)       # unpickle from binary file\n    file.close()                     # re-creates object in memory\n    return object\nTo store and fetch now, simply call these module functions; here they are in action\nmanaging a fairly complex structure with multiple references to the same nested\nobject\u2014the nested list called L at first is stored only once in the file:\nC:\\...\\PP4E\\Dbase> python\n>>> from filepickle import *\n>>> L = [0]\n>>> D = {'x':0, 'y':L}\n>>> table = {'A':L, 'B':D}              # L appears twice\n>>> saveDbase('myfile', table)          # serialize to file\n1312 | Chapter 17:\u2002Databases and PersistenceC:\\...\\PP4E\\Dbase>python\n>>> from filepickle import *\n>>> table = loadDbase('myfile')         # reload/unpickle\n>>> table\n{'A': [0], 'B': {'y': [0], 'x': 0}}\n>>> table['A'][0] = 1                   # change shared object\n>>> saveDbase('myfile', table)          # rewrite to the file\nC:\\...\\PP4E\\Dbase>python\n>>> from filepickle import *\n>>> print(loadDbase('myfile'))          # both L's updated as expected\n{'A': [1], 'B': {'y': [1], 'x': 0}}\nBesides built-in types like the lists, tuples, and dictionaries of the examples so far, class\ninstances may also be pickled to file-like objects. This provides a natural way to associate\nbehavior with stored data (class methods process instance attributes) and provides a\nsimple migration path (class changes made in module files are automatically picked up\nby stored instances). Here\u2019s a brief interactive demonstration:\n>>> class Rec:\n        def __init__(self, hours):\n            self.hours = hours\n        def pay(self, rate=50):\n            return self.hours * rate\n>>> bob = Rec(40)\n>>> import pickle\n>>> pickle.dump(bob, open('bobrec', 'wb'))\n>>>\n>>> rec = pickle.load(open('bobrec', 'rb'))\n>>> rec.hours\n40\n>>> rec.pay()\n2000\nWe\u2019ll explore how this works in more detail in conjunction with shelves later in this\nchapter\u2014as we\u2019ll see, although the pickle module can be used directly this way, it is\nalso the underlying translation engine in both shelves and ZODB databases.\nIn general, Python can pickle just about anything, except for:\n\u2022 Compiled code objects: functions and classes record just their names and those of\ntheir modules in pickles, to allow for later reimport and automatic acquisition of\nchanges made in module files.\n\u2022 Instances of classes that do not follow class importability rules: in short, the class\nmust be importable on object loads (more on this at the end of the section \u201cShelve\nFiles\u201d on page 1315).\n\u2022 Instances of some built-in and user-defined types that are coded in C or depend\nupon transient operating system states (e.g., open file objects cannot be pickled).\nA PicklingError is raised if an object cannot be pickled. Again, we\u2019ll revisit the pickler\u2019s\nconstraints on pickleable objects and classes when we study shelves.\nPickled Objects | 1313Pickle Details: Protocols, Binary Modes, and _pickle\nIn later Python releases, the pickler introduced the notion of protocols\u2014storage formats\nfor pickled data. Specify the desired protocol by passing an extra parameter to the\npickling calls (but not to unpickling calls: the protocol is automatically determined\nfrom the pickled data):\npickle.dump(object, file, protocol)       # or protocol=N keyword argument\nPickled data may be created in either text or binary protocols; the binary protocols\u2019\nformat is more efficient, but it cannot be readily understood if inspected. By default,\nthe storage protocol in Python 3.X is a 3.X-only binary bytes format (also known as\nprotocol 3). In text mode (protocol 0), the pickled data is printable ASCII text, which\ncan be read by humans (it\u2019s essentially instructions for a stack machine), but it is still\na bytes object in Python 3.X. The alternative protocols (protocols 1 and 2) create the\npickled data in binary format as well.\nFor all protocols, pickled data is a bytes object in 3.X, not a str, and therefore implies\nbinary-mode reads and writes when stored in flat files (see Chapter 4 if you\u2019ve forgotten\nwhy). Similarly, we must use a bytes-oriented object when forging the file object\u2019s\ninterface:\n>>> import io, pickle\n>>> pickle.dumps([1, 2, 3])                      # default=binary protocol\nb'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.'\n>>> pickle.dumps([1, 2, 3], protocol=0)          # ASCII format protocol\nb'(lp0\\nL1L\\naL2L\\naL3L\\na.'\n>>> pickle.dump([1, 2, 3], open('temp','wb'))    # same if protocol=0, ASCII\n>>> pickle.dump([1, 2, 3], open('temp','w'))     # must use 'rb' to read too\nTypeError: must be str, not bytes\n>>> pickle.dump([1, 2, 3], open('temp','w'), protocol=0)\nTypeError: must be str, not bytes\n>>> B = io.BytesIO()                             # use bytes streams/buffers\n>>> pickle.dump([1, 2, 3], B)\n>>> B.getvalue()\nb'\\x80\\x03]q\\x00(K\\x01K\\x02K\\x03e.'\n>>> B = io.BytesIO()                             # also bytes for ASCII\n>>> pickle.dump([1, 2, 3], B, protocol=0)\n>>> B.getvalue()\nb'(lp0\\nL1L\\naL2L\\naL3L\\na.'\n>>> S = io.StringIO()                            # it's not a str anymore\n>>> pickle.dump([1, 2, 3], S)                    # same if protocol=0, ASCII\nTypeError: string argument expected, got 'bytes'\n>>> pickle.dump([1, 2, 3], S, protocol=0)\nTypeError: string argument expected, got 'bytes'\n1314 | Chapter 17:\u2002Databases and PersistenceRefer to Python\u2019s library manual for more information on the pickler; it supports ad-\nditional interfaces that classes may use to customize its behavior, which we\u2019ll bypass\nhere in the interest of space. Also check out marshal, a module that serializes an object\ntoo, but can handle only simple object types. pickle is more general than marshal and\nis normally preferred.\nAn additional related module, _pickle, is a C-coded optimization of pickle, and is\nautomatically used by pickle internally if available; it need not be selected or used\ndirectly. The shelve module inherits this optimization automatically by proxy. I haven\u2019t\nexplained shelve yet, but I will now.\nShelve Files\nPickling allows you to store arbitrary objects on files and file-like objects, but it\u2019s still\na fairly unstructured medium; it doesn\u2019t directly support easy access to members of\ncollections of pickled objects. Higher-level structures can be added to pickling, but they\nare not inherent:\n\u2022 You can sometimes craft your own higher-level pickle file organizations with the\nunderlying filesystem (e.g., you can store each pickled object in a file whose name\nuniquely identifies the object), but such an organization is not part of pickling itself\nand must be manually managed.\n\u2022 You can also store arbitrarily large dictionaries in a pickled file and index them by\nkey after they are loaded back into memory, but this will load and store the entire\ndictionary all at once when unpickled and pickled, not just the entry you are in-\nterested in.\nShelves provide structure for collections of pickled objects that removes some of these\nconstraints. They are a type of file that stores arbitrary Python objects by key for later\nretrieval, and they are a standard part of the Python system. Really, they are not much\nof a new topic\u2014shelves are simply a combination of the DBM files and object pickling\nwe just met:\n\u2022 To store an in-memory object by key, the shelve module first serializes the object\nto a string with the pickle module, and then it stores that string in a DBM file by\nkey with the dbm module.\n\u2022 To fetch an object back by key, the shelve module first loads the object\u2019s serialized\nstring by key from a DBM file with the dbm module, and then converts it back to\nthe original in-memory object with the pickle module.\nBecause shelve uses pickle internally, it can store any object that pickle can: strings,\nnumbers, lists, dictionaries, cyclic objects, class instances, and more. Because shelve\nuses dbm internally, it inherits all of that module\u2019s capabilities, as well as its portability\nconstraints.\nShelve Files | 1315Using Shelves\nIn other words, shelve is just a go-between; it serializes and deserializes objects so that\nthey can be placed in string-based DBM files. The net effect is that shelves let you store\nnearly arbitrary Python objects on a file by key and fetch them back later with the\nsame key.\nYour scripts never see all of this interfacing, though. Like DBM files, shelves provide\nan interface that looks like a dictionary that must be opened. In fact, a shelve is simply\na persistent dictionary of persistent Python objects\u2014the shelve dictionary\u2019s content is\nautomatically mapped to a file on your computer so that it is retained between program\nruns. This is quite a feat, but it\u2019s simpler to your code than it may sound. To gain access\nto a shelve, import the module and open your file:\nimport shelve\ndbase = shelve.open(\"mydbase\")\nInternally, Python opens a DBM file with the name mydbase, or creates it if it does not\nyet exist (it uses the DBM 'c' input/output open mode by default). Assigning to a shelve\nkey stores an object:\ndbase['key'] = object      # store object\nInternally, this assignment converts the object to a serialized byte stream with pickling\nand stores it by key on a DBM file. Indexing a shelve fetches a stored object:\nvalue = dbase['key']       # fetch object\nInternally, this index operation loads a string by key from a DBM file and unpickles it\ninto an in-memory object that is the same as the object originally stored. Most dic-\ntionary operations are supported here, too:\nlen(dbase)                 # number of items stored\ndbase.keys()               # stored item key index iterable\nAnd except for a few fine points, that\u2019s really all there is to using a shelve. Shelves are\nprocessed with normal Python dictionary syntax, so there is no new database API to\nlearn. Moreover, objects stored and fetched from shelves are normal Python objects;\nthey do not need to be instances of special classes or types to be stored away. That is,\nPython\u2019s persistence system is external to the persistent objects themselves.\nTable 17-2 summarizes these and other commonly used shelve operations.\nTable 17-2. Shelve file operations\nPython code\nAction\nDescription\nimport shelve\nImport\nGet bsddb, gdbm, and so on\u2026whatever is installed\nfile=shelve.open('filename')\nOpen\nCreate or open an existing shelve\u2019s DBM file\nfile['key'] = anyvalue\nStore\nCreate or change the entry for key\nvalue = file['key']\nFetch\nLoad the value for the entry key\ncount = len(file)\nSize\nReturn the number of entries stored\n1316 | Chapter 17:\u2002Databases and PersistencePython code\nAction\nDescription\nindex = file.keys()\nIndex\nFetch the stored keys list (an iterable view)\nfound = 'key' in file\nQuery\nSee if there\u2019s an entry for key\ndel file['key']\nDelete\nRemove the entry for key\nfor key in file:\nIterate\nIterate over stored keys\nfile.close()\nClose\nManual close, not always needed\nBecause shelves export a dictionary-like interface, too, this table is almost identical to\nthe DBM operation table. Here, though, the module name dbm is replaced by shelve,\nopen calls do not require a second c argument, and stored values can be nearly arbitrary\nkinds of objects, not just strings. Keys are still strings, though (technically, keys are\nalways a str which is encoded to and from bytes automatically per UTF-8), and you\nstill should close shelves explicitly after making changes to be safe: shelves use dbm\ninternally, and some underlying DBMs require closes to avoid data loss or damage.\nRecent changes: The shelve module now has an optional writeback ar-\ngument; if passed True, all entries fetched are cached in memory, and\nwritten back to disk automatically at close time. This obviates the need\nto manually reassign changed mutable entries to flush them to disk, but\ncan perform poorly if many items are fetched\u2014it may require a large\namount of memory for the cache, and it can make the close operation\nslow since all fetched entries must be written back to disk (Python can-\nnot tell which of the objects may have been changed).\nBesides allowing values to be arbitrary objects instead of just strings, in\nPython 3.X the shelve interface differs from the DBM interface in two\nsubtler ways. First, the keys method returns an iterable view object (not\na physical list). Second, the values of keys are always str in your code,\nnot bytes\u2014on fetches, stores, deletes, and other contexts, the str keys\nyou use are encoded to the bytes expected by DBM using the UTF-8\nUnicode encoding. This means that unlike dbm, you cannot use bytes\nfor shelve keys in your code to employ arbitrary encodings.\nShelve keys are also decoded from bytes to str per UTF-8 whenever they\nare returned from the shelve API (e.g., keys iteration). Stored values are\nalways the bytes object produced by the pickler to represent a serialized\nobject. We\u2019ll see these behaviors in action in the examples of this\nsection.\nStoring Built-in Object Types in Shelves\nLet\u2019s run an interactive session to experiment with shelve interfaces. As mentioned,\nshelves are essentially just persistent dictionaries of objects, which you open and close:\nC:\\...\\PP4E\\Dbase> python\n>>> import shelve\nShelve Files | 1317>>> dbase = shelve.open(\"mydbase\")\n>>> object1 = ['The', 'bright', ('side', 'of'), ['life']]\n>>> object2 = {'name': 'Brian', 'age': 33, 'motto': object1}\n>>> dbase['brian']  = object2\n>>> dbase['knight'] = {'name': 'Knight', 'motto': 'Ni!'}\n>>> dbase.close()\nHere, we open a shelve and store two fairly complex dictionary and list data structures\naway permanently by simply assigning them to shelve keys. Because shelve uses\npickle internally, almost anything goes here\u2014the trees of nested objects are automat-\nically serialized into strings for storage. To fetch them back, just reopen the shelve and\nindex:\nC:\\...\\PP4E\\Dbase> python\n>>> import shelve\n>>> dbase = shelve.open(\"mydbase\")\n>>> len(dbase)                             # entries\n2\n>>> dbase.keys()                           # index\nKeysView(<shelve.DbfilenameShelf object at 0x0181F630>)\n>>> list(dbase.keys())\n['brian', 'knight']\n>>> dbase['knight']                        # fetch\n{'motto': 'Ni!', 'name': 'Knight'}\n>>> for row in dbase.keys():               # .keys() is optional\n...     print(row, '=>')\n...     for field in dbase[row].keys():\n...         print('  ', field, '=', dbase[row][field])\n...\nbrian =>\n   motto = ['The', 'bright', ('side', 'of'), ['life']]\n   age = 33\n   name = Brian\nknight =>\n   motto = Ni!\n   name = Knight\nThe nested loops at the end of this session step through nested dictionaries\u2014the outer\nscans the shelve and the inner scans the objects stored in the shelve (both could use\nkey iterators and omit their .keys() calls). The crucial point to notice is that we\u2019re using\nnormal Python syntax, both to store and to fetch these persistent objects, as well as to\nprocess them after loading. It\u2019s persistent Python data on disk.\nStoring Class Instances in Shelves\nOne of the more useful kinds of objects to store in a shelve is a class instance. Because\nits attributes record state and its inherited methods define behavior, persistent class\n1318 | Chapter 17:\u2002Databases and Persistenceobjects effectively serve the roles of both database records and database-processing\nprograms. We can also use the underlying pickle module to serialize instances to flat\nfiles and other file-like objects (e.g., network sockets), but the higher-level shelve mod-\nule also gives us a convenient keyed-access storage medium. For instance, consider the\nsimple class shown in Example 17-2, which is used to model people in a hypothetical\nwork scenario.\nExample 17-2. PP4E\\Dbase\\person.py (version 1)\n\"a person object: fields + behavior\"\nclass Person:\n    def __init__(self, name, job, pay=0):\n        self.name = name\n        self.job  = job\n        self.pay  = pay               # real instance data\n    def tax(self):\n        return self.pay * 0.25        # computed on call\n    def info(self):\n        return self.name, self.job, self.pay, self.tax()\nNothing about this class suggests it will be used for database records\u2014it can be im-\nported and used independent of external storage. It\u2019s easy to use it for a database\u2019s\nrecords, though: we can make some persistent objects from this class by simply creating\ninstances as usual, and then storing them by key on an opened shelve:\nC:\\...\\PP4E\\Dbase> python\n>>> from person import Person\n>>> bob   = Person('bob', 'psychologist', 70000)\n>>> emily = Person('emily', 'teacher', 40000)\n>>>\n>>> import shelve\n>>> dbase = shelve.open('cast')          # make new shelve\n>>> for obj in (bob, emily):             # store objects\n...     dbase[obj.name] = obj            # use name for key\n...\n>>> dbase.close()                        # need for bsddb\nHere we used the instance objects\u2019 name attribute as their key in the shelve database.\nWhen we come back and fetch these objects in a later Python session or script, they\nare re-created in memory exactly as they were when they were stored:\nC:\\...\\PP4E\\Dbase> python\n>>> import shelve\n>>> dbase = shelve.open('cast')          # reopen shelve\n>>>\n>>> list(dbase.keys())                   # both objects are here\n['bob', 'emily']\n>>> print(dbase['emily'])\n<person.Person object at 0x0197EF70>\n>>>\n>>> print(dbase['bob'].tax())            # call: bob's tax\n17500.0\nShelve Files | 1319Notice that calling Bob\u2019s tax method works even though we didn\u2019t import the Person\nclass in this last session. Python is smart enough to link this object back to its original\nclass when unpickled, such that all the original methods are available through fetched\nobjects.\nChanging Classes of Objects Stored in Shelves\nTechnically, Python reimports a class to re-create its stored instances as they are fetched\nand unpickled. Here\u2019s how this works:\nStore\nWhen Python pickles a class instance to store it in a shelve, it saves the instance\u2019s\nattributes plus a reference to the instance\u2019s class. In effect, pickled class instances\nin the prior example record the self attributes assigned in the class. Really, Python\nserializes and stores the instance\u2019s __dict__ attribute dictionary along with enough\nsource file information to be able to locate the class\u2019s module later\u2014the names of\nthe instance\u2019s class as well as its class\u2019s enclosing module.\nFetch\nWhen Python unpickles a class instance fetched from a shelve, it re-creates the\ninstance object in memory by reimporting the class using the save class and module\nname strings, assigning the saved attribute dictionary to a new empty instance, and\nlinking the instance back to the class. This is be default, and it can be tailored by\ndefining special methods that will be called by pickle to fetch and store instance\nstate (see the Python library manual for details).\nThe key point in this is that the class and stored instance data are separate. The class\nitself is not stored with its instances, but is instead located in the Python source file and\nreimported later when instances are fetched.\nThe downside of this model is that the class must be importable to load instances off\na shelve (more on this in a moment). The upside is that by modifying external classes\nin module files, we can change the way stored objects\u2019 data is interpreted and used\nwithout actually having to change those stored objects. It\u2019s as if the class is a program\nthat processes stored records.\nTo illustrate, suppose the Person class from the previous section was changed to the\nsource code in Example 17-3.\nExample 17-3. PP4E\\Dbase\\person.py (version 2)\n\"\"\"\na person object: fields + behavior\nchange: the tax method is now a computed attribute\n\"\"\"\nclass Person:\n    def __init__(self, name, job, pay=0):\n        self.name = name\n1320 | Chapter 17:\u2002Databases and Persistenceself.job  = job\n        self.pay  = pay                  # real instance data\n    def __getattr__(self, attr):         # on person.attr\n        if attr == 'tax':\n            return self.pay * 0.30       # computed on access\n        else:\n            raise AttributeError()       # other unknown names\n    def info(self):\n        return self.name, self.job, self.pay, self.tax\nThis revision has a new tax rate (30 percent), introduces a __getattr__ qualification\noverload method, and deletes the original tax method. Because this new version of the\nclass is re-imported when its existing instances are loaded from the shelve file, they\nacquire the new behavior automatically\u2014their tax attribute references are now inter-\ncepted and computed when accessed:\nC:\\...\\PP4E\\Dbase> python\n>>> import shelve\n>>> dbase = shelve.open('cast')      # reopen shelve\n>>>\n>>> print(list(dbase.keys()))        # both objects are here\n['bob', 'emily']\n>>> print(dbase['emily'])\n<person.Person object at 0x019AEE90>\n>>>\n>>> print(dbase['bob'].tax)          # no need to call tax()\n21000.0\nBecause the class has changed, tax is now simply qualified, not called. In addition,\nbecause the tax rate was changed in the class, Bob pays more this time around. Of\ncourse, this example is artificial, but when used well, this separation of classes and\npersistent instances can eliminate many traditional database update programs. In most\ncases, you can simply change the class, not each stored instance, for new behavior.\nShelve Constraints\nAlthough shelves are generally straightforward to use, there are a few rough edges worth\nknowing about.\nKeys must be strings (and str)\nFirst, although they can store arbitrary objects, keys must still be strings. The following\nfails, unless you convert the integer 42 to the string 42 manually first:\ndbase[42] = value      # fails, but str(42) will work\nThis is different from in-memory dictionaries, which allow any immutable object to be\nused as a key, and derives from the shelve\u2019s use of DBM files internally. As we\u2019ve seen,\nShelve Files | 1321keys must further be str strings in Python 3.X, not bytes, because the shelve will at-\ntempt to encode them in all cases.\nObjects are unique only within a key\nAlthough the shelve module is smart enough to detect multiple occurrences of a nested\nobject and re-create only one copy when fetched, this holds true only within a given slot:\ndbase[key] = [object, object]    # OK: only one copy stored and fetched\ndbase[key1] = object\ndbase[key2] = object             # bad?: two copies of object in the shelve\nWhen key1 and key2 are fetched, they reference independent copies of the original\nshared object; if that object is mutable, changes from one won\u2019t be reflected in the\nother. This really stems from the fact the each key assignment runs an independent\npickle operation\u2014the pickler detects repeated objects but only within each pickle call.\nThis may or may not be a concern in your practice, and it can be avoided with extra\nsupport logic, but an object can be duplicated if it spans keys.\nUpdates must treat shelves as fetch-modify-store mappings\nBecause objects fetched from a shelve don\u2019t know that they came from a shelve, oper-\nations that change components of a fetched object change only the in-memory copy,\nnot the data on a shelve:\ndbase[key].attr = value   # shelve unchanged\nTo really change an object stored on a shelve, fetch it into memory, change its parts,\nand then write it back to the shelve as a whole by key assignment:\nobject = dbase[key]       # fetch it\nobject.attr = value       # modify it\ndbase[key] = object       # store back-shelve changed (unless writeback)\nAs noted earlier, the shelve.open call\u2019s optional writeback argument can be used to\navoid the last step here, by automatically caching objects fetched and writing them to\ndisk when the shelve is closed, but this can require substantial memory resources and\nmake close operations slow.\nConcurrent updates are not directly supported\nThe shelve module does not currently support simultaneous updates. Simultaneous\nreaders are OK, but writers must be given exclusive access to the shelve. You can trash\na shelve if multiple processes write to it at the same time, which is a common potential\nin things such as server-side scripts on the Web. If your shelves may be updated by\nmultiple processes, be sure to wrap updates in calls to the os.open standard library\nfunction to lock files and provide exclusive access.\n1322 | Chapter 17:\u2002Databases and PersistenceUnderlying DBM format portability\nWith shelves, the files created by an underlying DBM system used to store your per-\nsistent objects are not necessarily compatible with all possible DBM implementations\nor Pythons. For instance, a file generated by gdbm on Linux, or by the bsddb library on\nWindows, may not be readable by a Python with other DBM modules installed.\nThis is really the same portability issue we discussed for DBM files earlier. As you\u2019ll\nrecall, when a DBM file (or by proxy, a shelve) is created, the dbm module tries to import\nall possible DBM system modules in a predefined order and uses the first that it finds.\nWhen dmb later opens an existing file, it attempts to determine which DBM system\ncreated it by inspecting the files(s). Because the bsddb system is tried first at file creation\ntime and is available on both Windows and many Unix-like systems, your DBM file is\nportable as long as your Pythons support BSD on both platforms. This is also true if all\nplatforms you\u2019ll use fall back on Python\u2019s own dbm.dumb implementation. If the system\nused to create a DBM file is not available on the underlying platform, though, the DBM\nfile cannot be used.\nIf DBM file portability is a concern, make sure that all the Pythons that will read your\ndata use compatible DBM modules. If that is not an option, use the pickle module\ndirectly and flat files for storage (thereby bypassing both shelve and dbm), or use the\nOODB systems we\u2019ll meet later in this chapter. Such systems may also offer a more\ncomplete answer to transaction processing, with calls to commit changes, and automatic\nrollback to prior commit points on errors.\nPickled Class Constraints\nIn addition to these shelve constraints, storing class instances in a shelve adds a set of\nadditional rules you need to be aware of. Really, these are imposed by the pickle mod-\nule, not by shelve, so be sure to follow these if you store class instance objects with\npickle directly too:\nClasses must be importable\nAs we\u2019ve seen, the Python pickler stores instance attributes only when pickling an\ninstance object, and it reimports the class later to re-create the instance. Because\nof that, the classes of stored objects must be importable when objects are\nunpickled\u2014they must be coded unnested at the top level of a module file that is\naccessible on the module import search path at load time (e.g., named in PYTHON\nPATH or in a .pth file, or the current working directory or that of the top-level script).\nFurther, the class usually must be associated with a real imported module when\ninstances are pickled, not with a top-level script (with the module name\n__main__), unless they will only ever be used in the top-level script. You also need\nto be careful about moving class modules after instances are stored. When an in-\nstance is unpickled, Python must find its class\u2019s module on the module search using\nthe original module name (including any package path prefixes) and fetch the class\nShelve Files | 1323from that module using the original class name. If the module or class has been\nmoved or renamed, it might not be found.\nIn applications where pickled objects are shipped over network sockets, it\u2019s pos-\nsible to satisfy this constraint by shipping the text of the class along with stored\ninstances; recipients may simply store the class in a local module file on the import\nsearch path prior to unpickling received instances. Where this is inconvenient or\nimpossible, simpler pickled objects such as lists and dictionaries with nesting may\nbe transferred instead, as they require no source file to be reconstructed.\nClass changes must be backward compatible\nAlthough Python lets you change a class while instances of it are stored on a shelve,\nthose changes must be backward compatible with the objects already stored. For\ninstance, you cannot change the class to expect an attribute not associated with\nalready stored persistent instances unless you first manually update those stored\ninstances or provide extra conversion protocols on the class.\nOther pickle module constraints\nShelves also inherit the pickling systems\u2019 nonclass limitations. As discussed earlier,\nsome types of objects (e.g., open files and sockets) cannot be pickled, and thus\ncannot be stored in a shelve.\nIn an early Python release, persistent object classes also had to either use constructors\nwith no arguments or provide defaults for all constructor arguments (much like the\nnotion of a C++ copy constructor). This constraint was dropped as of Python 1.5.2\u2014\nclasses with nondefaulted constructor arguments now work as is in the pickling system.*\nOther Shelve Limitations\nFinally, although shelves store objects persistently, they are not really object-oriented\ndatabase systems. Such systems also implement features such as immediate automatic\nwrite-through on changes, transaction commits and rollbacks, safe concurrent updates,\nand object decomposition and delayed (\u201clazy\u201d) component fetches based on generated\nobject IDs. Parts of larger objects may be loaded into memory only as they are accessed.\nIt\u2019s possible to extend shelves to support such features manually, but you don\u2019t need\nto\u2014the ZODB system, among others, provides an implementation of a more complete\nobject-oriented database system. It is constructed on top of Python\u2019s built-in pickling\n* Interestingly, Python avoids calling the class to re-create a pickled instance and instead simply makes a class\nobject generically, inserts instance attributes, and sets the instance\u2019s __class__ pointer to the original class\ndirectly. This avoids the need for defaults, but it also means that the class __init__ constructors that are no\nlonger called as objects are unpickled, unless you provide extra methods to force the call. See the library\nmanual for more details, and see the pickle module\u2019s source code (pickle.py in the source library) if you\u2019re\ncurious about how this works. Or see the PyForm example later in this chapter\u2014it does something very\nsimilar with __class__ links to build an instance object from a class and dictionary of attributes, without\ncalling the class\u2019s __init__ constructor. This makes constructor argument defaults unnecessary in classes\nused for records browsed by PyForm, but it\u2019s the same idea.\n1324 | Chapter 17:\u2002Databases and Persistencepersistence support, but it offers additional features for advanced data stores. For more\non ZODB, let\u2019s move on to the next section.\nThe ZODB Object-Oriented Database\nZODB, the Zope Object Database, is a full-featured and Python-specific object-oriented\ndatabase (OODB) system. ZODB can be thought of as a more powerful alternative to\nPython\u2019s shelves of the preceding section. It allows you to store nearly arbitrary Python\nobjects persistently by key, like shelves, but it adds a set of additional features in ex-\nchange for a small amount of extra interface code.\nZODB is not the only OODB available for Python: the Durus system is generally seen\nas a simpler OODB which was inspired by ZODB. While Durus offers some advantages,\nit does not provide all the features of ZODB today, and it has not been as widely de-\nployed (though perhaps in part because it is newer). Because of that, this section focuses\non ZODB to introduce OODB concepts in general.\nZODB is an open source, third-party add-on for Python. It was originally developed as\nthe database mechanism for websites developed with the Zope web framework men-\ntioned in Chapter 12, but it is now available as a standalone package. It\u2019s useful outside\nthe context of both Zope and the Web as a general database management system in\nany domain.\nAlthough ZODB does not support SQL queries, objects stored in ZODB can leverage\nthe full power of the Python language. Moreover, in some applications, stored data is\nmore naturally represented as a structured Python object. Table-based relational sys-\ntems often must represent such data as individual parts scattered across multiple tables\nand associate them with complex and potentially slow key-based joins, or otherwise\nmap them to and from the Python class model. Because OODBs store native Python\nobjects directly, they can often provide a simpler model in systems which do not require\nthe full power of SQL.\nUsing a ZODB database is very similar to Python\u2019s standard library shelves, described\nin the prior section. Just like shelves, ZODB uses the Python pickling system to imple-\nment a persistent dictionary of persistent Python objects. In fact, there is almost no\ndatabase interface to be found\u2014objects are made persistent simply by assigning them\nto keys of the root ZODB dictionary object, or embedding them in objects stored in\nthe database root. And as in a shelve, \u201crecords\u201d take the form of native Python objects,\nprocessed with normal Python syntax and tools.\nUnlike shelves, though, ZODB adds features critical to some types of programs:\nConcurrent updates\nYou don\u2019t need to manually lock files to avoid data corruption if there are poten-\ntially many concurrent writers, the way you would for shelves.\nThe ZODB Object-Oriented Database | 1325Transaction commit and rollback\nIf your program crashes, your changes are not retained unless you explicitly commit\nthem to the database.\nAutomatic updates for some types of in-memory object changes\nObjects in ZODB derived from a persistence superclass are smart enough to know\nthe database must be updated when an attribute is assigned.\nAutomatic caching of objects\nObjects are cached in memory for efficiency and are automatically removed from\nthe cache when they haven\u2019t been used.\nPlatform-independent storage\nBecause ZODB stores your database in a single flat file with large-file support, it is\nimmune to the potential size constraints and DBM filesystem format differences\nof shelves. As we saw earlier in this chapter, a shelve created on Windows using\nbsddb may not be accessible to a script running with gdbm on Linux.\nBecause of such advantages, ZODB is probably worth your attention if you need to\nstore Python objects in a database persistently in a production environment. The only\nsignificant price you\u2019ll pay for using ZODB is a small amount of extra code:\n\u2022 Accessing the database requires a small amount of extra boilerplate code to inter-\nface with ZODB\u2014it\u2019s not a simple open call.\n\u2022 Classes are derived from a persistence superclass if you want them to take advant-\nage of automatic updates on changes\u2014persistent classes are generally not as\ncompletely independent of the database as in shelves, though they can be.\nConsidering the extra functionality ZODB provides beyond shelves, these trade-offs\nare usually more than justified for many applications.\nThe Mostly Missing ZODB Tutorial\nUnfortunately, as I write this edition in June 2010, ZODB is not yet available for Python\n3.X, the version used in this book. Because of that, the prior edition\u2019s Python 2.X ex-\namples and material have been removed from this section. However, in deference to\nPython 2.X users, as well as 3.X readers of some bright future where a 3.X-base ZODB\nhas materialized, I\u2019ve made the prior edition\u2019s ZODB materials and examples available\nin this edition\u2019s examples package.\nSee the Preface for details on the examples package, and see these locations within it\nfor more on ZODB:\nC:\\...\\Dbase\\Zodb-2.x                   # ZODB examples code third edition\nC:\\...\\Dbase\\Zodb-2.x\\Documentaion      # The 3rd Edition's ZODB tutorial\nAlthough I cannot predict the future, ZODB will likely become available for Python\n3.X eventually. In the absence of this, other Python-based OODBs may offer additional\n3.X options.\n1326 | Chapter 17:\u2002Databases and PersistenceTo give you a brief sample of ZODB\u2019s flavor, though, here\u2019s a quick spin through its\noperation in Python 2.X. Once we\u2019ve installed a compatible ZODB, we begin by first\ncreating a database:\n...\\PP4E\\Dbase\\Zodb-2.x> python\n>>> from ZODB import FileStorage, DB\n>>> storage = FileStorage.FileStorage(r'C:\\temp\\mydb.fs')\n>>> db = DB(storage)\n>>> connection = db.open()\n>>> root = connection.root()\nThis is mostly standard \u201cboilerplate\u201d code for connecting to a ZODB database: we\nimport its tools, create a FileStorage and a DB from it, and then open the database and\ncreate the root object. The root object is the persistent dictionary in which objects are\nstored. FileStorage is an object that maps the database to a flat file. Other storage\ninterface options, such as relational database-based storage, are also possible.\nAdding objects to a ZODB database is as simple as in shelves. Almost any Python object\nwill do, including tuples, lists, dictionaries, class instances, and nested combinations\nthereof. As for shelve, simply assign your objects to a key in the database root object\nto make them persistent:\n>>> object1 = (1, 'spam', 4, 'YOU')\n>>> object2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n>>> object3 = {'name': ['Bob', 'Doe'],\n               'age':  42,\n               'job':  ('dev', 'mgr')}\n>>> root['mystr']   = 'spam' * 3\n>>> root['mytuple'] = object1\n>>> root['mylist']  = object2\n>>> root['mydict']  = object3\n>>> root['mylist']\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nBecause ZODB supports transaction rollbacks, you must commit your changes to the\ndatabase to make them permanent. Ultimately, this transfers the pickled representation\nof your objects to the underlying file storage medium\u2014here, three files that include the\nname of the file we gave when opening:\n>>> import transaction\n>>> transaction.commit()\n>>> storage.close()\n...\\PP4E\\Dbase\\Zodb-2.x> dir /B c:\\temp\\mydb*\nmydb.fs\nmydb.fs.index\nmydb.fs.tmp\nWithout the final commit in this session, none of the changes we made would be saved.\nThis is what we want in general\u2014if a program aborts in the middle of an update task,\nThe ZODB Object-Oriented Database | 1327none of the partially complete work it has done is retained. In fact, ZODB supports\ngeneral database undo operations.\nPulling persistent objects back from ZODB in another session or program is just as\nstraightforward: reopen the database as before and index the root to fetch objects back\ninto memory. Like shelves, the database root supports dictionary interfaces\u2014it may\nbe indexed, has dictionary methods and a length, and so on:\n...\\PP4E\\Dbase\\Zodb-2.x> python\n>>> from ZODB import FileStorage, DB\n>>> storage = FileStorage.FileStorage(r'C:\\temp\\mydb.fs')\n>>> db = DB(storage)\n>>> connection = db.open()\n>>> root = connection.root()                          # connect\n>>> len(root), root.keys()                            # size, index\n(4 ['mylist', 'mystr', 'mytuple', 'mydict'])\n>>> root['mylist']                                    # fetch objects\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n>>> root['mydict']\n{'job': ('dev', 'mgr'), 'age': 42, 'name': ['Bob', 'Doe']}\n>>> root['mydict']['name'][-1]                        # Bob's last name\n'Doe'\nBecause the database root looks just like a dictionary, we can process it with normal\ndictionary code\u2014stepping through the keys list to scan record by record, for instance:\n>>> for key in root.keys():\n        print('%s => %s' % (key.ljust(10), root[key]))\nmylist     => [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nmystr      => spamspamspam\nmytuple    => (1, 'spam', 4, 'YOU')\nmydict     => {'job': ('dev', 'mgr'), 'age': 42, 'name': ['Bob', 'Doe']}\nAlso like pickling and shelves, ZODB supports storage and retrieval of class instance\nobjects, though they must inherit from a superclass which provides required protocol\nand intercepts attribute changes in order to flush them to disk automatically:\nfrom persistent import Persistent\nclass Person(Persistent):\n    def __init__(self, name, job=None, rate=0):\n        self.name = name\n        self.job  = job\n        self.rate = rate\n    def changeRate(self, newrate):\n        self.rate = newrate                   # automatically updates database\nWhen changing ZODB persistent class instances, in-memory attribute changes are\nautomatically written back to the database. Other types of changes, such as in-place\nappends and key assignments, still require reassignment to the original key as in shelves\n1328 | Chapter 17:\u2002Databases and Persistenceto force the change to be written to disk (built-in list and dictionary objects do not\nknow that they are persistent).\nBecause ZODB does not yet work with Python 3.X, that\u2019s as much as we can say about\nit in this book. For more details, search for ZODB and Zope resources on the Web, and\nsee the examples package resources listed earlier. Here, let\u2019s move on to see how Python\nprograms can make use of a very different sort of database interface\u2014relational data-\nbases and SQL.\nSQL Database Interfaces\nThe shelve module and ZODB package of the prior sections are powerful tools. Both\nallow scripts to throw nearly arbitrary Python objects on a keyed-access file and load\nthem back later\u2014in a single step for shelves and with a small amount of administrative\ncode for ZODB. Especially for applications that record highly structured data, object\ndatabases can be convenient and efficient\u2014there is no need to split and later join to-\ngether the parts of large objects, and stored data is processed with normal Python syntax\nbecause it is normal Python objects.\nShelves and ZODB aren\u2019t relational database systems, though; objects (records) are\naccessed with a single key, and there is no notion of SQL queries. Shelves, for instance,\nare essentially databases with a single index and no other query-processing support.\nAlthough it\u2019s possible to build a multiple-index interface to store data with multiple\nshelves, it\u2019s not a trivial task and requires manually coded extensions.\nZODB supports some types of searching beyond shelve (e.g., its cataloging feature),\nand persistent objects may be traversed with all the power of the Python language.\nHowever, neither shelves nor ZODB object-oriented databases provide the full gener-\nality of SQL queries. Moreover, especially for data that has a naturally tabular structure,\nrelational databases may sometimes be a better fit.\nFor programs that can benefit from the power of SQL, Python also broadly supports\nrelational database management systems (RDBMSs). Relational databases are not nec-\nessarily mutually exclusive with the object persistence topics we studied earlier in this\nchapter\u2014it is possible, for example, to store the serialized string representation of a\nPython object produced by pickling in a relational database. ZODB also supports the\nnotion of mapping an object database to a relational storage medium.\nThe databases we\u2019ll meet in this section, though, are structured and processed in very\ndifferent ways:\n\u2022 They store data in related tables of columns (rather than in persistent dictionaries\nof arbitrarily structured persistent Python objects).\n\u2022 They support the SQL query language for accessing data and exploiting relation-\nships among it (instead of Python object traversals).\nSQL Database Interfaces | 1329For some applications, the end result can be a potent combination. Moreover, some\nSQL-based database systems provide industrial-strength persistence support for\nenterprise-level data.\nToday, there are freely available interfaces that let Python scripts utilize all common\nrelational database systems, both free and commercial: MySQL, Oracle, Sybase, In-\nformix, InterBase, PostgreSQL (Postgres), SQLite, ODBC, and more. In addition, the\nPython community has defined a database API specification that works portably with\na variety of underlying database packages. Scripts written for this API can be migrated\nto different database vendor packages, with minimal or no source code changes.\nAs of Python 2.5, Python itself includes built-in support for the SQLite relational da-\ntabase system as part of its standard library. Because this system supports the portable\ndatabase API, it serves as a tool for both program storage and prototyping\u2014systems\ndeveloped with SQLite work largely unchanged when a more feature-rich database such\nas MySQL or Oracle is deployed.\nMoreover, the popular SQLObject and SQLAlchemy third-party systems both provide\nan Object Relational Mapper (ORM), which grafts an object interface onto your data-\nbase, in which tables are modeled by as Python classes, rows by instances of those\nclasses, and columns by instance attributes. Since ORMs largely just wrap SQL data-\nbases in Python classes, we\u2019ll defer their coverage until later in this chapter; for now,\nlet\u2019s explore SQL basics in Python.\nSQL Interface Overview\nLike ZODB, and unlike the pickle and shelve persistence modules presented earlier,\nmost SQL databases are optional extensions that are not part of Python itself. SQLite\nis the only relational database package that comes with Python. Moreover, you need\nto know SQL to fully understand their interfaces. Because we don\u2019t have space to teach\nSQL in this text, this section gives a brief overview of the API; please consult other SQL\nreferences and the database API resources mentioned in the next section for more de-\ntails that we\u2019ll skip here.\nThe good news is that you can access SQL databases from Python, through a straight-\nforward and portable model. The Python database API specification defines an interface\nfor communicating with underlying database systems from Python scripts. Vendor-\nspecific database interfaces for Python may or may not conform to this API completely,\nbut all database extensions for Python in common use are minor variations on a theme.\nUnder the database API, SQL databases in Python are grounded on three core\nconcepts:\nConnection objects\nRepresent a connection to a database, are the interface to rollback and commit\noperations, provide package implementation details, and generate cursor objects.\n1330 | Chapter 17:\u2002Databases and PersistenceCursor objects\nRepresent an SQL statement submitted as a string and can be used to access and\nstep through SQL statement results.\nQuery results of SQL select statements\nAre returned to scripts as Python sequences of sequences (e.g., a list of tuples),\nrepresenting database tables of rows. Within these row sequences, column field\nvalues are normal Python objects such as strings, integers, and floats (e.g., [('bob',\n48), ('emily',47)]). Column values may also be special types that encapsulate\nthings such as date and time, and database NULL values are returned as the Python\nNone object.\nBeyond this, the API defines a standard set of database exception types, special database\ntype object constructors, and informational top-level calls including thread safety and\nreplacement style checks.\nFor instance, to establish a database connection under the Python API-compliant Ora-\ncle interface, install the commonly used Python Oracle extension module as well as\nOracle itself, and then run a statement of this form:\nconnobj = connect(\"user/password@system\")\nThis call\u2019s arguments may vary per database and vendor (e.g., some may require net-\nwork details or a local file\u2019s name), but they generally contain what you provide to log\nin to your database system. Once you have a connection object, there a variety of things\nyou can do with it, including:\nconnobj.close()                       close connection now (not at object __del__ time)\nconnobj.commit()                      commit any pending transactions to the database\nconnobj.rollback()                    roll database back to start of pending transactions\nBut one of the most useful things to do with a connection object is to generate a cursor\nobject:\ncursobj = connobj.cursor()            return a new cursor object for running SQL\nCursor objects have a set of methods, too (e.g., close to close the cursor before its\ndestructor runs, and callproc to call a stored procedure), but the most important may\nbe this one:\ncursobj.execute(sqlstring [, parameters])   run SQL query or command string\nParameters are passed in as a sequence or mapping of values, and are substituted into\nthe SQL statement string according to the interface module\u2019s replacement target con-\nventions. The execute method can be used to run a variety of SQL statement strings:\n\u2022 DDL definition statements (e.g., CREATE TABLE)\n\u2022 DML modification statements (e.g., UPDATE or INSERT)\n\u2022 DQL query statements (e.g., SELECT)\nSQL Database Interfaces | 1331After running an SQL statement, the cursor\u2019s rowcount attribute gives the number of\nrows changed (for DML changes) or fetched (for DQL queries), and the cursor\u2019s\ndescription attribute gives column names and types after a query; execute also returns\nthe number of rows affected or fetched in the most vendor interfaces. For DQL query\nstatements, you must call one of the fetch methods to complete the operation:\ntuple       = cursobj.fetchone()          fetch next row of a query result\nlistoftuple = cursobj.fetchmany([size])   fetch next set of rows of query result\nlistoftuple = cursobj.fetchall()          fetch all remaining rows of the result\nAnd once you\u2019ve received fetch method results, table information is processed using\nnormal Python sequence operations; for example, you can step through the tuples in\na fetchall result list with a simple for loop or comprehension expression. Most Python\ndatabase interfaces also allow you to provide values to be passed to SQL statement\nstrings, by providing targets and a tuple of parameters. For instance:\nquery = 'SELECT name, shoesize FROM spam WHERE job = ? AND age = ?'\ncursobj.execute(query, (value1, value2))\nresults = cursobj.fetchall()\nfor row in results: ...\nIn this event, the database interface utilizes prepared statements (an optimization and\nconvenience) and correctly passes the parameters to the database regardless of their\nPython types. The notation used to code targets in the query string may vary in some\ndatabase interfaces (e.g., :p1 and :p2 or two %s, rather than the two ?s used by the\nOracle interface); in any event, this is not the same as Python\u2019s % string formatting\noperator, as it sidesteps security issues along the way.\nFinally, if your database supports stored procedures, you can call them with the call\nproc method or by passing an SQL CALL or EXEC statement string to the execute method.\ncallproc may generate a result table retrieved with a fetch variant, and returns a modi-\nfied copy of the input sequence\u2014input parameters are left untouched, and output and\ninput/output parameters are replaced with possibly new values. Additional API fea-\ntures, including support for database blobs (roughly, with sized results), is described\nin the API\u2019s documentation. For now, let\u2019s move on to do some real SQL processing\nin Python.\nAn SQL Database API Tutorial with SQLite\nWe don\u2019t have space to provide an exhaustive reference for the database API in this\nbook. To sample the flavor of the interface, though, let\u2019s step through a few simple\nexamples. We\u2019ll use the SQLite database system for this tutorial. SQLite is a standard\npart of Python itself, which you can reasonably expect to be available in all Python\ninstallations. Although SQLite implements a complete relational database system, it\ntakes the form of an in-process library instead of a server. This generally makes it better\nsuited for program storage than for enterprise-level data needs.\n1332 | Chapter 17:\u2002Databases and PersistenceThanks to Python\u2019s portable database API, though, other popular database packages\nsuch as PostgreSQL, MySQL, and Oracle are used almost identically; the initial call to\nlog in to the database will be all that normally requires different argument values for\nscripts that use standard SQL code. Because of this, we can use the SQLite system both\nas a prototyping tool in applications development and as an easy way to get started\nwith the Python SQL database API in this book.\nAs mentioned earlier, the third edition\u2019s coverage of MySQL had to be\nreplaced here because the interface used is not yet ported to Python 3.X.\nHowever, the third edition\u2019s MySQL-based examples and overview are\navailable in the book examples package, in directory C:\\...\\PP4E\\Dbase\n\\Sql\\MySql-2.X, and its Documentation subdirectory. The examples are\nin Python 2.X form, but their database-related code is largely version\nneutral. Since that code is also largely database neutral, it is probably of\nlimited value to most readers; the scripts listed in this book should work\non other database packages like MySQL with only trivial changes.\nGetting started\nRegardless of which database system your scripts talk to, the basic SQL interface in\nPython is very simple. In fact, it\u2019s hardly object-oriented at all\u2014queries and other da-\ntabase commands are sent as strings of SQL. If you know SQL, you already have most\nof what you need to use relational databases in Python. That\u2019s good news if you fall\ninto this category, but adds a prerequisite if you don\u2019t.\nThis isn\u2019t a book on the SQL language, so we\u2019ll defer to other resources for details on\nthe commands we\u2019ll be running here (O\u2019Reilly has a suite of books on the topic). In\nfact, the databases we\u2019ll use are tiny, and the commands we\u2019ll use are deliberately simple\nas SQL goes\u2014you\u2019ll want to extrapolate from what you see here to the more realistic\ntasks you face. This section is just a brief look at how to use the Python language in\nconjunction with an SQL database.\nWhether large or small, though, the Python code needed to process your database turns\nout to be surprisingly straightforward. To get started, the first thing we need to do is\nopen a connection to the database and create a table for storing records:\nC:\\...\\PP4E\\Dbase\\Sql> python\n>>> import sqlite3\n>>> conn = sqlite3.connect('dbase1')     # use a full path for files elsewhere\nWe start out by importing the Python SQLite interface here\u2014it\u2019s a standard library\nmodule called sqlite3 to our scripts. Next we create a connection object, passing in\nthe items our database requires at start-up time\u2014here, the name of the local file where\nour databases will be stored. This file is what you\u2019ll want to back up to save your\ndatabase. It will create the file if needed, or open its current content; SQLite also accepts\nthat special string \u201c:memory:\u201d to create a temporary database in memory instead.\nSQL Database Interfaces | 1333As long as a script sticks to using standard SQL code, the connect call\u2019s arguments are\nusually the only thing that can vary across different database systems. For example, in\nthe MySQL interface this call accepts a network host\u2019s domain name, user name, and\npassword, passed as keyword arguments instead, and the Oracle example sketched\nearlier expects a more specific sting syntax. Once we\u2019ve gotten past this platform-\nspecific call, though, the rest of the API is largely database neutral.\nMaking databases and tables\nNext, let\u2019s make a cursor for submitting SQL statements to the database server, and\nsubmit one to create a first table:\n>>> curs = conn.cursor()\n>>>>\n>>> tblcmd = 'create table people (name char(30), job char(10), pay int(4))'\n>>> curs.execute(tblcmd)\nThe last command here creates the table called \u201cpeople\u201d within the database; the name,\njob, and pay information specifies the columns in this table, as well as their datatypes,\nusing a \u201ctype(size)\u201d syntax\u2014two strings and an integer. Datatypes can be more so-\nphisticated than ours, but we\u2019ll ignore such details here (see SQL references). In SQLite,\nthe file is the database, so there\u2019s no notion of creating or using a specific database\nwithin it, as there is in some systems. At this point, there is a simple flat file in the\ncurrent working directory named data1, which contains binary data and contains our\npeople database table.\nAdding records\nSo far, we\u2019ve logged in (which just means opening a local file in SQLite) and created a\ntable. Next let\u2019s start a new Python session and create some records. There are three\nbasic statement-based approaches we can use here: inserting one row at a time or in-\nserting multiple rows with a single call statement or a Python loop. Here is the simple\ncase (I\u2019m omitting some call return values here if they are irrelevant to the story):\nC:\\...\\PP4E\\Dbase\\Sql> python\n>>> import sqlite3\n>>> conn = sqlite3.connect('dbase1')\n>>> curs = conn.cursor()\n>>> curs.execute('insert into people values (?, ?, ?)', ('Bob', 'dev', 5000))\n>>> curs.rowcount\n1\n>>> sqlite3.paramstyle\n'qmark'\nCreate a cursor object to submit SQL statements to the database server as before. The\nSQL insert command adds a single row to the table. After an execute call, the cursor\u2019s\nrowcount attribute gives the number of rows produced or affected by the last statement\nrun. This is also available as the return value of an execute call in some database inter-\nface modules, but this is not defined in the database API specification, and isn\u2019t\n1334 | Chapter 17:\u2002Databases and Persistenceprovided in SQLite; in other words, don\u2019t depend on it if you want your database scripts\nto work on other database systems.\nParameters to substitute into the SQL statement string are generally passed in as a\nsequence (e.g., list or tuple). Notice the module\u2019s paramstyle\u2014this tells us what style\nit uses for substitution targets in the statement string. Here, qmark means this module\naccepts ? for replacement targets. Other database modules might use styles such as\nformat (meaning a %s target), or numeric indexes or mapping keys; see the DB API for\nmore details.\nTo insert multiple rows with a single statement, use the executemany method and a\nsequence of row sequences (e.g., a list of lists). This call is like calling execute once for\neach row sequence in the argument, and in fact may be implemented as such; database\ninterfaces may also use database-specific techniques to make this run quicker, though:\n>>> curs.executemany('insert into people values (?, ?, ?)',\n...          [ ('Sue', 'mus', '70000'),\n...            ('Ann', 'mus', '60000')])\n>>> curs.rowcount\n2\nWe inserted two rows at once in the last statement. It\u2019s hardly any more work to achieve\nthe same result by inserting one row at a time with a Python loop:\n>>> rows = [['Tom', 'mgr', 100000],\n...         ['Kim', 'adm', 30000],\n...         ['pat', 'dev', 90000]]\n>>> for row in rows:\n...     curs.execute('insert into people values (? , ?, ?)', row)\n...\n>>> conn.commit()\nBlending Python and SQL like this starts to open up all sorts of interesting possibilities.\nNotice the last command; we always need to call the connection\u2019s commit method to\nwrite our changes out to the database. Otherwise, when the connection is closed, our\nchanges may be lost. In fact, until we call the commit method, none of our inserts may\nbe visible from other database connections.\nTechnically, the API suggests that a connection object should automatically call its\nrollback method to back out changes that have not yet been committed, when it is\nclosed (which happens manually when its close method is called, or automatically\nwhen the connection object is about to be garbage collected). For database systems\nthat don\u2019t support transaction commit and rollback operations, these calls may do\nnothing. SQLite implements both the commit and rollback methods; the latter rolls\nback any changes made since the last commit.\nSQL Database Interfaces | 1335Running queries\nOK, we\u2019ve now added six records to our database table. Let\u2019s run an SQL query to see\nhow we did:\n>>> curs.execute('select * from people')\n>>> curs.fetchall()\n[('Bob', 'dev', 5000), ('Sue', 'mus', 70000), ('Ann', 'mus', 60000), ('Tom', 'mgr',\n100000), ('Kim', 'adm', 30000), ('pat', 'dev', 90000)]\nRun an SQL select statement with a cursor object to grab all rows and call the cursor\u2019s\nfetchall to retrieve them. They come back to our script as a sequence of sequences. In\nthis module, it\u2019s a list of tuples\u2014the outer list represents the result table, the nested\ntuples are that table\u2019s rows, and the nested tuple\u2019s contents are the column data. Be-\ncause it\u2019s all Python data, once we get the query result, we process it with normal Python\ncode. For example, to make the display a bit more coherent, loop through the query\u2019s\nresult as usual:\n>>> curs.execute('select * from people')\n>>> for row in curs.fetchall():\n...     print(row)\n...\n('Bob', 'dev', 5000)\n('Sue', 'mus', 70000)\n('Ann', 'mus', 60000)\n('Tom', 'mgr', 100000)\n('Kim', 'adm', 30000)\n('pat', 'dev', 90000)\nTuple unpacking comes in handy in loops here, too, to pick out column values as we\ngo. Here\u2019s a simple formatted display of two of the columns\u2019 values:\n>>> curs.execute('select * from people')\n>>> for (name, job, pay) in curs.fetchall():\n...     print(name, ':', pay)\n...\nBob : 5000\nSue : 70000\nAnn : 60000\nTom : 100000\nKim : 30000\npat : 90000\nBecause the query result is a sequence, we can use Python\u2019s powerful sequence and\niteration tools to process it. For instance, to select just the name column values, we can\nrun a more specific SQL query and get a list of tuples:\n>>> curs.execute('select name from people')\n>>> names = curs.fetchall()\n>>> names\n[('Bob',), ('Sue',), ('Ann',), ('Tom',), ('Kim',), ('pat',)]\nOr we can use a Python list comprehension to pick out the fields we want\u2014by using\nPython code, we have more control over the data\u2019s content and format:\n1336 | Chapter 17:\u2002Databases and Persistence>>> curs.execute('select * from people')\n>>> names = [rec[0] for rec in curs.fetchall()]\n>>> names\n['Bob', 'Sue', 'Ann', 'Tom', 'Kim', 'pat']\nThe fetchall call we\u2019ve used so far fetches the entire query result table all at once, as\na single sequence (an empty sequence comes back, if the result is empty). That\u2019s con-\nvenient, but it may be slow enough to block the caller temporarily for large result tables\nor generate substantial network traffic if the server is running remotely (something\ncould easily require a parallel thread in GUI). To avoid such a bottleneck, we can also\ngrab just one row, or a bunch of rows, at a time with fetchone and fetchmany. The\nfetchone call returns the next result row or a None false value at the end of the table:\n>>> curs.execute('select * from people')\n>>> while True:\n...     row = curs.fetchone()\n...     if not row: break\n...     print(row)\n...\n('Bob', 'dev', 5000)\n('Sue', 'mus', 70000)\n('Ann', 'mus', 60000)\n('Tom', 'mgr', 100000)\n('Kim', 'adm', 30000)\n('pat', 'dev', 90000)\nThe fetchmany call returns a sequence of rows from the result, but not the entire table;\nyou can specify how many rows to grab each time with a parameter or rely on the default\nas given by the cursor\u2019s arraysize attribute. Each call gets at most that many more rows\nfrom the result or an empty sequence at the end of the table:\n>>> curs.execute('select * from people')\n>>> while True:\n...     rows = curs.fetchmany()           # size=N optional argument\n...     if not rows: break\n...     for row in rows:\n...         print(row)\n...\n('Bob', 'dev', 5000)\n('Sue', 'mus', 70000)\n('Ann', 'mus', 60000)\n('Tom', 'mgr', 100000)\n('Kim', 'adm', 30000)\n('pat', 'dev', 90000)\nFor this module at least, the result table is exhausted after a fetchone or fetchmany\nreturns a False value. The DB API says that fetchall returns \u201call (remaining) rows,\u201d\nso you generally need to call execute again to regenerate results before fetching\nnew data:\n>>> curs.fetchone()\n>>> curs.fetchmany()\n[]\nSQL Database Interfaces | 1337>>> curs.fetchall()\n[]\nNaturally, we can do more than fetch an entire table; the full power of the SQL language\nis at your disposal in Python:\n>>> curs.execute('select name, job from people where pay > 60000')\n>>> curs.fetchall()\n[('Sue', 'mus'), ('Tom', 'mgr'), ('pat', 'dev')]\nThe last query fetches name and job fields for people who earn more than $60,000. The\nnext is similar, but passes in the selection value as a parameter and orders the result\ntable:\n>>> query = 'select name, job from people where pay >= ? order by name'\n>>> curs.execute(query, [60000])\n>>> for row in curs.fetchall(): print(row)\n...\n('Ann', 'mus')\n('Sue', 'mus')\n('Tom', 'mgr')\n('pat', 'dev')\nRunning updates\nCursor objects also are used to submit SQL update statements to the database server\u2014\nupdates, deletes, and inserts. We\u2019ve already seen the insert statement at work. Let\u2019s\nstart a new session to perform some other kinds of updates; we begin with the same\ndata we had in the prior session:\nC:\\...\\PP4E\\Dbase\\Sql> python\n>>> import sqlite3\n>>> conn = sqlite3.connect('dbase1')\n>>> curs = conn.cursor()\n>>> curs.execute('select * from people')\n>>> curs.fetchall()\n[('Bob', 'dev', 5000), ('Sue', 'mus', 70000), ('Ann', 'mus', 60000), ('Tom', 'mgr',\n100000), ('Kim', 'adm', 30000), ('pat', 'dev', 90000)]\nThe SQL update statement changes records\u2014the following changes three records\u2019 pay\ncolumn values to 65000 (Bob, Ann, and Kim), because their pay was no more than\n$60,000. As usual, the cursor\u2019s rowcount gives the number of records changed:\n>>> curs.execute('update people set pay=? where pay <= ?', [65000, 60000])\n>>> curs.rowcount\n3\n>>> curs.execute('select * from people')\n>>> curs.fetchall()\n[('Bob', 'dev', 65000), ('Sue', 'mus', 70000), ('Ann', 'mus', 65000), ('Tom', 'mgr',\n100000), ('Kim', 'adm', 65000), ('pat', 'dev', 90000)]\nThe SQL delete statement removes records, optionally according to a condition (to\ndelete all records, omit the condition). In the following, we delete Bob\u2019s record, as well\nas any record with a pay that is at least $90,000:\n1338 | Chapter 17:\u2002Databases and Persistence>>> curs.execute('delete from people where name = ?', ['Bob'])\n>>> curs.execute('delete from people where pay >= ?',(90000,))\n>>> curs.execute('select * from people')\n>>> curs.fetchall()\n[('Sue', 'mus', 70000), ('Ann', 'mus', 65000), ('Kim', 'adm', 65000)]\n>>> conn.commit()\nFinally, remember to commit your changes to the database before exiting Python, as-\nsuming you wish to keep them. Without a commit, a connection rollback or close call,\nas well as the connection\u2019s __del__ deletion method, will back out uncommitted\nchanges. Connection objects are automatically closed if they are still open when they\nare garbage collected, which in turn triggers a __del__ and a rollback; garbage collection\nhappens automatically on program exit, if not sooner.\nBuilding Record Dictionaries\nNow that we\u2019ve seen the basics in action, let\u2019s move on and apply them to a few larger\ntasks. The SQL API defines query results to be sequences of sequences. One of the more\ncommon features that people seem to miss from the API is the ability to get records\nback as something more structured\u2014a dictionary or class instance, for example, with\nkeys or attributes giving column names. The ORMs we\u2019ll meet at the end of this chapter\nmap to class instances, but because this is Python, it\u2019s easy to code this kind of trans-\nformation in other ways. Moreover, the API already gives us the tools we need.\nUsing table descriptions\nFor example, after a query execute call, the DB API specifies that the cursor\u2019s\ndescription attribute gives the names and (for some databases) types of the columns\nin the result table. To see how, let\u2019s continue with the database in the state in which\nwe left it in the prior section:\n>>> curs.execute('select * from people')\n>>> curs.description\n(('name', None, None, None, None, None, None), ('job', None, None, None, None, None,\nNone), ('pay', None, None, None, None, None, None))\n>>> curs.fetchall()\n[('Sue', 'mus', 70000), ('Ann', 'mus', 65000), ('Kim', 'adm', 65000)]\nFormally, the description is a sequence of column-description sequences, each of the\nfollowing form. See the DB API for more on the meaning of the type code slot\u2014it maps\nto objects at the top level of the database interface module, but the sqlite3 module\nimplements only the name component:\n(name, type_code, display_size, internal_size, precision, scale, null_ok)\nNow, we can use this metadata anytime we want to label the columns\u2014for instance,\nin a formatted records display (be sure to regenerate a query result first, since the prior\nresult has been fetched):\nSQL Database Interfaces | 1339>>> curs.execute('select * from people')\n>>> colnames = [desc[0] for desc in curs.description]\n>>> colnames\n['name', 'job', 'pay']\n>>> for row in curs.fetchall():\n...     for name, value in zip(colnames, row):\n...         print(name, '\\t=>', value)\n...     print()\n...\nname    => Sue\njob     => mus\npay     => 70000\nname    => Ann\njob     => mus\npay     => 65000\nname    => Kim\njob     => adm\npay     => 65000\nNotice how a tab character is used to try to make this output align; a better approach\nmight be to determine the maximum field name length (we\u2019ll see how in a later\nexample).\nRecord dictionaries construction\nIt\u2019s a minor extension of our formatted display code to create a dictionary for each\nrecord, with field names for keys\u2014we just need to fill in the dictionary as we go:\n>>> curs.execute('select * from people')\n>>> colnames = [desc[0] for desc in curs.description]\n>>> rowdicts = []\n>>> for row in curs.fetchall():\n...     newdict = {}\n...     for name, val in zip(colnames, row):\n...         newdict[name] = val\n...     rowdicts.append(newdict)\n...\n>>> for row in rowdicts: print(row)\n...\n{'pay': 70000, 'job': 'mus', 'name': 'Sue'}\n{'pay': 65000, 'job': 'mus', 'name': 'Ann'}\n{'pay': 65000, 'job': 'adm', 'name': 'Kim'}\nBecause this is Python, though, there are more powerful ways to build up these record\ndictionaries. For instance, the dictionary constructor call accepts the zipped name/\nvalue pairs to fill out the dictionaries for us:\n>>> curs.execute('select * from people')\n>>> colnames = [desc[0] for desc in curs.description]\n>>> rowdicts = []\n>>> for row in curs.fetchall():\n...     rowdicts.append( dict(zip(colnames, row)) )\n1340 | Chapter 17:\u2002Databases and Persistence...\n>>> rowdicts[0]\n{'pay': 70000, 'job': 'mus', 'name': 'Sue'}\nAnd finally, a list comprehension will do the job of collecting the dictionaries into a\nlist\u2014not only is this less to type, but it probably runs quicker than the original version:\n>>> curs.execute('select * from people')\n>>> colnames = [desc[0] for desc in curs.description]\n>>> rowdicts = [dict(zip(colnames, row)) for row in curs.fetchall()]\n>>> rowdicts[0]\n{'pay': 70000, 'job': 'mus', 'name': 'Sue'}\nOne of the things we lose when moving to dictionaries is record field order\u2014if you\nlook back at the raw result of fetchall, you\u2019ll notice that record fields are in the name,\njob, and pay order in which they were stored. Our dictionary\u2019s fields come back in the\npseudorandom order of Python mappings. As long as we fetch fields by key, this is\nirrelevant to our script. Tables still maintain their order, and dictionary construction\nworks fine because the description result tuple is in the same order as the fields in row\ntuples returned by queries.\nWe\u2019ll leave the task of translating record tuples into class instances as a suggested\nexercise, except for two hints: Python\u2019s standard library collections module imple-\nments more exotic data types, such as named tuples and ordered dictionaries; and we\ncan access fields as attributes rather than as keys, by simply creating an empty class\ninstance and assigning to attributes with the Python setattr function. Classes would\nalso provide a natural place to code inheritable tools such as standard display methods.\nIn fact, this is part of the utility that the upcoming ORMs can provide for us.\nAutomating with scripts and modules\nUp to this point, we\u2019ve essentially used Python as a command-line SQL client\u2014our\nqueries have been typed and run interactively. All the kinds of code we\u2019ve run, though,\ncan be used as the basis of database access in script files. Working interactively requires\nretyping things such as multiline loops, which can become tedious. With scripts, we\ncan automate our work.\nTo demonstrate, let\u2019s make the last section\u2019s prior example into a utility module\u2014\nExample 17-4 is a reusable module that knows how to translate the result of a query\nfrom row tuples to row dictionaries.\nExample 17-4. PP4E\\Dbase\\Sql\\makedicts.py\n\"\"\"\nconvert list of row tuples to list of row dicts with field name keys\nthis is not a command-line utility: hardcoded self-test if run\n\"\"\"\ndef makedicts(cursor, query, params=()):\n    cursor.execute(query, params)\n    colnames = [desc[0] for desc in cursor.description]\nSQL Database Interfaces | 1341rowdicts = [dict(zip(colnames, row)) for row in cursor.fetchall()]\n    return rowdicts\nif __name__ == '__main__':   # self test\n    import sqlite3\n    conn = sqlite3.connect('dbase1')\n    cursor = conn.cursor()\n    query  = 'select name, pay from people where pay < ?'\n    lowpay = makedicts(cursor, query, [70000])\n    for rec in lowpay: print(rec)\nAs usual, we can run this file from the system command line as a script to invoke its\nself-test code:\n...\\PP4E\\Dbase\\Sql> makedicts.py\n{'pay': 65000, 'name': 'Ann'}\n{'pay': 65000, 'name': 'Kim'}\nOr we can import it as a module and call its function from another context, like the\ninteractive prompt. Because it is a module, it has become a reusable database tool:\n...\\PP4E\\Dbase\\Sql> python\n>>> from makedicts import makedicts\n>>> from sqlite3 import connect\n>>> conn = connect('dbase1')\n>>> curs = conn.cursor()\n>>> curs.execute('select * from people')\n>>> curs.fetchall()\n[('Sue', 'mus', 70000), ('Ann', 'mus', 65000), ('Kim', 'adm', 65000)]\n>>> rows = makedicts(curs, \"select name from people where job = 'mus'\")\n>>> rows\n[{'name': 'Sue'}, {'name': 'Ann'}]\nOur utility handles arbitrarily complex queries\u2014they are simply passed through the\nDB API to the database server or library. The order by clause here sorts the result on\nthe name field:\n>>> query = 'select name, pay from people where job = ? order by name'\n>>> musicians = makedicts(curs, query, ['mus'])\n>>> for row in musicians: print(row)\n...\n{'pay': 65000, 'name': 'Ann'}\n{'pay': 70000, 'name': 'Sue'}\nTying the Pieces Together\nSo far, we\u2019ve learned how to make databases and tables, insert records into tables, query\ntable contents, and extract column names. For reference, and to show how these tech-\nniques are combined, Example 17-5 collects them into a single script.\n1342 | Chapter 17:\u2002Databases and PersistenceExample 17-5. PP4E\\Dbase\\Sql\\testdb.py\nfrom sqlite3 import connect\nconn = connect('dbase1')\ncurs = conn.cursor()\ntry:\n    curs.execute('drop table people')\nexcept:\n    pass  # did not exist\ncurs.execute('create table people (name char(30), job char(10), pay int(4))')\ncurs.execute('insert into people values (?, ?, ?)', ('Bob', 'dev', 50000))\ncurs.execute('insert into people values (?, ?, ?)', ('Sue', 'dev', 60000))\ncurs.execute('select * from people')\nfor row in curs.fetchall():\n    print(row)\ncurs.execute('select * from people')\ncolnames = [desc[0] for desc in curs.description]\nwhile True:\n    print('-' * 30)\n    row = curs.fetchone()\n    if not row: break\n    for (name, value) in zip(colnames, row):\n        print('%s => %s' % (name, value))\nconn.commit()   # save inserted records\nRefer to prior sections in this tutorial if any of the code in this script is unclear. When\nrun, it creates a two-record database and lists its content to the standard output stream:\nC:\\...\\PP4E\\Dbase\\Sql> testdb.py\n('Bob', 'dev', 50000)\n('Sue', 'dev', 60000)\n------------------------------\nname => Bob\njob => dev\npay => 50000\n------------------------------\nname => Sue\njob => dev\npay => 60000\n------------------------------\nAs is, this example is really just meant to demonstrate the database API. It hardcodes\ndatabase names, and it re-creates the database from scratch each time. We could turn\nthis code into generally useful tools by refactoring it into reusable parts, as we\u2019ll see\nlater in this section. First, though, let\u2019s explore techniques for getting data into our\ndatabases.\nSQL Database Interfaces | 1343Loading Database Tables from Files\nOne of the nice things about using Python in the database domain is that you can\ncombine the power of the SQL query language with the power of the Python general-\npurpose programming language. They naturally complement each other.\nLoading with SQL and Python\nSuppose, for example, that you want to load a database table from a flat file, where\neach line in the file represents a database row, with individual field values separated by\ncommas. Examples 17-6 and 17-7 list two such datafiles we\u2019re going to be using here.\nExample 17-6. PP4E\\Dbase\\Sql\\data.txt\nbob,devel,50000\nsue,music,60000\nann,devel,40000\ntim,admin,30000\nkim,devel,60000\nExample 17-7. PP4E\\Dbase\\Sql\\data2.txt\nbob,developer,80000\nsue,music,90000\nann,manager,80000\nNow, some database systems like MySQL have a handy SQL statement for loading such\na table quickly. Its load data statement parses and loads data from a text file, located\non either the client or the server machine. In the following, the first command deletes\nall records in the table, and we\u2019re using the fact that Python automatically concatenates\nadjacent string literals to split the SQL statement over multiple lines:\n# Using MySQL (currently available for Python 2.X only)\n...log into MySQL first...\n>>> curs.execute('delete from people')                # all records\n>>> curs.execute(\n...     \"load data local infile 'data.txt' \"\n...           \"into table people fields terminated by ','\")\n>>> curs.execute('select * from people')\n>>> for row in curs.fetchall(): print(row)\n...\n('bob', 'devel', 50000L)\n('sue', 'music', 60000L)       # 2.X long integers\n('ann', 'devel', 40000L)\n('tim', 'admin', 30000L)\n('kim', 'devel', 60000L)\n>>> conn.commit()\nThis works as expected. But what if you must use a system like the SQLite database\nused in this book, which lacks this specific SQL statement? Or, perhaps you just need\nto do something more custom than this MySQL statement allows. Not to worry\u2014a\n1344 | Chapter 17:\u2002Databases and Persistencesmall amount of simple Python code can easily accomplish the same result with SQLite\nand Python 3.X (again, some irrelevant output lines are omitted here):\nC:\\...\\PP4E\\Dbase\\Sql> python\n>>> from sqlite3 import connect\n>>> conn = connect('dbase1')\n>>> curs = conn.cursor()\n>>> curs.execute('delete from people')         # empty the table\n>>> curs.execute('select * from people')\n>>> curs.fetchall()\n[]\n>>> file = open('data.txt')\n>>> rows = [line.rstrip().split(',') for line in file]\n>>> rows[0]\n['bob', 'devel', '50000']\n>>> for rec in rows:\n...     curs.execute('insert into people values (?, ?, ?)', rec)\n...\n>>> curs.execute('select * from people')\n>>> for rec in curs.fetchall(): print(rec)\n...\n('bob', 'devel', 50000)\n('sue', 'music', 60000)\n('ann', 'devel', 40000)\n('tim', 'admin', 30000)\n('kim', 'devel', 60000)\nThis code makes use of a list comprehension to collect string split results for all lines\nin the file after removing any newline characters, and file iterators to step through the\nfile line by line. Its Python loop does the same work as the MySQL load statement, and\nit will work on more database types, including SQLite. We can get some similar result\nfrom an executemany DB API call shown earlier as well, but the Python for loop here\nhas the potential to be more general.\nPython versus SQL\nIn fact, you have the entire Python language at your disposal for processing database\nresults, and a little Python can often duplicate or go beyond SQL syntax. For instance,\nSQL has special aggregate function syntax for computing things such as sums and\naverages:\n>>> curs.execute(\"select sum(pay), avg(pay) from people where job = 'devel'\")\n>>> curs.fetchall()\n[(150000, 50000.0)]\nBy shifting the processing to Python, we can sometimes simplify and do more than\nSQL\u2019s syntax allows (albeit potentially sacrificing any query performance optimizations\nthe database may perform). Computing pay sums and averages with Python can be\naccomplished with a simple loop:\nSQL Database Interfaces | 1345>>> curs.execute(\"select name, pay from people where job = 'devel'\")\n>>> result = curs.fetchall()\n>>> result\n(('bob', 50000L), ('ann', 40000L), ('kim', 60000L))\n>>> tot = 0\n>>> for (name, pay) in result: tot += pay\n...\n>>> print('total:', tot, 'average:', tot / len(result))         # use // to truncate\ntotal: 150000 average: 50000.0\nOr we can use more advanced tools such as comprehensions and generator expressions\nto calculate sums, averages, maximums, and the like:\n>>> print(sum(rec[1] for rec in result))         # generator expr\n150000\n>>> print(sum(rec[1] for rec in result) / len(result))\n50000.0\n>>> print(max(rec[1] for rec in result))\n60000\nThe Python approach is more general, but it doesn\u2019t buy us much until things become\nmore complex. For example, here are a few more advanced comprehensions that collect\nthe names of people whose pay is above and below the average in the query result set:\n>>> avg = sum(rec[1] for rec in result) / len(result)\n>>> print([rec[0] for rec in result if rec[1] > avg])\n['kim']\n>>> print([rec[0] for rec in result if rec[1] < avg])\n['ann']\nWe may be able to do some of these kinds of tasks with more advanced SQL techniques\nsuch as nested queries, but we eventually reach a complexity threshold where Python\u2019s\ngeneral-purpose nature makes it attractive and potentially more portable. For compar-\nison, here is the equivalent SQL:\n>>> query = (\"select name from people where job = 'devel' and \"\n...                \"pay > (select avg(pay) from people where job = 'devel')\")\n>>> curs.execute(query)\n>>> curs.fetchall()\n[('kim',)]\n>>> query = (\"select name from people where job = 'devel' and \"\n...                \"pay < (select avg(pay) from people where job = 'devel')\")\n>>> curs.execute(query)\n>>> curs.fetchall()\n[('ann',)]\nThis isn\u2019t the most complex SQL you\u2019re likely to meet, but beyond this point, SQL can\nbecome more involved. Moreover, unlike Python, SQL is limited to database-specific\ntasks by design. Imagine a query that compares a column\u2019s values to data fetched off\nthe Web or from a user in a GUI\u2014simple with Python\u2019s Internet and GUI support, but\nwell beyond the scope of a special-purpose language such as SQL. By combining Python\nand SQL, you get the best of both and can choose which is best suited to your goals.\n1346 | Chapter 17:\u2002Databases and PersistenceWith Python, you also have access to utilities you\u2019ve already coded: your database tool\nset is arbitrarily extensible with functions, modules, and classes. To illustrate, here are\nsome of the same operations coded in a more mnemonic fashion with the dictionary-\nrecord module we wrote earlier:\n>>> from makedicts import makedicts\n>>> recs = makedicts(curs, \"select * from people where job = 'devel'\")\n>>> print(len(recs), recs[0])\n3 {'pay': 50000, 'job': 'devel', 'name': 'bob'}\n>>> print([rec['name'] for rec in recs])\n['bob', 'ann', 'kim']\n>>> print(sum(rec['pay'] for rec in recs))\n150000\n>>> avg = sum(rec['pay'] for rec in recs) / len(recs)\n>>> print([rec['name'] for rec in recs if rec['pay'] > avg])\n['kim']\n>>> print([rec['name'] for rec in recs if rec['pay'] >= avg])\n['bob', 'kim']\nSimilarly, Python\u2019s set object type provides operations such as intersection, union, and\ndifference which can serve as alternatives to other SQL database operations (in the\ninterest of space, we\u2019ll leave their exploration as a suggested side trip). For more\nadvanced database extensions, see the SQL-related tools available for Python in the\nthird-party domain. For example, a variety of packages add an OOP flavor to the DB\nAPI\u2014the ORMs we\u2019ll explore near the end of this chapter.\nSQL Utility Scripts\nAt this point in our SQL DB API tour, we\u2019ve started to stretch the interactive prompt\nto its breaking point\u2014we wind up retyping the same boilerplate code again every time\nwe start a session and every time we run a test. Moreover, the code we\u2019re writing is\nsubstantial enough to be reused in other programs. Let\u2019s wrap up by transforming our\ncode into reusable scripts that automate tasks and support reuse.\nTo illustrate more of the power of the Python/SQL mix, this section presents a handful\nof utility scripts that perform common tasks\u2014the sorts of things you\u2019d otherwise have\nto recode often during development. As an added bonus, most of these files are both\ncommand-line utilities and modules of functions that can be imported and called from\nother programs. Most of the scripts in this section also allow a database file name to\nbe passed in on the command line; this allows us to use different databases for different\npurposes during development\u2014changes in one won\u2019t impact others.\nTable load scripts\nLet\u2019s take a quick look at code first, before seeing it in action; feel free to skip ahead to\ncorrelate the code here with its behavior. As a first (and less than ideal) step, Exam-\nple 17-8 shows a simple way to script-ify the table-loading logic of the prior section.\nSQL Database Interfaces | 1347Example 17-8. PP4E\\Dbase\\Sql\\loaddb1.py\n\"\"\"\nload table from comma-delimited text file; equivalent to this nonportable SQL:\nload data local infile 'data.txt' into table people fields terminated by ','\"\n\"\"\"\nimport sqlite3\nconn = sqlite3.connect('dbase1')\ncurs = conn.cursor()\nfile = open('data.txt')\nrows = [line.rstrip().split(',') for line in file]\nfor rec in rows:\n    curs.execute('insert into people values (?, ?, ?)', rec)\nconn.commit()       # commit changes now, if db supports transactions\nconn.close()        # close, __del__ call rollback if changes not committed yet\nAs is, Example 17-8 is a top-level script geared toward one particular case. It\u2019s hardly\nany extra work to generalize this into a function that can be imported and used in a\nvariety of scenarios, as in Example 17-9\u2014a much more widely useful module and\ncommand-line script.\nExample 17-9. PP4E\\Dbase\\Sql\\loaddb.py\n\"\"\"\nload table from comma-delimited text file: reusable/generalized version\nImportable functions; command-line usage: loaddb.py dbfile? datafile? table?\n\"\"\"\ndef login(dbfile):\n    import sqlite3\n    conn = sqlite3.connect(dbfile)         # create or open db file\n    curs = conn.cursor()\n    return conn, curs\ndef loaddb(curs, table, datafile, conn=None, verbose=True):\n    file = open(datafile)                                  # x,x,x\\nx,x,x\\n\n    rows = [line.rstrip().split(',') for line in file]     # [[x,x,x], [x,x,x]]\n    rows = [str(tuple(rec)) for rec in rows]               # [\"(x,x,x)\", \"(x,x,x)\"]\n    for recstr in rows:\n        curs.execute('insert into ' + table + ' values ' + recstr)\n    if conn: conn.commit()\n    if verbose: print(len(rows), 'rows loaded')\nif __name__ == '__main__':\n    import sys\n    dbfile, datafile, table = 'dbase1', 'data.txt', 'people'\n    if len(sys.argv) > 1: dbfile   = sys.argv[1]\n    if len(sys.argv) > 2: datafile = sys.argv[2]\n    if len(sys.argv) > 3: table    = sys.argv[3]\n    conn, curs = login(dbfile)\n    loaddb(curs, table, datafile, conn)\n1348 | Chapter 17:\u2002Databases and PersistenceNotice the way this code uses two list comprehensions to build a string of record values\nfor the insert statement (see its comments for the transforms applied). We could also\nuse an executemany call as we did earlier, but we want to be general and avoid hard-\ncoding the fields insertion template\u2014this function might be used for tables with any\nnumber of columns.\nThis file also defines a login function to automate the initial connection calls\u2014after\nretyping this four-command sequence enough times, it seemed a prime candidate for\na function. In addition, this reduces code redundancy; in the future, such logic need\nonly be changed in a single location if we change database systems, as long as the\nlogin function is used everywhere.\nTable display script\nOnce we load data, we probably will want to display it. Example 17-10 allows us to\ndisplay results as we go\u2014it prints an entire table with either a simple display (which\ncould be parsed by other tools) or a formatted display (generated with the dictionary-\nrecord utility we wrote earlier). Notice how it computes the maximum field-name size\nfor alignment with a generator expression; the size is passed in to a string formatting\nexpression by specifying an asterisk (*) for the field size in the format string.\nExample 17-10. PP4E\\Dbase\\Sql\\dumpdb.py\n\"\"\"\ndisplay table contents as raw tuples, or formatted with field names\ncommand-line usage: dumpdb.py dbname? table? [-] (dash=formatted display)\n\"\"\"\ndef showformat(recs, sept=('-' * 40)):\n    print(len(recs), 'records')\n    print(sept)\n    for rec in recs:\n        maxkey = max(len(key) for key in rec)                # max key len\n        for key in rec:                                      # or: \\t align\n            print('%-*s => %s' % (maxkey, key, rec[key]))    # -ljust, *len\n        print(sept)\ndef dumpdb(cursor, table, format=True):\n    if not format:\n        cursor.execute('select * from ' + table)\n        while True:\n            rec = cursor.fetchone()\n            if not rec: break\n            print(rec)\n    else:\n        from makedicts import makedicts\n        recs = makedicts(cursor, 'select * from ' + table)\n        showformat(recs)\nif __name__ == '__main__':\n    import sys\n    dbname, format, table = 'dbase1', False, 'people'\nSQL Database Interfaces | 1349cmdargs = sys.argv[1:]\n    if '-' in cmdargs:                     # format if '-' in cmdline args\n        format = True                      # dbname if other cmdline arg\n        cmdargs.remove('-')\n    if cmdargs: dbname = cmdargs.pop(0)\n    if cmdargs: table  = cmdargs[0]\n    from loaddb import login\n    conn, curs = login(dbname)\n    dumpdb(curs, table, format)\nWhile we\u2019re at it, let\u2019s code some utility scripts to initialize and erase the database, so\nwe do not have to type these by hand at the interactive prompt again every time we\nwant to start from scratch. Example 17-11 completely deletes and re-creates the data-\nbase, to reset it to an initial state (we did this manually at the start of the tutorial).\nExample 17-11. PP4E\\Dbase\\Sql\\makedb.py\n\"\"\"\nphysically delete and re-create database files\nusage: makedb.py dbname? tablename?\n\"\"\"\nimport sys\nif input('Are you sure?').lower() not in ('y', 'yes'):\n    sys.exit()\ndbname = (len(sys.argv) > 1 and sys.argv[1]) or 'dbase1'\ntable  = (len(sys.argv) > 2 and sys.argv[2]) or 'people'\nfrom loaddb import login\nconn, curs = login(dbname)\ntry:\n    curs.execute('drop table ' + table)\nexcept:\n    print('database table did not exist')\ncommand = 'create table %s (name char(30), job char(10), pay int(4))' % table\ncurs.execute(command)\nconn.commit()                 # commit may be optional here\nprint('made', dbname, table)\nNext, the clear script in Example 17-12 deletes all rows in the table, instead of dropping\nand re-creating them entirely. For testing purposes, either approach is sufficient. Minor\ncaveat: the rowcount attribute doesn\u2019t always reflect the number of rows deleted in\nSQLite; see its library manual entry for details.\nExample 17-12. PP4E\\Dbase\\Sql\\cleardb.py\n\"\"\"\ndelete all rows in table, but don't drop the table or database it is in\nusage: cleardb.py dbname? tablename?\n\"\"\"\n1350 | Chapter 17:\u2002Databases and Persistenceimport sys\nif input('Are you sure?').lower() not in ('y', 'yes'):\n    sys.exit()\ndbname = sys.argv[1] if len(sys.argv) > 1 else 'dbase1'\ntable  = sys.argv[2] if len(sys.argv) > 2 else 'people'\nfrom loaddb import login\nconn, curs = login(dbname)\ncurs.execute('delete from ' + table)\n#print(curs.rowcount, 'records deleted')        # conn closed by its __del__\nconn.commit()                                   # else rows not really deleted\nFinally, Example 17-13 provides a command-line tool that runs a query and prints its\nresult table in formatted style. There\u2019s not much to this script; because we\u2019ve automated\nmost of its tasks already, this is largely just a combination of existing tools. Such is the\npower of code reuse in Python.\nExample 17-13. PP4E\\Dbase\\Sql\\querydb.py\n\"\"\"\nrun a query string, display formatted result table\nexample: querydb.py dbase1 \"select name, job from people where pay > 50000\"\n\"\"\"\nimport sys\ndatabase, querystr = 'dbase1', 'select * from people'\nif len(sys.argv) > 1: database = sys.argv[1]\nif len(sys.argv) > 2: querystr = sys.argv[2]\nfrom makedicts import makedicts\nfrom dumpdb    import showformat\nfrom loaddb    import login\nconn, curs = login(database)\nrows = makedicts(curs, querystr)\nshowformat(rows)\nUsing the scripts\nLast but not least, here is a log of a session that makes use of these scripts in command-\nline mode, to illustrate their operation. Most of the files also have functions that can\nbe imported and called from a different program; the scripts simply map command-\nline arguments to the functions\u2019 arguments when run standalone. The first thing we do\nis initialize a testing database and load its table from a text file:\n...\\PP4E\\Dbase\\Sql> makedb.py testdb\nAre you sure?y\ndatabase table did not exist\nmade testdb people\n...\\PP4E\\Dbase\\Sql> loaddb.py testdb data2.txt\n3 rows loaded\nSQL Database Interfaces | 1351Next, let\u2019s check our work with the dump utility (use a - argument to force a formatted\ndisplay):\n...\\PP4E\\Dbase\\Sql> dumpdb.py testdb\n('bob', 'developer', 80000)\n('sue', 'music', 90000)\n('ann', 'manager', 80000)\n...\\PP4E\\Dbase\\Sql> dumpdb.py testdb -\n3 records\n----------------------------------------\npay  => 80000\njob  => developer\nname => bob\n----------------------------------------\npay  => 90000\njob  => music\nname => sue\n----------------------------------------\npay  => 80000\njob  => manager\nname => ann\n----------------------------------------\nThe dump script is an exhaustive display; to be more specific about which records to\nview, use the query script and pass in a query string on the command line (the command\nlines are split here to fit in this book):\n...\\PP4E\\Dbase\\Sql> querydb.py testdb\n                               \"select name, job from people where pay = 80000\"\n2 records\n----------------------------------------\njob  => developer\nname => bob\n----------------------------------------\njob  => manager\nname => ann\n----------------------------------------\n...\\PP4E\\Dbase\\Sql> querydb.py testdb\n                               \"select * from people where name = 'sue'\"\n1 records\n----------------------------------------\npay  => 90000\njob  => music\nname => sue\n----------------------------------------\nNow, let\u2019s erase and start again with a new data set file. The clear script erases all records\nbut doesn\u2019t reinitialize the database completely:\n...\\PP4E\\Dbase\\Sql> cleardb.py testdb\nAre you sure?y\n...\\PP4E\\Dbase\\Sql> dumpdb.py testdb -\n0 records\n1352 | Chapter 17:\u2002Databases and Persistence----------------------------------------\n...\\PP4E\\Dbase\\Sql> loaddb.py testdb data.txt\n5 rows loaded\n...\\PP4E\\Dbase\\Sql> dumpdb.py testdb\n('bob', 'devel', 50000)\n('sue', 'music', 60000)\n('ann', 'devel', 40000)\n('tim', 'admin', 30000)\n('kim', 'devel', 60000)\nIn closing, here are three queries in action on this new data set: they fetch names of\ndevelopers, jobs that pay above an amount, and records with a given pay level sorted\nby job. We could run these at the Python interactive prompt, of course, but we\u2019re getting\na lot of setup and boilerplate code for free here:\n...\\PP4E\\Dbase\\Sql> querydb.py testdb\n                               \"select name from people where job = 'devel'\"\n3 records\n----------------------------------------\nname => bob\n----------------------------------------\nname => ann\n----------------------------------------\nname => kim\n----------------------------------------\n...\\PP4E\\Dbase\\Sql> querydb.py testdb\n                               \"select job from people where pay >= 60000\"\n2 records\n----------------------------------------\njob => music\n----------------------------------------\njob => devel\n----------------------------------------\n...\\PP4E\\Dbase\\Sql> querydb.py testdb\n                               \"select * from people where pay >= 60000 order by job\"\n2 records\n----------------------------------------\npay  => 60000\njob  => devel\nname => kim\n----------------------------------------\npay  => 60000\njob  => music\nname => sue\n----------------------------------------\nBefore we move on, some context: the scripts in this section illustrate the benefits of\ncode reuse, accomplish their purpose (which was partly demonstrating the SQL API),\nand serve as a model for canned database utilities. But they are still not as general as\nthey could be; support for sorting options in the dump script, for example, may be a\nSQL Database Interfaces | 1353useful extension. Although we could generalize to support more options, at some point\nwe may need to revert to typing SQL commands in a client\u2014part of the reason SQL is\na language is because it must support so much generality. Further extensions to these\nscripts are left as exercises. Change this code as you like; it\u2019s Python, after all.\nSQL Resources\nAlthough the examples we\u2019ve seen in this section are simple, their techniques scale up\nto much more realistic databases and contexts. The websites we studied in the prior\npart of the book, for instance, can make use of SQL-based systems such as MySQL to\nstore page state information as well as long-lived client information. Because MySQL\n(among others) supports both large databases and concurrent updates, it\u2019s a natural\nfor website implementation.\nThere is more to database interfaces than we\u2019ve seen, but additional API documentation\nis readily available on the Web. To find the full database API specification, search the\nWeb for \u201cPython Database API.\u201d You\u2019ll find the formal API definition\u2014really just a\ntext file describing the PEP (the Python Enhancement Proposal) under which the API\nwas hashed out.\nPerhaps the best resource for additional information about database extensions today\nis the home page of the Python database SIG. Go to http://www.python.org, click on\nthe Community and SIGs links there, and navigate to the database group\u2019s page, or run\na search. There, you\u2019ll find API documentation (this is where it is officially maintained),\nlinks to database vendor\u2013specific extension modules, and more. And as always, see the\nPyPI website and search the Web at large for related third-party tools and extensions.\nORMs: Object Relational Mappers\nIn this chapter, we\u2019ve seen OODBs that store native Python objects persistently, as well\nas SQL databases that store information in tables. It turns out that there is another class\nof system that attempts to bridge the object and table worlds, which I\u2019ve hinted at earlier\nin this chapter: ORMs graft the Python class model onto the tables of relational data-\nbases. They combine the power of relational database systems with the simplicity of\nPython class-based syntax\u2014you don\u2019t need to forgo SQL-based databases, but you can\nstill store data that seems like Python objects to your scripts.\nToday, there are two leading open source third-party systems that implement this\nmapping: SQLObject and SQLAlchemy. Both are fairly complex systems that we can-\nnot do full justice to in this text, and you\u2019re best off researching their documentation\non the Web for the full story (there are also dedicated books covering SQLAlchemy\ntoday). Moreover, neither is completely Python 3.X ready as I write these words, so we\ncan\u2019t run live examples with them in this text.\n1354 | Chapter 17:\u2002Databases and PersistenceTo give you a slightly more concrete flavor of the ORM model, though, here is a very\nquick look at how you might use it to create and process database records in the\nSQLObject system. In brief, SQLObject maps:\n\u2022 Python classes to database tables\n\u2022 Python class instances to rows in the table\n\u2022 Python instance attributes to row columns\nFor example, to create a table, we define it with a class, with class attributes that define\ncolumns, and call its creation method (this code is derived from a more complete ex-\nample at SQLObject\u2019s website):\nfrom sqlobject import *\nsqlhub.processConnection = connectionForURI('sqlite:/:memory:')\nclass Person(SQLObject):                  # class: describes table\n    first = StringCol()                   # class attributes: row columns\n    mid   = StringCol(length=1, default=None)\n    last  = StringCol()\nPerson.createTable()                      # create a database table\nOnce created, making an instance automatically inserts a row into the database, and\nattribute fetches and assignments are automatically mapped to fetches and updates of\nthe corresponding table row\u2019s column:\np = Person(first='Bob', last='Smith')     # new instance: makes and inserts row\np                                         # prints all attributes by name\np.first                                   # attribute: fetches row column\np.mid = 'M'                               # attribute: updates record\nExisting rows/instances may be fetched by methods calls, and we can assign multiple\ncolumns/attributes with a single update operation:\np2 = Person.get(1)                        # fetch existing record/instance: p2 is p\np.set(first='Tom', last='Jones')          # update two attributes/fields at once\nIn addition, we can select by column values by creating a query object and executing it:\nts = Person.select(Person.q.first=='Tom') # query: select by column value\nlist(ts)                                  # run the query: list of instances\ntjs = Person.selectBy(first='Tom', last='Jones')   # alternative query form (AND)\nNaturally, this barely scratches the surface of the available functionality. Even at this\nlevel of complexity, though, this is quite a trick\u2014SQLObject automatically issues all\nthe SQL required to fetch, store, and query the table and rows implied by the Python\nclass syntax here. Again, the net effect allows systems to leverage the power of\nenterprise-level relational databases, but still use familiar Python class syntax to process\nstored data in Python scripts.\nORMs: Object Relational Mappers | 1355The code used with the SQLAlchemy ORM is of course very different, but the end result\nis functionally similar. For more details on ORMs for Python, consult your friendly\nneighborhood web search engine. You can also learn more about such systems by their\nroles in some larger web development frameworks; Django, for instance, has an ORM\nwhich is another variation on this theme.\nPyForm: A Persistent Object Viewer (External)\nInstead of going into additional database interface details that are freely available on\nthe Web, I\u2019m going to close out this chapter by directing you to a supplemental example\nthat shows one way to combine the GUI technology we met earlier in the text with the\npersistence techniques introduced in this chapter. This example is named PyForm\u2014a\nPython/tkinter GUI designed to let you browse and edit tables of records:\n\u2022 Tables browsed may be shelves, DBM files, in-memory dictionaries, or any other\nobject that looks and feels like a dictionary.\n\u2022 Records within tables browsed can be class instances, simple dictionaries, strings,\nor any other object that can be translated to and from a dictionary.\nAlthough this example is about GUIs and persistence, it also illustrates Python design\ntechniques. To keep its implementation both simple and type-independent, the PyForm\nGUI is coded to expect tables to look like dictionaries of dictionaries. To support a\nvariety of table and record types, PyForm relies on separate wrapper classes to translate\ntables and records to the expected protocol:\n\u2022 At the top table level, the translation is easy\u2014shelves, DBM files, and in-memory\ndictionaries all have the same key-based interface.\n\u2022 At the nested record level, the GUI is coded to assume that stored items have a\ndictionary-like interface, too, but classes intercept dictionary operations to make\nrecords compatible with the PyForm protocol. Records stored as strings are con-\nverted to and from the dictionary objects on fetches and stores; records stored as\nclass instances are translated to and from attribute dictionaries. More specialized\ntranslations can be added in new table wrapper classes.\nThe net effect is that PyForm can be used to browse and edit a wide variety of table\ntypes, despite its dictionary interface expectations. When PyForm browses shelves and\nDBM files, table changes made within the GUI are persistent\u2014they are saved in the\nunderlying files. When used to browse a shelve of class instances, PyForm essentially\nbecomes a GUI frontend to a simple object database that is built using standard Python\npersistence tools. To view and update a shelve of objects with PyForm, for example,\ncode like the following will suffice:\nimport shelve\nfrom formgui import FormGui                 # after initcast\ndb = shelve.open('../data/castfile')        # reopen shelve file\nFormGui(db).mainloop()                      # browse existing shelve-of-dicts\n1356 | Chapter 17:\u2002Databases and PersistenceTo view or update a shelve of instances of an imported Actor class, we can use code\nlike this:\nfrom PP4E.Dbase.testdata inport Actor\nfrom formgui import FormGui                 # run in TableBrowser dir\nfrom formtable import ShelveOfInstance\ntestfile = '../data/shelve'                 # external filename\ntable = ShelveOfInstance(testfile, Actor)   # wrap shelf in Table object\nFormGui(table).mainloop()\ntable.close()                               # close needed for some dbm\nFigure 17-1 captures the scene under Python 3.1 and Windows 7 when viewing a shelve\nof persistent class instance objects. This PyForm session was kicked off by a command-\nline described in its form table module\u2019s self-test code: formtable.py shelve 1, and\nomit the 1 (or pass it as 0) to avoid reinitializing the shelve at the start of each session\nso changes are retained.\nPyForm\u2019s GUI can also be started from the PyDemos launcher we met in Chapter 10,\nthough it does not save changes persistently in this mode. Run the example on your\nown computer to get a better sample of its operation. Though not a fully general Python\npersistent object table viewer, PyForm serves as a simple object database front end.\nFigure 17-1. PyForm displaying a shelve of Actor objects\nBecause we are short on time and space in this edition, I\u2019m going to omit both the\nsource code for this example and its description here. To study PyForm, see the fol-\nlowing directory in the book\u2019s examples package distribution described in the Preface:\nC:\\...\\PP4E\\Dbase\\TableBrowser\nPyForm: A Persistent Object Viewer (External) | 1357See especially the Documentation subdirectory there, which contains the original \nPyForm overview material from the third edition in a PDF file. PyForm\u2019s source code \nfiles are ported to Python 3.X form, though code in the overview document still shows \nits 2.X third edition roots. For the purposes of the published portions of this book, let\u2019s \nmove on to the next chapter and our next tools topic: data structure implementations.\n1358 | Chapter 17:\u2002Databases and Persistence", "18": "CHAPTER 18\nData Structures\n\u201cRoses Are Red, Violets Are Blue; Lists Are Mutable,\nand So Is Set Foo\u201d\nData structures are a central theme in most programs, even if Python programmers\noften don\u2019t need to care. Their apathy is warranted\u2014Python comes \u201cout of the box\u201d\nwith a rich set of built-in and already optimized types that make it easy to deal with\nstructured data: lists, strings, tuples, dictionaries, sets, and the like. For simple systems,\nthese types are usually enough. Dictionaries, for example, subsume many of the clas-\nsical searching algorithms, and lists replace much of the work you\u2019d do to support\ncollections in lower-level languages. Even so, both are so easy to use that you generally\nnever give them a second thought.\nBut for advanced applications, we may need to add more sophisticated types of our\nown to handle extra requirements or special cases. In this chapter, we\u2019ll explore a\nhandful of advanced data structure implementations in Python: sets, stacks, graphs,\nand so on. As we\u2019ll see, data structures can take the form of new object types in Python,\nintegrated into the language\u2019s type model. That is, objects we code in Python become\nfull-fledged datatypes\u2014to the scripts that use them, they can look and feel just like\nbuilt-in lists, numbers, and dictionaries.\nAlthough the examples in this chapter illustrate advanced programming and computer\nscience techniques, they also underscore Python\u2019s support for writing reusable soft-\nware. As object implementations are coded with classes and modules, they naturally\nbecome generally useful components that can be used in any program that imports\nthem. In effect, we will be building libraries of data structure tools, whether we plan\nfor it or not.\nMoreover, though most examples in this chapter are pure Python code (and at least to\nlinear readers, some may seem relatively simple compared to those of earlier chapters),\nthey also provide a use case for discussing Python performance issues, and hint at what\u2019s\npossible with the subject of Chapter 20\u2014from the most general perspective, new\n1359Python objects can be implemented in either Python or an integrated language such as\nC. Types coded in C use patterns similar to those here.\nIn the end, though, we\u2019ll also see that Python\u2019s built-in support can often take the place\nof homegrown solutions in this domain. Although custom data structure implemen-\ntations are sometimes necessary and still have much to offer in terms of code mainte-\nnance and evolution, they are not always as paramount in Python as they are in less\nprogrammer-friendly languages.\nImplementing Stacks\nStacks are a common and straightforward data structure, used in a variety of applica-\ntions: language processing, graph searches, and so on. For instance, expression evalu-\nation in the next chapter\u2019s calculator GUI is largely an exercise in juggling stacks, and\nprogramming languages in general typically implement function calls as stack opera-\ntions in order to remember what to resume as calls return. Stacks can also help in XML\nparsing: they are a natural for tracking progress any time constructs might be arbitrarily\nnested.\nIn short, stacks are a last-in-first-out collection of objects\u2014the last item added to the\ncollection is always the next one to be removed. Unlike the queues we used for thread\ncommunication, which add and delete at opposite ends, all the activity in stacks hap-\npens at the top. Clients use stacks by:\n\u2022 Pushing items onto the top\n\u2022 Popping items off the top\nDepending on client requirements, there may also be tools for such tasks as testing\nwhether the stack is empty, fetching the top item without popping it, iterating over a\nstack\u2019s items, testing for item membership, and so on.\nBuilt-in Options\nIn Python, a simple list is often adequate for implementing a stack: because we can\nchange lists in place arbitrarily, we can add and delete items from either the beginning\n(left) or the end (right). Table 18-1 summarizes various built-in operations available for\nimplementing stack-like behavior with Python lists and in-place changes. They vary\ndepending on whether the stack \u201ctop\u201d is the first or the last node in the list; in this\ntable, the string 'b' is the initial top item on the stack.\nTable 18-1. Stacks as lists\nOperation\nTop is end-of-list\nTop is front-of-list\nTop is front-of-list\nNew\nstack=['a', 'b']\nstack=['b', 'a']\nstack=['b', 'a']\nPush\nstack.append('c')\nstack.insert(0,'c')\nstack[0:0]=['c']\n1360 | Chapter 18:\u2002Data StructuresOperation\nTop is end-of-list\nTop is front-of-list\nTop is front-of-list\nPop\ntop = stack[-1];\ndel stack[-1]\ntop = stack[0];\ndel stack[0]\ntop = stack[0];\nstack[:1] = []\nEven more conveniently, Python grew a list pop method later in its life designed to be\nused in conjunction with append to implement stacks and other common structures\nsuch as queues, yielding the even simpler coding options listed in Table 18-2.\nTable 18-2. Stacks as lists, coding alternatives\nOperation\nTop is end-of-list\nTop is front-of-list\nNew\nstack=['a', 'b']\nstack=['b', 'a']\nPush\nstack.append('c')\nstack.insert(0,'c')\nPop\ntop = stack.pop()\ntop = stack.pop(0)\nBy default, pop is equivalent to fetching, and then deleting, the last item at offset \u22121.\nWith an argument, pop deletes and returns the item at that offset\u2014list.pop(-1) is the\nsame as list.pop(). For in-place change operations like append, insert, del, and pop,\nno new list is created in memory, so execution is quick (performance may further de-\npend upon which end is the \u201ctop,\u201d but this in turn depends on Python\u2019s current list\nimplementation, as well as measurement concepts we\u2019ll explore later). Queues can be\ncoded similarly, but they pop at the other end of the list.\nOther built-in coding schemes are possible as well. For instance, del stack[:1] is yet\nanother way to delete the first item in a list-based stack in-place. Depending on which\nend is interpreted as the top of the stack, the following sequence assignment statement\nforms can be used to fetch and remove the top item as well, albeit at the cost of making\na new list object each time:\n# top is front of list\ntop, stack = stack[0], stack[1:]        # Python 1.X+\ntop, *stack = stack                     # Python 3.X\n# top is end of list\nstack, top = stack[:-1], stack[-1]      # Python 1.X+\n*stack, top = stack                     # Python 3.X\nWith so many built-in stack options, why bother implementing others? For one thing,\nthey serve as a simple and familiar context for exploring data structure concepts in this\nbook. More importantly, though, there is a practical programming motive here. List\nrepresentations work and will be relatively fast, but they also bind stack-based pro-\ngrams to the stack representation chosen: all stack operations will be hardcoded\nthroughout a program. If we later want to change how a stack is represented or extend\nits basic operation set, we\u2019re stuck\u2014every stack-based program will have to be updated,\nand in every place where it accesses the stack.\nImplementing Stacks | 1361For instance, to add logic that monitors the number of stack operations a program\nperforms, we\u2019d have to add code around each hardcoded stack operation. In a large\nsystem, this update may be nontrivial work. As we\u2019ll discuss in Chapter 20, we may\nalso decide to move stacks to a C-based implementation, if they prove to be a perform-\nance bottleneck. As a general rule, hardcoded operations on built-in data structures\ndon\u2019t support future migrations as well as we\u2019d sometimes like.\nAs we\u2019ll see later, built-in types such as lists are actually class-like objects in Python\nthat we can subclass to customize, too. This might be only a partial fix, though; unless\nwe anticipate future changes and make instances of a subclass, we may still have a\nmaintenance issue if we use built-in list operations directly and ever want to extend\nwhat they do in the future.\nA Stack Module\nOf course, the real solution to such code maintenance dilemmas is to encapsulate\u2014\nthat is, wrap up\u2014stack implementations behind interfaces, using Python\u2019s code reuse\ntools. As long as clients stick to using the interfaces, we\u2019re free to change the interfaces\u2019\nimplementations arbitrarily without having to change every place they are called. Let\u2019s\nbegin by implementing a stack as a module containing a Python list, plus functions to\noperate on it; Example 18-1 shows one way to code this.\nExample 18-1. PP4E\\Dstruct\\Basic\\stack1.py\n\"a shared stack module\"\nstack = []                                   # on first import\nclass error(Exception): pass                 # local excs, stack1.error\ndef push(obj):\n    global stack                             # use 'global' to change\n    stack = [obj] + stack                    # add item to the front\ndef pop():\n    global stack\n    if not stack:\n        raise error('stack underflow')       # raise local error\n    top, *stack = stack                      # remove item at front\n    return top\ndef top():\n    if not stack:                            # raise local error\n        raise error('stack underflow')       # or let IndexError occur\n    return stack[0]\ndef empty():      return not stack           # is the stack []?\ndef member(obj):  return obj in stack        # item in stack?\ndef item(offset): return stack[offset]       # index the stack\ndef length():     return len(stack)          # number entries\ndef dump():       print('<Stack:%s>' % stack)\n1362 | Chapter 18:\u2002Data StructuresThis module creates a list object (stack) and exports functions to manage access to it.\nThe stack is declared global in functions that change it, but not in those that just ref-\nerence it. The module also defines an error object (error) that can be used to catch\nexceptions raised locally in this module. Some stack errors are built-in exceptions: the\nmethod item triggers IndexError for out-of-bounds indexes.\nMost of the stack\u2019s functions just delegate the operation to the embedded list used to\nrepresent the stack. In fact, the module is really just a simple wrapper around a Python\nlist. Because this extra layer of interface logic makes clients independent of the actual\nimplementation of the stack, though, we\u2019re able to change the stack later without im-\npacting its clients.\nAs usual, one of the best ways to understand such code is to see it in action. Here\u2019s an\ninteractive session that illustrates the module\u2019s interfaces\u2014it implements a stack of\narbitrary Python objects:\nC:\\...\\PP4E\\Dstruct\\Basic> python\n>>> import stack1\n>>> stack1.push('spam')\n>>> stack1.push(123)\n>>> stack1.top()\n123\n>>> stack1.stack\n[123, 'spam']\n>>> stack1.pop()\n123\n>>> stack1.dump()\n<Stack:['spam']>\n>>> stack1.pop()\n'spam'\n>>> stack1.empty()\nTrue\n>>> for c in 'spam': stack1.push(c)\n...\n>>> while not stack1.empty():\n...     print(stack1.pop(), end=' ')\n...\nm a p s >>>\n>>> stack1.pop()\nstack1.error: stack underflow\nOther operations are analogous, but the main thing to notice here is that all stack\noperations are module functions. For instance, it\u2019s possible to iterate over the stack, but\nwe need to use counter-loops and indexing function calls (item). Nothing is preventing\nclients from accessing (and even changing) stack1.stack directly, but doing so defeats\nthe purpose of interfaces like this one:\n>>> for c in 'spam': stack1.push(c)\n...\n>>> stack1.dump()\n<Stack:['m', 'a', 'p', 's']>\n>>>\n>>> for i in range(stack1.length()):\nImplementing Stacks | 1363...     print(stack1.item(i), end=' ')\n...\nm a p s >>>\nA Stack Class\nPerhaps the biggest drawback of the module-based stack is that it supports only a single\nstack object. All clients of the stack module effectively share the same stack. Sometimes\nwe want this feature: a stack can serve as a shared-memory object for multiple modules.\nBut to implement a true stack datatype that can generate independent objects, we need\nto use classes.\nTo illustrate, let\u2019s define a full-featured stack class. The Stack class shown in Exam-\nple 18-2 defines a new datatype with a variety of behaviors. Like the module, the class\nuses a Python list to hold stacked objects. But this time, each instance gets its own list.\nThe class defines both \u201creal\u201d methods and specially named methods that implement\ncommon type operations. Comments in the code describe special methods.\nExample 18-2. PP4E\\Dstruct\\Basic\\stack2.py\n\"a multi-instance stack class\"\nclass error(Exception): pass                 # when imported: local exception\nclass Stack:\n    def __init__(self, start=[]):            # self is the instance object\n        self.stack = []                      # start is any sequence: stack..\n        for x in start: self.push(x)\n        self.reverse()                       # undo push's order reversal\n    def push(self, obj):                     # methods: like module + self\n        self.stack = [obj] + self.stack      # top is front of list\n    def pop(self):\n        if not self.stack: raise error('underflow')\n        top, *self.stack = self.stack\n        return top\n    def top(self):\n        if not self.stack: raise error('underflow')\n        return self.stack[0]\n    def empty(self):\n        return not self.stack                     # instance.empty()\n    # overloads\n    def __repr__(self):\n        return '[Stack:%s]' % self.stack          # print, repr(),..\n    def __eq__(self, other):\n        return self.stack == other.stack          # '==', '!='?\n    def __len__(self):\n1364 | Chapter 18:\u2002Data Structuresreturn len(self.stack)                    # len(instance), not instance\n    def __add__(self, other):\n        return Stack(self.stack + other.stack)    # instance1 + instance2\n    def __mul__(self, reps):\n        return Stack(self.stack * reps)           # instance * reps\n    def __getitem__(self, offset):                # see also __iter__\n        return self.stack[offset]                 # instance[i], [i:j], in, for\n    def __getattr__(self, name):\n        return getattr(self.stack, name)          # instance.sort()/reverse()/..\nNow distinct instances are created by calling the Stack class like a function. In most\nrespects, the Stack class implements operations exactly like the stack module in Ex-\nample 18-1. But here, access to the stack is qualified by self, the subject instance object.\nEach instance has its own stack attribute, which refers to the instance\u2019s own list. Fur-\nthermore, instance stacks are created and initialized in the __init__ constructor\nmethod, not when the module is first imported. Let\u2019s make a couple of stacks to see\nhow all this works in practice:\n>>> from stack2 import Stack\n>>> x = Stack()                   # make a stack object, push items\n>>> x.push('spam')\n>>> x.push(123)\n>>> x                             # __repr__ prints a stack\n[Stack:[123, 'spam']]\n>>> y = Stack()                   # two distinct stack objects\n>>> y.push(3.1415)                # they do not share content\n>>> y.push(x.pop())\n>>> x, y\n([Stack:['spam']], [Stack:[123, 3.1415]])\n>>> z = Stack()                   # third distinct stack object\n>>> for c in 'spam': z.push(c)\n...\n>>> while z:                      # __len__ tests stack truth\n...     print(z.pop(), end=' ')\n...\nm a p s >>>\n>>> z = x + y                     # __add__ handles stack +\n>>> z                             # holds three different types\n[Stack:['spam', 123, 3.1415]]\n>>> for item in z:                # __getitem__ does for\n...     print(item, end=' ')\n...\nspam 123 3.1415 >>>\n>>> z.reverse()                   # __getattr__ delegates to list\n>>> z\n[Stack:[3.1415, 123, 'spam']]\nImplementing Stacks | 1365Like lists and dictionaries, Stack defines both methods and operators for manipulating\ninstances by attribute references and expressions. Additionally, it defines the __get\nattr__ special method to intercept references to attributes not defined in the class and\nto route them to the wrapped list object (to support list methods: sort, append,\nreverse, and so on). Many of the module\u2019s operations become operators in the class.\nTable 18-3 shows the equivalence of module and class operations (columns 1 and 2)\nand gives the class method that comes into play for each (column 3).\nTable 18-3. Module/class operation comparison\nModule operations\nClass operations\nClass method\nmodule.empty()\nnot instance\n__len__\nmodule.member(x)\nx in instance\n__getitem__\nmodule.item(i)\ninstance[i]\n__getitem__\nmodule.length()\nlen(instance)\n__len__\nmodule.dump()\nprint(instance)\n__repr__\nrange() counter loops\nfor x in instance\n__getitem__\nmanual loop logic\ninstance + instance\n__add__\nmodule.stack.reverse()\ninstance.reverse()\n__getattr__\nmodule.push/pop/top\ninstance.push/pop/top\npush/pop/top\nIn effect, classes let us extend Python\u2019s set of built-in types with reusable types imple-\nmented in Python modules. Class-based types may be used just like built-in types:\ndepending on which operation methods they define, classes can implement numbers,\nmappings, and sequences, and may or may not be mutable. Class-based types may also\nfall somewhere in between these categories.\nCustomization: Performance Monitors\nSo far we\u2019ve seen how classes support multiple instances and integrate better with\nPython\u2019s object model by defining operator methods. One of the other main reasons\nfor using classes is to allow for future extensions and customizations. By implementing\nstacks with a class, we can later add subclasses that specialize the implementation for\nnew demands. In fact, this is often the main reason for using a custom class instead of\na built-in alternative.\nFor instance, suppose we\u2019ve started using the Stack class in Example 18-2, but we start\nrunning into performance problems. One way to isolate bottlenecks is to instrument\ndata structures with logic that keeps track of usage statistics, which we can analyze\nafter running client applications. Because Stack is a class, we can add such logic in a\nnew subclass without affecting the original stack module (or its clients). The subclass\nin Example 18-3 extends Stack to keep track of overall push/pop usage frequencies and\nto record the maximum size of each instance.\n1366 | Chapter 18:\u2002Data StructuresExample 18-3. PP4E\\Dstruct\\Basic\\stacklog.py\n\"customize stack for usage data\"\nfrom stack2 import Stack                    # extends imported Stack\nclass StackLog(Stack):                      # count pushes/pops, max-size\n    pushes = pops = 0                       # shared/static class members\n    def __init__(self, start=[]):           # could also be module vars\n        self.maxlen = 0\n        Stack.__init__(self, start)\n    def push(self, object):\n        Stack.push(self, object)                    # do real push\n        StackLog.pushes += 1                        # overall stats\n        self.maxlen = max(self.maxlen, len(self))   # per-instance stats\n    def pop(self):\n        StackLog.pops += 1                          # overall counts\n        return Stack.pop(self)                      # not 'self.pops': instance\n    def stats(self):\n        return self.maxlen, self.pushes, self.pops  # get counts from instance\nThis subclass works the same as the original Stack; it just adds monitoring logic. The\nnew stats method is used to get a statistics tuple through an instance:\n>>> from stacklog import StackLog\n>>> x = StackLog()\n>>> y = StackLog()                           # make two stack objects\n>>> for i in range(3): x.push(i)             # and push object on them\n...\n>>> for c in 'spam':   y.push(c)\n...\n>>> x, y                                     # run inherited __repr__\n([Stack:[2, 1, 0]], [Stack:['m', 'a', 'p', 's']])\n>>> x.stats(), y.stats()\n((3, 7, 0), (4, 7, 0))\n>>>\n>>> y.pop(), x.pop()\n('m', 2)\n>>> x.stats(), y.stats()                     # my maxlen, all pushes, all pops\n((3, 7, 2), (4, 7, 2))\nNotice the use of class attributes to record overall pushes and pops, and instance at-\ntributes for per-instance maximum length. By hanging attributes on different objects,\nwe can expand or narrow their scopes.\nOptimization: Tuple Tree Stacks\nOne of the nice things about wrapping objects up in classes is that you are free to change\nthe underlying implementation without breaking the rest of your program. Optimiza-\ntions can be added in the future, for instance, with minimal impact; the interface is\nImplementing Stacks | 1367unchanged, even if the internals are. There are a variety of ways to implement stacks,\nsome more efficient than others. So far, our stacks have used slicing and extended\nsequence assignment to implement pushing and popping. This method is relatively\ninefficient: both operations make copies of the wrapped list object. For large stacks,\nthis practice can add a significant time penalty.\nOne way to speed up such code is to change the underlying data structure completely.\nFor example, we can store the stacked objects in a binary tree of tuples: each item may\nbe recorded as a pair, (object, tree), where object is the stacked item and tree is\neither another tuple pair giving the rest of the stack or None to designate an empty stack.\nA stack of items [1,2,3,4] would be internally stored as a tuple tree (1,(2,(3,\n(4,None)))).\nThis tuple-based representation is similar to the notion of \u201ccons-cells\u201d in Lisp-family\nlanguages: the object on the left is the car, and the rest of the tree on the right is the\ncdr. Because we add or remove only a top tuple to push and pop items, this structure\navoids copying the entire stack. For large stacks, the benefit might be significant. The\nnext class, shown in Example 18-4, implements these ideas.\nExample 18-4. PP4E\\Dstruct\\Basic\\stack3.py\n\"optimize with tuple pair trees\"\nclass Stack:\n    def __init__(self, start=[]):              # init from any sequence\n        self.stack = None                      # even other (fast)stacks\n        for i in range(-len(start), 0):\n            self.push(start[-i - 1])           # push in reverse order\n    def push(self, node):                      # grow tree 'up/left'\n        self.stack = node, self.stack          # new root tuple: (node, tree)\n    def pop(self):\n        node, self.stack = self.stack          # remove root tuple\n        return node                            # TypeError if empty\n    def empty(self):\n        return not self.stack                  # is it 'None'?\n    def __len__(self):                         # on: len, not\n        len, tree = 0, self.stack\n        while tree:\n            len, tree = len+1, tree[1]         # visit right subtrees\n        return len\n    def __getitem__(self, index):              # on: x[i], in, for\n        len, tree = 0, self.stack\n        while len < index and tree:            # visit/count nodes\n            len, tree = len+1, tree[1]\n        if tree:\n            return tree[0]                     # IndexError if out-of-bounds\n        else:\n1368 | Chapter 18:\u2002Data Structuresraise IndexError()                 # so 'in' and 'for' stop\n    def __repr__(self):\n        return '[FastStack:' + repr(self.stack) + ']'\nThis class\u2019s __getitem__ method handles indexing, in tests, and for loop iteration as\nbefore (when no __iter__ is defined), but this version has to traverse a tree to find a\nnode by index. Notice that this isn\u2019t a subclass of the original Stack class. Since nearly\nevery operation is implemented differently here, inheritance won\u2019t really help. But cli-\nents that restrict themselves to the operations that are common to both classes can still\nuse them interchangeably\u2014they just need to import a stack class from a different mod-\nule to switch implementations. Here\u2019s a session with this stack version; as long as we\nstick to pushing, popping, indexing, and iterating, this version is essentially indistin-\nguishable from the original:\n>>> from stack3 import Stack\n>>> x = Stack()\n>>> y = Stack()\n>>> for c in 'spam': x.push(c)\n...\n>>> for i in range(3): y.push(i)\n...\n>>> x\n[FastStack:('m', ('a', ('p', ('s', None))))]\n>>> y\n[FastStack:(2, (1, (0, None)))]\n>>> len(x), x[2], x[-1]\n(4, 'p', 'm')\n>>> x.pop()\n'm'\n>>> x\n[FastStack:('a', ('p', ('s', None)))]\n>>>\n>>> while y: print(y.pop(), end=' ')\n...\n2 1 0 >>>\nOptimization: In-Place List Modifications\nThe last section tried to speed up pushes and pops with a different data structure, but\nwe might also be able to speed up our stack object by falling back on the mutability of\nPython\u2019s list object. Because lists can be changed in place, they can be modified more\nquickly than any of the prior examples. In-place change operations such as append are\nprone to complications when a list is referenced from more than one place. But because\nthe list inside the stack object isn\u2019t meant to be used directly, we\u2019re probably safe.\nThe module in Example 18-5 shows one way to implement a stack with in-place\nchanges; some operator overloading methods have been dropped to keep this simple.\nThe Python pop method it uses is equivalent to indexing and deleting the item at\nImplementing Stacks | 1369offset \u22121 (top is end-of-list here). Compared to using built-in lists directly, this class\nincurs some performance degradation for the extra method calls, but it supports future\nchanges better by encapsulating stack operations.\nExample 18-5. PP4E\\Dstruct\\Basic\\stack4.py\n\"optimize with in-place list operations\"\nclass error(Exception): pass                 # when imported: local exception\nclass Stack:\n    def __init__(self, start=[]):            # self is the instance object\n        self.stack = []                      # start is any sequence: stack...\n        for x in start: self.push(x)\n    def push(self, obj):                     # methods: like module + self\n        self.stack.append(obj)               # top is end of list\n    def pop(self):\n        if not self.stack: raise error('underflow')\n        return self.stack.pop()              # like fetch and delete stack[-1]\n    def top(self):\n        if not self.stack: raise error('underflow')\n        return self.stack[-1]\n    def empty(self):\n        return not self.stack                # instance.empty()\n    def __len__(self):\n        return len(self.stack)               # len(instance), not instance\n    def __getitem__(self, offset):\n        return self.stack[offset]            # instance[offset], in, for\n    def __repr__(self):\n        return '[Stack:%s]' % self.stack\nThis version works like the original in module stack2, too; just replace stack2 with\nstack4 in the previous interaction to get a feel for its operation. The only obvious dif-\nference is that stack items are in reverse when printed (i.e., the top is the end):\n>>> from stack4 import Stack\n>>> x = Stack()\n>>> x.push('spam')\n>>> x.push(123)\n>>> x\n[Stack:['spam', 123]]\n>>>\n>>> y = Stack()\n>>> y.push(3.1415)\n>>> y.push(x.pop())\n>>> x, y\n1370 | Chapter 18:\u2002Data Structures([Stack:['spam']], [Stack:[3.1415, 123]])\n>>> y.top()\n123\nTiming the Improvements\nThe prior section\u2019s in-place changes stack object probably runs faster than both the\noriginal and the tuple-tree versions, but the only way to really be sure is to time the\nalternative implementations.* Since this could be something we\u2019ll want to do more than\nonce, let\u2019s first define a general module for timing functions in Python. In Exam-\nple 18-6, the built-in time module provides a clock function that we can use to get the\ncurrent CPU time in floating-point seconds, and the function timer.test simply calls\na function reps times and returns the number of elapsed seconds by subtracting stop\nfrom start times.\nExample 18-6. PP4E\\Dstruct\\Basic\\timer.py\n\"generic code timer tool\"\ndef test(reps, func, *args):        # or best of N? see Learning Python\n    import time\n    start = time.clock()            # current CPU time in float seconds\n    for i in range(reps):           # call function reps times\n        func(*args)                 # discard any return value\n    return time.clock() - start     # stop time - start time\nThere are other ways to time code, including a best-of-N approach and Python\u2019s own\ntimeit module, but this module suffices for our purpose here. If you\u2019re interested in\ndoing better, see Learning Python, Fourth Edition, for a larger case study on this topic,\nor experiment on your own.\nNext, we define a test driver script which deploys the timer, in Example 18-7. It expects\nthree command-line arguments: the number of pushes, pops, and indexing operations\nto perform (we\u2019ll vary these arguments to test different scenarios). When run at the top\nlevel, the script creates 200 instances of the original and optimized stack classes and\nperforms the specified number of operations on each stack. Pushes and pops change\nthe stack; indexing just accesses it.\nExample 18-7. PP4E\\Dstruct\\Basic\\stacktime.py\n\"compare performance of stack alternatives\"\nimport stack2           # list-based stacks: [x]+y\nimport stack3           # tuple-tree stacks: (x,y)\n* Because Python is so dynamic, guesses about relative performance in Python are just as likely to be wrong as\nright. Moreover, their accuracy is prone to change over time. Trust me on this. I\u2019ve made sweeping statements\nabout performance in other books, only to be made wrong by a later Python release that optimized some\noperations more than others. Performance measurement in Python is both nontrivial and an ongoing task.\nIn general, code for readability first, and worry about performance later, but always gather data to support\nyour optimization efforts.\nImplementing Stacks | 1371import stack4           # in-place stacks:   y.append(x)\nimport timer            # general function timer utility\nrept = 200\nfrom sys import argv\npushes, pops, items = (int(arg) for arg in argv[1:])\ndef stackops(stackClass):\n    x = stackClass('spam')                    # make a stack object\n    for i in range(pushes): x.push(i)         # exercise its methods\n    for i in range(items):  t = x[i]          # 3.X: range generator\n    for i in range(pops):   x.pop()\n                                              # or mod = __import__(n)\nfor mod in (stack2, stack3, stack4):          # rept*(push+pop+ix)\n    print('%s:' % mod.__name__, end=' ')\n    print(timer.test(rept, stackops, getattr(mod, 'Stack')))\nResults under Python 3.1\nThe following are some of the timings reported by the test driver script. The three\noutputs represent the measured run times in seconds for the original, tuple, and in-\nplace stacks. For each stack type, the first test creates 200 stack objects and performs\nroughly 120,000 stack operations (200 repetitions \u00d7 (200 pushes + 200 indexes + 200\npops)) in the test duration times listed. These results were obtained on a fairly slow\nWindows 7 netbook laptop under Python 3.1; as usual for benchmarks, your mileage\nwill probably vary.\nC:\\...\\PP4E\\Dstruct\\Basic> python stacktime.py 200 200 200\nstack2: 0.838853884098\nstack3: 2.52424649244\nstack4: 0.215801718938\nC:\\...\\PP4E\\Dstruct\\Basic> python stacktime.py 200 50 200\nstack2: 0.775219065818\nstack3: 2.539294115\nstack4: 0.156989574341\nC:\\...\\PP4E\\Dstruct\\Basic> python stacktime.py 200 200 50\nstack2: 0.743521212289\nstack3: 0.286850521181\nstack4: 0.156262000363\nC:\\...\\PP4E\\Dstruct\\Basic> python stacktime.py 200 200 0\nstack2: 0.721035029026\nstack3: 0.116366779208\nstack4: 0.141471921584\nIf you look closely enough, you\u2019ll notice that the results show that the tuple-based stack\n(stack3) performs better when we do more pushing and popping, but worse if we do\nmuch indexing. Indexing lists is extremely fast for built-in lists (stack2 and stack4), but\nvery slow for tuple trees\u2014the Python class must traverse the tree manually.\n1372 | Chapter 18:\u2002Data StructuresThe in-place change stacks (stack4) are almost always fastest, unless no indexing is\ndone at all\u2014tuples (stack3) win by a hair in the last test case. When there is no indexing,\nas in the last test, the tuple and in-place change stacks are roughly six and five times\nquicker than the simple list-based stack, respectively. Since pushes and pops are most\nof what clients would normally do to a stack, tuples are a contender here, despite their\npoor indexing performance.\nOf course, we\u2019re talking about fractions of a second after many tens of thousands of\noperations; in many applications, your users probably won\u2019t care either way. If you\naccess a stack millions of times in your program, though, this difference may accumu-\nlate to a significant amount of time.\nMore on performance analysis\nTwo last notes on performance here. Although absolute times have changed over the\nyears with new Pythons and test machines, these results have remained relatively the\nsame. That is, tuple-based stacks win when no indexing is performed. All performance\nmeasurements in a dynamic language like Python are prone to change over time,\nthough, so run such tests on your own for more accurate results.\nSecond, there\u2019s often more to performance measurement than timing alternatives this\nway. For a more complete picture, read about Python\u2019s standard library profile module\n(and its optimized workalike, cProfile). The profilers run Python code, collect per-\nformance data along the way, and provide it in a report on code exit. It\u2019s the most\ncomplete way to isolate your code\u2019s bottleneck, before you start working on optimizing\nwith better coding, algorithms, and data structures or moving portions to the\nC language.\nFor simple performance analysis, though, our timing module provides the data we need.\nIn fact, we\u2019ll reuse it to measure a more dramatic improvement in relative speed for set\nimplementation alternatives\u2014the topic of the next section.\nImplementing Sets\nAnother commonly used data structure is the set, a collection of objects that support \noperations such as:\nIntersection\nMake a new set with all items in common.\nUnion\nMake a new set with all items in either operand.\nMembership\nTest whether an item exists in a set.\nOther operations, such as difference and subset tests, can be useful as well, depending\non the intended use. Sets come in handy for dealing with abstract group combinations.\nImplementing Sets | 1373For instance, given a set of engineers and a set of writers, you can pick out individuals\nwho do both activities by intersecting the two sets. A union of such sets would contain\neither type of individual, but would include any given individual only once. This latter\nproperty also makes sets ideal for removing duplicates from collections\u2014simply con-\nvert to and from a set to filter out repeats.\nIn fact, we relied on such operations in earlier chapters; PyMailGUI in Chapter 14, for\nexample, used intersection, union, and difference to manage the set of active mail\ndownloads, and filtered out duplicate recipients in multiple contexts with set conver-\nsion. Sets are a widely relevant tool on practical programs.\nBuilt-in Options\nIf you\u2019ve studied the core Python language, you should already know that, as for stacks,\nPython comes with built-in support here as well. Here, though, the support is even\nmore direct\u2014Python\u2019s set datatype provides standard and optimized set operations\ntoday. As a quick review, built-in set usage is straightforward: set objects are initially\ncreated by calling the type name with an iterable or sequence giving the components\nof the set or by running a set comprehension expression:\n>>> x = set('abcde')                # make set from an iterable/sequence\n>>> y = {c for c in 'bdxyz'}        # same via set comprehension expression\n>>> x\n{'a', 'c', 'b', 'e', 'd'}\n>>> y\n{'y', 'x', 'b', 'd', 'z'}\nOnce you have a set, all the usual operations are available; here are the most common:\n>>> 'e' in x                        # membership\nTrue\n>>> x \u2013 y                           # difference\n{'a', 'c', 'e'}\n>>> x & y                           # intersection\n{'b', 'd'}\n>>> x | y                           # union\n{'a', 'c', 'b', 'e', 'd', 'y', 'x', 'z'}\nInterestingly, just like the dictionaries, built-in sets are unordered, and require that all\nset components be hashable (immutable). Making a set with a dictionary of items\nworks, but only because set uses the dictionary iterator, which returns the next key on\neach iteration (it ignores key values):\n>>> x = set(['spam', 'ham', 'eggs'])       # sequence of immutables\n>>> x\n{'eggs', 'ham', 'spam'}\n>>> x = {'spam', 'ham', 'eggs'}            # same but set literal if items known\n>>> x\n{'eggs', 'ham', 'spam'}\n>>> x = set([['spam', 'ham'], ['eggs']])   # immutables do not work as items\nTypeError: unhashable type: 'list'\n1374 | Chapter 18:\u2002Data Structures>>> x = set({'spam':[1, 1], 'ham': [2, 2], 'eggs':[3, 3]})\n>>> x\n{'eggs', 'ham', 'spam'}\nPlus there are additional operations we won\u2019t illuminate here\u2014see a core language text\nsuch as Learning Python for more details. For instance, built-in sets also support op-\nerations such as superset testing, and they come in two flavors: mutable and frozen\n(frozen sets are hashable, and thus usable in sets of sets). Moreover, set comprehensions\nare more powerful than suggested, and sets are a natural at duplicate removal:\n>>> y = {c.upper() * 4 for c in 'spamham'}   # set comprehension\n>>> y\n{'SSSS', 'AAAA', 'MMMM', 'HHHH', 'PPPP'}\n>>>\n>>> list(set([1, 2, 3, 1, 2]))               # remove duplicates from a list\n[1, 2, 3]\nAs for stacks, though, the built-in set type might not by itself achieve all our goals.\nMoreover, homegrown set implementations turn out to be an ideal vehicle for studying\ncustom data structure implementations in Python. Although the end result may not\ncompete with the performance of built-in set objects today, the code can still be in-\nstructive to read, and fun to experiment with.\nAlso as for stacks, a custom set implementation will generally be based upon other\nbuilt-in types. Python lists, tuples, and strings come close to the notion of a set: the\nin operator tests membership, for iterates, and so on. Here, we\u2019ll add operations not\ndirectly supported by Python sequences. In effect, we\u2019re extending built-in types for\nunique requirements.\nSet Functions\nAs before, let\u2019s first start out with a function-based set manager. But this time, instead\nof managing a shared set object in a module, let\u2019s define functions to implement set\noperations on passed-in Python sequences (see Example 18-8).\nExample 18-8. PP4E\\Dstruct\\Basic\\inter.py\n\"set operations for two sequences\"\ndef intersect(seq1, seq2):\n    res = []                          # start with an empty list\n    for x in seq1:                    # scan the first sequence\n        if x in seq2:\n            res.append(x)             # add common items to the end\n    return res\ndef union(seq1, seq2):\n    res = list(seq1)                  # make a copy of seq1\n    for x in seq2:                    # add new items in seq2\n        if not x in res:\nImplementing Sets | 1375res.append(x)\n    return res\nThese functions work on any type of sequence\u2014lists strings, tuples, and other iterable\nobjects that conform to the protocols expected by these functions (for loops, in mem-\nbership tests). In fact, we can even use them on mixed object types: the last two com-\nmands in the following test compute the intersection and union of a list and a tuple.\nAs usual in Python, the object interface is what matters, not the specific types:\nC:\\...\\PP4E\\Dstruct\\Basic> python\n>>> from inter import *\n>>> s1 = \"SPAM\"\n>>> s2 = \"SCAM\"\n>>> intersect(s1, s2), union(s1, s2)\n(['S', 'A', 'M'], ['S', 'P', 'A', 'M', 'C'])\n>>> intersect([1,2,3], (1,4))\n[1]\n>>> union([1,2,3], (1,4))\n[1, 2, 3, 4]\nNotice that the result is always a list here, regardless of the type of sequences passed\nin. We could work around this by converting types or by using a class to sidestep this\nissue (and we will in a moment). But type conversions aren\u2019t clear-cut if the operands\nare mixed-type sequences. Which type do we convert to?\nSupporting multiple operands\nIf we\u2019re going to use the intersect and union functions as general tools, one useful\nextension is support for multiple arguments (i.e., more than two). The functions in\nExample 18-9 use Python\u2019s variable-length argument lists feature to compute the in-\ntersection and union of arbitrarily many operands.\nExample 18-9. PP4E\\Dstruct\\Basic\\inter2.py\n\"set operations for multiple sequences\"\ndef intersect(*args):\n    res = []\n    for x in args[0]:                  # scan the first list\n        for other in args[1:]:         # for all other arguments\n            if x not in other: break   # this item in each one?\n        else:\n            res.append(x)              # add common items to the end\n    return res\ndef union(*args):\n    res = []\n    for seq in args:                   # for all sequence-arguments\n        for x in seq:                  # for all nodes in argument\n            if not x in res:\n                res.append(x)          # add new items to result\n    return res\n1376 | Chapter 18:\u2002Data StructuresThese multi-operand functions work on sequences in the same way as the originals,\nbut they also support three or more operands. Notice the use of an else on the\nintersection\u2019s for loop here to detect common items. Also note that the last two ex-\namples in the following session work on lists with embedded compound objects: the\nin tests used by the intersect and union functions apply equality testing to sequence\nnodes recursively, as deep as necessary to determine collection comparison results:\nC:\\...\\PP4E\\Dstruct\\Basic> python\n>>> from inter2 import *\n>>> s1, s2, s3 = 'SPAM', 'SLAM', 'SCAM'\n>>> intersect(s1, s2)\n['S', 'A', 'M']\n>>> intersect(s1, s2, s3)\n['S', 'A', 'M']\n>>> intersect(s1, s2, s3, 'HAM')\n['A', 'M']\n>>> union(s1, s2), union(s1, s2, s3)\n(['S', 'P', 'A', 'M', 'L'], ['S', 'P', 'A', 'M', 'L', 'C'])\n>>> intersect([1, 2, 3], (1, 4), range(5))                      # 3.X: range okay\n[1]\n>>> s1 = (9, (3.14, 1), \"bye\", [1, 2], \"mello\")\n>>> s2 = [[1, 2], \"hello\", (3.14, 0), 9]\n>>> intersect(s1, s2)\n[9, [1, 2]]\n>>> union(s1, s2)\n[9, (3.14, 1), 'bye', [1, 2], 'mello', 'hello', (3.14, 0)]\nSet Classes\nThe preceding section\u2019s set functions can operate on a variety of objects, but they aren\u2019t\nas friendly as true objects. Among other things, your scripts need to keep track of the\nsequences passed into these functions manually. Classes can do better: the class in\nExample 18-10 implements a set object that can hold any type of object. Like the stack\nclasses, it\u2019s essentially a wrapper around a Python list with extra set operations.\nExample 18-10. PP4E\\Dstruct\\Basic\\set.py\n\"multi-instance, customizable, encapsulated set class\"\nclass Set:\n    def __init__(self, value = []):     # on object creation\n        self.data = []                  # manages a local list\n        self.concat(value)\n    def intersect(self, other):         # other is any sequence type\n        res = []                        # self is the instance subject\n        for x in self.data:\n            if x in other:\n                res.append(x)\n        return Set(res)                 # return a new Set\nImplementing Sets | 1377def union(self, other):\n        res = self.data[:]              # make a copy of my list\n        for x in other:\n            if not x in res:\n                res.append(x)\n        return Set(res)\n    def concat(self, value):            # value: a list, string, Set...\n        for x in value:                 # filters out duplicates\n           if not x in self.data:\n                self.data.append(x)\n    def __len__(self):          return len(self.data)\n    def __getitem__(self, key): return self.data[key]\n    def __and__(self, other):   return self.intersect(other)\n    def __or__(self, other):    return self.union(other)\n    def __repr__(self):         return '<Set:' + repr(self.data) + '>'\nThe Set class is used like the Stack class we saw earlier in this chapter: we make instances\nand apply sequence operators plus unique set operations to them. Intersection and\nunion can be called as methods, or by using the & and | operators normally used for\nbuilt-in integer objects. Because we can string operators in expressions now (e.g., x &\ny & z), there is no obvious need to support multiple operands in intersect/union\nmethods here (though this model\u2019s need to create temporary objects within expressions\nmight eventually come to bear on performance). As with all rightly packaged objects,\nwe can either use the Set class within a program or test it interactively as follows:\n>>> from set import Set\n>>> users1 = Set(['Bob', 'Emily', 'Howard', 'Peeper'])\n>>> users2 = Set(['Jerry', 'Howard', 'Carol'])\n>>> users3 = Set(['Emily', 'Carol'])\n>>> users1 & users2\n<Set:['Howard']>\n>>> users1 | users2\n<Set:['Bob', 'Emily', 'Howard', 'Peeper', 'Jerry', 'Carol']>\n>>> users1 | users2 & users3\n<Set:['Bob', 'Emily', 'Howard', 'Peeper', 'Carol']>\n>>> (users1 | users2) & users3\n<Set:['Emily', 'Carol']>\n>>> users1.data\n['Bob', 'Emily', 'Howard', 'Peeper']\nOptimization: Moving Sets to Dictionaries\nOnce you start using the Set class, the first problem you might encounter is its per-\nformance: its nested for loops and in scans become exponentially slow. That slowness\nmay or may not be significant in your applications, but library classes should generally\nbe coded as efficiently as possible.\nOne way to optimize set performance is by changing the implementation to use dic-\ntionaries rather than lists for storing sets internally\u2014items may be stored as the keys\n1378 | Chapter 18:\u2002Data Structuresof a dictionary whose values are all None. Because lookup time is constant and short for\ndictionaries, the in list scans of the original set can be replaced with direct dictionary\nfetches in this scheme. In traditional terms, moving sets to dictionaries replaces slow\nlinear searches with fast hashtable fetches. A computer scientist would explain this by\nsaying that the repeated nested scanning of the list-based intersection is an exponen-\ntial algorithm in terms of its complexity, but dictionaries can be linear.\nThe module in Example 18-11 implements this idea. Its class is a subclass of the original\nset, and it redefines the methods that deal with the internal representation but inherits\nothers. The inherited & and | methods trigger the new intersect and union methods\nhere, and the inherited len method works on dictionaries as is. As long as Set clients\nare not dependent on the order of items in a set, most can switch to this version directly\nby just changing the name of the module from which Set is imported; the class name\nis the same.\nExample 18-11. PP4E\\Dstruct\\Basic\\fastset.py\n\"optimize with linear-time scans using dictionaries\"\nimport set\n                                           # fastset.Set extends set.Set\nclass Set(set.Set):\n    def __init__(self, value = []):\n        self.data = {}                     # manages a local dictionary\n        self.concat(value)                 # hashing: linear search times\n    def intersect(self, other):\n        res = {}\n        for x in other:                    # other: a sequence or Set\n            if x in self.data:             # use hash-table lookup; 3.X\n                res[x] = None\n        return Set(res.keys())             # a new dictionary-based Set\n    def union(self, other):\n        res = {}                           # other: a sequence or Set\n        for x in other:                    # scan each set just once\n            res[x] = None\n        for x in self.data.keys():         # '&' and '|' come back here\n            res[x] = None                  # so they make new fastset's\n        return Set(res.keys())\n    def concat(self, value):\n        for x in value: self.data[x] = None\n    # inherit and, or, len\n    def __getitem__(self, ix):\n        return list(self.data.keys())[ix]            # 3.X: list()\n    def __repr__(self):\n        return '<Set:%r>' % list(self.data.keys())  # ditto\nImplementing Sets | 1379This works about the same as the previous version, even though the internal imple-\nmentation is radically different:\n>>> from fastset import Set\n>>> users1 = Set(['Bob', 'Emily', 'Howard', 'Peeper'])\n>>> users2 = Set(['Jerry', 'Howard', 'Carol'])\n>>> users3 = Set(['Emily', 'Carol'])\n>>> users1 & users2\n<Set:['Howard']>\n>>> users1 | users2\n<Set:['Howard', 'Peeper', 'Jerry', 'Carol', 'Bob', 'Emily']>\n>>> users1 | users2 & users3\n<Set:['Peeper', 'Carol', 'Howard', 'Bob', 'Emily']>\n>>> (users1 | users2) & users3\n<Set:['Carol', 'Emily']>\n>>> users1.data\n{'Peeper': None, 'Bob': None, 'Howard': None, 'Emily': None}\nThe main functional difference in this version is the order of items in the set: because\ndictionaries are randomly ordered, this set\u2019s order will differ from the original. The\norder of results can even vary across Python releases (in fact it did, between Python 2.X\nand 3.X in the third and fourth editions of this book). For instance, you can store\ncompound objects in sets, but the order of items varies in this version:\n>>> import set, fastset\n>>> a = set.Set([(1,2), (3,4), (5,6)])\n>>> b = set.Set([(3,4), (7,8)])\n>>> a & b\n<Set:[(3, 4)]>\n>>> a | b\n<Set:[(1, 2), (3, 4), (5, 6), (7, 8)]>\n>>> a = fastset.Set([(1,2), (3,4), (5,6)])\n>>> b = fastset.Set([(3,4), (7,8)])\n>>> a & b\n<Set:[(3, 4)]>\n>>> a | b\n<Set:[(1, 2), (5, 6), (3, 4), (7, 8)]>\n>>> b | a\n<Set:[(1, 2), (5, 6), (3, 4), (7, 8)]>\nSets aren\u2019t supposed to be ordered anyhow, so this isn\u2019t a showstopper. A deviation\nthat might matter, though, is that this version cannot be used to store unhashable (that\nis, immutable) objects. This stems from the fact that dictionary keys must be immutable.\nBecause values are stored in keys, dictionary sets can contain only things such as tuples,\nstrings, numbers, and class objects with immutable signatures. Mutable objects such\nas lists and dictionaries won\u2019t work directly in this dictionary-based set, but do in the\noriginal set class. Tuples do work here as compound set items, though, because they\nare immutable; Python computes hash values and tests key equality as expected:\n>>> set.Set([[1, 2],[3, 4]])\n<Set:[[1, 2], [3, 4]]>\n>>> fastset.Set([[1, 2],[3, 4]])\nTypeError: unhashable type: 'list'\n1380 | Chapter 18:\u2002Data Structures>>> x = fastset.Set([(1, 2), (3, 4)])\n>>> x & fastset.Set([(3, 4), (1, 5)])\n<Set:[(3, 4)]>\nTiming the results under Python 3.1\nSo how did we do on the optimization front this time? Again, guesses aren\u2019t usually\ngood enough, though algorithmic complexity seems a compelling piece of evidence\nhere. To be sure, Example 18-12 codes a script to compare set class performance. It\nreuses the timer module of Example 18-6 used earlier to compare stacks (our code may\nimplement different objects, but it doesn\u2019t warp time).\nExample 18-12. PP4E\\Dstruct\\Basic\\settime.py\n\"compare set alternatives performance\"\nimport timer, sys\nimport set, fastset\ndef setops(Class):                       # 3.X: range okay\n    a = Class(range(50))                 # a 50-integer set\n    b = Class(range(20))                 # a 20-integer set\n    c = Class(range(10))\n    d = Class(range(5))\n    for i in range(5):\n        t = a & b & c & d                # 3 intersections\n        t = a | b | c | d                # 3 unions\nif __name__ == '__main__':\n    rept = int(sys.argv[1])\n    print('set =>    ', timer.test(rept, setops, set.Set))\n    print('fastset =>', timer.test(rept, setops, fastset.Set))\nThe setops function makes four sets and combines them with intersection and union\noperators five times. A command-line argument controls the number of times this\nwhole process is repeated. More accurately, each call to setops makes 34 Set instances\n(4 + [5 \u00d7 (3 + 3)]) and runs the intersect and union methods 15 times each (5 \u00d7 3) in\nthe for loop\u2019s body. The performance improvement is equally dramatic this time\naround, on the same Windows 7 laptop under Python 3.1:\nC:\\...\\PP4E\\Dstruct\\Basic> python settime.py 50\nset =>     0.637593916437\nfastset => 0.20435049302\nC:\\...\\PP4E\\Dstruct\\Basic> python settime.py 100\nset =>     1.21924758303\nfastset => 0.393896570828\nC:\\...\\PP4E\\Dstruct\\Basic> python settime.py 200\nset =>     2.51036677716\nfastset => 0.802708664223\nImplementing Sets | 1381These results will vary per machine, and they may vary per Python release. But at least\nfor this specific test case, the dictionary-based set implementation (fastest) is roughly\nthree times faster than the simple list-based set (set). In fact, this threefold speedup is\nprobably sufficient. Python dictionaries are already optimized hashtables that you\nmight be hard-pressed to improve on. Unless there is evidence that dictionary-based\nsets are still too slow, our work here is probably done.\nBy comparison, results for Python 2.4 in the prior edition of this book showed\nfastest to be six times faster than set in all cases. Either iteration operations sped up,\nor dictionary operations slowed down in 3.X. In the even older Python 1.5.2 and second\nedition, the relative results were the same as they are today in Python 3.1. In any event,\nthis well underscores the fact that you must test performance on your machine and\nyour Python\u2014today\u2019s Python performance observation may easily be tomorrow\u2019s his-\ntoric anecdote.\nAdding Relational Algebra to Sets (External)\nIf you are interested in studying additional set-like operations coded in Python, see the\nfollowing files in this book\u2019s examples distribution:\nPP4E\\Dstruct\\Basic\\rset.py\nRSet implementation\nPP4E\\Dstruct\\Basic\\reltest.py\nTest script for RSet; its expected output is in reltest.results.txt\nThe RSet subclass defined in rset.py adds basic relational algebra operations for sets of\ndictionaries. It assumes the items in sets are mappings (rows), with one entry per col-\numn (field). RSet inherits all the original Set operations (iteration, intersection, union,\n& and | operators, uniqueness filtering, and so on), and adds new operations as\nmethods:\nSelect\nReturn a set of nodes that have a field equal to a given value.\nBagof\nCollect set nodes that satisfy an expression string.\nFind\nSelect tuples according to a comparison, field, and value.\nMatch\nFind nodes in two sets with the same values for common fields.\nProduct\nCompute a Cartesian product: concatenate tuples from two sets.\nJoin\nCombine tuples from two sets that have the same value for a field.\n1382 | Chapter 18:\u2002Data StructuresProject\nExtract named fields from the tuples in a table.\nDifference\nRemove one set\u2019s tuples from another.\nThese operations go beyond the tools provided by Python\u2019s built-in set object, and are\na prime example of why you may wish to implement a custom set type in the first place.\nAlthough I have ported this code to run under Python 3.X, I have not revisited it in any\nsort of depth for this edition, because today I would probably prefer to implement it\nas a subclass of the built-in set type, rather than a part of a proprietary set implemen-\ntation. Coincidentally, that leads us to our next topic.\nSubclassing Built-in Types\nBefore we move on to other classical data structures, there is one more twist in the stack\nand set story. In recent Python releases, it is also possible to subclass built-in datatypes\nsuch as lists and dictionaries, in order to extend them. That is, because datatypes are\nnow themselves customizable classes, we can code unique datatypes that are extensions\nof built-ins, with subclasses that inherit built-in tool sets. This is especially true in\nPython 3.X, where \u201ctype\u201d and \u201cclass\u201d have become veritable synonyms altogether.\nTo demonstrate, Example 18-13 shows the main parts of a module containing variants\nof our stack and set objects coded in the prior sections, revised as customized lists. For\nvariety, the set union method has also been simplified slightly here to remove a redun-\ndant loop.\nExample 18-13. PP4E\\Dstruct\\Basic\\typesubclass.py\n\"customize built-in types to extend, instead of starting from scratch\"\nclass Stack(list):\n    \"a list with extra methods\"\n    def top(self):\n        return self[-1]\n    def push(self, item):\n        list.append(self, item)\n    def pop(self):\n        if not self:\n            return None                 # avoid exception\n        else:\n            return list.pop(self)\nclass Set(list):\n    \" a list with extra methods and operators\"\n    def __init__(self, value=[]):      # on object creation\n        list.__init__(self)\n        self.concat(value)\nSubclassing Built-in Types | 1383def intersect(self, other):         # other is any sequence type\n        res = []                        # self is the instance subject\n        for x in self:\n            if x in other:\n                res.append(x)\n        return Set(res)                 # return a new Set\n    def union(self, other):\n        res = Set(self)                 # new set with a copy of my list\n        res.concat(other)               # insert uniques from other\n        return res\n    def concat(self, value):            # value: a list, string, Set...\n        for x in value:                 # filters out duplicates\n           if not x in self:\n                self.append(x)\n    # len, getitem, iter inherited, use list repr\n    def __and__(self, other):   return self.intersect(other)\n    def __or__(self, other):    return self.union(other)\n    def __str__(self):          return '<Set:' + repr(self) + '>'\nclass FastSet(dict):\n    pass    # this doesn't simplify much\n...self-test code omitted: see examples package file...\nThe stack and set implemented in this code are essentially like those we saw earlier,\nbut instead of embedding and managing a list, these objects really are customized lists.\nThey add a few additional methods, but they inherit all of the list object\u2019s functionality.\nThis can reduce the amount of wrapper code required, but it can also expose func-\ntionality that might not be appropriate in some cases. As coded, for example, we\u2019re\nable to sort and insert into stacks and reverse a set, because we\u2019ve inherited these\nmethods from the built-in list object. In most cases, such operations don\u2019t make sense\nfor these data structures, and barring extra code that disables such nonfeatures, the\nwrapper class approach of the prior sections may still be preferred.\nFor more on the class subtype classes, see the remainder of their implementation file\nin the examples package for self-test code and its expected output. Because these objects\nare used in the same way as our original stacks and sets, interacting with them is left\nas suggested exercise here.\nSubclassing built-in types has other applications, which may be more useful than those\ndemonstrated by the preceding code. Consider a queue, or ordered dictionary, for ex-\nample. The queue could take the form of a list subclass with get and put methods to\ninsert on one end and delete from the other; the dictionary could be coded as a dic-\ntionary subclass with an extra list of keys that is sorted on insertion or request. While\nthis scheme works well for types that resemble built-ins, though, type subclasses may\n1384 | Chapter 18:\u2002Data Structuresnot address data structures of radically different form\u2014like those of the next two \nsections.\nBinary Search Trees\nBinary trees are a data structure that impose an order on inserted nodes: items less than\na node are stored in the left subtree, and items greater than a node are inserted in the\nright. At the bottom, the subtrees are empty. Because of this structure, binary trees\nnaturally support quick, recursive traversals, and hence fast lookup and search in a\nwide variety of applications\u2014at least ideally, every time you follow a link to a subtree,\nyou divide the search space in half.\nBuilt-in Options\nHere too, Python supports search operations with built-in tools. Dictionaries, for ex-\nample, already provide a highly optimized, C-coded search table tool. In fact, indexing\na dictionary by key directly is likely to be faster than searching a Python-coded\nequivalent:\n>>> x = {}                                          # empty dict\n>>> for i in [3, 1, 9, 2, 7]: x[i] = None           # insert\n...\n>>> x\n{7: None, 1: None, 2: None, 3: None, 9: None}\n>>>\n>>> for i in range(8): print((i, i in x), end=' ')  # lookup\n...\n(0, False) (1, True) (2, True) (3, True) (4, False) (5, False) (6, False) (7, True)\nBecause dictionaries are built into the language, they are always available and will usu-\nally be faster than Python-based data structure implementations. Built-in sets can often\noffer similar functionality\u2014in fact, it\u2019s not too much of an abstraction to think of sets\nas valueless dictionaries:\n>>> x = set()                                       # empty set\n>>> for i in [3, 1, 9, 2, 7]: x.add(i)              # insert\n...\n>>> x\n{7, 1, 2, 3, 9}\n>>> for i in range(8): print((i, i in x), end=' ')  # lookup\n...\n(0, False) (1, True) (2, True) (3, True) (4, False) (5, False) (6, False) (7, True)\nIn fact, there are a variety of ways to insert items into both sets and dictionaries; both\nare useful for checking if a key is stored, but dictionaries further allow search keys to\nhave associated values:\n>>> v = [3, 1, 9]\n>>> {k for k in v}                       # set comprehension\nBinary Search Trees | 1385{1, 3, 9}\n>>> set(v)                               # set constructor\n{1, 3, 9}\n>>> {k: k+100 for k in v}                # dict comprehension\n{1: 101, 3: 103, 9: 109}\n>>> dict(zip(v, [99] * len(v)))          # dict constructor\n{1: 99, 3: 99, 9: 99}\n>>> dict.fromkeys(v, 99)                 # dict method\n{1: 99, 3: 99, 9: 99}\nSo why bother with a custom search data structure implementation here, given such\nflexible built-ins? In some applications, you might not, but here especially, a custom\nimplementation often makes sense to allow for customized tree algorithms. For in-\nstance, custom tree balancing can help speed lookups in pathological cases, and might\noutperform the generalized hashing algorithms used in dictionaries and sets. Moreover,\nthe same motivations we gave for custom stacks and sets apply here as well\u2014by en-\ncapsulating tree access in class-based interfaces, we support future extension and\nchange in more manageable ways.\nImplementing Binary Trees\nBinary trees are named for the implied branch-like structure of their subtree links.\nTypically, their nodes are implemented as a triple of values: (LeftSubtree, NodeValue,\nRightSubtree). Beyond that, there is fairly wide latitude in the tree implementation.\nHere we\u2019ll use a class-based approach:\n\u2022 BinaryTree is a header object, which initializes and manages the actual tree.\n\u2022 EmptyNode is the empty object, shared at all empty subtrees (at the bottom).\n\u2022 BinaryNode objects are nonempty tree nodes with a value and two subtrees.\nInstead of coding distinct search functions, binary trees are constructed with \u201csmart\u201d\nobjects\u2014class instances that know how to handle insert/lookup and printing requests\nand pass them to subtree objects. In fact, this is another example of the object-oriented\nprogramming (OOP) composition relationship in action: tree nodes embed other tree\nnodes and pass search requests off to the embedded subtrees. A single empty class\ninstance is shared by all empty subtrees in a binary tree, and inserts replace an Empty\nNode with a BinaryNode at the bottom. Example 18-14 shows what this means in code.\nExample 18-14. PP4E\\Dstruct\\Classics\\btree.py\n\"a valueless binary search tree\"\nclass BinaryTree:\n    def __init__(self):       self.tree = EmptyNode()\n    def __repr__(self):       return repr(self.tree)\n    def lookup(self, value):  return self.tree.lookup(value)\n    def insert(self, value):  self.tree = self.tree.insert(value)\n1386 | Chapter 18:\u2002Data Structuresclass EmptyNode:\n    def __repr__(self):\n        return '*'\n    def lookup(self, value):                      # fail at the bottom\n        return False\n    def insert(self, value):\n        return BinaryNode(self, value, self)      # add new node at bottom\nclass BinaryNode:\n    def __init__(self, left, value, right):\n        self.data, self.left, self.right  =  value, left, right\n    def lookup(self, value):\n        if self.data == value:\n            return True\n        elif self.data > value:\n            return self.left.lookup(value)               # look in left\n        else:\n            return self.right.lookup(value)              # look in right\n    def insert(self, value):\n        if self.data > value:\n            self.left = self.left.insert(value)          # grow in left\n        elif self.data < value:\n            self.right = self.right.insert(value)        # grow in right\n        return self\n    def __repr__(self):\n        return ('( %s, %s, %s )' %\n                 (repr(self.left), repr(self.data), repr(self.right)))\nAs usual, BinaryTree can contain objects of any type that support the expected interface\nprotocol\u2014here, > and < comparisons. This includes class instances with the __lt__ and\n__gt__ methods. Let\u2019s experiment with this module\u2019s interfaces. The following code\nstuffs five integers into a new tree, and then searches for values 0 . . . 7, as we did earlier\nfor dictionaries and sets:\nC:\\...\\PP4E\\Dstruct\\Classics> python\n>>> from btree import BinaryTree\n>>> x = BinaryTree()\n>>> for i in [3, 1, 9, 2, 7]: x.insert(i)\n...\n>>> for i in range(8): print((i, x.lookup(i)), end=' ')\n...\n (0, False) (1, True) (2, True) (3, True) (4, False) (5, False) (6, False) (7, True)\nTo watch this tree grow, add a print call statement after each insert. Tree nodes print\nthemselves as triples, and empty nodes print as *. The result reflects tree nesting:\n>>> y = BinaryTree()\n>>> y\n*\n>>> for i in [3, 1, 9, 2, 7]:\n...     y.insert(i); print(y)\n...\nBinary Search Trees | 1387( *, 3, * )\n( ( *, 1, * ), 3, * )\n( ( *, 1, * ), 3, ( *, 9, * ) )\n( ( *, 1, ( *, 2, * ) ), 3, ( *, 9, * ) )\n( ( *, 1, ( *, 2, * ) ), 3, ( ( *, 7, * ), 9, * ) )\nAt the end of this chapter, we\u2019ll see another way to visualize such trees in a GUI named\nPyTree (you\u2019re invited to flip ahead now if you prefer). Node values in this tree object\ncan be any comparable Python object\u2014for instance, here is a tree of strings:\n>>> z = BinaryTree()\n>>> for c in 'badce':  z.insert(c)\n...\n>>> z\n( ( *, 'a', * ), 'b', ( ( *, 'c', * ), 'd', ( *, 'e', * ) ) )\n>>> z = BinaryTree()\n>>> for c in 'abcde':  z.insert(c)\n...\n>>> z\n( *, 'a', ( *, 'b', ( *, 'c', ( *, 'd', ( *, 'e', * ) ) ) ) )\n>>> z = BinaryTree()\n>>> for c in 'edcba':  z.insert(c)\n...\n>>> z\n( ( ( ( ( *, 'a', * ), 'b', * ), 'c', * ), 'd', * ), 'e', * )\nNotice the last tests here: if items inserted into a binary tree are already ordered, you\nwind up with a linear structure and lose the search-space partitioning magic of binary\ntrees (the tree grows in right or left branches only). This is a worst-case scenario, and\nbinary trees generally do a good job of dividing values in practice. But if you are inter-\nested in pursuing this topic further, see a data structures text for tree-balancing tech-\nniques that automatically keep the tree as dense as possible but are beyond our scope\nhere.\nTrees with Both Keys and Values\nAlso note that to keep the code simple, these trees store a value only and lookups return\na true or false result. In practice, you sometimes may want to store both a key and an\nassociated value (or even more) at each tree node. Example 18-15 shows what such a\ntree object looks like, for any prospective lumberjacks in the audience.\nExample 18-15. PP4E\\Dstruct\\Classics\\btreevals.py\n\"a binary search tree with values for stored keys\"\nclass KeyedBinaryTree:\n    def __init__(self):          self.tree = EmptyNode()\n    def __repr__(self):          return repr(self.tree)\n    def lookup(self, key):       return self.tree.lookup(key)\n    def insert(self, key, val):  self.tree = self.tree.insert(key, val)\n1388 | Chapter 18:\u2002Data Structuresclass EmptyNode:\n    def __repr__(self):\n        return '*'\n    def lookup(self, key):                               # fail at the bottom\n        return None\n    def insert(self, key, val):\n        return BinaryNode(self, key, val, self)          # add node at bottom\nclass BinaryNode:\n    def __init__(self, left, key, val, right):\n        self.key,  self.val   = key, val\n        self.left, self.right = left, right\n    def lookup(self, key):\n        if self.key == key:\n            return self.val\n        elif self.key > key:\n            return self.left.lookup(key)                 # look in left\n        else:\n            return self.right.lookup(key)                # look in right\n    def insert(self, key, val):\n        if self.key == key:\n            self.val = val\n        elif self.key > key:\n            self.left = self.left.insert(key, val)       # grow in left\n        elif self.key < key:\n            self.right = self.right.insert(key, val)     # grow in right\n        return self\n    def __repr__(self):\n        return ('( %s, %s=%s, %s )' %\n        (repr(self.left), repr(self.key), repr(self.val), repr(self.right)))\nif __name__ == '__main__':\n    t = KeyedBinaryTree()\n    for (key, val) in [('bbb', 1), ('aaa', 2), ('ccc', 3)]:\n        t.insert(key, val)\n    print(t)\n    print(t.lookup('aaa'), t.lookup('ccc'))\n    t.insert('ddd', 4)\n    t.insert('aaa', 5)                       # changes key's value\n    print(t)\nThe following shows this script\u2019s self-test code at work; nodes simply have more con-\ntent this time around:\nC:\\...\\PP4E\\Dstruct\\Classics> python btreevals.py\n( ( *, 'aaa'=2, * ), 'bbb'=1, ( *, 'ccc'=3, * ) )\n2 3\n( ( *, 'aaa'=5, * ), 'bbb'=1, ( *, 'ccc'=3, ( *, 'ddd'=4, * ) ) )\nIn fact, the effect is similar to the keys and values of a built-in dictionary, but a custom\ntree structure like this might support custom use cases and algorithms, as well as code\nBinary Search Trees | 1389evolution, more robustly. To see a data structure that departs even further from the\nbuilt-in gang, though, we need to move on to the next section.\nGraph Searching\nMany problems that crop up in both real life and real programming can be fairly rep-\nresented as a graph\u2014a set of states with transitions (\u201carcs\u201d) that lead from one state\nto another. For example, planning a route for a trip is really a graph search problem in\ndisguise: the states are places you\u2019d like to visit, and the arcs are the transportation\nlinks between them. A program that searches for a trip\u2019s optimal route is a graph\nsearcher. For that matter, so are many programs that walk hyperlinks on the Web.\nThis section presents simple Python programs that search through a directed, cyclic\ngraph to find the paths between a start state and a goal. Graphs can be more general\nthan trees because links may point at arbitrary nodes\u2014even ones already searched\n(hence the word cyclic). Moreover, there isn\u2019t any direct built-in support for this type\nof goal; although graph searchers may ultimately use built-in types, their search routines\nare custom enough to warrant proprietary implementations.\nThe graph used to test searchers in this section is sketched in Figure 18-1. Arrows at\nthe end of arcs indicate valid paths (e.g., A leads to B, E, and G). The search algorithms\nwill traverse this graph in a depth-first fashion, and they will trap cycles in order to\navoid looping. If you pretend that this is a map, where nodes represent cities and arcs\nrepresent roads, this example will probably seem a bit more meaningful.\nFigure 18-1. A directed graph\nImplementing Graph Search\nThe first thing we need to do is choose a way to represent this graph in a Python script.\nOne approach is to use built-in datatypes and searcher functions. The file in Exam-\nple 18-16 builds the test graph as a simple dictionary: each state is a dictionary key,\n1390 | Chapter 18:\u2002Data Structureswith a list of keys of nodes it leads to (i.e., its arcs). This file also defines a function that\nwe\u2019ll use to run a few searches in the graph.\nExample 18-16. PP4E\\Dstruct\\Classics\\gtestfunc.py\n\"dictionary based graph representation\"\nGraph = {'A':  ['B', 'E', 'G'],\n         'B':  ['C'],                        # a directed, cyclic graph\n         'C':  ['D', 'E'],                   # stored as a dictionary\n         'D':  ['F'],                        # 'key' leads-to [nodes]\n         'E':  ['C', 'F', 'G'],\n         'F':  [ ],\n         'G':  ['A']  }\ndef tests(searcher):                         # test searcher function\n    print(searcher('E', 'D', Graph))         # find all paths from 'E' to 'D'\n    for x in ['AG', 'GF', 'BA', 'DA']:\n        print(x, searcher(x[0], x[1], Graph))\nNow, let\u2019s code two modules that implement the actual search algorithms. They are\nboth independent of the graph to be searched (it is passed in as an argument). The first\nsearcher, in Example 18-17, uses recursion to walk through the graph.\nExample 18-17. PP4E\\Dstruct\\Classics\\gsearch1.py\n\"find all paths from start to goal in graph\"\ndef search(start, goal, graph):\n    solns = []\n    generate([start], goal, solns, graph)              # collect paths\n    solns.sort(key=lambda x: len(x))                   # sort by path length\n    return solns\ndef generate(path, goal, solns, graph):\n    state = path[-1]\n    if state == goal:                                  # found goal here\n        solns.append(path)                             # change solns in-place\n    else:                                              # check all arcs here\n        for arc in graph[state]:                       # skip cycles on path\n            if arc not in path:\n                generate(path + [arc], goal, solns, graph)\nif __name__ == '__main__':\n    import gtestfunc\n    gtestfunc.tests(search)\nThe second searcher, in Example 18-18, uses an explicit stack of paths to be expanded\nusing the tuple-tree stack representation we explored earlier in this chapter.\nGraph Searching | 1391Example 18-18. PP4E\\Dstruct\\Classics\\gsearch2.py\n\"graph search, using paths stack instead of recursion\"\ndef search(start, goal, graph):\n    solns = generate(([start], []), goal, graph)\n    solns.sort(key=lambda x: len(x))\n    return solns\ndef generate(paths, goal, graph):                      # returns solns list\n    solns = []                                         # use a tuple-stack\n    while paths:\n        front, paths = paths                           # pop the top path\n        state = front[-1]\n        if state == goal:\n            solns.append(front)                        # goal on this path\n        else:\n            for arc in graph[state]:                   # add all extensions\n                if arc not in front:\n                    paths = (front + [arc]), paths\n    return solns\nif __name__ == '__main__':\n    import gtestfunc\n    gtestfunc.tests(search)\nTo avoid cycles, both searchers keep track of nodes visited along a path. If an extension\nis already on the current path, it is a loop. The resulting solutions list is sorted by\nincreasing lengths using the list sort method and its optional key value transform ar-\ngument. To test the searcher modules, simply run them; their self-test code calls the\ncanned search test in the gtestfunc module:\nC:\\...\\PP4E\\Dstruct\\Classics> python gsearch1.py\n[['E', 'C', 'D'], ['E', 'G', 'A', 'B', 'C', 'D']]\nAG [['A', 'G'], ['A', 'E', 'G'], ['A', 'B', 'C', 'E', 'G']]\nGF [['G', 'A', 'E', 'F'], ['G', 'A', 'B', 'C', 'D', 'F'],\n    ['G', 'A', 'B', 'C', 'E', 'F'], ['G', 'A', 'E', 'C', 'D', 'F']]\nBA [['B', 'C', 'E', 'G', 'A']]\nDA []\nC:\\...\\PP4E\\Dstruct\\Classics> python gsearch2.py\n[['E', 'C', 'D'], ['E', 'G', 'A', 'B', 'C', 'D']]\nAG [['A', 'G'], ['A', 'E', 'G'], ['A', 'B', 'C', 'E', 'G']]\nGF [['G', 'A', 'E', 'F'], ['G', 'A', 'E', 'C', 'D', 'F'],\n    ['G', 'A', 'B', 'C', 'E', 'F'], ['G', 'A', 'B', 'C', 'D', 'F']]\nBA [['B', 'C', 'E', 'G', 'A']]\nDA []\nThis output shows lists of possible paths through the test graph; I added two line breaks\nto make it more readable (Python pprint pretty-printer module might help with read-\nability here as well). Notice that both searchers find the same paths in all tests, but the\norder in which they find those solutions may differ. The gsearch2 order depends on\n1392 | Chapter 18:\u2002Data Structureshow and when extensions are added to its path\u2019s stack; try tracing through the outputs\nand code to see how.\nMoving Graphs to Classes\nUsing dictionaries to represent graphs is efficient: connected nodes are located by a fast\nhashing operation. But depending on the application, other representations might\nmake more sense. For instance, classes can be used to model nodes in a network, too,\nmuch like the binary tree example earlier. As classes, nodes may contain content useful\nfor more sophisticated searches. They may also participate in inheritance hierarchies,\nto acquire additional behaviors. To illustrate the basic idea, Example 18-19 shows an\nalternative coding for our graph searcher; its algorithm is closest to gsearch1.\nExample 18-19. PP4E\\Dstruct\\Classics\\graph.py\n\"build graph with objects that know how to search\"\nclass Graph:\n    def __init__(self, label, extra=None):\n        self.name = label                                # nodes=inst objects\n        self.data = extra                                # graph=linked objs\n        self.arcs = []\n    def __repr__(self):\n        return self.name\n    def search(self, goal):\n        Graph.solns = []\n        self.generate([self], goal)\n        Graph.solns.sort(key=lambda x: len(x))\n        return Graph.solns\n    def generate(self, path, goal):\n        if self == goal:                                 # class == tests addr\n            Graph.solns.append(path)                     # or self.solns: same\n        else:\n            for arc in self.arcs:\n                if arc not in path:\n                    arc.generate(path + [arc], goal)\nIn this version, graphs are represented as a network of embedded class instance objects.\nEach node in the graph contains a list of the node objects it leads to (arcs), which it\nknows how to search. The generate method walks through the objects in the graph.\nBut this time, links are directly available on each node\u2019s arcs list; there is no need to\nindex (or pass) a dictionary to find linked objects. The search is effectively spread across\nthe graph\u2019s linked objects.\nTo test, the module in Example 18-20 builds the test graph again, this time using linked\ninstances of the Graph class. Notice the use of exec in this code: it executes dynamically\nGraph Searching | 1393constructed strings to do the work of seven assignment statements (A=Graph('A'),\nB=Graph('B'), and so on).\nExample 18-20. PP4E\\Dstruct\\Classics\\gtestobj1.py\n\"build class-based graph and run test searches\"\nfrom graph import Graph\n# this doesn't work inside def in 3.1: B undefined\nfor name in \"ABCDEFG\":                               # make objects first\n    exec(\"%s = Graph('%s')\" % (name, name))          # label=variable-name\nA.arcs = [B, E, G]\nB.arcs = [C]                 # now configure their links:\nC.arcs = [D, E]              # embedded class-instance list\nD.arcs = [F]\nE.arcs = [C, F, G]\nG.arcs = [A]\nA.search(G)\nfor (start, stop) in [(E,D), (A,G), (G,F), (B,A), (D,A)]:\n    print(start.search(stop))\nRunning this test executes the same sort of graph walking, but this time it\u2019s routed\nthrough object methods:\nC:\\...\\PP4E\\Dstruct\\Classics> python gtestobj1.py\n[[E, C, D], [E, G, A, B, C, D]]\n[[A, G], [A, E, G], [A, B, C, E, G]]\n[[G, A, E, F], [G, A, B, C, D, F], [G, A, B, C, E, F], [G, A, E, C, D, F]]\n[[B, C, E, G, A]]\n[]\nThe results are the same as for the functions, but node name labels are not quoted:\nnodes on path lists here are Graph instances, and this class\u2019s __repr__ scheme suppresses\nquotes. Example 18-21 is one last graph test before we move on; sketch the nodes and\narcs on paper if you have more trouble following the paths than Python.\nExample 18-21. PP4E\\Dstruct\\Classics\\gtestobj2.py\nfrom graph import Graph\nS = Graph('s')\nP = Graph('p')       # a graph of spam\nA = Graph('a')       # make node objects\nM = Graph('m')\nS.arcs = [P, M]      # S leads to P and M\nP.arcs = [S, M, A]   # arcs: embedded objects\nA.arcs = [M]\nprint(S.search(M))   # find all paths from S to M\n1394 | Chapter 18:\u2002Data StructuresThis test finds three paths in its graph between nodes S and M. We\u2019ve really only\nscratched the surface of this academic yet useful domain here; experiment further on\nyour own, and see other books for additional topics (e.g., breadth-first search by levels,\nand best-first search by path or state scores):\nC:\\...\\PP4E\\Dstruct\\Classics> python gtestobj2.py\n[[s, m], [s, p, m], [s, p, a, m]]\nPermuting Sequences\nOur next data structure topic implements extended functionality for sequences that is\nnot present in Python\u2019s built-in objects. The functions defined in Example 18-22 shuffle\nsequences in a number of ways:\npermute\nconstructs a list with all valid permutations of any sequence\nsubset\nconstructs a list with all valid permutations of a specific length\ncombo\nworks like subset, but order doesn\u2019t matter: permutations of the same items are\nfiltered out\nThese results are useful in a variety of algorithms: searches, statistical analysis, and\nmore. For instance, one way to find an optimal ordering for items is to put them in a\nlist, generate all possible permutations, and simply test each one in turn. All three of\nthe functions make use of generic sequence slicing so that the result list contains se-\nquences of the same type as the one passed in (e.g., when we permute a string, we get\nback a list of strings).\nExample 18-22. PP4E\\Dstruct\\Classics\\permcomb.py\n\"permutation-type operations for sequences\"\ndef permute(list):\n    if not list:                                        # shuffle any sequence\n        return [list]                                   # empty sequence\n    else:\n        res = []\n        for i in range(len(list)):\n            rest = list[:i] + list[i+1:]                # delete current node\n            for x in permute(rest):                     # permute the others\n                res.append(list[i:i+1] + x)             # add node at front\n        return res\ndef subset(list, size):\n    if size == 0 or not list:                            # order matters here\n        return [list[:0]]                                # an empty sequence\n    else:\n        result = []\nPermuting Sequences | 1395for i in range(len(list)):\n            pick = list[i:i+1]                           # sequence slice\n            rest = list[:i] + list[i+1:]                 # keep [:i] part\n            for x in subset(rest, size-1):\n                result.append(pick + x)\n        return result\ndef combo(list, size):\n    if size == 0 or not list:                            # order doesn't matter\n        return [list[:0]]                                # xyz == yzx\n    else:\n        result = []\n        for i in range(0, (len(list) - size) + 1):       # iff enough left\n            pick = list[i:i+1]\n            rest = list[i+1:]                            # drop [:i] part\n            for x in combo(rest, size - 1):\n                result.append(pick + x)\n        return result\nAll three of these functions work on any sequence object that supports len, slicing, and\nconcatenation operations. For instance, we can use permute on instances of some of the\nstack classes defined at the start of this chapter (experiment with this on your own for\nmore insights).\nThe following session shows our sequence shufflers in action. Permuting a list enables\nus to find all the ways the items can be arranged. For instance, for a four-item list, there\nare 24 possible permutations (4 \u00d7 3 \u00d7 2 \u00d7 1). After picking one of the four for the first\nposition, there are only three left to choose from for the second, and so on. Order\nmatters: [1,2,3] is not the same as [1,3,2], so both appear in the result:\nC:\\...\\PP4E\\Dstruct\\Classics> python\n>>> from permcomb import *\n>>> permute([1, 2, 3])\n[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n>>> permute('abc')\n['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n>>> permute('help')\n['help', 'hepl', 'hlep', 'hlpe', 'hpel', 'hple', 'ehlp', 'ehpl', 'elhp', 'elph',\n 'ephl', 'eplh', 'lhep', 'lhpe', 'lehp', 'leph', 'lphe', 'lpeh', 'phel', 'phle',\n 'pehl', 'pelh', 'plhe', 'pleh']\ncombo results are related to permutations, but a fixed-length constraint is put on the\nresult, and order doesn\u2019t matter: abc is the same as acb, so only one is added to the\nresult set:\n>>> combo([1, 2, 3], 3)\n[[1, 2, 3]]\n>>> combo('abc', 3)\n['abc']\n>>> combo('abc', 2)\n['ab', 'ac', 'bc']\n>>> combo('abc', 4)\n[]\n>>> combo((1, 2, 3, 4), 3)\n1396 | Chapter 18:\u2002Data Structures[(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]\n>>> for i in range(0, 6): print(i, combo(\"help\", i))\n...\n0 ['']\n1 ['h', 'e', 'l', 'p']\n2 ['he', 'hl', 'hp', 'el', 'ep', 'lp']\n3 ['hel', 'hep', 'hlp', 'elp']\n4 ['help']\n5 []\nFinally, subset is just fixed-length permutations; order matters, so the result is larger\nthan for combo. In fact, calling subset with the length of the sequence is identical to\npermute:\n>>> subset([1, 2, 3], 3)\n[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n>>> subset('abc', 3)\n['abc', 'acb', 'bac', 'bca', 'cab', 'cba']\n>>> for i in range(0, 6): print(i, subset(\"help\", i))\n...\n0 ['']\n1 ['h', 'e', 'l', 'p']\n2 ['he', 'hl', 'hp', 'eh', 'el', 'ep', 'lh', 'le', 'lp', 'ph', 'pe', 'pl']\n3 ['hel', 'hep', 'hle', 'hlp', 'hpe', 'hpl', 'ehl', 'ehp', 'elh', 'elp', 'eph',\n   'epl', 'lhe', 'lhp', 'leh', 'lep', 'lph', 'lpe', 'phe', 'phl', 'peh', 'pel',\n   'plh', 'ple']\n4 ['help', 'hepl', 'hlep', 'hlpe', 'hpel', 'hple', 'ehlp', 'ehpl', 'elhp',\n   'elph', 'ephl', 'eplh', 'lhep', 'lhpe', 'lehp', 'leph', 'lphe', 'lpeh',\n   'phel', 'phle', 'pehl', 'pelh', 'plhe', 'pleh']\n5 ['help', 'hepl', 'hlep', 'hlpe', 'hpel', 'hple', 'ehlp', 'ehpl', 'elhp',\n   'elph', 'ephl', 'eplh', 'lhep', 'lhpe', 'lehp', 'leph', 'lphe', 'lpeh',\n   'phel', 'phle', 'pehl', 'pelh', 'plhe', 'pleh']\nThese are some fairly dense algorithms (and frankly, may seem to require a Zen-like\n\u201cmoment of clarity\u201d to grasp completely), but they are not too obscure if you trace\nthrough a few simple cases first. They\u2019re also representative of the sort of operation\nthat requires custom data structure code\u2014unlike the last stop on our data structures\ntour in the next section.\nReversing and Sorting Sequences\nThe permutation utilities of the prior section are useful in a variety of applications, but\nthere are even more fundamental operations that might seem prime candidates for\nautomation. Reversing and sorting collections of values, for example, are core opera-\ntions in a broad range of programs. To demonstrate coding techniques, and to provide\nexamples that yield closure for a recurring theme of this chapter, let\u2019s take a quick look\nat both of these in turn.\nReversing and Sorting Sequences | 1397Implementing Reversals\nReversal of collections can be coded either recursively or iteratively in Python, and as\nfunctions or class methods. Example 18-23 is a first attempt at two simple reversal\nfunctions.\nExample 18-23. PP4E\\Dstruct\\Classics\\rev1.py\ndef reverse(list):               # recursive\n    if list == []:\n        return []\n    else:\n        return reverse(list[1:]) + list[:1]\ndef ireverse(list):              # iterative\n    res = []\n    for x in list: res = [x] + res\n    return res\nBoth reversal functions work correctly on lists. But if we try reversing nonlist sequences\n(strings, tuples, and so on), the ireverse function always returns a list for the result\nregardless of the type of sequence passed:\n>>> ireverse(\"spam\")\n['m', 'a', 'p', 's']\nMuch worse, the recursive reverse version won\u2019t work at all for nonlists\u2014it gets stuck\nin an infinite loop. The reason is subtle: when reverse reaches the empty string (\"\"),\nit\u2019s not equal to the empty list ([]), so the else clause is selected. But slicing an empty\nsequence returns another empty sequence (indexes are scaled): the else clause recurs\nagain with an empty sequence, without raising an exception. The net effect is that this\nfunction gets stuck in a loop, calling itself over and over again until Python runs out of\nmemory.\nThe versions in Example 18-24 fix both problems by using generic sequence handling\ntechniques much like that of the prior section\u2019s permutation utilities:\n\u2022 reverse uses the not operator to detect the end of the sequence and returns the\nempty sequence itself, rather than an empty list constant. Since the empty sequence\nis the type of the original argument, the + operation always builds the correct type\nsequence as the recursion unfolds.\n\u2022 ireverse makes use of the fact that slicing a sequence returns a sequence of the\nsame type. It first initializes the result to the slice [:0], a new, empty slice of\nthe argument\u2019s type. Later, it uses slicing to extract one-node sequences to add to\nthe result\u2019s front, instead of a list constant.\nExample 18-24. PP4E\\Dstruct\\Classics\\rev2.py\ndef reverse(list):\n    if not list:                               # empty? (not always [])\n        return list                            # the same sequence type\n1398 | Chapter 18:\u2002Data Structureselse:\n        return reverse(list[1:]) + list[:1]    # add front item on the end\ndef ireverse(list):\n    res = list[:0]                             # empty, of same type\n    for i in range(len(list)):\n        res = list[i:i+1] + res                # add each item to front\n    return res\nThe combination of the changes allows the new functions to work on any sequence,\nand return a new sequence of the same type as the sequence passed in. If we pass in a\nstring, we get a new string as the result. In fact, they reverse any sequence object that\nresponds to slicing, concatenation, and len\u2014even instances of Python classes and C\ntypes. In other words, they can reverse any object that has sequence interface protocols.\nHere they are working on lists, strings, and tuples:\n>>> from rev2 import *\n>>> reverse([1, 2, 3]), ireverse([1, 2, 3])\n([3, 2, 1], [3, 2, 1])\n>>> reverse(\"spam\"), ireverse(\"spam\")\n('maps', 'maps')\n>>> reverse((1.2, 2.3, 3.4)), ireverse((1.2, 2.3, 3.4))\n((3.4, 2.3, 1.2), (3.4, 2.3, 1.2))\nImplementing Sorts\nAnother staple of many systems is sorting: ordering items in a collection according to\nsome constraint. The script in Example 18-25 defines a simple sort routine in Python,\nwhich orders a list of objects on a field. Because Python indexing is generic, the field\ncan be an index or a key\u2014this function can sort lists of either sequences or mappings.\nExample 18-25. PP4E\\Dstruct\\Classics\\sort1.py\ndef sort(list, field):\n    res = []                                     # always returns a list\n    for x in list:\n        i = 0\n        for y in res:\n            if x[field] <= y[field]: break       # list node goes here?\n            i += 1\n        res[i:i] = [x]                           # insert in result slot\n    return res\nif __name__ == '__main__':\n    table = [ {'name':'john', 'age':25}, {'name':'doe', 'age':32} ]\n    print(sort(table, 'name'))\n    print(sort(table, 'age'))\n    table = [ ('john', 25), ('doe', 32) ]\n    print(sort(table, 0))\n    print(sort(table, 1))\nReversing and Sorting Sequences | 1399Here is this module\u2019s self-test code in action; the first tests sort dictionaries, and the\nlast sort tuples:\nC:\\...\\PP4E\\Dstruct\\Classics> python sort1.py\n[{'age': 32, 'name': 'doe'}, {'age': 25, 'name': 'john'}]\n[{'age': 25, 'name': 'john'}, {'age': 32, 'name': 'doe'}]\n[('doe', 32), ('john', 25)]\n[('john', 25), ('doe', 32)]\nAdding comparison functions\nSince functions can be passed in like any other object, we can easily allow for an optional\ncomparison function. In the next version, Example 18-26, the second argument takes\na function that should return true if its first argument should be placed before its\nsecond. A lambda is used to provide an ascending-order test by default. This sorter also\nreturns a new sequence that is the same type as the sequence passed in, by applying the\nslicing techniques used in the reversal tools earlier\u2014if you sort a tuple of nodes, you\nget back a tuple.\nExample 18-26. PP4E\\Dstruct\\Classics\\sort2.py\ndef sort(seq, func=(lambda x,y: x <= y)):             # default: ascending\n    res = seq[:0]                                     # return seq's type\n    for j in range(len(seq)):\n        i = 0\n        for y in res:\n            if func(seq[j], y): break\n            i += 1\n        res = res[:i] + seq[j:j+1] + res[i:]          # seq can be immutable\n    return res\nif __name__ == '__main__':\n    table = ({'name':'doe'}, {'name':'john'})\n    print(sort(list(table),  (lambda x, y: x['name'] > y['name'])))\n    print(sort(tuple(table), (lambda x, y: x['name'] <= y['name'])))\n    print(sort('axbyzc'))\nThis time, the table entries are ordered per a field comparison function passed in:\nC:\\...\\PP4E\\Dstruct\\Classics> python sort2.py\n[{'name': 'john'}, {'name': 'doe'}]\n({'name': 'doe'}, {'name': 'john'})\nabcxyz\nThis version also dispenses with the notion of a field altogether and lets the passed-in\nfunction handle indexing if needed. That makes this version much more general; for\ninstance, it\u2019s also useful for sorting strings.\nData Structures Versus Built-ins: The Conclusion\nBut now that I\u2019ve shown you these reversing and sorting algorithms, I need to also tell\nyou that they may not be an optimal approach, especially in these specific cases.\n1400 | Chapter 18:\u2002Data StructuresAlthough these examples serve an educational role, built-in lists and functions generally\naccomplish what we just did the hard way:\nBuilt-in sorting tools\nPython\u2019s two built-in sorting tools are so fast that you would be hard-pressed to\nbeat them in most scenarios. To use the list object\u2019s sort method for arbitrary kinds\nof iterables, convert first if needed:\ntemp = list(sequence)\ntemp.sort()\n...use items in temp...\nAlternatively, the sorted built-in function operates on any iterable so you don\u2019t\nneed to convert, and returns a new sorted result list so you can use it within a larger\nexpression or context. Because it is not an in-place change, you also don\u2019t need to\nbe concerned about the possible side effects of changing the original list:\nfor item in sorted(iterable):\n   ...use item...\nFor custom sorts, simply pass in the key keyword arguments to tailor the built-in\nsort\u2019s operation\u2014it maps values to sort keys instead of performing comparisons,\nbut the effect is just as general (see the earlier graph searchers\u2019 length ordering for\nanother example):\n>>> L = [{'n':3}, {'n':20}, {'n':0}, {'n':9}]\n>>> L.sort(key=lambda x: x['n'])\n>>> L\n[{'n': 0}, {'n': 3}, {'n': 9}, {'n': 20}]\nBoth sorting tools also accept a Boolean reverse flag to make the result order de-\nscending instead of ascending; there is no need to manually reverse after the sort.\nThe underlying sort routine in Python is so good that its documentation claims\nthat it has \u201csupernatural performance\u201d\u2014not bad for a sort.\nBuilt-in reversal tools\nOur reversal routines are generally superfluous by the same token\u2014because Py-\nthon provides for fast reversals in both in-place and iterable forms, you\u2019re likely\nbetter off using them whenever possible:\n>>> L = [2, 4, 1, 3, 5]\n>>> L.reverse()\n>>> L\n[5, 3, 1, 4, 2]\n>>> L = [2, 4, 1, 3, 5]\n>>> list(reversed(L))\n[5, 3, 1, 4, 2]\nIn fact, this has been a recurring theme of this chapter on purpose, to underscore a key\npoint in Python work: although there are plenty of exceptions, you\u2019re generally better\nReversing and Sorting Sequences | 1401off not reinventing the data structure wheel unless you have to. Built-in functionality\nwill often prove a better choice in the end.\nMake no mistake: sometimes you really do need objects that add functionality to built-\nin types or do something more custom. The set classes we met, for instance, can add\ncustom tools not directly supported by Python today, binary search trees may support\nsome algorithms better than dictionaries and sets can, and the tuple-tree stack imple-\nmentation was actually faster than one based on built-in lists for common usage pat-\nterns. Moreover, graphs and permutations are something you must code on your own.\nAs we\u2019ve also seen, class encapsulations make it possible to change and extend object\ninternals without impacting the rest of your system. Although subclassing built-in types\ncan address much of the same goals, the end result is still a custom data structure.\nYet because Python comes with a set of built-in, flexible, and optimized datatypes, data\nstructure implementations are often not as important in Python as they are in lesser-\nequipped and lower-level programming languages. Before you code that new datatype,\nbe sure to ask yourself whether a built-in type or call might be more in line with the\nPython way of thinking.\nFor more on extended data structures for use in Python, see also the relatively new\ncollections module in its standard library. As mentioned in the preceding chapter, this\nmodule implements named tuples, ordered dictionaries, and more. It\u2019s described in\nPython\u2019s library manual, but its source code, like much in the standard library, can\nserve as a source of supplemental examples as well.\nPyTree: A Generic Tree Object Viewer\nThis chapter has been command line\u2013oriented. To wrap up, I want to refer you to a\nprogram that merges the GUI technology we studied earlier in the book with some of\nthe data structure ideas we\u2019ve explored here.\nThis program is called PyTree\u2014a generic tree data structure viewer written in Python\nwith the tkinter GUI library. PyTree sketches out the nodes of a tree on-screen as boxes\nconnected by arrows. It also knows how to route mouse clicks on drawn tree nodes\nback to the tree, to trigger tree-specific actions. Because PyTree lets you visualize the\nstructure of the tree generated by a set of parameters, it\u2019s an arguably fun way to explore\ntree-based algorithms.\nPyTree supports arbitrary tree types by \u201cwrapping\u201d real trees in interface objects. The\ninterface objects implement a standard protocol by communicating with the underlying\ntree object. For the purposes of this chapter, PyTree is instrumented to display binary\nsearch trees; for the next chapter, it\u2019s also set up to render expression parse trees. New\ntrees can be viewed by coding wrapper classes to interface to new tree types.\n1402 | Chapter 18:\u2002Data StructuresThe GUI interfaces PyTree utilizes were covered in depth earlier in this book. Because\nit is written with Python and tkinter, it should be portable to Windows, Unix, and\nMacs. At the top, it\u2019s used with code of this form:\nroot = Tk()                                 # build a single viewer GUI\nbwrapper = BinaryTreeWrapper()              # add extras: input line, test btns\npwrapper = ParseTreeWrapper()               # make wrapper objects\nviewer   = TreeViewer(bwrapper, root)       # start out in binary mode\ndef onRadio():\n    if var.get() == 'btree':\n        viewer.setTreeType(bwrapper)        # change viewer's wrapper\n    elif var.get() == 'ptree':\n        viewer.setTreeType(pwrapper)\nFigure 18-2 captures the display produced by PyTree under Python 3.1 on Windows 7\nby running its top-level treeview.py file with no arguments; PyTree can also be started\nfrom a button in the PyDemos launcher we met in Chapter 10. As usual, you can run\nit on your own computer to get a better feel for its behavior. Although this screenshot\ncaptures one specific kind of tree, PyTree is general enough to display arbitrary tree\ntypes, and can even switch them while running.\nFigure 18-2. PyTree viewing a binary search tree (test1 button)\nPyTree: A Generic Tree Object Viewer | 1403Just like the PyForm example of the preceding chapter, the source code and documen-\ntation for this example have been moved to the book\u2019s examples package in this edition\nto save real estate here. To study PyTree, see the following directory:\nC:\\...\\PP4E\\Dstruct\\TreeView\nAlso like PyForm, the Documentation directory there has the original description of this\nexample that appeared in the third edition of this book; PyTree\u2019s code is in Python 3.X\nform, but the third edition overview may not be.\nAs mentioned, PyTree is set up to display both the binary search trees of this chapter\nand the expression parse trees of the next chapter. When viewing the latter, PyTree\nbecomes a sort of visual calculator\u2014you can generate arbitrary expression trees and\nevaluate any part of them by clicking on nodes displayed. But at this point, there is not\nmuch more I can show and/or tell you about those kinds of trees until you move on to\nChapter 19.\n1404 | Chapter 18:\u2002Data Structures", "19": "CHAPTER 19\nText and Language\n\u201cSee Jack Hack. Hack, Jack, Hack\u201d\nIn one form or another, processing text-based information is one of the more common\ntasks that applications need to perform. This can include anything from scanning a text\nfile by columns to analyzing statements in a language defined by a formal grammar.\nSuch processing usually is called parsing\u2014analyzing the structure of a text string. In\nthis chapter, we\u2019ll explore ways to handle language and text-based information and\nsummarize some Python development concepts in sidebars along the way. In the proc-\ness, we\u2019ll meet string methods, text pattern matching, XML and HTML parsers, and\nother tools.\nSome of this material is advanced, but the examples are small to keep this chapter short.\nFor instance, recursive descent parsing is illustrated with a simple example to show\nhow it can be implemented in Python. We\u2019ll also see that it\u2019s often unnecessary to write\ncustom parsers for each language processing task in Python. They can usually be re-\nplaced by exporting APIs for use in Python programs, and sometimes by a single built-\nin function call. Finally, this chapter closes by presenting PyCalc\u2014a calculator GUI\nwritten in Python, and the last major Python coding example in this text. As we\u2019ll see,\nwriting calculators isn\u2019t much more difficult than juggling stacks while scanning text.\nStrategies for Processing Text in Python\nIn the grand scheme of things, there are a variety of ways to handle text processing and\nlanguage analysis in Python:\nExpressions\nBuilt-in string object expressions\nMethods\nBuilt-in string object method calls\nPatterns\nRegular expression pattern matching\n1405Parsers: markup\nXML and HTML text parsing\nParsers: grammars\nCustom language parsers, both handcoded and generated\nEmbedding\nRunning Python code with eval and exec built-ins\nAnd more\nNatural language processing\nFor simpler tasks, Python\u2019s built-in string object is often all we really need. Python\nstrings can be indexed, concatenated, sliced, and processed with both string method\ncalls and built-in functions. Our main emphasis in this chapter is mostly on higher-\nlevel tools and techniques for analyzing textual information and language, but we\u2019ll\nbriefly explore each of these techniques in turn. Let\u2019s get started.\nSome readers may have come to this chapter seeking coverage of Uni-\ncode text, too, but this topic is not presented here. For a look at Python\u2019s\nUnicode support, see Chapter 2\u2019s discussion of string tools, Chap-\nter 4\u2019s discussion of text and binary file distinctions and encodings, and\nChapter 9\u2019s coverage of text in tkinter GUIs. Unicode also appears in\nvarious Internet and database topics throughout this book (e.g., email\nencodings).\nBecause Unicode is a core language topic, all these chapters will also\nrefer you to the fuller coverage of Unicode in Learning Python, Fourth\nEdition. Most of the topics in this chapter, including string methods and\npattern matching, apply to Unicode automatically simply because the\nPython 3.X str string type is Unicode, whether ASCII or wider.\nString Method Utilities\nThe first stop on our text and language tour is the most basic: Python\u2019s string objects\ncome with an array of text processing tools, and serve as your first line of defense in\nthis domain. As you undoubtedly know by now, concatenation, slicing, formatting,\nand other string expressions are workhorses of most programs (I\u2019m including the newer\nformat method in this category, as it\u2019s really just an alternative to the % expression):\n>>> 'spam eggs ham'[5:10]                     # slicing: substring extraction\n'eggs '\n>>> 'spam ' + 'eggs ham'                      # concatenation (and *, len(), [ix])\n'spam eggs ham'\n>>> 'spam %s %s' % ('eggs',  'ham')           # formatting expression: substitution\n'spam eggs ham'\n>>> 'spam {} {}'.format('eggs',  'ham')       # formatting method: % alternative\n'spam eggs ham'\n>>> 'spam = \"%-5s\", %+06d' % ('ham',  99)     # more complex formatting\n1406 | Chapter 19:\u2002Text and Language'spam = \"ham  \", +00099'\n>>> 'spam = \"{0:<5}\", {1:+06}'.format('ham',  99)\n'spam = \"ham  \", +00099'\nThese operations are covered in core language resources such as Learning Python. For\nthe purposes of this chapter, though, we\u2019re interested in more powerful tools: Python\u2019s\nstring object methods include a wide variety of text-processing utilities that go above\nand beyond string expression operators. We saw some of these in action early on in\nChapter 2, and have been using them ever since. For instance, given an instance str of\nthe built-in string object type, operations like the following are provided as object\nmethod calls:\nstr.find(substr)\nPerforms substring searches\nstr.replace(old, new)\nPerforms substring substitutions\nstr.split(delimiter)\nChops up a string around a delimiter or whitespace\nstr.join(iterable)\nPuts substrings together with delimiters between\nstr.strip()\nRemoves leading and trailing whitespace\nstr.rstrip()\nRemoves trailing whitespace only, if any\nstr.rjust(width)\nRight-justifies a string in a fixed-width field\nstr.upper()\nConverts to uppercase\nstr.isupper()\nTests whether the string is uppercase\nstr.isdigit()\nTests whether the string is all digit characters\nstr.endswith(substr-or-tuple)\nTests for a substring (or a tuple of alternatives) at the end\nstr.startswith(substr-or-tuple)\nTests for a substring (or a tuple of alternatives) at the front\nThis list is representative but partial, and some of these methods take additional op-\ntional arguments. For the full list of string methods, run a dir(str) call at the Python\ninteractive prompt and run help(str.method) on any method for some quick docu-\nmentation. The Python library manual and reference books such as Python Pocket Ref-\nerence also include an exhaustive list.\nString Method Utilities | 1407Moreover, in Python today all normal string methods apply to both bytes and str\nstrings. The latter makes them applicable to arbitrarily encoded Unicode text, simply \nbecause the str type is Unicode text, even if it\u2019s only ASCII. These methods originally \nappeared as function in the string module, but are only object methods today; the \nstring module is still present because it contains predefined constants (e.g., \nstring.ascii_uppercase), as well as the Template substitution interface in 2.4 and \nlater\u2014one of the techniques discussed in the next section.\nTemplating with Replacements and Formats\nBy way of review, let\u2019s take a quick look at string methods in the context of some of \ntheir most common use cases. As we saw when generating HTML forwarding pages in \nChapter 6, the string replace method is often adequate by itself as a string templating \ntool\u2014we can compute values and insert them at fixed positions in a string with simple \nreplacement calls:\n>>> template = '---$target1---$target2---'\n>>> val1 = 'Spam'\n>>> val2 = 'shrubbery'\n>>> template = template.replace('$target1', val1)\n>>> template = template.replace('$target2', val2)\n>>> template\n'---Spam---shrubbery---'\nAs we also saw when generating HTML reply pages in the CGI scripts of Chapters 15 \nand 16, the string % formatting operator is also a powerful templating tool, especially \nwhen combined with dictionaries\u2014simply fill out a dictionary with values and apply \nmultiple substitutions to the HTML string all at once:\n>>> template = \"\"\"\n... ---\n... ---%(key1)s---\n... ---%(key2)s---\n... \"\"\"\n>>>\n>>> vals = {}\n>>> vals['key1'] = 'Spam'\n>>> vals['key2'] = 'shrubbery'\n>>> print(template % vals)\n---\n---Spam---\n---shrubbery---\nBeginning with Python 2.4, the string module\u2019s Template feature is essentially a sim-\nplified and limited variation of the dictionary-based format scheme just shown, but it \nallows some additional call patterns which some may consider simpler:\n>>> vals\n{'key2': 'shrubbery', 'key1': 'Spam'}\n1408 | Chapter 19:\u2002Text and Language>>> import string\n>>> template = string.Template('---$key1---$key2---')\n>>> template.substitute(vals)\n'---Spam---shrubbery---'\n>>> template.substitute(key1='Brian', key2='Loretta')\n'---Brian---Loretta---'\nSee the library manual for more on this extension. Although the string datatype does\nnot itself support the pattern-directed text processing that we\u2019ll meet later in this chap-\nter, its tools are powerful enough for many tasks.\nParsing with Splits and Joins\nIn terms of this chapter\u2019s main focus, Python\u2019s built-in tools for splitting and joining\nstrings around tokens turn out to be especially useful when it comes to parsing text:\nstr.split(delimiter?, maxsplits?)\nSplits a string into a list of substrings, using either whitespace (tabs, spaces, new-\nlines) or an explicitly passed string as a delimiter. maxsplits limits the number of\nsplits performed, if passed.\ndelimiter.join(iterable)\nConcatenates a sequence or other iterable of substrings (e.g., list, tuple, generator),\nadding the subject separator string between each.\nThese two are among the most powerful of string methods. As we saw in Chapter 2,\nsplit chops a string into a list of substrings and join puts them back together:\n>>> 'A B C D'.split()\n['A', 'B', 'C', 'D']\n>>> 'A+B+C+D'.split('+')\n['A', 'B', 'C', 'D']\n>>> '--'.join(['a', 'b', 'c'])\n'a--b--c'\nDespite their simplicity, they can handle surprisingly complex text-parsing tasks.\nMoreover, string method calls are very fast because they are implemented in C language\ncode. For instance, to quickly replace all tabs in a file with four periods, pipe the file\ninto a script that looks like this:\nfrom sys import *\nstdout.write(('.' * 4).join(stdin.read().split('\\t')))\nThe split call here divides input around tabs, and the join puts it back together with\nperiods where tabs had been. In this case, the combination of the two calls is equivalent\nto using the simpler global replacement string method call as follows:\nstdout.write(stdin.read().replace('\\t', '.' * 4))\nAs we\u2019ll see in the next section, splitting strings is sufficient for many text-parsing goals.\nString Method Utilities | 1409Summing Columns in a File\nLet\u2019s look next at some practical applications of string splits and joins. In many do-\nmains, scanning files by columns is a fairly common task. For instance, suppose you\nhave a file containing columns of numbers output by another system, and you need to\nsum each column\u2019s numbers. In Python, string splitting is the core operation behind\nsolving this problem, as demonstrated by Example 19-1. As an added bonus, it\u2019s easy\nto make the solution a reusable tool in Python by packaging it as an importable function.\nExample 19-1. PP4E\\Lang\\summer.py\n#!/usr/local/bin/python\ndef summer(numCols, fileName):\n    sums = [0] * numCols                             # make list of zeros\n    for line in open(fileName):                      # scan file's lines\n        cols = line.split()                          # split up columns\n        for i in range(numCols):                     # around blanks/tabs\n            sums[i] += eval(cols[i])                 # add numbers to sums\n    return sums\nif __name__ == '__main__':\n    import sys\n    print(summer(eval(sys.argv[1]), sys.argv[2]))    # '% summer.py cols file'\nNotice that we use file iterators here to read line by line, instead of calling the file\nreadlines method explicitly (recall from Chapter 4 that iterators avoid loading the\nentire file into memory all at once). The file itself is a temporary object, which will be\nautomatically closed when garbage collected.\nAs usual for properly architected scripts, you can both import this module and call its\nfunction, and run it as a shell tool from the command line. The summer.py script calls\nsplit to make a list of strings representing the line\u2019s columns, and eval to convert\ncolumn strings to numbers. Here\u2019s an input file that uses both blanks and tabs to sep-\narate columns, and the result of turning our script loose on it:\nC:\\...\\PP4E\\Lang> type table1.txt\n1       5       10    2   1.0\n2       10      20    4   2.0\n3       15      30    8    3\n4       20      40   16   4.0\nC:\\...\\PP4E\\Lang> python summer.py 5 table1.txt\n[10, 50, 100, 30, 10.0]\nAlso notice that because the summer script uses eval to convert file text to numbers,\nyou could really store arbitrary Python expressions in the file. Here, for example, it\u2019s\nrun on a file of Python code snippets:\nC:\\...\\PP4E\\Lang> type table2.txt\n2     1+1          1<<1           eval(\"2\")\n16    2*2*2*2      pow(2,4)       16.0\n1410 | Chapter 19:\u2002Text and Language3     len('abc')   [1,2,3][2]     {'spam':3}['spam']\nC:\\...\\PP4E\\Lang> python summer.py 4 table2.txt\n[21, 21, 21, 21.0]\nSumming with zips and comprehensions\nWe\u2019ll revisit eval later in this chapter, when we explore expression evaluators. Some-\ntimes this is more than we want\u2014if we can\u2019t be sure that the strings that we run this\nway won\u2019t contain malicious code, for instance, it may be necessary to run them with\nlimited machine access or use more restrictive conversion tools. Consider the following\nrecoding of the summer function (this is in file summer2.py in the examples package if\nyou care to experiment with it):\ndef summer(numCols, fileName):\n    sums = [0] * numCols\n    for line in open(fileName):                     # use file iterators\n        cols = line.split(',')                      # assume comma-delimited\n        nums = [int(x) for x in cols]               # use limited converter\n        both = zip(sums, nums)                      # avoid nested for loop\n        sums = [x + y for (x, y) in both]           # 3.X: zip is an iterable\n    return sums\nThis version uses int for its conversions from strings to support only numbers, and not\narbitrary and possibly unsafe expressions. Although the first four lines of this coding\nare similar to the original, for variety this version also assumes the data is separated by\ncommas rather than whitespace, and runs list comprehensions and zip to avoid the\nnested for loop statement. This version is also substantially trickier than the original\nand so might be less desirable from a maintenance perspective. If its code is confusing,\ntry adding print call statements after each step to trace the results of each operation.\nHere is its handiwork:\nC:\\...\\PP4E\\Lang> type table3.txt\n1,5,10,2,1\n2,10,20,4,2\n3,15,30,8,3\n4,20,40,16,4\nC:\\...\\PP4E\\Lang> python summer2.py 5 table3.txt\n[10, 50, 100, 30, 10]\nSumming with dictionaries\nThe summer logic so far works, but it can be even more general\u2014 by making the column\nnumbers a key of a dictionary rather than an offset in a list, we can remove the need to\npass in a number-columns value altogether. Besides allowing us to associate meaningful\nlabels with data rather than numeric positions, dictionaries are often more flexible than\nlists in general, especially when there isn\u2019t a fixed size to our problem. For instance,\nsuppose you need to sum up columns of data stored in a text file where the number of\ncolumns is not known or fixed:\nString Method Utilities | 1411C:\\...\\PP4E\\Lang> python\n>>> print(open('table4.txt').read())\n001.1 002.2 003.3\n010.1 020.2 030.3 040.4\n100.1 200.2 300.3\nHere, we cannot preallocate a fixed-length list of sums because the number of columns\nmay vary. Splitting on whitespace extracts the columns, and float converts to numbers,\nbut a fixed-size list won\u2019t easily accommodate a set of sums (at least, not without extra\ncode to manage its size). Dictionaries are more convenient here because we can use\ncolumn positions as keys instead of using absolute offsets. The following code dem-\nonstrates interactively (it\u2019s also in file summer3.py in the examples package):\n>>> sums = {}\n>>> for line in open('table4.txt'):\n...     cols = [float(col) for col in line.split()]\n...     for pos, val in enumerate(cols):\n...        sums[pos] = sums.get(pos, 0.0) + val\n...\n>>> for key in sorted(sums):\n...     print(key, '=', sums[key])\n...\n0 = 111.3\n1 = 222.6\n2 = 333.9\n3 = 40.4\n>>> sums\n{0: 111.3, 1: 222.6, 2: 333.90000000000003, 3: 40.4}\nInterestingly, most of this code uses tools added to Python over the years\u2014file and\ndictionary iterators, comprehensions, dict.get, and the enumerate and sorted built-ins\nwere not yet formed when Python was new. For related examples, also see the tkinter\ngrid examples in Chapter 9 for another case of eval table magic at work. That chapter\u2019s\ntable sums logic is a variation on this theme, which obtains the number of columns\nfrom the first line of a data file and tailors its summations for display in a GUI.\nParsing and Unparsing Rule Strings\nSplitting comes in handy for dividing text into columns, but it can also be used as a\nmore general parsing tool\u2014by splitting more than once on different delimiters, we can\npick apart more complex text. Although such parsing can also be achieved with more\npowerful tools, such as the regular expressions we\u2019ll meet later in this chapter, split-\nbased parsing is simper to code in quick prototypes, and may run faster.\nFor instance, Example 19-2 demonstrates one way that splitting and joining strings can\nbe used to parse sentences in a simple language. It is taken from a rule-based expert\nsystem shell (holmes) that is written in Python and included in this book\u2019s examples\ndistribution (more on holmes in a moment). Rule strings in holmes take the form:\n\"rule <id> if <test1>, <test2>... then <conclusion1>, <conclusion2>...\"\n1412 | Chapter 19:\u2002Text and LanguageTests and conclusions are conjunctions of terms (\u201c,\u201d means \u201cand\u201d). Each term is a\nlist of words or variables separated by spaces; variables start with ?. To use a rule, it is\ntranslated to an internal form\u2014a dictionary with nested lists. To display a rule, it is\ntranslated back to the string form. For instance, given the call:\nrules.internal_rule('rule x if a ?x, b then c, d ?x')\nthe conversion in function internal_rule proceeds as follows:\nstring = 'rule x if a ?x, b then c, d ?x'\ni = ['rule x', 'a ?x, b then c, d ?x']\nt = ['a ?x, b', 'c, d ?x']\nr = ['', 'x']\nresult = {'rule':'x', 'if':[['a','?x'], ['b']], 'then':[['c'], ['d','?x']]}\nWe first split around the if, then around the then, and finally around rule. The result\nis the three substrings that were separated by the keywords. Test and conclusion sub-\nstrings are split around \u201c,\u201d first and spaces last. join is used later to convert back (un-\nparse) to the original string for display. Example 19-2 is the concrete implementation\nof this scheme.\nExample 19-2. PP4E\\Lang\\rules.py\ndef internal_rule(string):\n    i = string.split(' if ')\n    t = i[1].split(' then ')\n    r = i[0].split('rule ')\n    return {'rule': r[1].strip(), 'if':internal(t[0]), 'then':internal(t[1])}\ndef external_rule(rule):\n    return ('rule '    + rule['rule']           +\n            ' if '     + external(rule['if'])   +\n            ' then '   + external(rule['then']) + '.')\ndef internal(conjunct):\n    res = []                                    # 'a b, c d'\n    for clause in conjunct.split(','):          # -> ['a b', ' c d']\n        res.append(clause.split())              # -> [['a','b'], ['c','d']]\n    return res\ndef external(conjunct):\n    strs = []\n    for clause in conjunct:                     # [['a','b'], ['c','d']]\n        strs.append(' '.join(clause))           # -> ['a b', 'c d']\n    return ', '.join(strs)                      # -> 'a b, c d'\nToday we could use list comprehensions and generator expressions to gain some con-\nciseness here. The internal and external functions, for instance, could be recoded to\nsimply (see file rules2.py):\ndef internal(conjunct):\n    return [clause.split() for clause in conjunct.split(',')]\nString Method Utilities | 1413def external(conjunct):\n    return ', '.join(' '.join(clause) for clause in conjunct)\nto produce the desired nested lists and string by combining two steps into one. This\nform might run faster; we\u2019ll leave it to the reader to decide whether it is more difficult\nto understand. As usual, we can test components of this module interactively:\n>>> import rules\n>>> rules.internal('a ?x, b')\n[['a', '?x'], ['b']]\n>>> rules.internal_rule('rule x if a ?x, b then c, d ?x')\n{'then': [['c'], ['d', '?x']], 'rule': 'x', 'if': [['a', '?x'], ['b']]}\n>>> r = rules.internal_rule('rule x if a ?x, b then c, d ?x')\n>>> rules.external_rule(r)\n'rule x if a ?x, b then c, d ?x.'\nParsing by splitting strings around tokens like this takes you only so far. There is no\ndirect support for recursive nesting of components, and syntax errors are not handled\nvery gracefully. But for simple language tasks like this, string splitting might be enough,\nat least for prototyping or experimental systems. You can always add a more robust\nrule parser later or reimplement rules as Python code or classes.\nMore on the holmes expert system shell\nSo how are these rules actually used? As mentioned, the rule parser we just met is part\nof the Python-coded holmes expert system shell. Holmes is an old system written\naround 1993 and before Python 1.0. It implemented both forward and backward\nchaining inference over rule sets. For example, the rule:\nrule pylike if ?X likes coding, ?X likes spam then ?X likes Python\ncan be used both to prove whether someone likes Python (chaining backward, from\n\u201cthen\u201d to \u201cif\u201d), and to deduce that someone likes Python from a set of known facts\n(chaining forward, from \u201cif\u201d to \u201cthen\u201d). Deductions may span multiple rules, multiple\nclauses represent conjunctions, and rules that name the same conclusion represent\nalternatives. holmes also performs simple pattern-matching along the way to assign the\nvariables that appear in rules (e.g., ?X), and it is able to explain both its deductions and\nquestions.\nHolmes also served as proof of concept for Python in general at a time when such\nevidence was still sometimes necessary, and at last check it still worked unchanged on\nPython 2.X platforms. However, its code no longer reflects modern Python best prac-\ntice. Because of this, I no longer maintain this system today. In fact, it has suffered from\nbit rot so much and for so long that I\u2019ve opted not to revisit it for this edition at all. Its\noriginal Python 0.X code is included in the book examples package, but it has not been\nported to Python 3.X form, and does not accurately reflect Python as it exists today.\nThat is, holmes is an ex-system. It has ceased to be. And it won\u2019t be discussed further\nhere. For more modern AI tools and support for Python, search the Web. This is a fun\n1414 | Chapter 19:\u2002Text and Languagefield to explore, but holmes is probably best left to the foggy mists of Python prehistory\n(and souls brave enough to try the port).\nLesson 1: Prototype and Migrate\nIf you care about performance, try to use the string object\u2019s methods rather than things\nsuch as regular expressions whenever you can. Although this is a broad rule of thumb\nand can vary from release to release, some string methods may be faster because they\nhave less work to do.\nIn fact, we can learn something from Python\u2019s own history here. Today\u2019s string object\nmethods began life as Python-coded functions in the original string module. Due to\ntheir prevalence, they were later optimized by moving their implementation to the C\nlanguage. When you imported string, it internally replaced most of its content with\nfunctions imported from the strop C extension module; strop methods were reportedly\n100 to 1,000 times faster than their Python-coded equivalents at the time.\nThe result was dramatically faster performance for string client programs without im-\npacting the interface. That is, string module clients became instantly faster without\nhaving to be modified for the new C-based module. Of course, these operations evolved\nfurther and were finally moved to string object methods, their only form today. But this\nreflects a common pattern in Python work. A similar migration path was applied to\nthe pickle module we met in Chapter 17\u2014the later cPickle recoding in Python 2.X\nand _pickle in 3.X are compatible but much faster.\nThis is a great lesson about Python development: modules can be coded quickly in\nPython at first and translated to C later for efficiency if required. Because the interface\nto Python and C extension modules is identical (both are imported modules with call-\nable function attributes), C translations of modules are backward compatible with their\nPython prototypes. The only impact of the translation of such modules on clients usu-\nally is an improvement in performance.\nThere is normally no need to move every module to C for delivery of an application:\nyou can pick and choose performance-critical modules (such as string and pickle) for\ntranslation and leave others coded in Python. Use the timing and profiling techniques\ndiscussed in Chapter 18 to isolate which modules will give the most improvement when\ntranslated to C. Once you do, the next chapter shows how to go about writing C-based\nextension modules.\nRegular Expression Pattern Matching\nSplitting and joining strings is a simple way to process text, as long as it follows the\nformat you expect. For more general text analysis tasks where the structure of your\ndata is not so rigidly defined, Python provides regular expression matching utilities.\nEspecially for the kinds of text associated with domains such as the Internet and data-\nbases today, this flexibility can be a powerful ally.\nRegular Expression Pattern Matching | 1415Regular expressions are simply strings that define patterns to be matched against other\nstrings. Supply a pattern and a string and ask whether the string matches your pattern.\nAfter a match, parts of the string matched by parts of the pattern are made available to\nyour script. That is, matches not only give a yes/no answer, but also can pick out\nsubstrings as well.\nRegular expression pattern strings can be complicated (let\u2019s be honest\u2014they can be\ndownright gross to look at). But once you get the hang of them, they can replace larger\nhandcoded string search routines\u2014a single pattern string generally does the work of\ndozens of lines of manual string scanning code and may run much faster. They are a\nconcise way to encode the expected structure of text and extract portions of it.\nThe re Module\nIn Python, regular expressions are not part of the syntax of the Python language itself,\nbut they are supported by the re standard library module that you must import to use.\nThe module defines functions for running matches immediately, compiling pattern\nstrings into pattern objects, matching these objects against strings, and fetching\nmatched substrings after a match. It also provides tools for pattern-based splitting,\nreplacing, and so on.\nThe re module implements a rich regular expression pattern syntax that tries to be close\nto that used to code patterns in the Perl language (regular expressions are a feature of\nPerl worth emulating). For instance, re supports the notions of named groups; char-\nacter classes; and nongreedy matches\u2014regular expression pattern operators that match\nas few characters as possible (other operators always match the longest possible sub-\nstring). The re module has also been optimized repeatedly, and in Python 3.X supports\nmatching for both bytes byte-strings and str Unicode strings. The net effect is that\nPython\u2019s pattern support uses Perl-like patterns, but is invoked with a different top-\nlevel module interface.\nI need to point out up front that regular expressions are complex tools that cannot be\ncovered in depth here. If this area sparks your interest, the text Mastering Regular Ex-\npressions, written by Jeffrey E. F. Friedl (O\u2019Reilly), is a good next step to take. We won\u2019t\nbe able to cover pattern construction itself well enough here to turn you into an expert.\nOnce you learn how to code patterns, though, the top-level interface for performing\nmatches is straightforward. In fact, they are so easy to use that we\u2019ll jump right into\nsome live examples before getting into more details.\nFirst Examples\nThere are two basic ways to kick off matches: through top-level function calls and via\nmethods of precompiled pattern objects. The latter precompiled form is quicker if you\nwill be applying the same pattern more than once\u2014to all lines in a text file, for instance.\n1416 | Chapter 19:\u2002Text and LanguageTo demonstrate, let\u2019s do some matching on the following strings (see file\nre-interactive.txt for all the interactive code run in this section):\n>>> text1 = 'Hello spam...World'\n>>> text2 = 'Hello spam...other'\nThe match performed in the following code does not precompile: it executes an im-\nmediate match to look for all the characters between the words Hello and World in our\ntext strings:\n>>> import re\n>>> matchobj = re.match('Hello(.*)World', text2)\n>>> print(matchobj)\nNone\nWhen a match fails as it does here (the text2 string doesn\u2019t end in World), we get back\nthe None object, which is Boolean false if tested in an if statement.\nIn the pattern string we\u2019re using here in the first argument to re.match, the words\nHello and World match themselves, and (.*) means any character (.) repeated zero or\nmore times (*). The fact that it is enclosed in parentheses tells Python to save away the\npart of the string matched by that part of the pattern as a group\u2014a matched substring\navailable after the match. To see how, we need to make a match work:\n>>> matchobj = re.match('Hello(.*)World', text1)\n>>> print(matchobj)\n<_sre.SRE_Match object at 0x009D6520>\n>>> matchobj.group(1)\n' spam...'\nWhen a match succeeds, we get back a match object, which has interfaces for extracting\nmatched substrings\u2014the group(1) call returns the portion of the string matched by the\nfirst, leftmost, parenthesized portion of the pattern (our (.*)). As mentioned, matching\nis not just a yes/no answer; by enclosing parts of the pattern in parentheses, it is also a\nway to extract matched substrings. In this case, we\u2019ve parsed out the text between\nHello and World. Group number 0 is the entire string matched by the pattern\u2014useful\nif you want to be sure your pattern is consuming all the text you think it is.\nThe interface for precompiling is similar, but the pattern is implied in the pattern ob-\nject we get back from the compile call:\n>>> pattobj  = re.compile('Hello(.*)World')\n>>> matchobj = pattobj.match(text1)\n>>> matchobj.group(1)\n' spam...'\nAgain, you should precompile for speed if you will run the pattern multiple times, and\nyou normally will when scanning files line by line. Here\u2019s something a bit more complex\nthat hints at the generality of patterns. This one allows for zero or more blanks or tabs\nat the front ([ \\t]*), skips one or more after the word Hello ([ \\t]+), captures characters\nRegular Expression Pattern Matching | 1417in the middle ((.*)), and allows the final word to begin with an upper- or lowercase\nletter ([Ww]); as you can see, patterns can handle wide variations in data:\n>>> patt = '[ \\t]*Hello[ \\t]+(.*)[Ww]orld'\n>>> line = ' Hello   spamworld'\n>>> mobj = re.match(patt, line)\n>>> mobj.group(1)\n'spam'\nNotice that we matched a str pattern to a str string in the last listing. We can also\nmatch bytes to bytes in order to handle data such as encoded text, but we cannot mix\nthe two string types (a constraint which is true in Python in general\u2014Python wouldn\u2019t\nhave the encoding information needed to know how to convert between the raw bytes\nand the Unicode text):\n>>> patt = b'[ \\t]*Hello[ \\t]+(.*)[Ww]orld'      # both as bytes works too\n>>> line = b' Hello   spamworld'                 # and returns bytes groups\n>>> re.match(patt, line).group(1)                # but cannot mix str/bytes\nb'spam'\n>>> re.match(patt, ' Hello spamworld')\nTypeError: can't use a bytes pattern on a string-like object\n>>> re.match('[ \\t]*Hello[ \\t]+(.*)[Ww]orld', line)\nTypeError: can't use a string pattern on a bytes-like object\nIn addition to the tools these examples demonstrate, there are methods for scanning\nahead to find a match (search), scanning to find all matches (findall), splitting and\nreplacing on patterns, and so on. All have analogous module and precompiled call\nforms. The next section turns to a few examples to demonstrate more of the basics.\nString Operations Versus Patterns\nNotice how the preceding example skips optional whitespace and allows for uppercase\nor lowercase letters. This underscores why you may want to use patterns in the first\nplace\u2014they support more general kinds of text than string object methods can. Here\u2019s\nanother case in point: we\u2019ve seen that string methods can split on and replace a sub-\nstring, but they don\u2019t suffice if the delimiter might be more than one alternative:\n>>> 'aaa--bbb--ccc'.split('--')\n['aaa', 'bbb', 'ccc']\n>>> 'aaa--bbb--ccc'.replace('--', '...')        # string methods use fixed strings\n'aaa...bbb...ccc'\n>>> 'aaa--bbb==ccc'.split(['--', '=='])\nTypeError: Can't convert 'list' object to str implicitly\n>>> 'aaa--bbb==ccc'.replace(['--', '=='], '...')\nTypeError: Can't convert 'list' object to str implicitly\nPatterns can do similar work, but also can handle alternatives directly, by virtue of their\npattern matching syntax. In the following, the syntax --|== matches either string -- or\nstring ==; the syntax [-=] matches either the character - or = (a character set); and the\n1418 | Chapter 19:\u2002Text and Languageform (?:) can be used to group nested parts of a pattern without forming a saved\nsubstring group (split treats groups specially):\n>>> import re\n>>> re.split('--', 'aaa--bbb--ccc')\n['aaa', 'bbb', 'ccc']\n>>> re.sub('--', '...', 'aaa--bbb--ccc')            # single string case\n'aaa...bbb...ccc'\n>>> re.split('--|==', 'aaa--bbb==ccc')              # split on -- or ==\n['aaa', 'bbb', 'ccc']\n>>> re.sub('--|==', '...', 'aaa--bbb==ccc')         # replace -- or ==\n'aaa...bbb...ccc'\n>>> re.split('[-=]', 'aaa-bbb=ccc')                 # single char alternative\n['aaa', 'bbb', 'ccc']\n>>> re.split('(--)|(==)', 'aaa--bbb==ccc')          # split includes groups\n['aaa', '--', None, 'bbb', None, '==', 'ccc']\n>>> re.split('(?:--)|(?:==)', 'aaa--bbb==ccc')      # expr part, not group\n['aaa', 'bbb', 'ccc']\nSimilarly, splits can extract simple substrings for fixed delimiters, but patterns can also\nhandle surrounding context like brackets, mark parts as optional, ignore whitespace,\nand more. In the next tests \\s* means zero or more whitespace characters (a character\nclass); \\s+ means one or more of the same; /? matches an optional slash; [a-z] is any\nlowercase letter (a range);(.*?) means a saved substring of zero or more of any character\nagain\u2014but only as many as needed to match the rest of the pattern (nongreedily); and\nthe groups method is used to fetch the substrings matched by the parenthesized sub-\npatterns all at once:\n>>> 'spam/ham/eggs'.split('/')\n['spam', 'ham', 'eggs']\n>>> re.match('(.*)/(.*)/(.*)', 'spam/ham/eggs').groups()\n('spam', 'ham', 'eggs')\n>>> re.match('<(.*)>/<(.*)>/<(.*)>', '<spam>/<ham>/<eggs>').groups()\n('spam', 'ham', 'eggs')\n>>> re.match('\\s*<(.*)>/?<(.*)>/?<(.*)>', '  <spam>/<ham><eggs>').groups()\n('spam', 'ham', 'eggs')\n>>> 'Hello pattern world!'.split()\n['Hello', 'pattern', 'world!']\n>>> re.match('Hello\\s*([a-z]*)\\s+(.*?)\\s*!', 'Hellopattern   world !').groups()\n('pattern', 'world')\nIn fact, there\u2019s more than one way to match. The findall method provides generality\nthat leaves string objects in the dust\u2014it locates all occurrences of a pattern and returns\nall the substrings it matched (or a list of tuples for multiple groups). The search method\nis similar but stops at the first match\u2014it\u2019s like match plus an initial forward scan. In the\nfollowing, string object finds locate just one specific string, but patterns can be used to\nRegular Expression Pattern Matching | 1419locate and extract bracketed text anywhere in a string, even pairs with optional text\nbetween:\n>>> '<spam>/<ham>/<eggs>'.find('ham')               # find substring offset\n8\n>>> re.findall('<(.*?)>', '<spam>/<ham>/<eggs>')    # find all matches/groups\n['spam', 'ham', 'eggs']\n>>> re.findall('<(.*?)>', '<spam> /  <ham><eggs>')\n['spam', 'ham', 'eggs']\n>>> re.findall('<(.*?)>/?<(.*?)>', '<spam>/<ham> ... <eggs><cheese>')\n[('spam', 'ham'), ('eggs', 'cheese')]\n>>> re.search('<(.*?)>/?<(.*?)>', 'todays menu: <spam>/<ham>...<eggs><s>').groups()\n('spam', 'ham')\nEspecially when using findall, the (?s) operator comes in handy to force . to match\nend-of-line characters in multiline text; without it . matches everything except lines\nends. The following searches look for two adjacent bracketed strings with arbitrary text\nbetween, with and without skipping line breaks:\n>>> re.findall('<(.*?)>.*<(.*?)>', '<spam> \\n  <ham>\\n<eggs>')        # stop at \\n\n[]\n>>> re.findall('(?s)<(.*?)>.*<(.*?)>', '<spam> \\n  <ham>\\n<eggs>')    # greedy\n[('spam', 'eggs')]\n>>> re.findall('(?s)<(.*?)>.*?<(.*?)>', '<spam> \\n  <ham>\\n<eggs>')   # nongreedy\n[('spam', 'ham')]\nTo make larger patterns more mnemonic, we can even associate names with matched\nsubstring groups in using the <?P<name>) pattern syntax and fetch them by name after\nmatches, though this is of limited utility for findall. The next tests look for strings of\n\u201cword\u201d characters (\\w) separated by a /\u2014this isn\u2019t much more than a string split, but\nparts are named, and search and findall both scan ahead:\n>>> re.search('(?P<part1>\\w*)/(?P<part2>\\w*)', '...aaa/bbb/ccc]').groups()\n('aaa', 'bbb')\n>>> re.search('(?P<part1>\\w*)/(?P<part2>\\w*)', '...aaa/bbb/ccc]').groupdict()\n{'part1': 'aaa', 'part2': 'bbb'}\n>>> re.search('(?P<part1>\\w*)/(?P<part2>\\w*)', '...aaa/bbb/ccc]').group(2)\n'bbb'\n>>> re.search('(?P<part1>\\w*)/(?P<part2>\\w*)', '...aaa/bbb/ccc]').group('part2')\n'bbb'\n>>> re.findall('(?P<part1>\\w*)/(?P<part2>\\w*)', '...aaa/bbb ccc/ddd]')\n[('aaa', 'bbb'), ('ccc', 'ddd')]\nFinally, although basic string operations such as slicing and splits are sometimes\nenough, patterns are much more flexible. The following uses [^ ] to match any char-\nacter not following the ^, and escapes a dash within a [] alternative set using \\- so it\u2019s\nnot taken to be a character set range separator. It runs equivalent slices, splits, and\nmatches, along with a more general match that the other two cannot approach:\n>>> line = 'aaa bbb ccc'\n>>> line[:3], line[4:7], line[8:11]          # slice data at fixed offsets\n1420 | Chapter 19:\u2002Text and Language('aaa', 'bbb', 'ccc')\n>>> line.split()                             # split data with fixed delimiters\n['aaa', 'bbb', 'ccc']\n>>> re.split(' +', line)                     # split on general delimiters\n['aaa', 'bbb', 'ccc']\n>>> re.findall('[^ ]+', line)                # find non-delimiter runs\n['aaa', 'bbb', 'ccc']\n>>> line = 'aaa...bbb-ccc / ddd.-/e&e*e'     # handle generalized text\n>>> re.findall('[^ .\\-/]+', line)\n['aaa', 'bbb', 'ccc', 'ddd', 'e&e*e']\nAt this point, if you\u2019ve never used pattern syntax in the past your head may very well\nbe spinning (or have blown off entirely!). Before we go into any further examples, let\u2019s\ndig into a few of the details underlying the re module and its patterns.\nUsing the re Module\nThe Python re module comes with functions that can search for patterns right away or\nmake compiled pattern objects for running matches later. Pattern objects (and module\nsearch calls) in turn generate match objects, which contain information about success-\nful matches and matched substrings. For reference, the next few sections describe the\nmodule\u2019s interfaces and some of the operators you can use to code patterns.\nModule functions\nThe top level of the module provides functions for matching, substitution, precompil-\ning, and so on:\ncompile(pattern [, flags])\nCompile a regular expression pattern string into a regular expression pattern ob-\nject, for later matching. See the reference manual or Python Pocket Reference for\nthe flags argument\u2019s meaning.\nmatch(pattern, string [, flags])\nIf zero or more characters at the start of string match the pattern string, return a\ncorresponding match object, or None if no match is found. Roughly like a search\nfor a pattern that begins with the ^ operator.\nsearch(pattern, string [, flags])\nScan through string for a location matching pattern, and return a corresponding\nmatch object, or None if no match is found.\nfindall(pattern, string [, flags])\nReturn a list of strings giving all nonoverlapping matches of pattern in string. If\nthere are any groups in patterns, returns a list of groups, and a list of tuples if the\npattern has more than one group.\nfinditer(pattern, string [, flags])\nReturn iterator over all nonoverlapping matches of pattern in string.\nRegular Expression Pattern Matching | 1421split(pattern, string [, maxsplit, flags])\nSplit string by occurrences of pattern. If capturing parentheses (()) are used in the\npattern, the text of all groups in the pattern are also returned in the resulting list.\nsub(pattern, repl, string [, count, flags])\nReturn the string obtained by replacing the (first count) leftmost nonoverlapping\noccurrences of pattern (a string or a pattern object) in string by repl (which may\nbe a string with backslash escapes that may back-reference a matched group, or a\nfunction that is passed a single match object and returns the replacement string).\nsubn(pattern, repl, string [, count, flags])\nSame as sub, but returns a tuple: (new-string, number-of-substitutions-made).\nescape(string)\nReturn string with all nonalphanumeric characters backslashed, such that they\ncan be compiled as a string literal.\nCompiled pattern objects\nAt the next level, pattern objects provide similar attributes, but the pattern string is\nimplied. The re.compile function in the previous section is useful to optimize patterns\nthat may be matched more than once (compiled patterns match faster). Pattern objects\nreturned by re.compile have these sorts of attributes:\nmatch(string [, pos] [, endpos])\nsearch(string [, pos] [, endpos])\nfindall(string [, pos [, endpos]])\nfinditer(string [, pos [, endpos]])\nsplit(string [, maxsplit])\nsub(repl, string [, count])\nsubn(repl, string [, count])\nThese are the same as the re module functions, but the pattern is implied, and pos and\nendpos give start/end string indexes for the match.\nMatch objects\nFinally, when a match or search function or method is successful, you get back a match\nobject (None comes back on failed matches). Match objects export a set of attributes of\ntheir own, including:\ngroup(g)\ngroup(g1, g2, ...)\nReturn the substring that matched a parenthesized group (or groups) in the pattern.\nAccept group numbers or names. Group numbers start at 1; group 0 is the entire\nstring matched by the pattern. Returns a tuple when passed multiple group num-\nbers, and group number defaults to 0 if omitted.\n1422 | Chapter 19:\u2002Text and Languagegroups()\nReturns a tuple of all groups\u2019 substrings of the match (for group numbers 1 and\nhigher).\ngroupdict()\nReturns a dictionary containing all named groups of the match (see (?P<name>R)\nsyntax ahead).\nstart([group]) end([group])\nIndices of the start and end of the substring matched by group (or the entire matched\nstring, if no group is passed).\nspan([group])\nReturns the two-item tuple: (start(group), end(group)).\nexpand([template])\nPerforms backslash group substitutions; see the Python library manual.\nRegular expression patterns\nRegular expression strings are built up by concatenating single-character regular ex-\npression forms, shown in Table 19-1. The longest-matching string is usually matched\nby each form, except for the nongreedy operators. In the table, R means any regular\nexpression form, C is a character, and N denotes a digit.\nTable 19-1. re pattern syntax\nOperator\nInterpretation\n.\nMatches any character (including newline if DOTALL flag is specified or (?s) at pattern front)\n^\nMatches start of the string (of every line in MULTILINE mode)\n$\nMatches end of the string (of every line in MULTILINE mode)\nC\nAny nonspecial (or backslash-escaped) character matches itself\nR*\nZero or more of preceding regular expression R (as many as possible)\nR+\nOne or more of preceding regular expression R (as many as possible)\nR?\nZero or one occurrence of preceding regular expression R (optional)\nR{m}\nMatches exactly m copies preceding R: a{5} matches 'aaaaa'\nR{m,n}\nMatches from m to n repetitions of preceding regular expression R\nR*?, R+?, R??,\nR{m,n}?\nSame as *, +, and ? but matches as few characters/times as possible; these are known as\nnongreedy match operators (unlike others, they match and consume as few characters as\npossible)\n[...]\nDefines character set: e.g., [a-zA-Z] to match all letters (alternatives, with - for ranges)\n[^...]\nDefines complemented character set: matches if char is not in set\n\\\nEscapes special chars (e.g., *?+|()) and introduces special sequences in Table 19-2\n\\\\\nMatches a literal \\ (write as \\\\\\\\ in pattern, or use r'\\\\')\n\\N\nMatches the contents of the group of the same number N: '(.+) \\1' matches \u201c42 42\u201d\nRegular Expression Pattern Matching | 1423Operator\nInterpretation\nR|R\nAlternative: matches left or right R\nRR\nConcatenation: match both Rs\n(R)\nMatches any regular expression inside (), and delimits a group (retains matched substring)\n(?:R)\nSame as (R) but simply delimits part R and does not denote a saved group\n(?=R)\nLook-ahead assertion: matches if R matches next, but doesn\u2019t consume any of the string (e.g.,\nX (?=Y) matches X only if followed by Y)\n(?!R)\nMatches if R doesn\u2019t match next; negative of (?=R)\n(?P<name>R)\nMatches any regular expression inside (), and delimits a named group\n(?P=name)\nMatches whatever text was matched by the earlier group named name\n(?#...)\nA comment; ignored\n(?letter)\nSet mode flag; letter is one of aiLmsux (see the library manual)\n(?<=R)\nLook-behind assertion: matches if the current position in the string is preceded by a match\nof R that ends at the current position\n(?<!R)\nMatches if the current position in the string is not preceded by a match for R; negative of\n(?<= R)\n(?(id/\nname)yespattern|\nnopattern)\nWill try to match with yespattern if the group with given id or name exists, else with\noptional nopattern\nWithin patterns, ranges and selections can be combined. For instance, [a-zA-Z0-9_]+\nmatches the longest possible string of one or more letters, digits, or underscores. Special\ncharacters can be escaped as usual in Python strings: [\\t ]* matches zero or more tabs\nand spaces (i.e., it skips such whitespace).\nThe parenthesized grouping construct, (R), lets you extract matched substrings after a\nsuccessful match. The portion of the string matched by the expression in parentheses\nis retained in a numbered register. It\u2019s available through the group method of a match\nobject after a successful match.\nIn addition to the entries in this table, special sequences in Table 19-2 can be used in\npatterns, too. Because of Python string rules, you sometimes must double up on back-\nslashes (\\\\) or use Python raw strings (r'...') to retain backslashes in the pattern\nverbatim. Python ignores backslashes in normal strings if the letter following the back-\nslash is not recognized as an escape code. Some of the entries in Table 19-2 are affected\nby Unicode when matching str instead of bytes, and an ASCII flag may be set to emulate\nthe behavior for bytes; see Python\u2019s manuals for more details.\n1424 | Chapter 19:\u2002Text and LanguageTable 19-2. re special sequences\nSequence\nInterpretation\n\\number\nMatches text of group number (numbered from 1)\n\\A\nMatches only at the start of the string\n\\b\nEmpty string at word boundaries\n\\B\nEmpty string not at word boundaries\n\\d\nAny decimal digit character ([0-9] for ASCII)\n\\D\nAny nondecimal digit character ([^O-9] for ASCII)\n\\s\nAny whitespace character ([ \\t\\n\\r\\f\\v] for ASCII)\n\\S\nAny nonwhitespace character ([^ \\t\\n\\r\\f\\v] for ASCII)\n\\w\nAny alphanumeric character ([a-zA-Z0-9_] for ASCII)\n\\W\nAny nonalphanumeric character ([^a-zA-Z0-9_] for ASCII )\n\\Z\nMatches only at the end of the string\nMost of the standard escapes supported by Python string literals are also accepted by\nthe regular expression parser: \\a, \\b, \\f, \\n, \\r, \\t, \\v, \\x, and \\\\. The Python library\nmanual gives these escapes\u2019 interpretation and additional details on pattern syntax in\ngeneral. But to further demonstrate how the re pattern syntax is typically used in scripts,\nlet\u2019s go back to writing some code.\nMore Pattern Examples\nFor more context, the next few examples present short test files that match simple but\nrepresentative pattern forms. Comments in Example 19-3 describe the operations ex-\nercised; check Table 19-1 to see which operators are used in these patterns. If they are\nstill confusing, try running these tests interactively, and call group(0) instead of\nstart() to see which strings are being matched by the patterns.\nExample 19-3. PP4E\\Lang\\re-basics.py\n\"\"\"\nliterals, sets, ranges, alternatives, and escapes\nall tests here print 2: offset where pattern found\n\"\"\"\nimport re                                  # the one to use today\npattern, string = \"A.C.\", \"xxABCDxx\"       # nonspecial chars match themselves\nmatchobj = re.search(pattern, string)      # '.' means any one char\nif matchobj:                               # search returns match object or None\n    print(matchobj.start())                # start is index where matched\npattobj  = re.compile(\"A.*C.*\")            # 'R*' means zero or more Rs\nmatchobj = pattobj.search(\"xxABCDxx\")      # compile returns pattern obj\nif matchobj:                               # patt.search returns match obj\nRegular Expression Pattern Matching | 1425print(matchobj.start())\n# selection sets\nprint(re.search(\" *A.C[DE][D-F][^G-ZE]G\\t+ ?\", \"..ABCDEFG\\t..\").start())\n# alternatives: R1|R2 means R1 or R2\nprint(re.search(\"(A|X)(B|Y)(C|Z)D\", \"..AYCD..\").start())       # test each char\nprint(re.search(\"(?:A|X)(?:B|Y)(?:C|Z)D\", \"..AYCD..\").start()) # same, not saved\nprint(re.search(\"A|XB|YC|ZD\", \"..AYCD..\").start())             # matches just A!\nprint(re.search(\"(A|XB|YC|ZD)YCD\", \"..AYCD..\").start())        # just first char\n# word boundaries\nprint(re.search(r\"\\bABCD\", \"..ABCD \").start())     # \\b means word boundary\nprint(re.search(r\"ABCD\\b\", \"..ABCD \").start())     # use r'...' to escape '\\'\nNotice again that there are different ways to kick off a match with re: by calling module\nsearch functions and by making compiled pattern objects. In either event, you can hang\non to the resulting match object or not. All the print call statements in this script show\na result of 2\u2014the offset where the pattern was found in the string. In the first test, for\nexample, A.C. matches the ABCD at offset 2 in the search string (i.e., after the first xx):\nC:\\...\\PP4E\\Lang> python re-basic.py\n2\n...8 more 2s omitted...\nNext, in Example 19-4, parts of the pattern strings enclosed in parentheses delimit\ngroups; the parts of the string they matched are available after the match.\nExample 19-4. PP4E\\Lang\\re-groups.py\n\"\"\"\ngroups: extract substrings matched by REs in '()' parts\ngroups are denoted by position, but (?P<name>R) can also name them\n\"\"\"\nimport re\npatt = re.compile(\"A(.)B(.)C(.)\")                  # saves 3 substrings\nmobj = patt.match(\"A0B1C2\")                        # each '()' is a group, 1..n\nprint(mobj.group(1), mobj.group(2), mobj.group(3)) # group() gives substring\npatt = re.compile(\"A(.*)B(.*)C(.*)\")               # saves 3 substrings\nmobj = patt.match(\"A000B111C222\")                  # groups() gives all groups\nprint(mobj.groups())\nprint(re.search(\"(A|X)(B|Y)(C|Z)D\", \"..AYCD..\").groups())\nprint(re.search(\"(?P<a>A|X)(?P<b>B|Y)(?P<c>C|Z)D\", \"..AYCD..\").groupdict())\npatt = re.compile(r\"[\\t ]*#\\s*define\\s*([a-z0-9_]*)\\s*(.*)\")\nmobj = patt.search(\" # define  spam  1 + 2 + 3\")            # parts of C #define\nprint(mobj.groups())                                        # \\s is whitespace\nIn the first test here, for instance, the three (.) groups each match a single character,\nbut they retain the character matched; calling group pulls out the character matched.\n1426 | Chapter 19:\u2002Text and LanguageThe second test\u2019s (.*) groups match and retain any number of characters. The third\nand fourth tests shows how alternatives can be grouped by both position and name,\nand the last test matches C #define lines\u2014more on this pattern in a moment:\nC:\\...\\PP4E\\Lang> python re-groups.py\n0 1 2\n('000', '111', '222')\n('A', 'Y', 'C')\n{'a': 'A', 'c': 'C', 'b': 'Y'}\n('spam', '1 + 2 + 3')\nFinally, besides matches and substring extraction, re also includes tools for string re-\nplacement or substitution (see Example 19-5).\nExample 19-5. PP4E\\Lang\\re-subst.py\n\"substitutions: replace occurrences of pattern in string\"\nimport re\nprint(re.sub('[ABC]', '*', 'XAXAXBXBXCXC'))\nprint(re.sub('[ABC]_', '*', 'XA-XA_XB-XB_XC-XC_'))        # alternatives char + _\nprint(re.sub('(.) spam', 'spam\\\\1',  'x spam, y spam'))   # group back ref (or r'')\ndef mapper(matchobj):\n    return 'spam' + matchobj.group(1)\nprint(re.sub('(.) spam', mapper, 'x spam, y spam'))       # mapping function\nIn the first test, all characters in the set are replaced; in the second, they must be followed\nby an underscore. The last two tests illustrate more advanced group back-references\nand mapping functions in the replacement. Note the \\\\1 required to escape \\1 for\nPython\u2019s string rules; r'spam\\1' would work just as well. See also the earlier interactive\ntests in the section for additional substitution and splitting examples:\nC:\\...\\PP4E\\Lang> python re-subst.py\nX*X*X*X*X*X*\nXA-X*XB-X*XC-X*\nspamx, spamy\nspamx, spamy\nScanning C Header Files for Patterns\nTo wrap up, let\u2019s turn to a more realistic example: the script in Example 19-6 puts these\npattern operators to more practical use. It uses regular expressions to find #define and\n#include lines in C header files and extract their components. The generality of the\npatterns makes them detect a variety of line formats; pattern groups (the parts in pa-\nrentheses) are used to extract matched substrings from a line after a match.\nRegular Expression Pattern Matching | 1427Example 19-6. PP4E\\Lang\\cheader.py\n\"Scan C header files to extract parts of #define and #include lines\"\nimport sys, re\npattDefine = re.compile(                             # compile to pattobj\n    '^#[\\t ]*define[\\t ]+(\\w+)[\\t ]*(.*)')           # \"# define xxx yyy...\"\n                                                     # \\w like [a-zA-Z0-9_]\npattInclude = re.compile(\n    '^#[\\t ]*include[\\t ]+[<\"]([\\w\\./]+)')           # \"# include <xxx>...\"\ndef scan(fileobj):\n    count = 0\n    for line in fileobj:                             # scan by lines: iterator\n        count += 1\n        matchobj = pattDefine.match(line)            # None if match fails\n        if matchobj:\n            name = matchobj.group(1)                 # substrings for (...) parts\n            body = matchobj.group(2)\n            print(count, 'defined', name, '=', body.strip())\n            continue\n        matchobj = pattInclude.match(line)\n        if matchobj:\n            start, stop = matchobj.span(1)           # start/stop indexes of (...)\n            filename = line[start:stop]              # slice out of line\n            print(count, 'include', filename)        # same as matchobj.group(1)\nif len(sys.argv) == 1:\n    scan(sys.stdin)                    # no args: read stdin\nelse:\n    scan(open(sys.argv[1], 'r'))       # arg: input filename\nTo test, let\u2019s run this script on the text file in Example 19-7.\nExample 19-7. PP4E\\Lang\\test.h\n#ifndef TEST_H\n#define TEST_H\n#include <stdio.h>\n#include <lib/spam.h>\n#  include   \"Python.h\"\n#define DEBUG\n#define HELLO 'hello regex world'\n#  define SPAM    1234\n#define EGGS sunny + side + up\n#define  ADDER(arg) 123 + arg\n#endif\nNotice the spaces after # in some of these lines; regular expressions are flexible enough\nto account for such departures from the norm. Here is the script at work; picking out\n#include and #define lines and their parts. For each matched line, it prints the line\nnumber, the line type, and any matched substrings:\n1428 | Chapter 19:\u2002Text and LanguageC:\\...\\PP4E\\Lang> python cheader.py test.h\n2 defined TEST_H =\n4 include stdio.h\n5 include lib/spam.h\n6 include Python.h\n8 defined DEBUG =\n9 defined HELLO = 'hello regex world'\n10 defined SPAM = 1234\n12 defined EGGS = sunny + side + up\n13 defined ADDER = (arg) 123 + arg\nFor an additional example of regular expressions at work, see the file pygrep1.py in the\nbook examples package; it implements a simple pattern-based \u201cgrep\u201d file search utility,\nbut was cut here for space. As we\u2019ll see, we can also sometimes use regular expressions\nto parse information from XML and HTML text\u2014the topics of the next section.\nXML and HTML Parsing\nBeyond string objects and regular expressions, Python ships with support for parsing\nsome specific and commonly used types of formatted text. In particular, it provides\nprecoded parsers for XML and HTML which we can deploy and customize for our text\nprocessing goals.\nIn the XML department, Python includes parsing support in its standard library and\nplays host to a prolific XML special-interest group. XML (for eXtensible Markup Lan-\nguage) is a tag-based markup language for describing many kinds of structured data.\nAmong other things, it has been adopted in roles such as a standard database and\nInternet content representation in many contexts. As an object-oriented scripting lan-\nguage, Python mixes remarkably well with XML\u2019s core notion of structured document\ninterchange.\nXML is based upon a tag syntax familiar to web page writers, used to describe and\npackage data. The xml module package in Python\u2019s standard library includes tools for\nparsing this data from XML text, with both the SAX and the DOM standard parsing\nmodels, as well as the Python-specific ElementTree package. Although regular expres-\nsions can sometimes extract information from XML documents, too, they can be easily\nmisled by unexpected text, and don\u2019t directly support the notion of arbitrarily nested\nXML constructs (more on this limitation later when we explore languages in general).\nIn short, SAX parsers provide a subclass with methods called during the parsing oper-\nation, and DOM parsers are given access to an object tree representing the (usually)\nalready parsed document. SAX parsers are essentially state machines and must record\n(and possibly stack) page details as the parse progresses; DOM parsers walk object trees\nusing loops, attributes, and methods defined by the DOM standard. ElementTree is\nroughly a Python-specific analog of DOM, and as such can often yield simpler code; it\ncan also be used to generate XML text from their object-based representations.\nXML and HTML Parsing | 1429Beyond these parsing tools, Python also ships with an xmlrpc package to support the\nclient and server sides of the XML-RPC protocol (remote procedure calls that transmit\nobjects encoded as XML over HTTP), as well as a standard HTML parser, html.parser, \nthat works on similar principles and is presented later in this chapter. The third-party\ndomain has even more XML-related tools; most of these are maintained separately from\nPython to allow for more flexible release schedules. Beginning with Python 2.3, the\nExpat parser is also included as the underlying engine that drives the parsing process.\nXML Parsing in Action\nXML processing is a large, evolving topic, and it is mostly beyond the scope of this\nbook. For an example of a simple XML parsing task, though, consider the XML file in\nExample 19-8. This file defines a handful of O\u2019Reilly Python books\u2014ISBN numbers\nas attributes, and titles, publication dates, and authors as nested tags (with apologies\nto Python books not listed in this completely random sample\u2014there are many!).\nExample 19-8. PP4E\\Lang\\Xml\\books.xml\n<catalog>\n    <book isbn=\"0-596-00128-2\">\n        <title>Python &amp; XML</title>\n        <date>December 2001</date>\n        <author>Jones, Drake</author>\n    </book>\n    <book isbn=\"0-596-15810-6\">\n        <title>Programming Python, 4th Edition</title>\n        <date>October 2010</date>\n        <author>Lutz</author>\n    </book>\n    <book isbn=\"0-596-15806-8\">\n        <title>Learning Python, 4th Edition</title>\n        <date>September 2009</date>\n        <author>Lutz</author>\n    </book>\n    <book isbn=\"0-596-15808-4\">\n        <title>Python Pocket Reference, 4th Edition</title>\n        <date>October 2009</date>\n        <author>Lutz</author>\n    </book>\n    <book isbn=\"0-596-00797-3\">\n        <title>Python Cookbook, 2nd Edition</title>\n        <date>March 2005</date>\n        <author>Martelli, Ravenscroft, Ascher</author>\n    </book>\n    <book isbn=\"0-596-10046-9\">\n        <title>Python in a Nutshell, 2nd Edition</title>\n        <date>July 2006</date>\n        <author>Martelli</author>\n    </book>\n    <!-- plus many more Python books that should appear here -->\n</catalog>\n1430 | Chapter 19:\u2002Text and LanguageLet\u2019s quickly explore ways to extract this file\u2019s book ISBN numbers and corresponding\ntitles by example, using each of the four primary Python tools at our disposal\u2014patterns,\nSAX, DOM, and ElementTree.\nRegular expression parsing\nIn some contexts, the regular expressions we met earlier can be used to parse informa-\ntion from XML files. They are not complete parsers, and are not very robust or accurate\nin the presence of arbitrary text (text in tag attributes can especially throw them off).\nWhere applicable, though, they offer a simple option. Example 19-9 shows how we\nmight go about parsing the XML file in Example 19-8 with the prior section\u2019s re module.\nLike all four examples in this section, it scans the XML file looking at ISBN numbers\nand associated titles, and stores the two as keys and values in a Python dictionary.\nExample 19-9. PP4E\\Lang\\Xml\\rebook.py\n\"\"\"\nXML parsing: regular expressions (no robust or general)\n\"\"\"\nimport re, pprint\ntext    = open('books.xml').read()                        # str if str pattern\npattern = '(?s)isbn=\"(.*?)\".*?<title>(.*?)</title>'       # *?=nongreedy\nfound   = re.findall(pattern, text)                       # (?s)=dot matches /n\nmapping = {isbn: title for (isbn, title) in found}        # dict from tuple list\npprint.pprint(mapping)\nWhen run, the re.findall method locates all the nested tags we\u2019re interested in, ex-\ntracts their content, and returns a list of tuples representing the two parenthesized\ngroups in the pattern. Python\u2019s pprint module displays the dictionary created by the\ncomprehension nicely. The extract works, but only as long as the text doesn\u2019t deviate\nfrom the expected pattern in ways that would invalidate our script. Moreover, the XML\nentity for \u201c&\u201d in the first book\u2019s title is not un-escaped automatically:\nC:\\...\\PP4E\\Lang\\Xml> python rebook.py\n{'0-596-00128-2': 'Python &amp; XML',\n '0-596-00797-3': 'Python Cookbook, 2nd Edition',\n '0-596-10046-9': 'Python in a Nutshell, 2nd Edition',\n '0-596-15806-8': 'Learning Python, 4th Edition',\n '0-596-15808-4': 'Python Pocket Reference, 4th Edition',\n '0-596-15810-6': 'Programming Python, 4th Edition'}\nSAX parsing\nTo do better, Python\u2019s full-blown XML parsing tools let us perform this data extraction\nin a more accurate and robust way. Example 19-10, for instance, defines a SAX-based\nparsing procedure: its class implements callback methods that will be called during the\nparse, and its top-level code creates and runs a parser.\nXML and HTML Parsing | 1431Example 19-10. PP4E\\Lang\\Xml\\saxbook.py\n\"\"\"\nXML parsing: SAX is a callback-based API for intercepting parser events\n\"\"\"\nimport xml.sax, xml.sax.handler, pprint\nclass BookHandler(xml.sax.handler.ContentHandler):\n    def __init__(self):\n        self.inTitle = False                        # handle XML parser events\n        self.mapping = {}                           # a state machine model\n    def startElement(self, name, attributes):\n        if name == \"book\":                          # on start book tag\n            self.buffer = \"\"                        # save ISBN for dict key\n            self.isbn = attributes[\"isbn\"]\n        elif name == \"title\":                       # on start title tag\n            self.inTitle = True                     # save title text to follow\n    def characters(self, data):\n        if self.inTitle:                            # on text within tag\n            self.buffer += data                     # save text if in title\n    def endElement(self, name):\n      if name == \"title\":\n          self.inTitle = False                      # on end title tag\n          self.mapping[self.isbn] = self.buffer     # store title text in dict\nparser  = xml.sax.make_parser()\nhandler = BookHandler()\nparser.setContentHandler(handler)\nparser.parse('books.xml')\npprint.pprint(handler.mapping)\nThe SAX model is efficient, but it is potentially confusing at first glance, because the\nclass must keep track of where the parse currently is using state information. For ex-\nample, when the title tag is first detected, we set a state flag and initialize a buffer; as\neach character within the title tag is parsed, we append it to the buffer until the ending\nportion of the title tag is encountered. The net effect saves the title tag\u2019s content as a\nstring. This model is simple, but can be complex to manage; in cases of potentially\narbitrary nesting, for instance, state information may need to be stacked as the class\nreceives callbacks for nested tags.\nTo kick off the parse, we make a parser object, set its handler to an instance of our\nclass, and start the parse; as Python scans the XML file, our class\u2019s methods are called\nautomatically as components are encountered. When the parse is complete, we use the\nPython pprint module to display the result again\u2014the mapping dictionary object at-\ntached to our handler. The result is the mostly the same this time, but notice that the\n\u201c&\u201d escape sequence is properly un-escaped now\u2014SAX performs XML parsing, not\ntext matching:\n1432 | Chapter 19:\u2002Text and LanguageC:\\...\\PP4E\\Lang\\Xml> python saxbook.py\n{'0-596-00128-2': 'Python & XML',\n '0-596-00797-3': 'Python Cookbook, 2nd Edition',\n '0-596-10046-9': 'Python in a Nutshell, 2nd Edition',\n '0-596-15806-8': 'Learning Python, 4th Edition',\n '0-596-15808-4': 'Python Pocket Reference, 4th Edition',\n '0-596-15810-6': 'Programming Python, 4th Edition'}\nDOM parsing\nThe DOM parsing model for XML is perhaps simpler to understand\u2014we simply tra-\nverse a tree of objects after the parse\u2014but it might be less efficient for large documents,\nif the document is parsed all at once ahead of time and stored in memory. DOM also\nsupports random access to document parts via tree fetches, nested loops for known\nstructures, and recursive traversals for arbitrary nesting; in SAX, we are limited to a\nsingle linear parse. Example 19-11 is a DOM-based equivalent to the SAX parser of the\npreceding section.\nExample 19-11. PP4E\\Lang\\Xml\\dombook.py\n\"\"\"\nXML parsing: DOM gives whole document to the application as a traversable object\n\"\"\"\nimport pprint\nimport xml.dom.minidom\nfrom xml.dom.minidom import Node\ndoc = xml.dom.minidom.parse(\"books.xml\")          # load doc into object\n                                                  # usually parsed up front\nmapping = {}\nfor node in doc.getElementsByTagName(\"book\"):     # traverse DOM object\n    isbn = node.getAttribute(\"isbn\")              # via DOM object API\n    L = node.getElementsByTagName(\"title\")\n    for node2 in L:\n        title = \"\"\n        for node3 in node2.childNodes:\n            if node3.nodeType == Node.TEXT_NODE:\n                title += node3.data\n        mapping[isbn] = title\n# mapping now has the same value as in the SAX example\npprint.pprint(mapping)\nThe output of this script is the same as what we generated interactively for the SAX\nparser; here, though, it is built up by walking the document object tree after the parse\nhas finished using method calls and attributes defined by the cross-language DOM\nstandard specification. This is both a strength and potential weakness of DOM\u2014its\nAPI is language neutral, but it may seem a bit nonintuitive and verbose to some Python\nprogrammers accustomed to simpler models:\nC:\\...\\PP4E\\Lang\\Xml> python dombook.py\n{'0-596-00128-2': 'Python & XML',\nXML and HTML Parsing | 1433'0-596-00797-3': 'Python Cookbook, 2nd Edition',\n '0-596-10046-9': 'Python in a Nutshell, 2nd Edition',\n '0-596-15806-8': 'Learning Python, 4th Edition',\n '0-596-15808-4': 'Python Pocket Reference, 4th Edition',\n '0-596-15810-6': 'Programming Python, 4th Edition'}\nElementTree parsing\nAs a fourth option, the popular ElementTree package is a standard library tool for both\nparsing and generating XML. As a parser, it\u2019s essentially a more Pythonic type of\nDOM\u2014it parses documents into a tree of objects again, but the API for navigating the\ntree is more lightweight, because it\u2019s Python-specific.\nElementTree provides easy-to-use tools for parsing, changing, and generating XML\ndocuments. For both parsing and generating, it represents documents as a tree of\nPython \u201celement\u201d objects. Each element in the tree has a tag name, attribute dictionary,\ntext value, and sequence of child elements. The element object produced by a parse\ncan be navigating with normal Python loops for a known structures, and with recursion\nwhere arbitrary nesting is possible.\nThe ElementTree system began its life as a third-party extension, but it was largely\nincorporated into Python\u2019s standard library as the package xml.etree. Example 19-12\nshows how to use it to parse our book catalog file one last time.\nExample 19-12. PP4E\\Lang\\Xml\\etreebook.py\n\"\"\"\nXML parsing: ElementTree (etree) provides a Python-based API for parsing/generating\n\"\"\"\nimport pprint\nfrom xml.etree.ElementTree import parse\nmapping = {}\ntree = parse('books.xml')\nfor B in tree.findall('book'):\n    isbn = B.attrib['isbn']\n    for T in B.findall('title'):\n        mapping[isbn] = T.text\npprint.pprint(mapping)\nWhen run we get the exact same results as for SAX and DOM again, but the code\nrequired to extract the file\u2019s details seems noticeably simpler this time around:\nC:\\...\\PP4E\\Lang\\Xml> python etreebook.py\n{'0-596-00128-2': 'Python & XML',\n '0-596-00797-3': 'Python Cookbook, 2nd Edition',\n '0-596-10046-9': 'Python in a Nutshell, 2nd Edition',\n '0-596-15806-8': 'Learning Python, 4th Edition',\n '0-596-15808-4': 'Python Pocket Reference, 4th Edition',\n '0-596-15810-6': 'Programming Python, 4th Edition'}\n1434 | Chapter 19:\u2002Text and LanguageOther XML topics\nNaturally, there is much more to Python\u2019s XML support than these simple examples\nimply. In deference to space, though, here are pointers to XML resources in lieu of\nadditional examples:\nStandard library\nFirst, be sure to consult the Python library manual for more on the standard li-\nbrary\u2019s XML support tools. See the entries for re, xml.sax., xml.dom, and\nxml.etree for more on this section\u2019s examples.\nPyXML SIG tools\nYou can also find Python XML tools and documentation at the XML Special In-\nterest Group (SIG) web page at http://www.python.org. This SIG is dedicated to\nwedding XML technologies with Python, and it publishes free XML tools inde-\npendent of Python itself. Much of the standard library\u2019s XML support originated\nwith this group\u2019s work.\nThird-party tools\nYou can also find free, third-party Python support tools for XML on the Web by\nfollowing links at the XML SIGs web page. Of special interest, the 4Suite open\nsource package provides integrated tools for XML processing, including open\ntechnologies such as DOM, SAX, RDF, XSLT, XInclude, XPointer, XLink, and\nXPath.\nDocumentation\nA variety of books have been published which specifically address XML and text\nprocessing in Python. O\u2019Reilly offers a book dedicated to the subject of XML pro-\ncessing in Python, Python & XML, written by Christopher A. Jones and Fred L.\nDrake, Jr.\nAs usual, be sure to also see your favorite web search engine for more recent develop-\nments on this front.\nHTML Parsing in Action\nAlthough more limited in scope, Python\u2019s html.parser standard library module also\nsupports HTML-specific parsing, useful in \u201cscreen scraping\u201d roles to extract informa-\ntion from web pages. Among other things, this parser can be used to process Web\nreplies fetched with the urllib.request module we met in the Internet part of this book,\nto extract plain text from HTML email messages, and more.\nThe html.parser module has an API reminiscent of the XML SAX model of the prior\nsection: it provides a parser which we subclass to intercept tags and their data during\na parse. Unlike SAX, we don\u2019t provide a handler class, but extend the parser class\ndirectly. Here\u2019s a quick interactive example to demonstrate the basics (I copied all of\nthis section\u2019s code into file htmlparser.py in the examples package if you wish to ex-\nperiment with it yourself):\nXML and HTML Parsing | 1435>>> from html.parser import HTMLParser\n>>> class ParsePage(HTMLParser):\n...     def handle_starttag(self, tag, attrs):\n...         print('Tag start:', tag, attrs)\n...     def handle_endtag(self, tag):\n...         print('tag end:  ', tag)\n...     def handle_data(self, data):\n...         print('data......', data.rstrip())\n...\nNow, create a web page\u2019s HTML text string; we hardcode one here, but it might also\nbe loaded from a file, or fetched from a website with urllib.request:\n>>> page = \"\"\"\n... <html>\n... <h1>Spam!</h1>\n... <p>Click this <a href=\"http://www.python.org\">python</a> link</p>\n... </html>\"\"\"\nFinally, kick off the parse by feeding text to a parser instance\u2014tags in the HTML text\ntrigger class method callbacks, with tag names and attribute sequences passed in as\narguments:\n>>> parser = ParsePage()\n>>> parser.feed(page)\ndata......\nTag start: html []\ndata......\nTag start: h1 []\ndata...... Spam!\ntag end:   h1\ndata......\nTag start: p []\ndata...... Click this\nTag start: a [('href', 'http://www.python.org')]\ndata...... python\ntag end:   a\ndata......  link\ntag end:   p\ndata......\ntag end:   html\nAs you can see, the parser\u2019s methods receive callbacks for events during the parse. Much\nlike SAX XML parsing, your parser class will need to keep track of its state in attributes\nas it goes if it wishes to do something more specific than print tag names, attributes,\nand content. Watching for specific tags\u2019 content, though, might be as simple as check-\ning names and setting state flags. Moreover, building object trees to reflect the page\u2019s\nstructure during the parse would be straightforward.\n1436 | Chapter 19:\u2002Text and LanguageHandling HTML entity references (revisited)\nHere\u2019s another HTML parsing example: in Chapter 15, we used a simple method ex-\nported by this module to unquote HTML escape sequences (a.k.a. entities) in strings\nembedded in an HTML reply page:\n>>> import cgi, html.parser\n>>> s = cgi.escape(\"1<2 <b>hello</b>\")\n>>> s\n'1&lt;2 &lt;b&gt;hello&lt;/b&gt;'\n>>>\n>>> html.parser.HTMLParser().unescape(s)\n'1<2 <b>hello</b>'\nThis works for undoing HTML escapes, but that\u2019s all. When we saw this solution, I\nimplied that there was a more general approach; now that you know about the method\ncallback model of the HTML parser class, the more idiomatic way to handle entities\nduring a parse should make sense\u2014simply catch entity callbacks in a parser subclass,\nand translate as needed:\n>>> class Parse(html.parser.HTMLParser):\n...     def handle_data(self, data):\n...         print(data, end='')\n...     def handle_entityref(self, name):\n...         map = dict(lt='<', gt='>')\n...         print(map[name], end='')\n...\n>>> p = Parse()\n>>> p.feed(s); print()\n1<2 <b>hello</b>\nBetter still, we can use Python\u2019s related html.entities module to avoid hardcoding\nentity-to-character mappings for HTML entities. This module defines many more en-\ntity names than the simple dictionary in the prior example and includes all those you\u2019ll\nlikely encounter when parsing HTML text in the wild:\n>>> s\n'1&lt;2 &lt;b&gt;hello&lt;/b&gt;'\n>>>\n>>> from html.entities import entitydefs\n>>> class Parse(html.parser.HTMLParser):\n...     def handle_data(self, data):\n...         print(data, end='')\n...     def handle_entityref(self, name):\n...         print(entitydefs[name], end='')\n...\n>>> P = Parse()\n>>> P.feed(s); print()\n1<2 <b>hello</b>\nStrictly speaking, the html.entities module is able to map entity name to Unicode code\npoint and vice versa; its table used here simply converts code point integers to characters\nwith chr. See this module\u2019s documentation, as well as its source code in the Python\nstandard library for more details.\nXML and HTML Parsing | 1437Extracting plain text from HTML (revisited)\nNow that you understand the basic principles of the HTML parser class in Python\u2019s\nstandard library, the plain text extraction module used by Chapter 14\u2019s PyMailGUI\n(Example 14-8) will also probably make significantly more sense (this was an unavoid-\nable forward reference which we\u2019re finally able to close).\nRather than repeating its code here, I\u2019ll simply refer you back to that example, as well\nas its self-test and test input files, for another example of HTML parsing in Python to\nstudy on your own. It\u2019s essentially a minor elaboration on the examples here, which\ndetects more types of tags in its parser callback methods.\nBecause of space concerns, we have to cut short our treatment of HTML parsing here;\nas usual, knowing that it exists is enough to get started. For more details on the API,\nconsult the Python library manual. And for additional HTML support, check the Web\nfor the 3.X status of third-party HTML parser packages like those mentioned in\nChapter 14.\nAdvanced Language Tools\nIf you have a background in parsing theory, you may know that neither regular ex-\npressions nor string splitting is powerful enough to handle more complex language\ngrammars. Roughly, regular expressions don\u2019t have the stack \u201cmemory\u201d required by\ntrue language grammars, and so cannot support arbitrary nesting of language con-\nstructs\u2014nested if statements in a programming language, for instance. In fact, this is\nwhy the XML and HTML parsers of the prior section are required at all: both are\nlanguages of potentially arbitrary nesting, which are beyond the scope of regular ex-\npressions in general.\nFrom a theoretical perspective, regular expressions are really intended to handle just\nthe first stage of parsing\u2014separating text into components, otherwise known as lexical\nanalysis. Though patterns can often be used to extract data from text, true language\nparsing requires more. There are a number of ways to fill this gap with Python:\nPython as language tool\nIn most applications, the Python language itself can replace custom languages and\nparsers\u2014user-entered code can be passed to Python for evaluation with tools such\nas eval and exec. By augmenting the system with custom modules, user code in\nthis scenario has access to both the full Python language and any application-\nspecific extensions required. In a sense, such systems embed Python in Python.\nSince this is a common Python role, we\u2019ll revisit this approach later in this chapter.\nCustom language parsers: manual or toolkit\nFor some sophisticated language analysis tasks, though, a full-blown parser may\nstill be required. Such parsers can always be written by hand, but since Python is\nbuilt for integrating C tools, we can write integrations to traditional parser gener-\nator systems such as yacc and bison, tools that create parsers from language\n1438 | Chapter 19:\u2002Text and Languagegrammar definitions. Better yet, we could use an integration that already exists\u2014\ninterfaces to such common parser generators are freely available in the open source\ndomain (run a web search for up-to-date details and links).\nIn addition, a number of Python-specific parsing systems are available on the Web.\nAmong them: PLY is an implementation of lex and yacc parsing tools in and for\nPython; the kwParsing system is a parser generator written in Python; PyParsing \nis a pure-Python class library that makes it easy to build recursive-descent parsers\nquickly; and the SPARK toolkit is a lightweight system that employs the Earley\nalgorithm to work around technical problems with LALR parser generation (if you\ndon\u2019t know what that means, you probably don\u2019t need to care).\nOf special interest to this chapter, YAPPS (Yet Another Python Parser System) is a\nparser generator written in Python. It uses supplied grammar rules to generate\nhuman-readable Python code that implements a recursive descent parser; that is,\nit\u2019s Python code that generates Python code. The parsers generated by YAPPS look\nmuch like (and were inspired by) the handcoded custom expression parsers shown\nin the next section. YAPPS creates LL(1) parsers, which are not as powerful as\nLALR parsers but are sufficient for many language tasks. For more on YAPPS, see\nhttp://theory.stanford.edu/~amitp/Yapps or search the Web at large.\nNatural language processing\nEven more demanding language analysis tasks require techniques developed in\nartificial intelligence research, such as semantic analysis and machine learning. For\ninstance, the Natural Language Toolkit, or NLTK, is an open source suite of Python\nlibraries and programs for symbolic and statistical natural language processing. It\napplies linguistic techniques to textual data, and it can be used in the development\nof natural language recognition software and systems. For much more on this sub-\nject, be sure to also see the O\u2019Reilly book Natural Language Processing with Py-\nthon, which explores, among other things, ways to use NLTK in Python. Not every\nsystem\u2019s users will pose questions in a natural language, of course, but there are\nmany applications which can make good use of such utility.\nThough widely useful, parser generator systems and natural language analysis toolkits\nare too complex for us to cover in any sort of useful detail in this text. Consult http://\npython.org/ or search the Web for more information on language analysis tools available\nfor use in Python programs. For the purposes of this chapter, let\u2019s move on to explore\na more basic and manual approach that illustrates concepts underlying the domain\u2014\nrecursive descent parsing.\nLesson 2: Don\u2019t Reinvent the Wheel (Usually)\nSpeaking of parser generators, to use some of these tools in Python programs, you\u2019ll\nneed an extension module that integrates them. The first step in such scenarios should\nalways be to see whether the extension already exists in the public domain. Especially\nfor common tools like these, chances are that someone else has already implemented\nan integration that you can use off-the-shelf instead of writing one from scratch.\nAdvanced Language Tools | 1439Of course, not everyone can donate all their extension modules to the public domain,\nbut there\u2019s a growing library of available components that you can pick up for free and\na community of experts to query. Visit the PyPI site at http://www.python.org for links\nto Python software resources, or search the Web at large. With at least one million\nPython users out there as I write this book, much can be found in the prior-art\ndepartment.\nUnless, of course, the wheel does not work: We\u2019ve also seen a handful of cases in this\nbook where standard libraries were either not adequate or were broken altogether. For\ninstance, the Python 3.1 email package issues we explored in Chapter 13 required us\nto code workarounds of our own. In such cases, you may still ultimately need to code\nyour own infrastructure support. The \u201cnot invented here\u201d syndrome can still claim\nvictory when software dependencies break down.\nStill, you\u2019re generally better off trying to use the standard support provided by Python\nin most cases, even if doing so requires manually coded fixes. In the email package\nexample, fixing its problems seems much easier than coding an email parser and gen-\nerator from scratch\u2014a task far too large to have even attempted in this book. Python\u2019s\nbatteries included approach to development can be amazingly productive\u2014even when\nsome of those batteries require a charge.\nCustom Language Parsers\nAlthough toolkits abound in this domain, Python\u2019s status as a general-purpose pro-\ngramming language also makes it a reasonable vehicle for writing hand-coded parsers\nfor custom language analysis tasks. For instance, recursive descent parsing is a fairly\nwell-known technique for analyzing language-based information. Though not as pow-\nerful as some language tools, recursive descent parses are sufficient for a wide variety\nof language-related goals.\nTo illustrate, this section develops a custom parser for a simple grammar\u2014it parses\nand evaluates arithmetic expression strings. Though language analysis is the main topic\nhere, this example also demonstrates the utility of Python as a general-purpose pro-\ngramming language. Although Python is often used as a frontend or rapid development\nlanguage in tactical modes, it\u2019s also often useful for the kinds of strategic work you may\nhave formerly done in a systems development language such as C or C++.\nThe Expression Grammar\nThe grammar that our parser will recognize can be described as follows:\ngoal -> <expr> END                       [number, variable, ( ]\ngoal -> <assign> END                     [set]\nassign -> 'set' <variable> <expr>        [set]\nexpr -> <factor> <expr-tail>             [number, variable, ( ]\n1440 | Chapter 19:\u2002Text and Languageexpr-tail -> ^                           [END, ) ]\nexpr-tail -> '+' <factor> <expr-tail>    [+]\nexpr-tail -> '-' <factor> <expr-tail>    [-]\nfactor -> <term> <factor-tail>           [number, variable, ( ]\nfactor-tail -> ^                         [+, -, END, ) ]\nfactor-tail -> '*' <term> <factor-tail>  [*]\nfactor-tail -> '/' <term> <factor-tail>  [/]\nterm -> <number>                         [number]\nterm -> <variable>                       [variable]\nterm -> '(' <expr> ')'                   [(]\ntokens: (, ), num, var, -, +, /, *, set, end\nThis is a fairly typical grammar for a simple expression language, and it allows for\narbitrary expression nesting (some example expressions appear at the end of the test\nparser module listing in Example 19-15). Strings to be parsed are either an expression\nor an assignment to a variable name (set). Expressions involve numbers, variables, and\nthe operators +, \u2212, *, and /. Because factor is nested in expr in the grammar, * and /\nhave higher precedence (i.e., they bind tighter) than + and \u2212. Expressions can be en-\nclosed in parentheses to override precedence, and all operators are left associative\u2014\nthat is, they group on the left (e.g., 1-2-3 is treated the same as (1-2)-3).\nTokens are just the most primitive components of the expression language. Each gram-\nmar rule listed earlier is followed in square brackets by a list of tokens used to select it.\nIn recursive descent parsing, we determine the set of tokens that can possibly start a\nrule\u2019s substring, and we use that information to predict which rule will work ahead of\ntime. For rules that iterate (the -tail rules), we use the set of possibly following tokens\nto know when to stop. Typically, tokens are recognized by a string processor (a scan-\nner), and a higher-level processor (a parser) uses the token stream to predict and step\nthrough grammar rules and substrings.\nThe Parser\u2019s Code\nThe system is structured as two modules, holding two classes:\n\u2022 The scanner handles low-level character-by-character analysis.\n\u2022 The parser embeds a scanner and handles higher-level grammar analysis.\nThe parser is also responsible for computing the expression\u2019s value and testing the\nsystem. In this version, the parser evaluates the expression while it is being parsed. To\nuse the system, we create a parser with an input string and call its parse method. We\ncan also call parse again later with a new expression string.\nThere\u2019s a deliberate division of labor here. The scanner extracts tokens from the string,\nbut it knows nothing about the grammar. The parser handles the grammar, but it is\nCustom Language Parsers | 1441naive about the string itself. This modular structure keeps the code relatively simple.\nAnd it\u2019s another example of the object-oriented programming (OOP) composition re-\nlationship at work: parsers embed and delegate to scanners.\nThe module in Example 19-13 implements the lexical analysis task\u2014detecting the ex-\npression\u2019s basic tokens by scanning the text string left to right on demand. Notice that\nthis is all straightforward logic; such analysis can sometimes be performed with regular\nexpressions instead (described earlier), but the pattern needed to detect and extract\ntokens in this example would be too complex and fragile for my tastes. If your tastes\nvary, try recoding this module with re.\nExample 19-13. PP4E\\Lang\\Parser\\scanner.py\n\"\"\"\n###############################################################################\nthe scanner (lexical analyser)\n###############################################################################\n\"\"\"\nimport string\nclass SyntaxError(Exception): pass           # local errors\nclass LexicalError(Exception): pass          # used to be strings\nclass Scanner:\n    def __init__(self, text):\n        self.next = 0\n        self.text = text + '\\0'\n    def newtext(self, text):\n        Scanner.__init__(self, text)\n    def showerror(self):\n        print('=> ', self.text)\n        print('=> ', (' ' * self.start) + '^')\n    def match(self, token):\n        if self.token != token:\n            raise SyntaxError(token)\n        else:\n            value = self.value\n            if self.token != '\\0':\n                self.scan()                  # next token/value\n            return value                     # return prior value\n    def scan(self):\n        self.value = None\n        ix = self.next\n        while self.text[ix] in string.whitespace:\n            ix += 1\n        self.start = ix\n        if self.text[ix] in ['(', ')', '-', '+', '/', '*', '\\0']:\n            self.token = self.text[ix]\n            ix += 1\n1442 | Chapter 19:\u2002Text and Languageelif self.text[ix] in string.digits:\n            str = ''\n            while self.text[ix] in string.digits:\n                str += self.text[ix]\n                ix += 1\n            if self.text[ix] == '.':\n                str += '.'\n                ix += 1\n                while self.text[ix] in string.digits:\n                    str += self.text[ix]\n                    ix += 1\n                self.token = 'num'\n                self.value = float(str)\n            else:\n                self.token = 'num'\n                self.value = int(str)           # subsumes long() in 3.x\n        elif self.text[ix] in string.ascii_letters:\n            str = ''\n            while self.text[ix] in (string.digits + string.ascii_letters):\n                str += self.text[ix]\n                ix += 1\n            if str.lower() == 'set':\n                self.token = 'set'\n            else:\n                self.token = 'var'\n                self.value = str\n        else:\n            raise LexicalError()\n        self.next = ix\nThe parser module\u2019s class creates and embeds a scanner for its lexical chores and han-\ndles interpretation of the expression grammar\u2019s rules and evaluation of the expression\u2019s\nresult, as shown in Example 19-14.\nExample 19-14. PP4E\\Lang\\Parser\\parser1.py\n\"\"\"\n################################################################################\nthe parser (syntax analyser, evaluates during parse)\n################################################################################\n\"\"\"\nclass UndefinedError(Exception): pass\nfrom scanner import Scanner, LexicalError, SyntaxError\nclass Parser:\n    def __init__(self, text=''):\n        self.lex  = Scanner(text)              # embed a scanner\n        self.vars = {'pi': 3.14159}            # add a variable\n    def parse(self, *text):\n        if text:                               # main entry-point\nCustom Language Parsers | 1443self.lex.newtext(text[0])          # reuse this parser?\n        try:\n            self.lex.scan()                    # get first token\n            self.Goal()                        # parse a sentence\n        except SyntaxError:\n            print('Syntax Error at column:', self.lex.start)\n            self.lex.showerror()\n        except LexicalError:\n            print('Lexical Error at column:', self.lex.start)\n            self.lex.showerror()\n        except UndefinedError as E:\n            name = E.args[0]\n            print(\"'%s' is undefined at column:\" % name, self.lex.start)\n            self.lex.showerror()\n    def Goal(self):\n        if self.lex.token in ['num', 'var', '(']:\n            val = self.Expr()\n            self.lex.match('\\0')                    # expression?\n            print(val)\n        elif self.lex.token == 'set':               # set command?\n            self.Assign()\n            self.lex.match('\\0')\n        else:\n            raise SyntaxError()\n    def Assign(self):\n        self.lex.match('set')\n        var = self.lex.match('var')\n        val = self.Expr()\n        self.vars[var] = val           # assign name in dict\n    def Expr(self):\n        left = self.Factor()\n        while True:\n            if self.lex.token in ['\\0', ')']:\n                return left\n            elif self.lex.token == '+':\n                self.lex.scan()\n                left = left + self.Factor()\n            elif self.lex.token == '-':\n                self.lex.scan()\n                left = left - self.Factor()\n            else:\n                raise SyntaxError()\n    def Factor(self):\n        left = self.Term()\n        while True:\n            if self.lex.token in ['+', '-', '\\0', ')']:\n                return left\n            elif self.lex.token == '*':\n                self.lex.scan()\n                left = left * self.Term()\n            elif self.lex.token == '/':\n1444 | Chapter 19:\u2002Text and Languageself.lex.scan()\n                left = left / self.Term()\n            else:\n                raise SyntaxError()\n    def Term(self):\n        if self.lex.token == 'num':\n            val = self.lex.match('num')               # numbers\n            return val\n        elif self.lex.token == 'var':\n            if self.lex.value in self.vars.keys():    # keys(): EIBTI!\n                val = self.vars[self.lex.value]       # look up name's value\n                self.lex.scan()\n                return val\n            else:\n                raise UndefinedError(self.lex.value)\n        elif self.lex.token == '(':\n            self.lex.scan()\n            val = self.Expr()                         # sub-expression\n            self.lex.match(')')\n            return val\n        else:\n            raise SyntaxError()\nif __name__ == '__main__':\n    import testparser                       # self-test code\n    testparser.test(Parser, 'parser1')      # test local Parser\nIf you study this code closely, you\u2019ll notice that the parser keeps a dictionary\n(self.vars) to manage variable names: they\u2019re stored in the dictionary on a set com-\nmand and are fetched from it when they appear in an expression. Tokens are repre-\nsented as strings, with an optional associated value (a numeric value for numbers and\na string for variable names).\nThe parser uses iteration (while loops) rather than recursion for the expr-tail and\nfactor-tail rules. Other than this optimization, the rules of the grammar map directly\nonto parser methods: tokens become calls to the scanner, and nested rule references\nbecome calls to other methods.\nWhen the file parser1.py is run as a top-level program, its self-test code is executed,\nwhich in turn simply runs a canned test in the module shown in Example 19-15. Notice\nhow the scanner converts numbers to strings with int; this ensures that all integer math\ninvoked by the parser supports unlimited precision, simply because it uses Python\nintegers which always provide the extra precision if needed (the separate Python 2.X\nlong type and syntax is no more).\nAlso notice that mixed integer/floating-point operations cast up to floating point since\nPython operators are used to do the actual calculations along the way. The expression\nlanguage\u2019s / division operator also inherits Python 3.X\u2019s true division model which\nretains remainders and returns floating point results regardless of operand types. We\nCustom Language Parsers | 1445could simply run a // in our evaluation logic to retain prior behavior (or allow for\nboth / and // in our grammar), but we\u2019ll follow Python 3.X\u2019s lead here.\nExample 19-15. PP4E\\Lang\\Parser\\testparser.py\n\"\"\"\n############################################################################\nparser test code\n############################################################################\n\"\"\"\ndef test(ParserClass, msg):\n    print(msg, ParserClass)\n    x = ParserClass('4 / 2 + 3')            # allow different Parsers\n    x.parse()\n    x.parse('3 + 4 / 2')                    # like eval('3 + 4 / 2')...\n    x.parse('(3 + 4) / 2')                  # 3.X: / is now true div\n    x.parse('4 / (2 + 3)')                  # // is not supported (yet)\n    x.parse('4.0 / (2 + 3)')\n    x.parse('4 / (2.0 + 3)')\n    x.parse('4.0 / 2 * 3')\n    x.parse('(4.0 / 2) * 3')\n    x.parse('4.0 / (2 * 3)')\n    x.parse('(((3))) + 1')\n    y = ParserClass()\n    y.parse('set a 4 / 2 + 1')\n    y.parse('a * 3')\n    y.parse('set b 12 / a')\n    y.parse('b')\n    z = ParserClass()\n    z.parse('set a 99')\n    z.parse('set a a + 1')\n    z.parse('a')\n    z = ParserClass()\n    z.parse('pi')\n    z.parse('2 * pi')\n    z.parse('1.234 + 2.1')\ndef interact(ParserClass):                     # command-line entry\n    print(ParserClass)\n    x = ParserClass()\n    while True:\n        cmd = input('Enter=> ')\n        if cmd == 'stop':\n            break\n        x.parse(cmd)\nCorrelate the following results to print call statements in the self-test module:\nC:\\...\\PP4E\\Lang\\Parser> python parser1.py\nparser1 <class '__main__.Parser'>\n1446 | Chapter 19:\u2002Text and Language5.0\n5.0\n3.5\n0.8\n0.8\n0.8\n6.0\n6.0\n0.666666666667\n4\n9.0\n4.0\n100\n3.14159\n6.28318\n3.334\nAs usual, we can also test and use the system interactively to work through more of its\nutility:\nC:\\...\\PP4E\\Lang\\Parser> python\n>>> import parser1\n>>> x = parser1.Parser()\n>>> x.parse('1 + 2')\n3\nError cases are trapped and reported in a fairly friendly fashion (assuming users think\nin zero-based terms):\n>>> x.parse('1 + a')\n'a' is undefined at column: 4\n=>  1 + a\n=>      ^\n>>> x.parse('1+a+2')\n'a' is undefined at column: 2\n=>  1+a+2\n=>    ^\n>>> x.parse('1 * 2 $')\nLexical Error at column: 6\n=>  1 * 2 $\n=>        ^\n>>> x.parse('1 * - 1')\nSyntax Error at column: 4\n=>  1 * - 1\n=>      ^\n>>> x.parse('1 * (9')\nSyntax Error at column: 6\n=>  1 * (9\n=>        ^\n>>> x.parse('1 + 2 / 3')           # 3.X division change\n1.66666666667\n>>> x.parse('1 + 2 // 3')\nSyntax Error at column: 7\n=>  1 + 2 // 3\n=>         ^\nCustom Language Parsers | 1447Lesson 3: Divide and Conquer\nAs the custom parser system demonstrates, modular program design is almost always\na major win. By using Python\u2019s program structuring tools (functions, modules, classes,\nand so on), big tasks can be broken down into small, manageable parts that can be\ncoded and tested independently.\nFor instance, the scanner can be tested without the parser by making an instance with\nan input string and calling its scan or match methods repeatedly. We can even test it\nlike this interactively, from Python\u2019s command line. When we separate programs into\nlogical components, they become easier to understand and modify. Imagine what the\nparser would look like if the scanner\u2019s logic was embedded rather than called.\nPathologically big numbers are handled well, too, because Python\u2019s built-in objects and\noperators are used along the way:\n>>> x.parse('888888888888888888888888888888888888888888888.9999999')\n8.88888888889e+44\n>>> x.parse('99999999999999999999999999999999999999999 + 2')\n100000000000000000000000000000000000000001\n>>> x.parse('999999999999999999999999999999.88888888888 + 1.1')\n1e+30\nIn addition, there is an interactive loop interface in the testparser module if you want\nto use the parser as a simple command-line calculator (or if you get tired of typing parser\nmethod calls). Pass the Parser class, so testparser can make one of its own:\n>>> import testparser\n>>> testparser.interact(parser1.Parser)\n<class 'parser1.Parser'>\nEnter=> 4 * 3 + 5\n17\nEnter=> 5 + 4 * 3\n17\nEnter=> (5 + 4) * 3\n27\nEnter=> set a 99\nEnter=> set b 66\nEnter=> a + b\n165\nEnter=> # + 1\nLexical Error at column: 0\n=>  # + 1\n=>  ^\nEnter=> a * b + c\n'c' is undefined at column: 8\n=>  a * b + c\n=>          ^\nEnter=> a * b * + c\nSyntax Error at column: 8\n=>  a * b * + c\n=>          ^\nEnter=> a\n1448 | Chapter 19:\u2002Text and Language99\nEnter=> a * a * a\n970299\nEnter=> stop\n>>>\nAdding a Parse Tree Interpreter\nOne weakness in the parser1 program is that it embeds expression evaluation logic in\nthe parsing logic: the result is computed while the string is being parsed. This makes\nevaluation quick, but it can also make it difficult to modify the code, especially in larger\nsystems. To simplify, we could restructure the program to keep expression parsing and\nevaluation separate. Instead of evaluating the string, the parser can build up an inter-\nmediate representation of it that can be evaluated later. As an added incentive, building\nthe representation separately makes it available to other analysis tools (e.g., optimizers,\nviewers, and so on)\u2014they can be run as separate passes over the tree.\nExample 19-16 shows a variant of parser1 that implements this idea. The parser ana-\nlyzes the string and builds up a parse tree\u2014that is, a tree of class instances that repre-\nsents the expression and that may be evaluated in a separate step. The parse tree is built\nfrom classes that \u201cknow\u201d how to evaluate themselves: to compute the expression, we\njust ask the tree to evaluate itself. Root nodes in the tree ask their children to evaluate\nthemselves, and then combine the results by applying a single operator. In effect, eval-\nuation in this version is simply a recursive traversal of a tree of embedded class instances\nconstructed by the parser.\nExample 19-16. PP4E\\Lang\\Parser\\parser2.py\n\"\"\"\nSeparate expression parsing from evaluation by building an explicit parse tree\n\"\"\"\nTraceDefault = False\nclass UndefinedError(Exception): pass\nif __name__ == '__main__':\n    from scanner import Scanner, SyntaxError, LexicalError      # if run here\nelse:\n    from .scanner import Scanner, SyntaxError, LexicalError     # from PyTree\n#################################################################################\n# the interpreter (a smart objects tree)\n#################################################################################\nclass TreeNode:\n    def validate(self, dict):           # default error check\n        pass\n    def apply(self, dict):              # default evaluator\n        pass\n    def trace(self, level):             # default unparser\n        print('.' * level + '<empty>')\nCustom Language Parsers | 1449# ROOTS\nclass BinaryNode(TreeNode):\n    def __init__(self, left, right):            # inherited methods\n        self.left, self.right = left, right     # left/right branches\n    def validate(self, dict):\n        self.left.validate(dict)                # recurse down branches\n        self.right.validate(dict)\n    def trace(self, level):\n        print('.' * level + '[' + self.label + ']')\n        self.left.trace(level+3)\n        self.right.trace(level+3)\nclass TimesNode(BinaryNode):\n    label = '*'\n    def apply(self, dict):\n        return self.left.apply(dict) * self.right.apply(dict)\nclass DivideNode(BinaryNode):\n    label = '/'\n    def apply(self, dict):\n        return self.left.apply(dict) / self.right.apply(dict)\nclass PlusNode(BinaryNode):\n    label = '+'\n    def apply(self, dict):\n        return self.left.apply(dict) + self.right.apply(dict)\nclass MinusNode(BinaryNode):\n    label = '-'\n    def apply(self, dict):\n        return self.left.apply(dict) - self.right.apply(dict)\n# LEAVES\nclass NumNode(TreeNode):\n    def __init__(self, num):\n        self.num = num                 # already numeric\n    def apply(self, dict):             # use default validate\n        return self.num\n    def trace(self, level):\n        print('.' * level + repr(self.num))   # as code, was 'self.num'\nclass VarNode(TreeNode):\n    def __init__(self, text, start):\n        self.name   = text                    # variable name\n        self.column = start                   # column for errors\n    def validate(self, dict):\n        if not self.name in dict.keys():\n            raise UndefinedError(self.name, self.column)\n    def apply(self, dict):\n        return dict[self.name]                # validate before apply\n    def assign(self, value, dict):\n        dict[self.name] = value               # local extension\n1450 | Chapter 19:\u2002Text and Languagedef trace(self, level):\n        print('.' * level + self.name)\n# COMPOSITES\nclass AssignNode(TreeNode):\n    def __init__(self, var, val):\n        self.var, self.val = var, val\n    def validate(self, dict):\n        self.val.validate(dict)               # don't validate var\n    def apply(self, dict):\n        self.var.assign( self.val.apply(dict), dict )\n    def trace(self, level):\n        print('.' * level + 'set ')\n        self.var.trace(level + 3)\n        self.val.trace(level + 3)\n#################################################################################\n# the parser (syntax analyser, tree builder)\n#################################################################################\nclass Parser:\n    def __init__(self, text=''):\n        self.lex     = Scanner(text)           # make a scanner\n        self.vars    = {'pi':3.14159}          # add constants\n        self.traceme = TraceDefault\n    def parse(self, *text):                    # external interface\n        if text:\n            self.lex.newtext(text[0])          # reuse with new text\n        tree = self.analyse()                  # parse string\n        if tree:\n            if self.traceme:                   # dump parse-tree?\n                print(); tree.trace(0)\n            if self.errorCheck(tree):          # check names\n                self.interpret(tree)           # evaluate tree\n    def analyse(self):\n        try:\n            self.lex.scan()                    # get first token\n            return self.Goal()                 # build a parse-tree\n        except SyntaxError:\n            print('Syntax Error at column:', self.lex.start)\n            self.lex.showerror()\n        except LexicalError:\n            print('Lexical Error at column:', self.lex.start)\n            self.lex.showerror()\n    def errorCheck(self, tree):\n        try:\n            tree.validate(self.vars)           # error checker\n            return 'ok'\n        except UndefinedError as instance:     # args is a tuple\n            varinfo = instance.args\n            print(\"'%s' is undefined at column: %d\" % varinfo)\nCustom Language Parsers | 1451self.lex.start = varinfo[1]\n            self.lex.showerror()               # returns None\n    def interpret(self, tree):\n        result = tree.apply(self.vars)         # tree evals itself\n        if result != None:                     # ignore 'set' result\n            print(result)                      # ignores errors\n    def Goal(self):\n        if self.lex.token in ['num', 'var', '(']:\n            tree = self.Expr()\n            self.lex.match('\\0')\n            return tree\n        elif self.lex.token == 'set':\n            tree = self.Assign()\n            self.lex.match('\\0')\n            return tree\n        else:\n            raise SyntaxError()\n    def Assign(self):\n        self.lex.match('set')\n        vartree = VarNode(self.lex.value, self.lex.start)\n        self.lex.match('var')\n        valtree = self.Expr()\n        return AssignNode(vartree, valtree)               # two subtrees\n    def Expr(self):\n        left = self.Factor()                              # left subtree\n        while True:\n            if self.lex.token in ['\\0', ')']:\n                return left\n            elif self.lex.token == '+':\n                self.lex.scan()\n                left = PlusNode(left, self.Factor())      # add root-node\n            elif self.lex.token == '-':\n                self.lex.scan()\n                left = MinusNode(left, self.Factor())     # grows up/right\n            else:\n                raise SyntaxError()\n    def Factor(self):\n        left = self.Term()\n        while True:\n            if self.lex.token in ['+', '-', '\\0', ')']:\n                return left\n            elif self.lex.token == '*':\n                self.lex.scan()\n                left = TimesNode(left, self.Term())\n            elif self.lex.token == '/':\n                self.lex.scan()\n                left = DivideNode(left, self.Term())\n            else:\n                raise SyntaxError()\n1452 | Chapter 19:\u2002Text and Languagedef Term(self):\n        if self.lex.token == 'num':\n            leaf = NumNode(self.lex.match('num'))\n            return leaf\n        elif self.lex.token == 'var':\n            leaf = VarNode(self.lex.value, self.lex.start)\n            self.lex.scan()\n            return leaf\n        elif self.lex.token == '(':\n            self.lex.scan()\n            tree = self.Expr()\n            self.lex.match(')')\n            return tree\n        else:\n            raise SyntaxError()\n#################################################################################\n# self-test code: use my parser, parser1's tester\n#################################################################################\nif __name__ == '__main__':\n    import testparser\n    testparser.test(Parser, 'parser2')    #  run with Parser class here\nNotice the way we handle undefined name exceptions in errorCheck. When exceptions\nare derived from the built-in Exception class, their instances automatically return the\narguments passed to the exception constructor call as a tuple in their args attribute\u2014\nconvenient for use in string formatting here.\nAlso notice that the new parser reuses the same scanner module as well. To catch errors\nraised by the scanner, it also imports the specific classes that identify the scanner\u2019s\nexceptions. Both the scanner and the parser can raise exceptions on errors (lexical\nerrors, syntax errors, and undefined name errors). They\u2019re caught at the top level of\nthe parser, and they end the current parse. There\u2019s no need to set and check status flags\nto terminate the recursion. Since math is done using integers, floating-point numbers,\nand Python\u2019s operators, there\u2019s usually no need to trap numeric overflow or underflow\nerrors. But as is, the parser doesn\u2019t handle errors such as division by zero\u2014such Python\nexceptions make the parser system exit with a Python stack trace and message. Un-\ncovering the cause and fix for this is left as suggested exercise.\nWhen parser2 is run as a top-level program, we get the same test code output as\nfor parser1. In fact, it reuses the very same test code\u2014both parsers pass in their parser\nclass object to testparser.test. And since classes are also objects, we can also pass\nthis \nversion \nof \nthe \nparser \nto \ntestparser\u2019s \ninteractive \nloop:\ntestparser.interact(parser2.Parser).\nThe new parser\u2019s external behavior is identical to that of the original, so I won\u2019t repeat\nall its output here (run this live for a firsthand look). Of note, though, this parser sup-\nports both use as a top-level script, and package imports from other directories, such\nas the PyTree viewer we\u2019ll use in a moment. Python 3.X no longer searches a module\u2019s\nCustom Language Parsers | 1453own directory on the import search path, though, so we have to use package-relative\nimport syntax for the latter case, and import from another directory when testing\ninteractively:\nC:\\...\\PP4E\\Lang\\Parser> parser2.py\nparser2 <class '__main__.Parser'>\n5.0\n...rest is same as for parser1...\nC:\\...PP4E\\Lang\\Parser> python\n>>> import parser2\n    from .scanner import Scanner, SyntaxError, LexicalError     # from PyTree\nValueError: Attempted relative import in non-package\nC:\\...\\PP4E\\Lang\\Parser> cd ..\nC:\\...\\PP4E\\Lang> Parser\\parser2.py\nparser2 <class '__main__.Parser'>\n5.0\n...rest is same as for parser1...\nC:\\...\\PP4E\\Lang> python\n>>> from Parser import parser2\n>>> x = parser2.Parser()\n>>> x.parse('1 + 2 * 3 + 4')\n11\n>>> import Parser.testparser\n>>> Parser.testparser.interact(parser2.Parser)\n<class 'Parser.parser2.Parser'>\nEnter=> 4 * 3 + 5\n17\nEnter=> stop\n>>>\nUsing full package import paths in parser2 instead of either package-relative or un-\nqualified imports:\nfrom PP4E.Lang.Parser import scanner\nwould suffice for all three use cases\u2014script, and both same and other directory\nimports\u2014but requires the path to be set properly, and seems overkill for importing a\nfile in the same directory as the importer.\nParse Tree Structure\nReally, the only tangible difference with this latest parser is that it builds and uses trees\nto evaluate an expression internally instead of evaluating as it parses. The intermediate\nrepresentation of an expression is a tree of class instances, whose shape reflects the\norder of operator evaluation. This parser also has logic to print an indented listing of\nthe constructed parse tree if the traceme attribute is set to True (or 1). Indentation gives\nthe nesting of subtrees, and binary operators list left subtrees first. For example:\nC:\\...\\PP4E\\Lang>\n>>> from Parser import parser2\n1454 | Chapter 19:\u2002Text and Language>>> p = parser2.Parser()\n>>> p.traceme = True\n>>> p.parse('5 + 4 * 2')\n[+]\n...5\n...[*]\n......4\n......2\n13\nWhen this tree is evaluated, the apply method recursively evaluates subtrees and applies\nroot operators to their results. Here, * is evaluated before +, since it\u2019s lower in the tree.\nThe Factor method consumes the * substring before returning a right subtree to Expr.\nThe next tree takes a different shape:\n>>> p.parse('5 * 4 - 2')\n[-]\n...[*]\n......5\n......4\n...2\n18\nIn this example, * is evaluated before -. The Factor method loops through a substring\nof * and / expressions before returning the resulting left subtree to Expr. The next\nexample is more complex, but follows the same rules:\n>>> p.parse('1 + 3 * (2 * 3 + 4)')\n[+]\n...1\n...[*]\n......3\n......[+]\n.........[*]\n............2\n............3\n.........4\n31\nTrees are made of nested class instances. From an OOP perspective, it\u2019s another way\nto use composition. Since tree nodes are just class instances, this tree could be created\nand evaluated manually, too:\nPlusNode( NumNode(1),\n          TimesNode( NumNode(3),\n                     PlusNode( TimesNode(NumNode(2), NumNode(3)),\n                               NumNode(4) ))).apply({})\nBut we might as well let the parser build it for us (Python is not that much like Lisp,\ndespite what you may have heard).\nCustom Language Parsers | 1455Exploring Parse Trees with the PyTree GUI\nBut wait\u2014there is a better way to explore parse tree structures. Figure 19-1 shows the\nparse tree generated for the string 1 + 3 * (2 * 3 + 4), displayed in PyTree, the tree\nvisualization GUI described at the end of Chapter 18. This works only because the\nparser2 module builds the parse tree explicitly (parser1 evaluates during a parse in-\nstead) and because PyTree\u2019s code is generic and reusable.\nFigure 19-1. PyTree view of parse tree built for 1 + 3 * (2 * 3 + 4)\nIf you read the last chapter, you\u2019ll recall that PyTree can draw most any tree data struc-\nture, but it is preconfigured to handle binary search trees and the expression parse trees\nwe\u2019re studying in this chapter. For parse trees, clicking on nodes in a displayed parse\ntree evaluates the subtree rooted there.\n1456 | Chapter 19:\u2002Text and LanguagePyTree makes it easy to learn about and experiment with the parser. To determine the\ntree shape produced for a given expression, start PyTree, click on its Parser radio button,\ntype the expression in the input field at the bottom right, and press \u201cinput\u201d (or your\nEnter key). The parser class is run to generate a tree from your input, and the GUI\ndisplays the result. Depending on the operators used within an expression, some very\ndifferently shaped trees yield the same result when evaluated.\nTry running PyTree on your computer to get a better feel for the parsing process. (I\u2019d\nlike to show more example trees, but I ran out of page real estate at this point in the\nbook.)\nParsers Versus Python\nThe handcoded custom parser programs we\u2019ve met in this section illustrate some in-\nteresting concepts and underscore the power of Python for general-purpose program-\nming. Depending on your job description, they may also be typical of the sort of thing\nyou\u2019d write regularly in a traditional language such as C. Parsers are an important\ncomponent in a wide variety of applications, but in some cases, they\u2019re not as necessary\nas you might think. Let me explain why.\nSo far, we started with an expression parser and added a parse tree interpreter to make\nthe code easier to modify. As is, the parser works, but it may be slow compared to a C\nimplementation. If the parser is used frequently, we could speed it up by moving parts\nto C extension modules. For instance, the scanner might be moved to C initially, since\nit\u2019s often called from the parser. Ultimately, we might add components to the grammar\nthat allow expressions to access application-specific variables and functions.\nAll of these steps constitute good engineering. But depending on your application, this\napproach may not be the best one in Python. Often the easiest way to evaluate input\nexpressions in Python is to let Python do it for us, by calling its eval built-in function.\nIn fact, we can usually replace the entire expression evaluation program with this one\nfunction call. The next section will show how this can be used to simplify language-\nbased systems in general.\nMore important, the next section underscores a core idea behind the language: if you\nalready have an extensible, embeddable, high-level language system, why invent an-\nother? Python itself can often satisfy language-based component needs.\nPyCalc: A Calculator Program/Object\nTo wrap up this chapter, I\u2019m going to show you a practical application for some of the\nparsing technology introduced in the preceding section. This section presents PyCalc,\na Python calculator program with a graphical interface, similar to the calculator pro-\ngrams available on most window systems. Like most of the GUI examples in this book,\nthough, PyCalc offers a few advantages over existing calculators. Because PyCalc is\nPyCalc: A Calculator Program/Object | 1457written in Python, it is both easily customized and widely portable across window \nplatforms. And because it is implemented with classes, it is both a standalone program \nand a reusable object library.\nA Simple Calculator GUI\nBefore I show you how to write a full-blown calculator, though, the module shown in \nExample 19-17 starts this discussion in simpler terms. It implements a limited calcu-\nlator GUI, whose buttons just add text to the input field at the top in order to compose \na Python expression string. Fetching and running the string all at once produces results. \nFigure 19-2 shows the window this module makes when run as a top-level script.\nExample 19-17. PP4E\\Lang\\Calculator\\calc0.py\n\"a simplistic calculator GUI: expressions run all at once with eval/exec\"\nfrom tkinter import *\nfrom PP4E.Gui.Tools.widgets import frame, button, entry\nclass CalcGui(Frame):\n    def __init__(self, parent=None):                   # an extended frame\n        Frame.__init__(self, parent)                   # on default top-level\n        self.pack(expand=YES, fill=BOTH)               # all parts expandable\n        self.master.title('Python Calculator 0.1')     # 6 frames plus entry\n        self.master.iconname(\"pcalc1\")\n        self.names = {}                                # namespace for variables\n        text = StringVar()\n        entry(self, TOP, text)\n        rows = [\"abcd\", \"0123\", \"4567\", \"89()\"]\n        for row in rows:\n            frm = frame(self, TOP)\n            for char in row:\n                button(frm, LEFT, char,\n                            lambda char=char: text.set(text.get() + char))\n        frm = frame(self, TOP)\n        for char in \"+-*/=\":\n            button(frm, LEFT, char,\n                        lambda char=char: text.set(text.get()+ ' ' + char + ' '))\n        frm = frame(self, BOTTOM)\n        button(frm, LEFT, 'eval',  lambda: self.eval(text) )\n        button(frm, LEFT, 'clear', lambda: text.set('') )\n    def eval(self, text):\n        try:\n            text.set(str(eval(text.get(), self.names, self.names)))    # was 'x'\n        except SyntaxError:\n            try:\n                exec(text.get(), self.names, self.names)\n            except:\n1458 | Chapter 19:\u2002Text and Languagetext.set(\"ERROR\")         # bad as statement too?\n            else:\n                text.set('')              # worked as a statement\n        except:\n            text.set(\"ERROR\")             # other eval expression errors\nif __name__ == '__main__': CalcGui().mainloop()\nFigure 19-2. The calc0 script in action on Windows 7 (result=160.283)\nBuilding the GUI\nNow, this is about as simple as a calculator can be, but it demonstrates the basics. This\nwindow comes up with buttons for entry of numbers, variable names, and operators.\nIt is built by attaching buttons to frames: each row of buttons is a nested Frame, and\nthe GUI itself is a Frame subclass with an attached Entry and six embedded row frames\n(grids would work here, too). The calculator\u2019s frame, entry field, and buttons are made\nexpandable in the imported widgets utility module we coded earlier in Example 10-1.\nThis calculator builds up a string to pass to the Python interpreter all at once on \u201ceval\u201d\nbutton presses. Because you can type any Python expression or statement in the entry\nfield, the buttons are really just a convenience. In fact, the entry field isn\u2019t much more\nthan a command line. Try typing import sys, and then dir(sys) to display sys module\nattributes in the input field at the top\u2014it\u2019s not what you normally do with a calculator,\nbut it is demonstrative nevertheless.*\n* Once again, I need to warn you about running code strings like this if you can\u2019t be sure they won\u2019t cause\ndamage. If these strings can be entered by users you cannot trust, they will have access to anything on the\ncomputer that the Python process has access to. See Chapters 9 and 15 for more on security issues related to\ncode run in GUI, Web, and other contexts.\nPyCalc: A Calculator Program/Object | 1459In CalcGui\u2019s constructor, buttons are coded as lists of strings; each string represents a\nrow and each character in the string represents a button. Lambdas are used to save\nextra callback data for each button. The callback functions retain the button\u2019s character\nand the linked text entry variable so that the character can be added to the end of the\nentry widget\u2019s current string on a press.\nNotice how we must pass in the loop variable as a default argument to some lambdas\nin this code. Recall from Chapter 7 how references within a lambda (or nested def) to\nnames in an enclosing scope are evaluated when the nested function is called, not when\nit is created. When the generated function is called, enclosing scope references inside\nthe lambda reflect their latest setting in the enclosing scope, which is not necessarily\nthe values they held when the lambda expression ran. By contrast, defaults are evaluated\nat function creation time instead and so can remember the current values of loop var-\niables. Without the defaults, each button would reflect the last iteration of the loop.\nLesson 4: Embedding Beats Parsers\nThe calculator uses eval and exec to call Python\u2019s parser and interpreter at runtime\ninstead of analyzing and evaluating expressions manually. In effect, the calculator runs\nembedded Python code from a Python program. This works because Python\u2019s devel-\nopment environment (the parser and bytecode compiler) is always a part of systems\nthat use Python. Because there is no difference between the development and the de-\nlivery environments, Python\u2019s parser can be used by Python programs.\nThe net effect here is that the entire expression evaluator has been replaced with a single\ncall to eval or exec. In broader terms, this is a powerful technique to remember: the\nPython language itself can replace many small, custom languages. Besides saving de-\nvelopment time, clients have to learn just one language, one that\u2019s potentially simple\nenough for end-user coding.\nFurthermore, Python can take on the flavor of any application. If a language interface\nrequires application-specific extensions, just add Python classes, or export an API for\nuse in embedded Python code as a C extension. By evaluating Python code that uses\napplication-specific extensions, custom parsers become almost completely\nunnecessary.\nThere\u2019s also a critical added benefit to this approach: embedded Python code has access\nto all the tools and features of a powerful, full-blown programming language. It can\nuse lists, functions, classes, external modules, and even larger Python tools like tkinter\nGUIs, shelve storage, multiple threads, network sockets, and web page fetches. You\u2019d\nprobably spend years trying to provide similar functionality in a custom language\nparser. Just ask Guido.\nRunning code strings\nThis module implements a GUI calculator in some 45 lines of code (counting comments\nand blank lines). But truthfully, it \u201ccheats.\u201d Expression evaluation is delegated entirely\nto Python. In fact, the built-in eval and exec tools do most of the work here:\n1460 | Chapter 19:\u2002Text and Languageeval\nParses, evaluates, and returns the result of a Python expression represented as a\nstring.\nexec\nRuns an arbitrary Python statement represented as a string, and has no return value.\nBoth accept optional dictionaries to be used as global and local namespaces for assign-\ning and evaluating names used in the code strings. In the calculator, self.names be-\ncomes a symbol table for running calculator expressions. A related Python function,\ncompile, can be used to precompile code strings to code objects before passing them to\neval and exec (use it if you need to run the same string many times).\nBy default, a code string\u2019s namespace defaults to the caller\u2019s namespaces. If we didn\u2019t\npass in dictionaries here, the strings would run in the eval method\u2019s namespace. Since\nthe method\u2019s local namespace goes away after the method call returns, there would be\nno way to retain names assigned in the string. Notice the use of nested exception han-\ndlers in the class\u2019s eval method:\n1. It first assumes the string is an expression and tries the built-in eval function.\n2. If that fails because of a syntax error, it tries evaluating the string as a statement\nusing exec.\n3. Finally, if both attempts fail, it reports an error in the string (a syntax error, unde-\nfined name, and so on).\nStatements and invalid expressions might be parsed twice, but the overhead doesn\u2019t\nmatter here, and you can\u2019t tell whether a string is an expression or a statement without\nparsing it manually. Note that the \u201ceval\u201d button evaluates expressions, but = sets Python\nvariables by running an assignment statement. Variable names are combinations of the\nletter keys \u201cabcd\u201d (or any name typed directly). They are assigned and evaluated in a\ndictionary used to represent the calculator\u2019s namespace and retained for the session.\nExtending and attaching\nClients that reuse this calculator are as simple as the calculator itself. Like most class-\nbased tkinter GUIs, this one can be extended in subclasses\u2014Example 19-18 customizes\nthe simple calculator\u2019s constructor to add extra widgets.\nExample 19-18. PP4E\\Lang\\Calculator\\calc0ext.py\nfrom tkinter import *\nfrom calc0 import CalcGui\nclass Inner(CalcGui):                                          # extend GUI\n    def __init__(self):\n        CalcGui.__init__(self)\n        Label(self,  text='Calc Subclass').pack()              # add after\n        Button(self, text='Quit', command=self.quit).pack()    # top implied\nPyCalc: A Calculator Program/Object | 1461Inner().mainloop()\nIt can also be embedded in a container class\u2014Example 19-19 attaches the simple cal-\nculator\u2019s widget package, along with extras, to a common parent.\nExample 19-19. PP4E\\Lang\\Calculator\\calc0emb.py\nfrom tkinter import *\nfrom calc0 import CalcGui                       # add parent, no master calls\nclass Outer:\n    def __init__(self, parent):                               # embed GUI\n        Label(parent, text='Calc Attachment').pack()          # side=top\n        CalcGui(parent)                                       # add calc frame\n        Button(parent, text='Quit', command=parent.quit).pack()\nroot = Tk()\nOuter(root)\nroot.mainloop()\nFigure 19-3 shows the result of running both of these scripts from different command\nlines. Both have a distinct input field at the top. This works, but to see a more practical\napplication of such reuse techniques, we need to make the underlying calculator more\npractical, too.\nFigure 19-3. The calc0 script\u2019s object attached and extended\n1462 | Chapter 19:\u2002Text and LanguagePyCalc\u2014A \u201cReal\u201d Calculator GUI\nOf course, real calculators don\u2019t usually work by building up expression strings and\nevaluating them all at once; that approach is really little more than a glorified Python\ncommand line. Traditionally, expressions are evaluated in piecemeal fashion as they\nare entered, and temporary results are displayed as soon as they are computed. Imple-\nmenting this behavior requires a bit more work: expressions must be evaluated man-\nually and in parts, instead of calling the eval function only once. But the end result is\nmuch more useful and intuitive.\nLesson 5: Reusability Is Power\nThough simple, attaching and subclassing the calculator graphically, as shown in Fig-\nure 19-3, illustrates the power of Python as a tool for writing reusable software. By\ncoding programs with modules and classes, components written in isolation almost\nautomatically become general-purpose tools. Python\u2019s program organization features\npromote reusable code.\nIn fact, code reuse is one of Python\u2019s major strengths and has been one of the main\nthemes of this book. Good object-oriented design takes some practice and forethought,\nand the benefits of code reuse aren\u2019t apparent immediately. And sometimes we have\ngood cause to be more interested in a quick fix rather than a future use for the code.\nBut coding with some reusability in mind can save development time in the long run.\nFor instance, the handcoded custom parsers shared a scanner, the calculator GUI uses\nthe widgets module from Chapter 10 we discussed earlier, and the next section will\nreuse the GuiMixin class from Chapter 10 as well. Sometimes we\u2019re able to finish part\nof a job before we start.\nThis section presents the implementation of PyCalc, a more realistic Python/tkinter\nprogram that implements such a traditional calculator GUI. It touches on the subject\nof text and languages in two ways: it parses and evaluates expressions, and it imple-\nments a kind of stack-based language to perform the evaluation. Although its evaluation\nlogic is more complex than the simpler calculator shown earlier, it demonstrates ad-\nvanced programming techniques and serves as an interesting finale for this chapter.\nRunning PyCalc\nAs usual, let\u2019s look at the GUI before the code. You can run PyCalc from the PyGadgets\nand PyDemos launcher bars at the top of the examples tree, or by directly running the\nfile calculator.py listed shortly (e.g., click it in a file explorer, or type it in a shell com-\nmand line). Figure 19-4 shows PyCalc\u2019s main window. By default, it shows operand\nbuttons in black-on-blue (and opposite for operator buttons), but font and color op-\ntions can be passed into the GUI class\u2019s constructor method. Of course, that means\ngray-on-gray in this book, so you\u2019ll have to run PyCalc yourself to see what I mean.\nPyCalc: A Calculator Program/Object | 1463Figure 19-4. PyCalc calculator at work on Windows 7\nIf you do run this, you\u2019ll notice that PyCalc implements a normal calculator model\u2014\nexpressions are evaluated as entered, not all at once at the end. That is, parts of an\nexpression are computed and displayed as soon as operator precedence and manually\ntyped parentheses allow. The result in Figure 19-4, for instance, reflects pressing \u201c2\u201d,\nand then repeatedly pressing \u201c*\u201d to display successive powers of 2. I\u2019ll explain how this\nevaluation works in a moment.\nPyCalc\u2019s CalcGui class builds the GUI interface as frames of buttons much like the\nsimple calculator of the previous section, but PyCalc adds a host of new features.\nAmong them are another row of action buttons, inherited methods from GuiMixin\n(presented in Chapter 10), a new \u201ccmd\u201d button that pops up nonmodal dialogs for\nentry of arbitrary Python code, and a recent calculations history pop up. Figure 19-5\ncaptures some of PyCalc\u2019s pop-up windows.\nYou may enter expressions in PyCalc by clicking buttons in the GUI, typing full ex-\npressions in command-line pop ups, or typing keys on your keyboard. PyCalc intercepts\nkey press events and interprets them the same as corresponding button presses; typing\n+ is like pressing the + button, the Space bar key is \u201cclear,\u201d Enter is \u201ceval,\u201d backspace\nerases a character, and ? is like pressing \u201chelp.\u201d\nThe command-line pop-up windows are nonmodal (you can pop up as many as you\nlike). They accept any Python code\u2014press the Run button or your Enter key to evaluate\ntext in their input fields. The result of evaluating this code in the calculator\u2019s namespace\n1464 | Chapter 19:\u2002Text and Languagedictionary is thrown up in the main window for use in larger expressions. You can use\nthis as an escape mechanism to employ external tools in your calculations. For instance,\nyou can import and use functions coded in Python or C within these pop ups. The\ncurrent value in the main calculator window is stored in newly opened command-line\npop ups, too, for use in typed expressions.\nPyCalc supports integers (unlimited precision), negatives, and floating-point numbers\njust because Python does. Individual operands and expressions are still evaluated with\nthe eval built-in, which calls the Python parser/interpreter at runtime. Variable names\ncan be assigned and referenced in the main window with the letter, =, and \u201ceval\u201d keys;\nthey are assigned in the calculator\u2019s namespace dictionary (more complex variable\nnames may be typed in command-line pop ups). Note the use of pi in the history\nwindow: PyCalc preimports names in the math and random modules into the namespace\nwhere expressions are evaluated.\nEvaluating expressions with stacks\nNow that you have the general idea of what PyCalc does, I need to say a little bit about\nhow it does what it does. Most of the changes in this calculator involve managing the\nexpression display and evaluating expressions. PyCalc is structured as two classes:\nThe CalcGui class\nManages the GUI itself. It controls input events and is in charge of the main win-\ndow\u2019s display field at the top. It doesn\u2019t evaluate expressions, though; for that, it\nFigure 19-5. PyCalc calculator with some of its pop ups\nPyCalc: A Calculator Program/Object | 1465sends operators and operands entered in the GUI to an embedded instance of the\nEvaluator class.\nThe Evaluator class\nManages two stacks. One stack records pending operators (e.g., +), and one records\npending operands (e.g., 3.141). Temporary results are computed as new operators\nare sent from CalcGui and pushed onto the operands stack.\nAs you can see from this, the magic of expression evaluation boils down to juggling the\noperator and operand stacks. In a sense, the calculator implements a little stack-based\nlanguage, to evaluate the expressions being entered. While scanning expression strings\nfrom left to right as they are entered, operands are pushed along the way, but operators\ndelimit operands and may trigger temporary results before they are pushed. Because it\nrecords states and performs transitions, some might use the term state machine to de-\nscribe this calculator language implementation.\nHere\u2019s the general scenario:\n1. When a new operator is seen (i.e., when an operator button or key is pressed), the\nprior operand in the entry field is pushed onto the operands stack.\n2. The operator is then added to the operators stack, but only after all pending op-\nerators of higher precedence have been popped and applied to pending operands\n(e.g., pressing + makes any pending * operators on the stack fire).\n3. When \u201ceval\u201d is pressed, all remaining operators are popped and applied to all\nremaining operands, and the result is the last remaining value on the operands\nstack.\nIn the end, the last value on the operands stack is displayed in the calculator\u2019s entry\nfield, ready for use in another operation. This evaluation algorithm is probably best\ndescribed by working through examples. Let\u2019s step through the entry of a few expres-\nsions and watch the evaluation stacks grow.\nPyCalc stack tracing is enabled with the debugme flag in the module; if true, the operator\nand operand stacks are displayed on stdout each time the Evaluator class is about to\napply an operator and reduce (pop) the stacks. Run PyCalc with a console window to\nsee the traces. A tuple holding the stack lists (operators , operands) is printed on each\nstack reduction; tops of stacks are at the ends of the lists. For instance, here is the\nconsole output after typing and evaluating a simple string:\n1) Entered keys: \"5 * 3 + 4 <eval>\" [result = 19]\n(['*'], ['5', '3'])    [on '+' press: displays \"15\"]\n(['+'], ['15', '4'])   [on 'eval' press: displays \"19\"]\nNote that the pending (stacked) * subexpression is evaluated when the + is pressed: *\noperators bind tighter than +, so the code is evaluated immediately before the + operator\nis pushed. When the + button is pressed, the entry field contains 3; we push 3 onto the\noperands stack, reduce the * subexpression (5 * 3), push its result onto operands, push\n1466 | Chapter 19:\u2002Text and Language+ onto operators, and continue scanning user inputs. When \u201ceval\u201d is pressed at the end,\n4 is pushed onto operands, and the final + on operators is applied to stacked operands.\nThe text input and display field at the top of the GUI\u2019s main window plays a part in\nthis algorithm, too. The text input field and expression stacks are integrated by the\ncalculator class. In general, the text input field always holds the prior operand when\nan operator button is pressed (e.g., on 5 *); the text in the input field is pushed onto\nthe operands stack before the operator is resolved. Because of this, we have to pop\nresults before displaying them after \u201ceval\u201d or ) is pressed; otherwise the results are\npushed onto the stack twice\u2014they would be both on the stack and in the display field,\nfrom which they would be immediately pushed again when the next operator is input.\nFor both usability and accuracy, when an operator is seen, we also have to arrange to\nerase the input field\u2019s prior value when the next operand\u2019s entry is started (e.g., on both\n3 and 4 in 5 * 3 + 4). This erasure of the prior values is also arranged when \u201ceval\u201d\nor ) is applied, on the assumption that a subsequent operand key or button replaces\nthe prior result\u2014for a new expression after \u201ceval,\u201d and for an operand following a new\noperator after ); e.g., to erase the parenthesized 12 result on 2 in 5 + (3 * 4) * 2.\nWithout this erasure, operand buttons and keys simply concatenate to the currently\ndisplayed value. This model also allows user to change temporary result operands after\na ) by entry of operand instead of operator.\nExpression stacks also defer operations of lower precedence as the input is scanned. In\nthe next trace, the pending + isn\u2019t evaluated when the * button is pressed: since * binds\ntighter, we need to postpone the + until the * can be evaluated. The * operator isn\u2019t\npopped until its right operand 4 has been seen. There are two operators to pop and\napply to operand stack entries on the \u201ceval\u201d press\u2014the * at the top of operators is\napplied to the 3 and 4 at the top of operands, and then + is run on 5 and the 12 pushed\nfor *:\n2) Entered keys: \"5 + 3 * 4 <eval>\" [result = 17]\n(['+', '*'], ['5', '3', '4'])   [on 'eval' press]\n(['+'], ['5', '12'])            [displays \"17\"]\nFor strings of same-precedence operators such as the following, we pop and evaluate\nimmediately as we scan left to right, instead of postponing evaluation. This results in\na left-associative evaluation, in the absence of parentheses: 5+3+4 is evaluated as\n((5+3)+4). For + and * operations this is irrelevant because order doesn\u2019t matter:\n3) Entered keys: \"5 + 3 + 4 <eval>\" [result = 12]\n(['+'], ['5', '3'])     [on the second '+']\n(['+'], ['8', '4'])     [on 'eval']\nThe following trace is more complex. In this case, all the operators and operands are\nstacked (postponed) until we press the ) button at the end. To make parentheses work,\n( is given a higher precedence than any operator and is pushed onto the operators stack\nto seal off lower stack reductions until the ) is seen. When the ) button is pressed, the\nPyCalc: A Calculator Program/Object | 1467parenthesized subexpression is popped and evaluated ((3 * 4), then (1 + 12)), and 13\nis displayed in the entry field. On pressing \u201ceval,\u201d the rest is evaluated ((3 * 13), (1 +39)),\nand the final result (40) is shown. This result in the entry field itself becomes the left\noperand of a future operator.\n4) Entered keys: \"1 + 3 * ( 1 + 3 * 4 ) <eval>\" [result = 40]\n(['+', '*', '(', '+', '*'], ['1', '3', '1', '3', '4'])    [on ')']\n(['+', '*', '(', '+'], ['1', '3', '1', '12'])             [displays \"13\"]\n(['+', '*'], ['1', '3', '13'])                            [on 'eval']\n(['+'], ['1', '39'])\nIn fact, any temporary result can be used again: if we keep pressing an operator button\nwithout typing new operands, it\u2019s reapplied to the result of the prior press\u2014the value\nin the entry field is pushed twice and applied to itself each time. Press * many times\nafter entering 2 to see how this works (e.g., 2***). On the first *, it pushes 2 and the\n*. On the next *, it pushes 2 again from the entry field, pops and evaluates the stacked\n(2 * 2), pushes back and displays the result, and pushes the new *. And on each following\n*, it pushes the currently displayed result and evaluates again, computing successive\nsquares.\nFigure 19-6 shows how the two stacks look at their highest level while scanning the\nexpression in the prior example trace. On each reduction, the top operator is applied\nto the top two operands and the result is pushed back for the operator below. Because\nof the way the two stacks are used, the effect is similar to converting the expression to\na string of the form +1*3(+1*34 and evaluating it right to left. In other cases, though,\nparts of the expression are evaluated and displayed as temporary results along the way,\nso it\u2019s not simply a string conversion process.\nFigure 19-6. Evaluation stacks: 1 + 3 * (1 + 3 * 4)\nFinally, the next example\u2019s string triggers an error. PyCalc is casual about error han-\ndling. Many errors are made impossible by the algorithm itself, but things such as\nunmatched parentheses still trip up the evaluator. Instead of trying to detect all possible\nerror cases explicitly, a general try statement in the reduce method is used to catch\nthem all: expression errors, numeric errors, undefined name errors, syntax errors, and\nso on.\n1468 | Chapter 19:\u2002Text and LanguageOperands and temporary results are always stacked as strings, and each operator is\napplied by calling eval. When an error occurs inside an expression, a result operand of\n*ERROR* is pushed, which makes all remaining operators fail in eval too. *ERROR* es-\nsentially percolates to the top of the expression. At the end, it\u2019s the last operand and is\ndisplayed in the text entry field to alert you of the mistake:\n5) Entered keys: \"1 + 3 * ( 1 + 3 * 4 <eval>\" [result = *ERROR*]\n(['+', '*', '(', '+', '*'], ['1', '3', '1', '3', '4'])      [on eval]\n(['+', '*', '(', '+'], ['1', '3', '1', '12'])\n(['+', '*', '('], ['1', '3', '13'])\n(['+', '*'], ['1', '*ERROR*'])\n(['+'], ['*ERROR*'])\n(['+'], ['*ERROR*', '*ERROR*'])\nTry tracing through these and other examples in the calculator\u2019s code to get a feel for\nthe stack-based evaluation that occurs. Once you understand the general shift/reduce\n(push/pop) mechanism, expression evaluation is straightforward.\nPyCalc source code\nExample 19-20 contains the PyCalc source module that puts these ideas to work in the\ncontext of a GUI. It\u2019s a single-file implementation (not counting utilities imported and\nreused). Study the source for more details; as usual, there\u2019s no substitute for interacting\nwith the program on your own to get a better feel for its functionality.\nAlso see the opening comment\u2019s \u201cto do\u201d list for suggested areas for improvement. Like\nall software systems, this calculator is prone to evolve over time (and in fact it has, with\neach new edition of this book). Since it is written in Python, such future mutations will\nbe easy to apply.\nExample 19-20. PP4E\\Lang\\Calculator\\calculator.py\n#!/usr/local/bin/python\n\"\"\"\n################################################################################\nPyCalc 3.0+: a Python/tkinter calculator program and GUI component.\nEvaluates expressions as they are entered, catches keyboard keys for\nexpression entry; 2.0 added integrated command-line popups, a recent\ncalculations history display popup, fonts and colors configuration,\nhelp and about popups, preimported math/random constants, and more;\n3.0+ (PP4E, version number retained):\n-port to run under Python 3.X (only)\n-drop 'L' keypress (the long type is now dead in earnest)\n3.0 changes (PP3E):\n-use 'readonly' entry state, not 'disabled', else field is greyed\n out (fix for 2.3 Tkinter change);\n-avoid extended display precision for floats by using str(), instead\n of `x`/repr() (fix for Python change);\nPyCalc: A Calculator Program/Object | 1469-apply font to input field to make it larger;\n-use justify=right for input field so it displays on right, not left;\n-add 'E+' and 'E-' buttons (and 'E' keypress) for float exponents;\n 'E' keypress must generally be followed digits, not + or - optr key;\n-remove 'L' button (but still allow 'L' keypress): superfluous now,\n because Python auto converts up if too big ('L' forced this in past);\n-use smaller font size overall;\n-auto scroll to the end in the history window\nto do: add a commas-insertion mode (see str.format and LP4E example);\nallow '**' as an operator key; allow '+' and 'J' inputs for complex\nNumbers; use new decimal type for fixed precision floats; as is, can\nuse 'cmd' popup windows to input and evaluate things like complex, but\ncan't be input via main window; caveat: PyCalc's precision, accuracy,\nand some of its behaviour, is currently bound by result of str() call;\n################################################################################\n\"\"\"\nfrom tkinter import *                                            # widgets, consts\nfrom PP4E.Gui.Tools.guimixin import GuiMixin                     # quit method\nfrom PP4E.Gui.Tools.widgets import label, entry, button, frame   # widget builders\nFg, Bg, Font = 'black', 'skyblue', ('courier', 14, 'bold')       # default config\ndebugme = True\ndef trace(*args):\n    if debugme: print(args)\n################################################################################\n# the main class - handles user interface;\n# an extended Frame, on new Toplevel, or embedded in another container widget\n################################################################################\nclass CalcGui(GuiMixin, Frame):\n    Operators = \"+-*/=\"                              # button lists\n    Operands  = [\"abcd\", \"0123\", \"4567\", \"89()\"]     # customizable\n    def __init__(self, parent=None, fg=Fg, bg=Bg, font=Font):\n        Frame.__init__(self, parent)\n        self.pack(expand=YES, fill=BOTH)             # all parts expandable\n        self.eval = Evaluator()                      # embed a stack handler\n        self.text = StringVar()                      # make a linked variable\n        self.text.set(\"0\")\n        self.erase = 1                               # clear \"0\" text next\n        self.makeWidgets(fg, bg, font)               # build the GUI itself\n        if not parent or not isinstance(parent, Frame):\n            self.master.title('PyCalc 3.0')          # title iff owns window\n            self.master.iconname(\"PyCalc\")           # ditto for key bindings\n            self.master.bind('<KeyPress>', self.onKeyboard)\n            self.entry.config(state='readonly')      # 3.0: not 'disabled'=grey\n        else:\n            self.entry.config(state='normal')\n            self.entry.focus()\n    def makeWidgets(self, fg, bg, font):             # 7 frames plus text-entry\n1470 | Chapter 19:\u2002Text and Languageself.entry = entry(self, TOP, self.text)     # font, color configurable\n        self.entry.config(font=font)                 # 3.0: make display larger\n        self.entry.config(justify=RIGHT)             # 3.0: on right, not left\n        for row in self.Operands:\n            frm = frame(self, TOP)\n            for char in row:\n                button(frm, LEFT, char,\n                            lambda op=char: self.onOperand(op),\n                            fg=fg, bg=bg, font=font)\n        frm = frame(self, TOP)\n        for char in self.Operators:\n            button(frm, LEFT, char,\n                        lambda op=char: self.onOperator(op),\n                        fg=bg, bg=fg, font=font)\n        frm = frame(self, TOP)\n        button(frm, LEFT, 'dot ', lambda: self.onOperand('.'))\n        button(frm, LEFT, ' E+ ', lambda: self.text.set(self.text.get()+'E+'))\n        button(frm, LEFT, ' E- ', lambda: self.text.set(self.text.get()+'E-'))\n        button(frm, LEFT, 'cmd ', self.onMakeCmdline)\n        button(frm, LEFT, 'help', self.help)\n        button(frm, LEFT, 'quit', self.quit)       # from guimixin\n        frm = frame(self, BOTTOM)\n        button(frm, LEFT, 'eval ', self.onEval)\n        button(frm, LEFT, 'hist ', self.onHist)\n        button(frm, LEFT, 'clear', self.onClear)\n    def onClear(self):\n        self.eval.clear()\n        self.text.set('0')\n        self.erase = 1\n    def onEval(self):\n        self.eval.shiftOpnd(self.text.get())     # last or only opnd\n        self.eval.closeall()                     # apply all optrs left\n        self.text.set(self.eval.popOpnd())       # need to pop: optr next?\n        self.erase = 1\n    def onOperand(self, char):\n        if char == '(':\n            self.eval.open()\n            self.text.set('(')                      # clear text next\n            self.erase = 1\n        elif char == ')':\n            self.eval.shiftOpnd(self.text.get())    # last or only nested opnd\n            self.eval.close()                       # pop here too: optr next?\n            self.text.set(self.eval.popOpnd())\n            self.erase = 1\n        else:\n            if self.erase:\n                self.text.set(char)                     # clears last value\n            else:\n                self.text.set(self.text.get() + char)   # else append to opnd\nPyCalc: A Calculator Program/Object | 1471self.erase = 0\n    def onOperator(self, char):\n        self.eval.shiftOpnd(self.text.get())    # push opnd on left\n        self.eval.shiftOptr(char)               # eval exprs to left?\n        self.text.set(self.eval.topOpnd())      # push optr, show opnd|result\n        self.erase = 1                          # erased on next opnd|'('\n    def onMakeCmdline(self):\n        new = Toplevel()                            # new top-level window\n        new.title('PyCalc command line')            # arbitrary Python code\n        frm = frame(new, TOP)                       # only the Entry expands\n        label(frm, LEFT, '>>>').pack(expand=NO)\n        var = StringVar()\n        ent = entry(frm, LEFT, var, width=40)\n        onButton = (lambda: self.onCmdline(var, ent))\n        onReturn = (lambda event: self.onCmdline(var, ent))\n        button(frm, RIGHT, 'Run', onButton).pack(expand=NO)\n        ent.bind('<Return>', onReturn)\n        var.set(self.text.get())\n    def onCmdline(self, var, ent):            # eval cmdline pop-up input\n        try:\n            value = self.eval.runstring(var.get())\n            var.set('OKAY')\n            if value != None:                 # run in eval namespace dict\n                self.text.set(value)          # expression or statement\n                self.erase = 1\n                var.set('OKAY => '+ value)\n        except:                               # result in calc field\n            var.set('ERROR')                  # status in pop-up field\n        ent.icursor(END)                      # insert point after text\n        ent.select_range(0, END)              # select msg so next key deletes\n    def onKeyboard(self, event):\n        pressed = event.char                  # on keyboard press event\n        if pressed != '':                     # pretend button was pressed\n            if pressed in self.Operators:\n                self.onOperator(pressed)\n            else:\n                for row in self.Operands:\n                    if pressed in row:\n                        self.onOperand(pressed)\n                        break\n                else:                                          # 4E: drop 'Ll'\n                    if pressed == '.':\n                        self.onOperand(pressed)                # can start opnd\n                    if pressed in 'Ee':  # 2e10, no +/-\n                        self.text.set(self.text.get()+pressed) # can't: no erase\n                    elif pressed == '\\r':\n                        self.onEval()                          # enter key=eval\n                    elif pressed == ' ':\n                        self.onClear()                         # spacebar=clear\n                    elif pressed == '\\b':\n                        self.text.set(self.text.get()[:-1])    # backspace\n1472 | Chapter 19:\u2002Text and Languageelif pressed == '?':\n                        self.help()\n    def onHist(self):\n        # show recent calcs log popup\n        from tkinter.scrolledtext import ScrolledText     # or PP4E.Gui.Tour\n        new = Toplevel()                                  # make new window\n        ok = Button(new, text=\"OK\", command=new.destroy)\n        ok.pack(pady=1, side=BOTTOM)                      # pack first=clip last\n        text = ScrolledText(new, bg='beige')              # add Text + scrollbar\n        text.insert('0.0', self.eval.getHist())           # get Evaluator text\n        text.see(END)                                     # 3.0: scroll to end\n        text.pack(expand=YES, fill=BOTH)\n        # new window goes away on ok press or enter key\n        new.title(\"PyCalc History\")\n        new.bind(\"<Return>\", (lambda event: new.destroy()))\n        ok.focus_set()                      # make new window modal:\n        new.grab_set()                      # get keyboard focus, grab app\n        new.wait_window()                   # don't return till new.destroy\n    def help(self):\n        self.infobox('PyCalc', 'PyCalc 3.0+\\n'\n                               'A Python/tkinter calculator\\n'\n                               'Programming Python 4E\\n'\n                               'May, 2010\\n'\n                               '(3.0 2005, 2.0 1999, 1.0 1996)\\n\\n'\n                               'Use mouse or keyboard to\\n'\n                               'input numbers and operators,\\n'\n                               'or type code in cmd popup')\n################################################################################\n# the expression evaluator class\n# embedded in and used by a CalcGui instance, to perform calculations\n################################################################################\nclass Evaluator:\n    def __init__(self):\n        self.names = {}                         # a names-space for my vars\n        self.opnd, self.optr = [], []           # two empty stacks\n        self.hist = []                          # my prev calcs history log\n        self.runstring(\"from math import *\")    # preimport math modules\n        self.runstring(\"from random import *\")  # into calc's namespace\n    def clear(self):\n        self.opnd, self.optr = [], []           # leave names intact\n        if len(self.hist) > 64:                 # don't let hist get too big\n            self.hist = ['clear']\n        else:\n            self.hist.append('--clear--')\n    def popOpnd(self):\n        value = self.opnd[-1]                   # pop/return top|last opnd\n        self.opnd[-1:] = []                     # to display and shift next\nPyCalc: A Calculator Program/Object | 1473return value                            # or x.pop(), or del x[-1]\n    def topOpnd(self):\n        return self.opnd[-1]                    # top operand (end of list)\n    def open(self):\n        self.optr.append('(')                   # treat '(' like an operator\n    def close(self):                            # on ')' pop downto highest '('\n        self.shiftOptr(')')                     # ok if empty: stays empty\n        self.optr[-2:] = []                     # pop, or added again by optr\n    def closeall(self):\n        while self.optr:                        # force rest on 'eval'\n            self.reduce()                       # last may be a var name\n        try:\n            self.opnd[0] = self.runstring(self.opnd[0])\n        except:\n            self.opnd[0] = '*ERROR*'            # pop else added again next:\n    afterMe = {'*': ['+', '-', '(', '='],       # class member\n               '/': ['+', '-', '(', '='],       # optrs to not pop for key\n               '+': ['(', '='],                 # if prior optr is this: push\n               '-': ['(', '='],                 # else: pop/eval prior optr\n               ')': ['(', '='],                 # all left-associative as is\n               '=': ['('] }\n    def shiftOpnd(self, newopnd):               # push opnd at optr, ')', eval\n        self.opnd.append(newopnd)\n    def shiftOptr(self, newoptr):               # apply ops with <= priority\n        while (self.optr and\n               self.optr[-1] not in self.afterMe[newoptr]):\n            self.reduce()\n        self.optr.append(newoptr)               # push this op above result\n                                                # optrs assume next opnd erases\n    def reduce(self):\n        trace(self.optr, self.opnd)\n        try:                                    # collapse the top expr\n            operator       = self.optr[-1]      # pop top optr (at end)\n            [left, right]  = self.opnd[-2:]     # pop top 2 opnds (at end)\n            self.optr[-1:] = []                 # delete slice in-place\n            self.opnd[-2:] = []\n            result = self.runstring(left + operator + right)\n            if result == None:\n                result = left                   # assignment? key var name\n            self.opnd.append(result)            # push result string back\n        except:\n            self.opnd.append('*ERROR*')         # stack/number/name error\n    def runstring(self, code):\n        try:                                                  # 3.0: not `x`/repr\n            result = str(eval(code, self.names, self.names))  # try expr: string\n            self.hist.append(code + ' => ' + result)          # add to hist log\n        except:\n1474 | Chapter 19:\u2002Text and Languageexec(code, self.names, self.names)                # try stmt: None\n            self.hist.append(code)\n            result = None\n        return result\n    def getHist(self):\n        return '\\n'.join(self.hist)\ndef getCalcArgs():\n    from sys import argv                   # get cmdline args in a dict\n    config = {}                            # ex: -bg black -fg red\n    for arg in argv[1:]:                   # font not yet supported\n        if arg in ['-bg', '-fg']:          # -bg red' -> {'bg':'red'}\n            try:\n                config[arg[1:]] = argv[argv.index(arg) + 1]\n            except:\n                pass\n    return config\nif __name__ == '__main__':\n    CalcGui(**getCalcArgs()).mainloop()    # in default toplevel window\nUsing PyCalc as a component\nPyCalc serves a standalone program on my desktop, but it\u2019s also useful in the context\nof other GUIs. Like most of the GUI classes in this book, PyCalc can be customized\nwith subclass extensions or embedded in a larger GUI with attachments. The module\nin Example 19-21 demonstrates one way to reuse PyCalc\u2019s CalcGui class by extending\nand embedding, similar to what was done for the simple calculator earlier.\nExample 19-21. PP4E\\Lang\\Calculator\\calculator_test.py\n\"\"\"\ntest calculator: use as an extended and embedded GUI component\n\"\"\"\nfrom tkinter import *\nfrom calculator import CalcGui\ndef calcContainer(parent=None):\n    frm = Frame(parent)\n    frm.pack(expand=YES, fill=BOTH)\n    Label(frm, text='Calc Container').pack(side=TOP)\n    CalcGui(frm)\n    Label(frm, text='Calc Container').pack(side=BOTTOM)\n    return frm\nclass calcSubclass(CalcGui):\n    def makeWidgets(self, fg, bg, font):\n        Label(self, text='Calc Subclass').pack(side=TOP)\n        Label(self, text='Calc Subclass').pack(side=BOTTOM)\n        CalcGui.makeWidgets(self, fg, bg, font)\n        #Label(self, text='Calc Subclass').pack(side=BOTTOM)\nPyCalc: A Calculator Program/Object | 1475if __name__ == '__main__':\n    import sys\n    if len(sys.argv) == 1:              # % calculator_test.py\n        root = Tk()                     # run 3 calcs in same process\n        CalcGui(Toplevel())             # each in a new toplevel window\n        calcContainer(Toplevel())\n        calcSubclass(Toplevel())\n        Button(root, text='quit', command=root.quit).pack()\n        root.mainloop()\n    if len(sys.argv) == 2:              # % calculator_testl.py -\n        CalcGui().mainloop()            # as a standalone window (default root)\n    elif len(sys.argv) == 3:            # % calculator_test.py - -\n        calcContainer().mainloop()      # as an embedded component\n    elif len(sys.argv) == 4:            # % calculator_test.py - - -\n        calcSubclass().mainloop()       # as a customized superclass\nFigure 19-7 shows the result of running this script with no command-line arguments.\nWe get instances of the original calculator class, plus the container and subclass classes\ndefined in this script, all attached to new top-level windows.\nFigure 19-7. The calculator_test script: attaching and extending\nThese two windows on the right reuse the core PyCalc code running in the window on\nthe left. All of these windows run in the same process (e.g., quitting one quits them all),\nbut they all function as independent windows. Note that when running three calcula-\ntors in the same process like this, each has its own distinct expression evaluation name-\nspace because it\u2019s a class instance attribute, not a global module-level variable. Because\nof that, variables set in one calculator are set in that calculator only, and they don\u2019t\noverwrite settings made in other windows. Similarly, each calculator has its own eval-\nuation stack manager object, such that calculations in one window don\u2019t appear in or\nimpact other windows at all.\n1476 | Chapter 19:\u2002Text and LanguageThe two extensions in this script are artificial, of course\u2014they simply add labels at the\ntop and bottom of the window\u2014but the concept is widely applicable. You could reuse\nthe calculator\u2019s class by attaching it to any GUI that needs a calculator and customize\nit with subclasses arbitrarily. It\u2019s a reusable widget.\nAdding new buttons in new components\nOne obvious way to reuse the calculator is to add additional expression feature\nbuttons\u2014square roots, inverses, cubes, and the like. You can type such operations in\nthe command-line pop ups, but buttons are a bit more convenient. Such features could\nalso be added to the main calculator implementation itself, but since the set of features\nthat will be useful may vary per user and application, a better approach may be to add\nthem in separate extensions. For instance, the class in Example 19-22 adds a few extra\nbuttons to PyCalc by embedding (i.e., attaching) it in a container.\nExample 19-22. PP4E\\Lang\\Calculator\\calculator_plus_emb.py\n\"\"\"\n#############################################################################\na container with an extra row of buttons for common operations;\na more useful customization: adds buttons for more operations (sqrt,\n1/x, etc.) by embedding/composition, not subclassing; new buttons are\nadded after entire CalGui frame because of the packing order/options;\n#############################################################################\n\"\"\"\nfrom tkinter import *\nfrom calculator import CalcGui, getCalcArgs\nfrom PP4E.Gui.Tools.widgets import frame, button, label\nclass CalcGuiPlus(Toplevel):\n    def __init__(self, **args):\n        Toplevel.__init__(self)\n        label(self, TOP, 'PyCalc Plus - Container')\n        self.calc = CalcGui(self, **args)\n        frm = frame(self, BOTTOM)\n        extras = [('sqrt', 'sqrt(%s)'),\n                  ('x^2 ',  '(%s)**2'),\n                  ('x^3 ',  '(%s)**3'),\n                  ('1/x ',  '1.0/(%s)')]\n        for (lab, expr) in extras:\n            button(frm, LEFT, lab, (lambda expr=expr: self.onExtra(expr)))\n        button(frm, LEFT, ' pi ', self.onPi)\n    def onExtra(self, expr):\n        text = self.calc.text\n        eval = self.calc.eval\n        try:\n            text.set(eval.runstring(expr % text.get()))\n        except:\n            text.set('ERROR')\nPyCalc: A Calculator Program/Object | 1477def onPi(self):\n        self.calc.text.set(self.calc.eval.runstring('pi'))\nif __name__ == '__main__':\n    root = Tk()\n    button(root, TOP, 'Quit', root.quit)\n    CalcGuiPlus(**getCalcArgs()).mainloop()       # -bg,-fg to calcgui\nBecause PyCalc is coded as a Python class, you can always achieve a similar effect by\nextending PyCalc in a new subclass instead of embedding it, as shown in\nExample 19-23.\nExample 19-23. PP4E\\Lang\\Calculator\\calculator_plus_ext.py\n\"\"\"\n#############################################################################\na customization with an extra row of buttons for common operations;\na more useful customization: adds buttons for more operations (sqrt,\n1/x, etc.) by subclassing to extend the original class, not embedding;\nnew buttons show up before frame attached to bottom by calcgui class;\n#############################################################################\n\"\"\"\nfrom tkinter import *\nfrom calculator import CalcGui, getCalcArgs\nfrom PP4E.Gui.Tools.widgets import label, frame, button\nclass CalcGuiPlus(CalcGui):\n    def makeWidgets(self, *args):\n        label(self, TOP, 'PyCalc Plus - Subclass')\n        CalcGui.makeWidgets(self, *args)\n        frm = frame(self, BOTTOM)\n        extras = [('sqrt', 'sqrt(%s)'),\n                  ('x^2 ', '(%s)**2'),\n                  ('x^3 ', '(%s)**3'),\n                  ('1/x ', '1.0/(%s)')]\n        for (lab, expr) in extras:\n            button(frm, LEFT, lab, (lambda expr=expr: self.onExtra(expr)))\n        button(frm, LEFT, ' pi ', self.onPi)\n    def onExtra(self, expr):\n        try:\n            self.text.set(self.eval.runstring(expr % self.text.get()))\n        except:\n            self.text.set('ERROR')\n    def onPi(self):\n        self.text.set(self.eval.runstring('pi'))\nif __name__ == '__main__':\n    CalcGuiPlus(**getCalcArgs()).mainloop()       # passes -bg, -fg on\nNotice that these buttons\u2019 callbacks force floating-point division to be used for inverses\njust because that\u2019s how / operates in Python 3.X (// for integers truncates remainders\n1478 | Chapter 19:\u2002Text and Languageinstead); the buttons also wrap entry field values in parentheses to sidestep precedence\nissues. They could instead convert the entry\u2019s text to a number and do real math, but\nPython does all the work automatically when expression strings are run raw.\nAlso note that the buttons added by these scripts simply operate on the current value\nin the entry field, immediately. That\u2019s not quite the same as expression operators ap-\nplied with the stacks evaluator (additional customizations are needed to make them\ntrue operators). Still, these buttons prove the point these scripts are out to make\u2014they\nuse PyCalc as a component, both from the outside and from below.\nFinally, to test both of the extended calculator classes, as well as PyCalc configuration\noptions, the script in Example 19-24 puts up four distinct calculator windows (this is\nthe script run by PyDemos).\nExample 19-24. PP4E\\Lang\\Calculator\\calculator_plusplus.py\n#!/usr/local/bin/python\n\"\"\"\ndemo all 3 calculator flavors at once\neach is a distinct calculator object and window\n\"\"\"\nfrom tkinter import Tk, Button, Toplevel\nimport calculator, calculator_plus_ext, calculator_plus_emb\nroot=Tk()\ncalculator.CalcGui(Toplevel())\ncalculator.CalcGui(Toplevel(), fg='white', bg='purple')\ncalculator_plus_ext.CalcGuiPlus(Toplevel(), fg='gold', bg='black')\ncalculator_plus_emb.CalcGuiPlus(fg='black', bg='red')\nButton(root, text='Quit Calcs', command=root.quit).pack()\nroot.mainloop()\nFigure 19-8 shows the result\u2014four independent calculators in top-level windows\nwithin the same process. The two windows on the right represent specialized reuses of\nPyCalc as a component, and the Help dialog appears in the lower right. Although it\nmay not be obvious in this book, all four use different color schemes; calculator classes\naccept color and font configuration options and pass them down the call chain as\nneeded.\nAs we learned earlier, these calculators could also be run as independent processes by\nspawning command lines with the launchmodes module we met in Chapter 5. In fact,\nthat\u2019s how the PyGadgets and PyDemos launcher bars run calculators, so see their code\nfor more details. And as always, read the code and experiment on your own for further\nenlightenment; this is Python, after all.\nPyCalc: A Calculator Program/Object | 1479Figure 19-8. calculator_plusplus: extend, embed, and configure!\nThis chapter concludes our Python language material in this book. The next and final\ntechnical chapter of the text takes us on a tour of techniques for integrating Python\nwith programs written in compiled languages like C and C++. Not everyone needs to\nknow how to do this, so some readers may wish to skip ahead to the book\u2019s conclusion\nin Chapter 21 at this point. Since most Python programmers use wrapped C libraries\n(even if they don\u2019t wrap them themselves), though, I recommend a quick pass over the\nnext chapter before you close the book on this book.\n1480 | Chapter 19:\u2002Text and LanguageLesson 6: Have Fun\nIn closing, here\u2019s a less tangible but important aspect of Python programming. A com-\nmon remark among new users is that it\u2019s easy to \u201csay what you mean\u201d in Python without\ngetting bogged down in complex syntax or obscure rules. It\u2019s a programmer-friendly\nlanguage. In fact, it\u2019s not too uncommon for Python programs to run on the first\nattempt.\nAs we\u2019ve seen in this book, there are a number of factors behind this distinction\u2014lack\nof declarations, no compile steps, simple syntax, useful built-in objects, powerful li-\nbraries, and so on. Python is specifically designed to optimize speed of development\n(an idea we\u2019ll expand on in Chapter 21). For many users, the end result is a remarkably\nexpressive and responsive language, which can actually be fun to use for real work.\nFor instance, the calculator programs of this chapter were initially thrown together in\none afternoon, starting from vague, incomplete goals. There was no analysis phase, no\nformal design, and no official coding stage. I typed up some ideas and they worked.\nMoreover, Python\u2019s interactive nature allowed me to experiment with new ideas and\nget immediate feedback. Since its initial development, the calculator has been polished\nand expanded much, of course, but the core implementation remains unchanged.\nNaturally, such a laid-back programming mode doesn\u2019t work for every project. Some-\ntimes more upfront design is warranted. For more demanding tasks, Python has mod-\nular constructs and fosters systems that can be extended in either Python or C. And a\nsimple calculator GUI may not be what some would call \u201cserious\u201d software develop-\nment. But maybe that\u2019s part of the point, too.\nPyCalc: A Calculator Program/Object | 1481", "20": "CHAPTER 20\nPython/C Integration\n\u201cI Am Lost at C\u201d\nThroughout this book, our programs have all been written in Python code. We have\nused interfaces to services outside Python, and we\u2019ve coded reusable tools in the Python\nlanguage, but all our work has been done in Python itself. Despite our programs\u2019 scale\nand utility, they\u2019ve been Python through and through.\nFor many programmers and scripters, this mode makes perfect sense. In fact, such\nstandalone programming is one of the main ways people apply Python. As we\u2019ve seen,\nPython comes with batteries included\u2014interfaces to system tools, Internet protocols,\nGUIs, data storage, and much more is already available. Moreover, most custom tasks\nwe\u2019re likely to encounter have prebuilt solutions in the open source world; the PIL\nsystem, for example, allows us to process images in tkinter GUIs by simply running a\nself-installer.\nBut for some systems, Python\u2019s ability to integrate with components written in (or\ncompatible with) the C programming language is a crucial feature. In fact, Python\u2019s\nrole as an extension and interface language in larger systems is one of the reasons for\nits popularity and why it is often called a \u201cscripting\u201d language in the first place. Its\ndesign supports hybrid systems that mix components written in a variety of program-\nming languages. Because different languages have different strengths, being able to pick\nand choose on a component-by-component basis is a powerful concept. You can add\nPython to the mix anywhere you need a flexible and comparatively easy-to-use language\ntool, without sacrificing raw speed where it matters.\nCompiled languages such as C and C++ are optimized for speed of execution, but are\ncomplex to program\u2014for developers, and especially for end users who need to tailor\nprograms. Because Python is optimized for speed of development, using Python scripts\nto control or customize software components written in C or C++ can yield more\nflexible systems, quicker execution, and faster development modes. For example, mov-\ning selected components of a pure Python program to C can optimize program per-\nformance. Moreover, systems designed to delegate customizations to Python code\n1483don\u2019t need to be shipped with full source code and don\u2019t require end users to learn\ncomplex or proprietary languages.\nIn this last technical chapter of this book, we\u2019re going to take a brief look at tools for\ninterfacing with C-language components, and discuss both Python\u2019s ability to be used\nas an embedded language tool in other systems, and its interfaces for extending Python\nscripts with new modules implemented in C-compatible languages. We\u2019ll also briefly\nexplore other integration techniques that are less C specific, such as Jython.\nNotice that I said \u201cbrief\u201d in the preceding paragraph. Because not all Python program-\nmers need to master this topic, because it requires studying C language code and\nmakefiles, and because this is the final chapter of an already in-depth book, this chapter\nomits details that are readily available in both Python\u2019s standard manual set, and the\nsource code of Python itself. Instead, here we\u2019ll take a quick look at a handful of basic\nexamples to help get you started in this domain, and hint at the possibilities they imply\nfor Python systems.\nExtending and Embedding\nBefore we get to any code, I want to start out by defining what we mean by \u201cintegration\u201d\nhere. Although that term can be interpreted almost as widely as \u201cobject,\u201d our focus in\nthis chapter is on tight integration\u2014where control is transferred between languages by\na simple, direct, and fast in-process function call. Although it is also possible to link\ncomponents of an application less directly using IPC and networking tools such as\nsockets and pipes that we explored earlier in the book, we are interested in this part of\nthe book in more direct and efficient techniques.\nWhen you mix Python with components written in C (or other compiled languages),\neither Python or C can be \u201con top.\u201d Because of that, there are two distinct integration\nmodes and two distinct APIs:\nThe extending interface\nFor running compiled C library code from Python programs\nThe embedding interface\nFor running Python code from compiled C programs\nExtending generally has three main roles: to optimize programs\u2014recoding parts of a\nprogram in C is a last-resort performance boost; to leverage existing libraries\u2014opening\nthem up for use in Python code extends their reach; and to allow Python programs to\ndo things not directly supported by the language\u2014Python code cannot normally access\ndevices at absolute memory addresses, for instance, but can call C functions that do.\nFor example, the NumPy package for Python is largely an instance of extending at work:\nby integrating optimized numeric libraries, it turns Python into a flexible and efficient\nsystem for numeric programming that some compare to Matlab.\n1484 | Chapter 20:\u2002Python/C IntegrationEmbedding typically takes the role of customization\u2014by running user-configurable\nPython code, a system can be modified without shipping or building its full source\ncode. For instance, some programs provide a Python customization layer that can be\nused to modify the program on site by modifying Python code. Embedding is also\nsometimes used to route events to Python-coded callback handlers. Python GUI tool-\nkits, for example, usually employ embedding in some fashion to dispatch user events.\nFigure 20-1 sketches this traditional dual-mode integration model. In extending, con-\ntrol passes from Python through a glue layer on its way to C code. In embedding, C\ncode processes Python objects and runs Python code by calling Python C API functions.\nBecause Python is \u201con top\u201d in extending, it defines a fixed integration structure, which\ncan be automated with tools such as SWIG\u2014a code generator we\u2019ll meet in this chapter,\nwhich produces glue code required to wrap C and C++ libraries. Because Python is\nsubordinate in embedding, it instead provides a set of API tools which C programs\nemploy as needed.\nFigure 20-1. Traditional integration model\nIn some models, things are not as clear-cut. For example, under the ctypes module\ndiscussed later, Python scripts make library calls rather than employing C glue code.\nIn systems such as Cython (and its Pyrex predecessor), things are more different still\u2014\nC libraries are produced from combinations of Python and C code. And in Jython and\nIronPython, the model is similar, but Java and C# components replace the C language,\nand the integration is largely automated. We will meet such alternative systems later\nin this chapter. For now, our focus is on traditional Python/C integration models.\nThis chapter introduces extending first, and then moves on to explore the basics of\nembedding. Although we will study these topics in isolation, keep in mind that many\nsystems combine the two techniques. For instance, embedded Python code run from\nC can also import and call linked-in C extensions to interface with the enclosing ap-\nplication. And in callback-based systems, C libraries initially accessed through extend-\ning interfaces may later use embedding techniques to run Python callback handlers\non events.\n\u201cI Am Lost at C\u201d | 1485For example, when we created buttons with Python\u2019s tkinter GUI library earlier in the\nbook, we called out to a C library through the extending API. When our GUI\u2019s user\nlater clicked those buttons, the GUI C library caught the event and routed it to our\nPython functions with embedding. Although most of the details are hidden to Python\ncode, control jumps often and freely between languages in such systems. Python has\nan open and reentrant architecture that lets you mix languages arbitrarily.\nFor additional Python/C integration examples beyond this book, see the\nPython source code itself; its Modules and Objects directories are a\nwealth of code resources. Most of the Python built-ins we have used in\nthis book\u2014from simple things such as integers and strings to more ad-\nvanced tools such as files, system calls, tkinter, and DBM files\u2014are built\nwith the same structures we\u2019ll introduce here. Their utilization of inte-\ngration APIs can be studied in Python\u2019s source code distribution as\nmodels for extensions of your own.\nIn addition, Python\u2019s Extending and Embedding and Python/C API man-\nuals are reasonably complete, and provide supplemental information to\nthe presentation here. If you plan to do integration, you should consider\nbrowsing these as a next step. For example, the manuals go into addi-\ntional details about C extension types, C extensions in threaded pro-\ngrams, and multiple interpreters in embedded programs, which we will\nlargely bypass here.\nExtending Python in C: Overview\nBecause Python itself is coded in C today, compiled Python extensions can be coded\nin any language that is C compatible in terms of call stacks and linking. That includes\nC, but also C++ with appropriate \u201cextern C\u201d declarations (which are automatically\nprovided in Python header files). Regardless of the implementation language, the com-\npiled Python extensions language can take two forms:\nC modules\nLibraries of tools that look and feel like Python module files to their clients\nC types\nMultiple instance objects that behave like standard built-in types and classes\nGenerally, C extension modules are used to implement flat function libraries, and they\nwind up appearing as importable modules to Python code (hence their name). C ex-\ntension types are used to code objects that generate multiple instances, carry per-\ninstance state information, and may optionally support expression operators just like\nPython classes. C extension types can do anything that built-in types and Python-coded\nclasses can: method calls, addition, indexing, slicing, and so on.\nTo make the interface work, both C modules and types must provide a layer of \u201cglue\u201d\ncode that translates calls and data between the two languages. This layer registers\n1486 | Chapter 20:\u2002Python/C IntegrationC-coded operations with the Python interpreter as C function pointers. In all cases, the\nC layer is responsible for converting arguments passed from Python to C form and for\nconverting results from C to Python form. Python scripts simply import C extensions\nand use them as though they were really coded in Python. Because C code does all the\ntranslation work, the interface is very seamless and simple in Python scripts.\nC modules and types are also responsible for communicating errors back to Python,\ndetecting errors raised by Python API calls, and managing garbage-collector reference\ncounters on objects retained by the C layer indefinitely\u2014Python objects held by your\nC code won\u2019t be garbage-collected as long as you make sure their reference counts don\u2019t\nfall to zero. Once coded, C modules and types may be linked to Python either statically\n(by rebuilding Python) or dynamically (when first imported). Thereafter, the C exten-\nsion becomes another toolkit available for use in Python scripts.\nA Simple C Extension Module\nAt least that\u2019s the short story; C modules require C code, and C types require more of\nit than we can reasonably present in this chapter. Although this book can\u2019t teach you\nC development skills if you don\u2019t already have them, we need to turn to some code to\nmake this domain more concrete. Because C modules are simpler, and because C types\ngenerally export a C module with an instance constructor function, let\u2019s start off by\nexploring the basics of C module coding with a quick example.\nAs mentioned, when you add new or existing C components to Python in the traditional\nintegration model, you need to code an interface (\u201cglue\u201d) logic layer in C that handles\ncross-language dispatching and data translation. The C source file in Example 20-1\nshows how to code one by hand. It implements a simple C extension module named\nhello for use in Python scripts, with a function named message that simply returns its\ninput string argument with extra text prepended. Python scripts will call this function\nas usual, but this one is coded in C, not in Python.\nExample 20-1. PP4E\\Integrate\\Extend\\Hello\\hello.c\n/********************************************************************\n * A simple C extension module for Python, called \"hello\"; compile\n * this into a \".so\" on python path, import and call hello.message;\n ********************************************************************/\n#include <Python.h>\n#include <string.h>\n/* module functions */\nstatic PyObject *                                 /* returns object */\nmessage(PyObject *self, PyObject *args)           /* self unused in modules */\n{                                                 /* args from Python call */\n    char *fromPython, result[1024];\n    if (! PyArg_Parse(args, \"(s)\", &fromPython))  /* convert Python -> C */\n        return NULL;                              /* null=raise exception */\nA Simple C Extension Module | 1487else {\n        strcpy(result, \"Hello, \");                /* build up C string */\n        strcat(result, fromPython);               /* add passed Python string */\n        return Py_BuildValue(\"s\", result);        /* convert C -> Python */\n    }\n}\n/* registration table  */\nstatic PyMethodDef hello_methods[] = {\n    {\"message\",  message, METH_VARARGS, \"func doc\"},    /* name, &func, fmt, doc */\n    {NULL, NULL, 0, NULL}                               /* end of table marker */\n};\n/* module definition structure */\nstatic struct PyModuleDef hellomodule = {\n   PyModuleDef_HEAD_INIT,\n   \"hello\",         /* name of module */\n   \"mod doc\",       /* module documentation, may be NULL */\n   \u22121,              /* size of per-interpreter module state, \u22121=in global vars */\n   hello_methods    /* link to methods table */\n};\n/* module initializer */\nPyMODINIT_FUNC\nPyInit_hello()                         /* called on first import */\n{                                      /* name matters if loaded dynamically */\n    return PyModule_Create(&hellomodule);\n}\nThis C module has a 4-part standard structure described by its comments, which all C\nmodules follow, and which has changed noticeably in Python 3.X. Ultimately, Python\ncode will call this C file\u2019s message function, passing in a string object and getting back\na new string object. First, though, it has to be somehow linked into the Python inter-\npreter. To use this C file in a Python script, compile it into a dynamically loadable object\nfile (e.g., hello.so on Linux, hello.dll under Cygwin on Windows) with a makefile like\nthe one listed in Example 20-2, and drop the resulting object file into a directory listed\non your module import search path exactly as though it were a .py or .pyc file.\nExample 20-2. PP4E\\Integrate\\Extend\\Hello\\makefile.hello\n#############################################################\n# Compile hello.c into a shareable object file on Cygwin,\n# to be loaded dynamically when first imported by Python.\n#############################################################\nPYLIB = /usr/local/bin\nPYINC = /usr/local/include/python3.1\nhello.dll: hello.c\n        gcc hello.c -g -I$(PYINC) -shared -L$(PYLIB) -lpython3.1 -o hello.dll\nclean:\n        rm -f hello.dll core\n1488 | Chapter 20:\u2002Python/C IntegrationThis is a Cygwin makefile that uses gcc to compile our C code on Windows; other\nplatforms are analogous but will vary. As we learned in Chapter 5, Cygwin provides a\nUnix-like environment and libraries on Windows. To work along with the examples\nhere, either install Cygwin on your Windows platform, or change the makefiles listed\nper your compiler and platform requirements. Be sure to include the path to Python\u2019s\ninstall directory with -I flags to access Python include (a.k.a. header) files, as well as\nthe path to the Python binary library file with -L flags, if needed; mine point to\nPython 3.1\u2019s location on my laptop after building it from its source. Also note that you\u2019ll\nneed tabs for the indentation in makefile rules if a cut-and-paste from an ebook sub-\nstituted or dropped spaces.\nNow, to use the makefile in Example 20-2 to build the extension module in Exam-\nple 20-1, simply type a standard make command at your shell (the Cygwin shell is used\nhere, and I add a line break for clarity):\n.../PP4E/Integrate/Extend/Hello$ make -f makefile.hello\ngcc hello.c -g -I/usr/local/include/python3.1 -shared\n               -L/usr/local/bin -lpython3.1 -o hello.dll\nThis generates a shareable object file\u2014a .dll under Cygwin on Windows. When com-\npiled this way, Python automatically loads and links the C module when it is first\nimported by a Python script. At import time, the .dll binary library file will be located\nin a directory on the Python import search path, just like a .py file. Because Python\nalways searches the current working directory on imports, this chapter\u2019s examples will\nrun from the directory you compile them in (.) without any file copies or moves. In\nlarger systems, you will generally place compiled extensions in a directory listed in\nPYTHONPATH or .pth files instead, or use Python\u2019s distutils to install them in the site-\npackages subdirectory of the standard library.\nFinally, to call the C function from a Python program, simply import the module\nhello and call its hello.message function with a string; you\u2019ll get back a normal Python\nstring:\n.../PP4E/Integrate/Extend/Hello$ python\n>>> import hello                                   # import a C module\n>>> hello.message('world')                         # call a C function\n'Hello, world'\n>>> hello.message('extending')\n'Hello, extending'\nAnd that\u2019s it\u2014you\u2019ve just called an integrated C module\u2019s function from Python. The\nmost important thing to notice here is that the C function looks exactly as if it were\ncoded in Python. Python callers send and receive normal string objects from the call;\nthe Python interpreter handles routing calls to the C function, and the C function itself\nhandles Python/C data conversion chores.\nIn fact, there is little to distinguish hello as a C extension module at all, apart from its\nfilename. Python code imports the module and fetches its attributes as if it had been\nwritten in Python. C extension modules even respond to dir calls as usual and have the\nA Simple C Extension Module | 1489standard module and filename attributes, though the filename doesn\u2019t end in a .py\nor .pyc this time around\u2014the only obvious way you can tell it\u2019s a C library:\n>>> dir(hello)                                     # C module attributes\n['__doc__', '__file__', '__name__', '__package__', 'message']\n>>> hello.__name__, hello.__file__\n('hello', 'hello.dll')\n>>> hello.message                                  # a C function object\n<built-in function message>\n>>> hello                                          # a C module object\n<module 'hello' from 'hello.dll'>\n>>> hello.__doc__                                  # docstrings in C code\n'mod doc'\n>>> hello.message.__doc__\n'func doc'\n>>> hello.message()                                # errors work too\nTypeError: argument must be sequence of length 1, not 0\nLike any module in Python, you can also access the C extension from a script file. The\nPython file in Example 20-3, for instance, imports and uses the C extension module in\nExample 20-1.\nExample 20-3. PP4E\\Integrate\\Extend\\Hello\\hellouse.py\n\"import and use a C extension library module\"\nimport hello\nprint(hello.message('C'))\nprint(hello.message('module ' + hello.__file__))\nfor i in range(3):\n    reply = hello.message(str(i))\n    print(reply)\nRun this script as any other\u2014when the script first imports the module hello, Python\nautomatically finds the C module\u2019s .dll object file in a directory on the module search\npath and links it into the process dynamically. All of this script\u2019s output represents\nstrings returned from the C function in the file hello.c:\n.../PP4E/Integrate/Extend/Hello$ python hellouse.py\nHello, C\nHello, module /cygdrive/c/.../PP4E/Integrate/Extend/Hello/hello.dll\nHello, 0\nHello, 1\nHello, 2\nSee Python\u2019s manuals for more details on the code in our C module, as well as tips for\ncompilation and linkage. Of note, as an alternative to makefiles, also see the\ndisthello.py and disthello-alt.py files in the examples package. Here\u2019s a quick peek at\nthe source code of the first of these:\n1490 | Chapter 20:\u2002Python/C Integration# to build: python disthello.py build\n# resulting dll shows up in build subdir\nfrom distutils.core import setup, Extension\nsetup(ext_modules=[Extension('hello', ['hello.c'])])\nThis is a Python script that specifies compilation of the C extension using tools in the\ndistutils package\u2014a standard part of Python that is used to build, install, and dis-\ntribute Python extensions coded in Python or C. distutil\u2019s larger goal is automated\nand portable builds and installs for distributed packages, but it also knows how to build\nC extensions portably. Systems generally include a setup.py which installs in site-\npackages of the standard library. Regrettably, distutils is also too large to have survived\nthe cleaver applied to this chapter\u2019s material; see its two manuals in Python\u2019s manuals\nset for more details.\nThe SWIG Integration Code Generator\nAs you can probably tell, manual coding of C extensions can become fairly involved\n(this is almost inevitable in C language work). I\u2019ve introduced the basics in this chapter\nthus far so that you understand the underlying structure. But today, C extensions are\nusually better and more easily implemented with a tool that generates all the required\nintegration glue code automatically. There are a variety of such tools for use in the\nPython world, including SIP, SWIG, and Boost.Python; we\u2019ll explore alternatives at the\nend of this chapter. Among these, the SWIG system is widely used by Python\ndevelopers.\nSWIG\u2014the Simplified Wrapper and Interface Generator, is an open source system\ncreated by Dave Beazley and now developed by its community, much like Python. It\nuses C and C++ type declarations to generate complete C extension modules that in-\ntegrate existing libraries for use in Python scripts. The generated C (and C++) extension\nmodules are complete: they automatically handle data conversion, error protocols,\nreference-count management, and more.\nThat is, SWIG is a program that automatically generates all the glue code needed to\nplug C and C++ components into Python programs; simply run SWIG, compile its\noutput, and your extension work is done. You still have to manage compilation and\nlinking details, but the rest of the C extension task is largely performed by SWIG.\nA Simple SWIG Example\nTo use SWIG, instead of writing the C code in the prior section, write the C function\nyou want to use from Python without any Python integration logic at all, as though it\nis to be used from C alone. For instance, Example 20-4 is a recoding of Example 20-1\nas a straight C function.\nThe SWIG Integration Code Generator | 1491Example 20-4. PP4E\\Integrate\\Extend\\HelloLib\\hellolib.c\n/*********************************************************************\n * A simple C library file, with a single function, \"message\",\n * which is to be made available for use in Python programs.\n * There is nothing about Python here--this C function can be\n * called from a C program, as well as Python (with glue code).\n *********************************************************************/\n#include <string.h>\n#include <hellolib.h>\nstatic char result[1024];                /* this isn't exported */\nchar *\nmessage(char *label)                     /* this is exported */\n{\n    strcpy(result, \"Hello, \");           /* build up C string */\n    strcat(result, label);               /* add passed-in label */\n    return result;                       /* return a temporary */\n}\nWhile you\u2019re at it, define the usual C header file to declare the function externally, as\nshown in Example 20-5. This is probably overkill for such a small example, but it will\nprove a point.\nExample 20-5. PP4E\\Integrate\\Extend\\HelloLib\\hellolib.h\n/********************************************************************\n * Define hellolib.c exports to the C namespace, not to Python\n * programs--the latter is defined by a method registration\n * table in a Python extension module's code, not by this .h;\n ********************************************************************/\nextern char *message(char *label);\nNow, instead of all the Python extension glue code shown in the prior sections, simply\nwrite a SWIG type declarations input file, as in Example 20-6.\nExample 20-6. PP4E\\Integrate\\Extend\\Swig\\hellolib.i\n/******************************************************\n * Swig module description file, for a C lib file.\n * Generate by saying \"swig -python hellolib.i\".\n ******************************************************/\n%module hellowrap\n%{\n#include <hellolib.h>\n%}\nextern char *message(char*);    /* or: %include \"../HelloLib/hellolib.h\"   */\n                                /* or: %include hellolib.h, and use -I arg */\n1492 | Chapter 20:\u2002Python/C IntegrationThis file spells out the C function\u2019s type signature. In general, SWIG scans files con-\ntaining ANSI C and C++ declarations. Its input file can take the form of an interface\ndescription file (usually with a .i suffix) or a C/C++ header or source file. Interface files\nlike this one are the most common input form; they can contain comments in C or\nC++ format, type declarations just like standard header files, and SWIG directives that\nall start with %. For example:\n%module\nSets the module\u2019s name as known to Python importers.\n%{...%}\nEncloses code added to generated wrapper file verbatim.\nextern statements\nDeclare exports in normal ANSI C/C++ syntax.\n%include\nMakes SWIG scan another file (-I flags give search paths).\nIn this example, SWIG could also be made to read the hellolib.h header file of Exam-\nple 20-5 directly. But one of the advantages of writing special SWIG input files like\nhellolib.i is that you can pick and choose which functions are wrapped and exported\nto Python, and you may use directives to gain more control over the generation process.\nSWIG is a utility program that you run from your build scripts; it is not a programming\nlanguage, so there is not much more to show here. Simply add a step to your makefile\nthat runs SWIG and compile its output to be linked with Python. Example 20-7 shows\none way to do it on Cygwin.\nExample 20-7. PP4E\\Integrate\\Extend\\Swig\\makefile.hellolib-swig\n##################################################################\n# Use SWIG to integrate hellolib.c for use in Python programs on\n# Cygwin.  The DLL must have a leading \"_\" in its name in current\n# SWIG (>1.3.13) because also makes a .py without \"_\" in its name.\n##################################################################\nPYLIB = /usr/local/bin\nPYINC = /usr/local/include/python3.1\nCLIB  = ../HelloLib\nSWIG  = /cygdrive/c/temp/swigwin-2.0.0/swig\n# the library plus its wrapper\n_hellowrap.dll: hellolib_wrap.o $(CLIB)/hellolib.o\n        gcc -shared hellolib_wrap.o $(CLIB)/hellolib.o \\\n                       -L$(PYLIB) -lpython3.1 -o $@\n# generated wrapper module code\nhellolib_wrap.o: hellolib_wrap.c $(CLIB)/hellolib.h\n        gcc hellolib_wrap.c -g -I$(CLIB) -I$(PYINC) -c -o $@\nhellolib_wrap.c: hellolib.i\n        $(SWIG) -python -I$(CLIB) hellolib.i\nThe SWIG Integration Code Generator | 1493# C library code (in another directory)\n$(CLIB)/hellolib.o: $(CLIB)/hellolib.c $(CLIB)/hellolib.h\n        gcc $(CLIB)/hellolib.c -g -I$(CLIB) -c -o $(CLIB)/hellolib.o\nclean:\n        rm -f *.dll *.o *.pyc core\nforce:\n        rm -f *.dll *.o *.pyc core hellolib_wrap.c hellowrap.py\nWhen run on the hellolib.i input file by this makefile, SWIG generates two files:\nhellolib_wrap.c\nThe generated C extension module glue code file.\nhellowrap.py\nA Python module that imports the generated C extension module.\nThe former is named for the input file, and the latter per the %module directive. Really,\nSWIG generates two modules today: it uses a combination of Python and C code to\nachieve the integration. Scripts ultimately import the generated Python module file,\nwhich internally imports the generated and compiled C module. You can wade through\nthis generated code in the book\u2019s examples distribution if you are so inclined, but it is\nprone to change over time and is too generalized to be simple.\nTo build the C module, the makefile runs SWIG to generate the glue code; compiles\nits output; compiles the original C library code if needed; and then combines the result\nwith the compiled wrapper to produce _hellowrap.dll, the DLL which hellowrap.py will\nexpect to find when imported by a Python script:\n.../PP4E/Integrate/Extend/Swig$ dir\nhellolib.i  makefile.hellolib-swig\n.../PP4E/Integrate/Extend/Swig$ make -f makefile.hellolib-swig\n/cygdrive/c/temp/swigwin-2.0.0/swig -python -I../HelloLib hellolib.i\ngcc hellolib_wrap.c -g -I../HelloLib -I/usr/local/include/python3.1\n                 -c -o hellolib_wrap.o\ngcc ../HelloLib/hellolib.c -g -I../HelloLib -c -o ../HelloLib/hellolib.o\ngcc -shared hellolib_wrap.o ../HelloLib/hellolib.o \\\n                -L/usr/local/bin -lpython3.1 -o _hellowrap.dll\n.../PP4E/Integrate/Extend/Swig$ dir\n_hellowrap.dll  hellolib_wrap.c  hellowrap.py\nhellolib.i      hellolib_wrap.o  makefile.hellolib-swig\nThe result is a dynamically loaded C extension module file ready to be imported by\nPython code. Like all modules, _hellowrap.dll must, along with hellowrap.py, be placed\nin a directory on your Python module search path (the directory where you compile\nwill suffice if you run Python there too). Notice that the .dll file must be built with a\nleading underscore in its name; this is required because SWIG also created the .py file\nof the same name without the underscore\u2014if named the same, only one could be\n1494 | Chapter 20:\u2002Python/C Integrationimported, and we need both (scripts import the .py which in turn imports the .dll\ninternally).\nAs usual in C development, you may have to barter with the makefile to get it to work\non your system. Once you\u2019ve run the makefile, though, you are finished. The generated\nC module is used exactly like the manually coded version shown before, except that\nSWIG has taken care of the complicated parts automatically. Function calls in our\nPython code are routed through the generated SWIG layer, to the C code in Exam-\nple 20-4, and back again; with SWIG, this all \u201cjust works\u201d:\n.../PP4E/Integrate/Extend/Swig$ python\n >>> import hellowrap                       # import glue + library file\n>>> hellowrap.message('swig world')         # cwd always searched on imports\n'Hello, swig world'\n>>> hellowrap.__file__\n'hellowrap.py'\n>>> dir(hellowrap)\n['__builtins__', '__doc__', '__file__', '__name__', '_hellowrap', ... 'message']\n>>> hellowrap._hellowrap\n<module '_hellowrap' from '_hellowrap.dll'>\nIn other words, once you learn how to use SWIG, you can often largely forget the details\nbehind integration coding. In fact, SWIG is so adept at generating Python glue code\nthat it\u2019s usually easier and less error prone to code C extensions for Python as purely\nC- or C++-based libraries first, and later add them to Python by running their header\nfiles through SWIG, as demonstrated here.\nWe\u2019ve mostly just scratched the SWIG surface here, and there\u2019s more for you to learn\nabout it from its Python-specific manual\u2014available with SWIG at http://www.swig\n.org. Although its examples in this book are simple, SWIG is powerful enough to in-\ntegrate libraries as complex as Windows extensions and commonly used graphics APIs\nsuch as OpenGL. We\u2019ll apply it again later in this chapter, and explore its \u201cshadow\nclass\u201d model for wrapping C++ classes too. For now, let\u2019s move on to a more useful\nextension example.\nWrapping C Environment Calls\nOur next example is a C extension module that integrates the standard C library\u2019s\ngetenv and putenv shell environment variable calls for use in Python scripts. Exam-\nple 20-8 is a C file that achieves this goal in a hand-coded, manual fashion.\nExample 20-8. PP4E\\Integrate\\Extend\\Cenviron\\cenviron.c\n/******************************************************************\n * A C extension module for Python, called \"cenviron\".  Wraps the\n * C library's getenv/putenv routines for use in Python programs.\n ******************************************************************/\nWrapping C Environment Calls | 1495#include <Python.h>\n#include <stdlib.h>\n#include <string.h>\n/***********************/\n/* 1) module functions */\n/***********************/\nstatic PyObject *                                   /* returns object */\nwrap_getenv(PyObject *self, PyObject *args)         /* self not used */\n{                                                   /* args from python */\n    char *varName, *varValue;\n    PyObject *returnObj = NULL;                         /* null=exception */\n    if (PyArg_Parse(args, \"(s)\", &varName)) {           /* Python -> C */\n        varValue = getenv(varName);                     /* call C getenv */\n        if (varValue != NULL)\n            returnObj = Py_BuildValue(\"s\", varValue);   /* C -> Python */\n        else\n            PyErr_SetString(PyExc_SystemError, \"Error calling getenv\");\n    }\n    return returnObj;\n}\nstatic PyObject *\nwrap_putenv(PyObject *self, PyObject *args)\n{\n    char *varName, *varValue, *varAssign;\n    PyObject *returnObj = NULL;\n    if (PyArg_Parse(args, \"(ss)\", &varName, &varValue))\n    {\n        varAssign = malloc(strlen(varName) + strlen(varValue) + 2);\n        sprintf(varAssign, \"%s=%s\", varName, varValue);\n        if (putenv(varAssign) == 0) {\n            Py_INCREF(Py_None);                   /* C call success */\n            returnObj = Py_None;                  /* reference None */\n        }\n        else\n            PyErr_SetString(PyExc_SystemError, \"Error calling putenv\");\n    }\n    return returnObj;\n}\n/**************************/\n/* 2) registration table  */\n/**************************/\nstatic PyMethodDef cenviron_methods[] = {\n    {\"getenv\",  wrap_getenv, METH_VARARGS, \"getenv doc\"},  /* name, &func,... */\n    {\"putenv\",  wrap_putenv, METH_VARARGS, \"putenv doc\"},  /* name, &func,... */\n    {NULL, NULL, 0, NULL}                                  /* end of table marker */\n};\n1496 | Chapter 20:\u2002Python/C Integration/*************************/\n/* 3) module definition  */\n/*************************/\nstatic struct PyModuleDef cenvironmodule = {\n   PyModuleDef_HEAD_INIT,\n   \"cenviron\",        /* name of module */\n   \"cenviron doc\",    /* module documentation, may be NULL */\n   \u22121,                /* size of per-interpreter module state, \u22121=in global vars */\n   cenviron_methods   /* link to methods table */\n};\n/*************************/\n/* 4) module initializer */\n/*************************/\nPyMODINIT_FUNC\nPyInit_cenviron()                      /* called on first import */\n{                                      /* name matters if loaded dynamically */\n    return PyModule_Create(&cenvironmodule);\n}\nThough demonstrative, this example is arguably less useful now than it was in the first\nedition of this book\u2014as we learned in Part II, not only can you fetch shell environment\nvariables by indexing the os.environ table, but assigning to a key in this table auto-\nmatically calls C\u2019s putenv to export the new setting to the C code layer in the process.\nThat is, os.environ['key'] fetches the value of the shell variable 'key', and\nos.environ['key']=value assigns a variable both in Python and in C.\nThe second action\u2014pushing assignments out to C\u2014was added to Python releases after\nthe first edition of this book was published. Besides illustrating additional extension\ncoding techniques, though, this example still serves a practical purpose: even today,\nchanges made to shell variables by the C code linked into a Python process are not\npicked up when you index os.environ in Python code. That is, once your program\nstarts, os.environ reflects only subsequent changes made by Python code in the process.\nMoreover, although Python now has both a putenv and a getenv call in its os module,\ntheir integration seems incomplete. Changes to os.environ call os.putenv, but direct\ncalls to os.putenv do not update os.environ, so the two can become out of sync. And\nos.getenv today simply translates to an os.environ fetch, and hence will not pick up\nenvironment changes made in the process outside of Python code after startup time.\nThis may rarely, if ever, be an issue for you, but this C extension module is not com-\npletely without purpose; to truly interface environment variables with linked-in C code,\nwe need to call the C library routines directly (at least until Python changes this\nmodel again!).\nThe cenviron.c C file in Example 20-8 creates a Python module called cenviron that\ndoes a bit more than the prior examples\u2014it exports two functions, sets some exception\ndescriptions explicitly, and makes a reference count call for the Python None object (it\u2019s\nnot created anew, so we need to add a reference before passing it to Python). As before,\nWrapping C Environment Calls | 1497to add this code to Python, compile and link into an object file; the Cygwin makefile\nin Example 20-9 builds the C source code for dynamic binding on imports.\nExample 20-9. PP4E\\Integrate\\Extend\\Cenviron\\makefile.cenviron\n##################################################################\n# Compile cenviron.c into cenviron.dll--a shareable object file\n# on Cygwin, which is loaded dynamically when first imported.\n##################################################################\nPYLIB = /usr/local/bin\nPYINC = /usr/local/include/python3.1\ncenviron.dll: cenviron.c\n        gcc cenviron.c -g -I$(PYINC) -shared  -L$(PYLIB) -lpython3.1 -o $@\nclean:\n        rm -f *.pyc cenviron.dll\nTo build, type make -f makefile.cenviron at your shell. To run, make sure the result-\ning .dll file is in a directory on Python\u2019s module path (the current working directory\nworks too):\n.../PP4E/Integrate/Extend/Cenviron$ python\n>>> import cenviron\n>>> cenviron.getenv('USER')                # like os.environ[key] but refetched\n'mark'\n>>> cenviron.putenv('USER', 'gilligan')    # like os.environ[key]=value\n>>> cenviron.getenv('USER')                # C sees the changes too\n'gilligan'\nAs before, cenviron is a bona fide Python module object after it is imported, with all\nthe usual attached information, and errors are raised and reported correctly on errors:\n>>> dir(cenviron)\n['__doc__', '__file__', '__name__', '__packge__', 'getenv', 'putenv']\n>>> cenviron.__file__\n'cenviron.dll'\n>>> cenviron.__name__\n'cenviron'\n>>> cenviron.getenv\n<built-in function getenv>\n>>> cenviron\n<module 'cenviron' from 'cenviron.dll'>\n>>> cenviron.getenv('HOME')\n'/home/mark'\n>>> cenviron.getenv('NONESUCH')\nSystemError: Error calling getenv\n1498 | Chapter 20:\u2002Python/C IntegrationHere is an example of the problem this module addresses (but you have to pretend that\nsome of these calls are made by linked-in C code, not by Python; I changed USER in\nthe shell prior to this session with an export command):\n.../PP4E/Integrate/Extend/Cenviron$ python\n>>> import os\n>>> os.environ['USER']                      # initialized from the shell\n'skipper'\n>>> from cenviron import getenv, putenv     # direct C library call access\n>>> getenv('USER')\n'skipper'\n>>> putenv('USER', 'gilligan')              # changes for C but not Python\n>>> getenv('USER')\n'gilligan'\n>>> os.environ['USER']                      # oops--does not fetch values again\n'skipper'\n>>> os.getenv('USER')                       # ditto\n'skipper'\nAdding Wrapper Classes to Flat Libraries\nAs is, the C extension module exports a function-based interface, but it\u2019s easy to wrap\nits functions in Python code that makes the interface look any way you like. For in-\nstance, Example 20-10 makes the functions accessible by dictionary indexing and in-\ntegrates with the os.environ object\u2014it guarantees that the object will stay in sync with\nfetches and changes made by calling our C extension functions.\nExample 20-10. PP4E\\Integrate\\Extend\\Cenviron\\envmap.py\nimport os\nfrom cenviron import getenv, putenv       # get C module's methods\nclass EnvMapping:                         # wrap in a Python class\n    def __setitem__(self, key, value):\n        os.environ[key] = value           # on writes: Env[key]=value\n        putenv(key, value)                # put in os.environ too\n    def __getitem__(self, key):\n        value = getenv(key)               # on reads: Env[key]\n        os.environ[key] = value           # integrity check\n        return value\nEnv = EnvMapping()                        # make one instance\nTo use this module, clients may import its Env object using Env['var'] dictionary syntax\nto refer to environment variables. Example 20-11 goes a step further and exports the\nfunctions as qualified attribute names rather than as calls or keys\u2014variables are refer-\nenced with Env.var attribute syntax.\nWrapping C Environment Calls | 1499Example 20-11. PP4E\\Integrate\\Extend\\Cenviron\\envattr.py\nimport os\nfrom cenviron import getenv, putenv       # get C module's methods\nclass EnvWrapper:                         # wrap in a Python class\n    def __setattr__(self, name, value):\n        os.environ[name] = value          # on writes: Env.name=value\n        putenv(name, value)               # put in os.environ too\n    def __getattr__(self, name):\n        value = getenv(name)              # on reads: Env.name\n        os.environ[name] = value          # integrity check\n        return value\nEnv = EnvWrapper()                        # make one instance\nThe following shows our Python wrappers running atop our C extension module\u2019s\nfunctions to access environment variables. The main point to notice here is that you\ncan graft many different sorts of interface models on top of extension functions by\nproviding Python wrappers in addition to C extensions:\n>>> from envmap import Env\n>>> Env['USER']\n'skipper'\n>>> Env['USER'] = 'professor'\n>>> Env['USER']\n'professor'\n>>>\n>>> from envattr import Env\n>>> Env.USER\n'professor'\n>>> Env.USER = 'gilligan'\n>>> Env.USER\n'gilligan'\nWrapping C Environment Calls with SWIG\nYou can manually code extension modules like we just did, but you don\u2019t necessarily\nhave to. Because this example really just wraps functions that already exist in standard\nC libraries, the entire cenviron.c C code file in Example 20-8 can be replaced with a\nsimple SWIG input file that looks like Example 20-12.\nExample 20-12. PP4E\\Integrate\\Extend\\Swig\\Environ\\environ.i\n/***************************************************************\n * Swig module description file, to generate all Python wrapper\n * code for C lib getenv/putenv calls: \"swig -python environ.i\".\n ***************************************************************/\n%module environ\nextern char * getenv(const char *varname);\nextern int    putenv(char *assignment);\n1500 | Chapter 20:\u2002Python/C IntegrationAnd you\u2019re done. Well, almost; you still need to run this file through SWIG and compile\nits output. As before, simply add a SWIG step to your makefile and compile its output\nfile into a shareable object for dynamic linking, and you\u2019re in business. Exam-\nple 20-13 is a Cygwin makefile that does the job.\nExample 20-13. PP4E\\Integrate\\Extend\\Swig\\Environ\\makefile.environ-swig\n# build environ extension from SWIG generated code\nPYLIB = /usr/local/bin\nPYINC = /usr/local/include/python3.1\nSWIG  = /cygdrive/c/temp/swigwin-2.0.0/swig\n_environ.dll: environ_wrap.c\n        gcc environ_wrap.c -g -I$(PYINC) -L$(PYLIB) -lpython3.1 -shared -o $@\nenviron_wrap.c: environ.i\n        $(SWIG) -python environ.i\nclean:\n        rm -f *.o *.dll *.pyc core environ_wrap.c environ.py\nWhen run on environ.i, SWIG generates two files and two modules\u2014environ.py (the\nPython interface module we import) and environ_wrap.c (the lower-level glue code\nmodule file we compile into _environ.dll to be imported by the .py). Because the func-\ntions being wrapped here live in standard linked-in C libraries, there is nothing to\ncombine with the generated code; this makefile simply runs SWIG and compiles the\nwrapper file into a C extension module, ready to be imported:\n.../PP4E/Integrate/Extend/Swig/Environ$ make -f makefile.environ-swig\n/cygdrive/c/temp/swigwin-2.0.0/swig -python environ.i\ngcc environ_wrap.c -g -I/usr/local/include/python3.1 -L/usr/local/bin -lpython3.1\n    -shared -o _environ.dll\nAnd now you\u2019re really done. The resulting C extension module is linked when impor-\nted, and it\u2019s used as before (except that SWIG handled all the gory bits):\n.../PP4E/Integrate/Extend/Swig/Environ$ ls\n_environ.dll  environ.i  environ.py  environ_wrap.c  makefile.environ-swig\n.../PP4E/Integrate/Extend/Swig/Environ$ python\n>>> import environ\n>>> environ.getenv('USER')\n'gilligan'\n>>> environ.__name__, environ.__file__, environ\n('environ', 'environ.py', <module 'environ' from 'environ.py'>)\n>>> dir(environ)\n[ ... '_environ', 'getenv', 'putenv' ... ]\nWrapping C Environment Calls | 1501If you look closely, you may notice that I didn\u2019t call putenv this time. It\nturns out there\u2019s good cause: the C library\u2019s putenv wants a string of the\nform \u201cUSER=Gilligan\u201d to be passed, which becomes part of the envi-\nronment. In C code, this means we must create a new piece of memory\nto pass in; we used malloc in Example 20-8 to satisfy this constraint.\nHowever, there\u2019s no simple and direct way to guarantee this on the Py-\nthon side of the fence. In a prior Python release, it was apparently suf-\nficient to hold on to the string passed to putenv in a temporary Python\nvariable, but this no longer works with Python 3.X and/or SWIG 2.0. A\nfix may require either a custom C function or SWIG\u2019s typemaps which\nallow its handling of data translations to be customized. In the interest\nof space, we\u2019ll leave addressing this as suggested exercise; see SWIG for\ndetails.\nWrapping C++ Classes with SWIG\nSo far in this chapter, we\u2019ve been dealing with C extension modules\u2014flat function\nlibraries. To implement multiple-instance objects in C, you need to code a C extension\ntype, not a module. Like Python classes, C types generate multiple-instance objects and\ncan overload (i.e., intercept and implement) Python expression operators and type\noperations. C types can also support subclassing just like Python classes, largely be-\ncause the type/class distinction has largely evaporated in Python 3.X.\nYou can see what C types look like in Python\u2019s own source library tree; look for the\nObjects directory there. The code required for a C type can be large\u2014it defines instance\ncreation, named methods, operator implementations, an iterator type, and so on, and\nlinks all these together with tables\u2014but is largely boilerplate code that is structurally\nthe same for most types.\nYou can code new object types in C manually like this, and in some applications, this\napproach may make sense. But you don\u2019t necessarily have to\u2014because SWIG knows\nhow to generate glue code for C++ classes, you can instead automatically generate all\nthe C extension and wrapper class code required to integrate such an object, simply by\nrunning SWIG over an appropriate class declaration. The wrapped C++ class provides\na multiple-instance datatype much like the C extension type, but it can be substantially\nsimpler for you to code because SWIG handles language integration details.\nHere\u2019s how\u2014given a C++ class declaration and special command-line settings, SWIG\ngenerates the following:\n\u2022 A C++-coded Python extension module with accessor functions that interface with\nthe C++ class\u2019s methods and members\n\u2022 A Python-coded module with a wrapper class (called a \u201cshadow\u201d or \u201cproxy\u201d class\nin SWIG-speak) that interfaces with the C++ class accessor functions module\n1502 | Chapter 20:\u2002Python/C IntegrationAs we did earlier, to use SWIG in this domain, write and debug your class as though it\nwould be used only from C++. Then, simply run SWIG in your makefile to scan the\nC++ class declaration and compile and link its output. The end result is that by im-\nporting the shadow class in your Python scripts, you can utilize C++ classes as though\nthey were really coded in Python. Not only can Python programs make and use in-\nstances of the C++ class, they can also customize it by subclassing the generated shadow\nclass.\nA Simple C++ Extension Class\nTo see how this works, we need a C++ class. To illustrate, let\u2019s code one to be used in\nPython scripts. You have to understand C++ to make sense of this section, of course,\nand SWIG supports advanced C++ tools (including templates and overloaded func-\ntions and operators), but I\u2019ll keep this example simple for illustration. The following\nC++ files define a Number class with four methods (add, sub, square, and display), a data\nmember (data), and a constructor and destructor. Example 20-14 shows the header file.\nExample 20-14. PP4E\\Integrate\\Extend\\Swig\\Shadow\\number.h\nclass Number\n{\npublic:\n    Number(int start);             // constructor\n    ~Number();                     // destructor\n    void add(int value);           // update data member\n    void sub(int value);\n    int  square();                 // return a value\n    void display();                // print data member\n    int data;\n};\nExample 20-15 is the C++ class\u2019s implementation file; most methods print a message\nwhen called to trace class operations. Notice how this uses printf instead of C++\u2019s\ncout; this once resolved an output overlap issue when mixing C++ cout with Python\n2.X standard output streams on Cygwin. It\u2019s probably a moot point today\u2014because\nPython 3.X\u2019s output system and buffering might mix with C++\u2019s arbitrarily, C++\nshould generally flush the output stream (with fflush(stdout) or cout<<flush) if it\nprints intermixed text that doesn\u2019t end in a newline. Obscure but true when disparate\nlanguage systems are mixed.\nExample 20-15. PP4E\\Integrate\\Extend\\Swig\\Shadow\\number.cxx\n///////////////////////////////////////////////////////////////\n// implement a C++ class, to be used from Python code or not;\n// caveat: cout and print usually both work, but I ran into a\n// c++/py output overlap issue on Cygwin that prompted printf\n///////////////////////////////////////////////////////////////\n#include \"number.h\"\n#include \"stdio.h\"                       // versus #include \"iostream.h\"\nWrapping C++ Classes with SWIG | 1503Number::Number(int start) {\n    data = start;                        // python print goes to stdout\n    printf(\"Number: %d\\n\", data);        // or: cout << \"Number: \" << data << endl;\n}\nNumber::~Number() {\n    printf(\"~Number: %d\\n\", data);\n}\nvoid Number::add(int value) {\n    data += value;\n    printf(\"add %d\\n\", value);\n}\nvoid Number::sub(int value) {\n    data -= value;\n    printf(\"sub %d\\n\", value);\n}\nint Number::square() {\n    return data * data;       // if print label, fflush(stdout) or cout << flush\n}\nvoid Number::display() {\n    printf(\"Number=%d\\n\", data);\n}\nSo that you can compare languages, the following is how this class is used in a C++\nprogram. Example 20-16 makes a Number object, calls its methods, and fetches and sets\nits data attribute directly (C++ distinguishes between \u201cmembers\u201d and \u201cmethods,\u201d\nwhile they\u2019re usually both called \u201cattributes\u201d in Python).\nExample 20-16. PP4E\\Integrate\\Extend\\Swig\\Shadow\\main.cxx\n#include \"iostream.h\"\n#include \"number.h\"\nmain()\n{\n    Number *num;\n    int res, val;\n    num = new Number(1);            // make a C++ class instance\n    num->add(4);                    // call its methods\n    num->display();\n    num->sub(2);\n    num->display();\n    res = num->square();                     // method return value\n    cout << \"square: \" << res << endl;\n    num->data = 99;                          // set C++ data member\n    val = num->data;                         // fetch C++ data member\n    cout << \"data:   \" << val << endl;\n1504 | Chapter 20:\u2002Python/C Integrationcout << \"data+1: \" << val + 1 << endl;\n    num->display();\n    cout << num << endl;            // print raw instance ptr\n    delete num;                     // run destructor\n}\nYou can use the g++ command-line C++ compiler program to compile and run this\ncode on Cygwin (it\u2019s the same on Linux). If you don\u2019t use a similar system, you\u2019ll have\nto extrapolate; there are far too many C++ compiler differences to list here. Type the\ncompile command directly or use the cxxtest target in this example directory\u2019s makefile\nshown ahead, and then run the purely C++ program created:\n.../PP4E/Integrate/Extend/Swig/Shadow$ make -f makefile.number-swig cxxtest\ng++ main.cxx number.cxx -Wno-deprecated\n.../PP4E/Integrate/Extend/Swig/Shadow$ ./a.exe\nNumber: 1\nadd 4\nNumber=5\nsub 2\nNumber=3\nsquare: 9\ndata:   99\ndata+1: 100\nNumber=99\n0xe502c0\n~Number: 99\nWrapping the C++ Class with SWIG\nBut enough C++: let\u2019s get back to Python. To use the C++ Number class of the preceding\nsection in Python scripts, you need to code or generate a glue logic layer between the\ntwo languages, just as in prior C extension examples. To generate that layer automat-\nically, write a SWIG input file like the one shown in Example 20-17.\nExample 20-17. PP4E\\Integrate\\Extend\\Swig\\Shadow\\number.i\n/********************************************************\n * Swig module description file for wrapping a C++ class.\n * Generate by running \"swig -c++ -python number.i\".\n * The C++ module is generated in file number_wrap.cxx;\n * module 'number' refers to the number.py shadow class.\n ********************************************************/\n%module number\n%{\n#include \"number.h\"\n%}\n%include number.h\nWrapping C++ Classes with SWIG | 1505This interface file simply directs SWIG to read the C++ class\u2019s type signature infor-\nmation from the %-included number.h header file. SWIG uses the class declaration to\ngenerate two different Python modules again:\nnumber_wrap.cxx\nA C++ extension module with class accessor functions\nnumber.py\nA Python shadow class module that wraps accessor functions\nThe former must be compiled into a binary library. The latter imports and uses the\nformer\u2019s compiled form and is the file that Python scripts ultimately import. As for\nsimple functions, SWIG achieves the integration with a combination of Python and\nC++ code.\nAfter running SWIG, the Cygwin makefile shown in Example 20-18 combines the gen-\nerated number_wrap.cxx C++ wrapper code module with the C++ class implementa-\ntion file to create a _number.dll\u2014a dynamically loaded extension module that must be\nin a directory on your Python module search path when imported from a Python script,\nalong with the generated number.py (all files are in the same current working directory\nhere).\nAs before, the compiled C extension module must be named with a leading underscore\nin SWIG today: _number.dll, following a Python convention, rather than the other\nformats used by earlier releases. The shadow class module number.py internally imports\n_number.dll. Be sure to use a -c++ command-line argument for SWIG; an older\n-shadow argument is no longer needed to create the wrapper class in addition to the\nlower-level functional interface module, as this is enabled by default.\nExample 20-18. PP4E\\Integrate\\Extend\\Swig\\Shadow\\makefile.number-swig\n###########################################################################\n# Use SWIG to integrate the number.h C++ class for use in Python programs.\n# Update: name \"_number.dll\" matters, because shadow class imports _number.\n# Update: the \"-shadow\" swig command line arg is deprecated (on by default).\n# Update: swig no longer creates a .doc file to rm here (ancient history).\n###########################################################################\nPYLIB = /usr/local/bin\nPYINC = /usr/local/include/python3.1\nSWIG  = /cygdrive/c/temp/swigwin-2.0.0/swig\nall: _number.dll number.py\n# wrapper + real class\n_number.dll: number_wrap.o number.o\n        g++ -shared number_wrap.o number.o -L$(PYLIB) -lpython3.1 -o $@\n# generated class wrapper module(s)\nnumber_wrap.o: number_wrap.cxx number.h\n        g++ number_wrap.cxx -c -g -I$(PYINC)\n1506 | Chapter 20:\u2002Python/C Integrationnumber_wrap.cxx: number.i\n        $(SWIG) -c++ -python number.i\nnumber.py: number.i\n        $(SWIG) -c++ -python number.i\n# wrapped C++ class code\nnumber.o: number.cxx number.h\n        g++ number.cxx -c -g -Wno-deprecated\n# non Python test\ncxxtest:\n        g++ main.cxx number.cxx -Wno-deprecated\nclean:\n        rm -f *.pyc *.o *.dll core a.exe\nforce:\n        rm -f *.pyc *.o *.dll core a.exe number_wrap.cxx number.py\nAs usual, run this makefile to generate and compile the necessary glue code into an\nextension module that can be imported by Python programs:\n.../PP4E/Integrate/Extend/Swig/Shadow$ make -f makefile.number-swig\n/cygdrive/c/temp/swigwin-2.0.0/swig -c++ -python number.i\ng++ number_wrap.cxx -c -g -I/usr/local/include/python3.1\ng++ number.cxx -c -g -Wno-deprecated\ng++ -shared number_wrap.o number.o -L/usr/local/bin -lpython3.1 -o _number.dll\n.../PP4E/Integrate/Extend/Swig/Shadow$ ls\n_number.dll  makefile.number-swig  number.i   number_wrap.cxx\na.exe        number.cxx            number.o   number_wrap.o\nmain.cxx     number.h              number.py\nUsing the C++ Class in Python\nOnce the glue code is generated and compiled, Python scripts can access the C++ class\nas though it were coded in Python. In fact, it is\u2014the imported number.py shadow class\nwhich runs on top of the extension module is generated Python code. Example 20-19\nrepeats the main.cxx file\u2019s class tests. Here, though, the C++ class is being utilized from\nthe Python programming language\u2014an arguably amazing feat, but the code is remark-\nably natural on the Python side of the fence.\nExample 20-19. PP4E\\Integrate\\Extend\\Swig\\Shadow\\main.py\n\"\"\"\nuse C++ class in Python code (c++ module + py shadow class)\nthis script runs the same tests as the main.cxx C++ file\n\"\"\"\nfrom number import Number         # imports .py C++ shadow class module\nnum = Number(1)                   # make a C++ class object in Python\nnum.add(4)                        # call its methods from Python\nWrapping C++ Classes with SWIG | 1507num.display()                     # num saves the C++ 'this' pointer\nnum.sub(2)\nnum.display()\nres = num.square()                # converted C++ int return value\nprint('square: ', res)\nnum.data = 99                     # set C++ data member, generated __setattr__\nval = num.data                    # get C++ data member, generated __getattr__\nprint('data:   ', val)            # returns a normal Python integer object\nprint('data+1: ', val + 1)\nnum.display()\nprint(num)                        # runs repr in shadow/proxy class\ndel num                           # runs C++ destructor automatically\nBecause the C++ class and its wrappers are automatically loaded when imported by \nthe number.py shadow class module, you run this script like any other:\n.../PP4E/Integrate/Extend/Swig/Shadow$ python main.py\nNumber: 1\nadd 4\nNumber=5\nsub 2\nNumber=3\nsquare:  9\ndata:    99\ndata+1:  100\nNumber=99\n<number.Number; proxy of <Swig Object of type 'Number *' at 0x7ff4bb48> >\n~Number: 99\nMuch of this output is coming from the C++ class\u2019s methods and is largely the same \nas the main.cxx results shown in Example 20-16 (less the instance output format\u2014it\u2019s \na Python shadow class instance now).\nUsing the low-level extension module\nSWIG implements integrations as a C++/Python combination, but you can always use \nthe generated accessor functions module if you want to, as in Example 20-20. This \nversion runs the C++ extension module directly without the shadow class, to demon-\nstrate how the shadow class maps calls back to C++.\nExample 20-20. PP4E\\Integrate\\Extend\\Swig\\Shadow\\main_low.py \n\"\"\"\nrun similar tests to main.cxx and main.py\nbut use low-level C accessor function interface\n\"\"\"\nfrom _number import *           # c++ extension module wrapper\nnum = new_Number(1)\nNumber_add(num, 4)              # pass C++ 'this' pointer explicitly\n1508 | Chapter 20:\u2002Python/C IntegrationNumber_display(num)             # use accessor functions in the C module\nNumber_sub(num, 2)\nNumber_display(num)\nprint(Number_square(num))\nNumber_data_set(num, 99)\nprint(Number_data_get(num))\nNumber_display(num)\nprint(num)\ndelete_Number(num)\nThis script generates essentially the same output as main.py, but it\u2019s been slightly sim-\nplified, and the C++ class instance is something lower level than the proxy class here:\n.../PP4E/Integrate/Extend/Swig/Shadow$ python main_low.py\nNumber: 1\nadd 4\nNumber=5\nsub 2\nNumber=3\n9\n99\nNumber=99\n_6025aa00_p_Number\n~Number: 99\nSubclassing the C++ class in Python\nUsing the extension module directly works, but there is no obvious advantage to mov-\ning from the shadow class to functions here. By using the shadow class, you get both\nan object-based interface to C++ and a customizable Python object. For instance, the\nPython module shown in Example 20-21 extends the C++ class, adding an extra\nprint call statement to the C++ add method and defining a brand-new mul method.\nBecause the shadow class is pure Python, this works naturally.\nExample 20-21. PP4E\\Integrate\\Extend\\Swig\\Shadow\\main_subclass.py\n\"sublass C++ class in Python (generated shadow class)\"\nfrom number import Number                # import shadow class\nclass MyNumber(Number):\n    def add(self, other):                # extend method\n        print('in Python add...')\n        Number.add(self, other)\n    def mul(self, other):                # add new method\n        print('in Python mul...')\n        self.data = self.data * other\nnum = MyNumber(1)               # same tests as main.cxx, main.py\nnum.add(4)                      # using Python subclass of shadow class\nnum.display()                   # add() is specialized in Python\nnum.sub(2)\nnum.display()\nWrapping C++ Classes with SWIG | 1509print(num.square())\nnum.data = 99\nprint(num.data)\nnum.display()\nnum.mul(2)                      # mul() is implemented in Python\nnum.display()\nprint(num)                      # repr from shadow superclass\ndel num\nNow we get extra messages out of add calls, and mul changes the C++ class\u2019s data\nmember automatically when it assigns self.data\u2014the Python code extends the C++\ncode:\n.../PP4E/Integrate/Extend/Swig/Shadow$ python main_subclass.py\nNumber: 1\nin Python add...\nadd 4\nNumber=5\nsub 2\nNumber=3\n9\n99\nNumber=99\nin Python mul...\nNumber=198\n<__main__.MyNumber; proxy of <Swig Object of type 'Number *' at 0x7ff4baa0> >\n~Number: 198\nIn other words, SWIG makes it easy to use C++ class libraries as base classes in your\nPython scripts. Among other things, this allows us to leverage existing C++ class li-\nbraries in Python scripts and optimize by coding parts of class hierarchies in C++ when\nneeded. We can do much the same with C extension types today since types are classes\n(and vice versa), but wrapping C++ classes with SWIG is often much simpler.\nExploring the wrappers interactively\nAs usual, you can import the C++ class interactively to experiment with it some more\u2014\nbesides demonstrating a few more salient properties here, this technique allows us to\ntest wrapped C++ classes at the Python interactive prompt:\n.../PP4E/Integrate/Extend/Swig/Shadow$ python\n>>> import _number\n>>> _number.__file__              # the C++ class plus generated glue module\n'_number.dll'\n>>> import number                 # the generated Python shadow class module\n>>> number.__file__\n'number.py'\n>>> x = number.Number(2)          # make a C++ class instance in Python\nNumber: 2\n>>> y = number.Number(4)          # make another C++ object\nNumber: 4\n1510 | Chapter 20:\u2002Python/C Integration>>> x, y\n(<number.Number; proxy of <Swig Object of type 'Number *' at 0x7ff4bcf8> >,\n <number.Number; proxy of <Swig Object of type 'Number *' at 0x7ff4b998> >)\n>>> x.display()                   # call C++ method (like C++ x->display())\nNumber=2\n>>> x.add(y.data)                 # fetch C++ data member, call C++ method\nadd 4\n>>> x.display()\nNumber=6\n>>> y.data = x.data + y.data + 32         # set C++ data member\n>>> y.display()                           # y records the C++ this pointer\nNumber=42\n>>> y.square()                            # method with return value\n1764\n>>> t = y.square()\n>>> t, type(t)                            # type is class in Python 3.X\n(1764, <class 'int'>)\nNaturally, this example uses a small C++ class to underscore the basics, but even at\nthis level, the seamlessness of the Python-to-C++ integration we get from SWIG is\nastonishing. Python code uses C++ members and methods as though they are Python\ncode. Moreover, this integration transparency still applies once we step up to more\nrealistic C++ class libraries.\nSo what\u2019s the catch? Nothing much, really, but if you start using SWIG in earnest, the\nbiggest downside may be that SWIG cannot handle every feature of C++ today. If your\nclasses use some esoteric C++ tools (and there are many), you may need to handcode\nsimplified class type declarations for SWIG instead of running SWIG over the original\nclass header files. SWIG development is ongoing, so you should consult the SWIG\nmanuals and website for more details on these and other topics.\nIn return for any such trade-offs, though, SWIG can completely obviate the need to\ncode glue layers to access C and C++ libraries from Python scripts. If you have ever\ncoded such layers by hand in the past, you already know that this can be a very big win.\nIf you do go the handcoded route, though, consult Python\u2019s standard extension man-\nuals for more details on both API calls used in this chapter, as well as additional ex-\ntension tools we don\u2019t have space to cover in this text. C extensions can run the gamut\nfrom short SWIG input files to code that is staunchly wedded to the internals of the\nPython interpreter; as a rule of thumb, the former survives the ravages of time much\nbetter than the latter.\nOther Extending Tools\nIn closing the extending topic, I should mention that there are alternatives to SWIG,\nmany of which have a loyal user base of their own. This section briefly introduces some\nof the more popular tools in this domain today; as usual, search the Web for more\nOther Extending Tools | 1511details on these and others. Like SWIG, all of the following began life as third-party\ntools installed separately, though Python 2.5 and later incorporates the ctypes extension\nas a standard library module.\nSIP\nJust as a sip is a smaller swig in the drinking world, so too is the SIP system a lighter\nalternative to SWIG in the Python world (in fact, it was named on purpose for the\njoke). According to its web page, SIP makes it easy to create Python bindings for\nC and C++ libraries. Originally developed to create the PyQt Python bindings for\nthe Qt toolkit, it can be used to create bindings for any C or C++ library. SIP\nincludes a code generator and a Python support module.\nMuch like SWIG, the code generator processes a set of specification files and gen-\nerates C or C++ code, which is compiled to create the bindings extension module.\nThe SIP Python module provides support functions to the automatically generated\ncode. Unlike SWIG, SIP is specifically designed just for bringing together Python\nand C/C++. SWIG also generates wrappers for many other scripting languages,\nand so is viewed by some as a more complex project.\nctypes\nThe ctypes system is a foreign function interface (FFI) module for Python. It allows\nPython scripts to access and call compiled functions in a binary library file directly\nand dynamically, by writing dispatch code in Python itself, instead of generating\nor writing the integration C wrapper code we\u2019ve studied in this chapter. That is,\nlibrary glue code is written in pure Python instead of C. The main advantage is that\nyou don\u2019t need C code or a C build system to access C functions from a Python\nscript. The disadvantage is potential speed loss on dispatch, though this depends\nupon the alternative measured.\nAccording to its documentation, ctypes allows Python to call functions exposed\nfrom DLLs and shared libraries and has facilities to create, access, and manipulate\ncomplex C datatypes in Python. It is also possible to implement C callback func-\ntions in pure Python, and an experimental ctypes code generator feature allows\nautomatic creation of library wrappers from C header files. ctypes works on Win-\ndows, Mac OS X, Linux, Solaris, FreeBSD, and OpenBSD. It may run on additional\nsystems, provided that the libffi package it employs is supported. For Windows,\nctypes contains a ctypes.com package, which allows Python code to call and im-\nplement custom COM interfaces. See Python\u2019s library manuals for more on the\nctypes functionality included in the standard library.\nBoost.Python\nThe Boost.Python system is a C++ library that enables seamless interoperability\nbetween C++ and the Python programming language through an IDL-like model.\nUsing it, developers generally write a small amount of C++ wrapper code to create\na shared library for use in Python scripts. Boost.Python handles references, call-\nbacks, type mappings, and cleanup tasks. Because it is designed to wrap C++ in-\nterfaces nonintrusively, C++ code need not be changed to be wrapped. Like other\n1512 | Chapter 20:\u2002Python/C Integrationtools, this makes the system useful for wrapping existing libraries, as well as\ndeveloping new extensions from scratch.\nWriting interface code for large libraries can be more involved than the code gen-\neration approaches of SWIG and SIP, but it\u2019s easier than manually wrapping li-\nbraries and may afford greater control than a fully automated wrapping tool. In\naddition, the Py++ and older Pyste systems provide Boost.Python code generators,\nin which users specify classes and functions to be exported using a simple interface\nfile. Both use GCC-XML to parse all the headers and extract the necessary infor-\nmation to generate C++ code.\nCython (and Pyrex)\nCython, a successor to the Pyrex system, is a language specifically for writing\nPython extension modules. It lets you write files that mix Python code and C da-\ntatypes as you wish, and compiles the combination into a C extension for Python.\nIn principle, developers need not deal with the Python/C API at all, because Cython\ntakes care of things such as error-checking and reference counts automatically.\nTechnically, Cython is a distinct language that is Python-like, with extensions for\nmixing in C datatype declarations and C function calls. However, almost any Py-\nthon code is also valid Cython code. The Cython compiler converts Python code\ninto C code, which makes calls to the Python/C API. In this aspect, Cython is\nsimilar to the now much older Python2C conversion project. By combining Python\nand C code, Cython offers a different approach than the generation or coding of\nintegration code in other systems.\nCXX, weave, and more\nThe CXX system is roughly a C++ version of Python\u2019s usual C API, which handles\nreference counters, exception translation, and much of the type checking and\ncleanup inherent in C++ extensions. As such, CXX lets you focus on the\napplication-specific parts of your code. CXX also exposes parts of the C++ Stand-\nard Template Library containers to be compatible with Python sequences.\nThe weave package allows the inclusion of C/C++ in Python code. It\u2019s part of the \nSciPy package (http://www.scipy.org) but is also available as a standalone system.\nA page at http://www.python.org chronicles additional projects in this domain,\nwhich we don\u2019t have space to mention here.\nOther languages: Java, C#, FORTRAN, Objective-C, and others\nAlthough we\u2019re focused on C and C++ in this chapter, you\u2019ll also find direct sup-\nport for mixing Python with other programming languages in the open source\nworld. This includes languages that are compiled to binary form like C, as well as\nsome that are not.\nFor example, by providing full byte code compilers, the Jython and IronPython\nsystems allow code written in Python to interface with Java and C#/.NET com-\nponents in a largely seamless fashion. Alternatively, the JPype and Python for .NET\nprojects support Java and C#/.NET integration for normal CPython (the standard\nOther Extending Tools | 1513C-based implementation of Python) code, without requiring alternative byte code\ncompilers.\nMoreover, the f2py and PyFort systems provide integration with FORTRAN code,\nand other tools provide access to languages such as Delphi and Objective-C.\nAmong these, the PyObjC project aims to provide a bridge between Python and\nObjective-C; this supports writing Cocoa GUI applications on Mac OS X in Python.\nSearch the Web for details on other language integration tools. Also look for a wiki\npage currently at http://www.python.org that lists a large number of other integrat-\nable languages, including Prolog, Lisp, TCL, and more.\nBecause many of these systems support bidirectional control flows\u2014both extending\nand embedding\u2014we\u2019ll return to this category at the end of this chapter in the context\nof integration at large. First, though, we need to shift our perspective 180 degrees to\nexplore the other mode of Python/C integration: embedding.\nMixing Python and C++\nPython\u2019s standard implementation is currently coded in C, so all the normal rules about\nmixing C programs with C++ programs apply to the Python interpreter. In fact, there\nis nothing special about Python in this context, but here are a few pointers.\nWhen embedding Python in a C++ program, there are no special rules to follow. Simply\nlink in the Python library and call its functions from C++. Python\u2019s header files auto-\nmatically wrap themselves in extern \"C\" {...} declarations to suppress C++ name\nmangling. Hence, the Python library looks like any other C component to C++; there\nis no need to recompile Python itself with a C++ compiler.\nWhen extending Python with C++ components, Python header files are still C++\nfriendly, so Python API calls in C++ extensions work like any other C++-to-C call. But\nbe sure to wrap the parts of your extension code made visible to Python with extern\n\"C\" declarations so that they can be called by Python\u2019s C code. For example, to wrap\na C++ class, SWIG generates a C++ extension module that declares its initialization\nfunction this way.\nEmbedding Python in C: Overview\nSo far in this chapter, we\u2019ve explored only half of the Python/C integration picture:\ncalling C services from Python. This mode is perhaps the most commonly deployed; it\nallows programmers to speed up operations by moving them to C and to utilize external\nlibraries by wrapping them in C extension modules and types. But the inverse can be\njust as useful: calling Python from C. By delegating selected components of an appli-\ncation to embedded Python code, we can open them up to onsite changes without\nhaving to ship or rebuild a system\u2019s full code base.\nThis section tells this other half of the Python/C integration tale. It introduces the\nPython C interfaces that make it possible for programs written in C-compatible\n1514 | Chapter 20:\u2002Python/C Integrationlanguages to run Python program code. In this mode, Python acts as an embedded\ncontrol language (what some call a \u201cmacro\u201d language). Although embedding is mostly\npresented in isolation here, keep in mind that Python\u2019s integration support is best\nviewed as a whole. A system\u2019s structure usually determines an appropriate integration\napproach: C extensions, embedded code calls, or both. To wrap up, this chapter con-\ncludes by discussing a handful of alternative integration platforms such as Jython and\nIronPython, which offer broad integration possibilities.\nThe C Embedding API\nThe first thing you should know about Python\u2019s embedded-call API is that it is less\nstructured than the extension interfaces. Embedding Python in C may require a bit\nmore creativity on your part than extending: you must pick tools from a general col-\nlection of calls to implement the Python integration instead of coding to a boilerplate\nstructure. The upside of this loose structure is that programs can combine embedding\ncalls and strategies to build up arbitrary integration architectures.\nThe lack of a more rigid model for embedding is largely the result of a less clear-cut\ngoal. When extending Python, there is a distinct separation for Python and C respon-\nsibilities and a clear structure for the integration. C modules and types are required to\nfit the Python module/type model by conforming to standard extension structures. This\nmakes the integration seamless for Python clients: C extensions look like Python objects\nand handle most of the work. It also supports automation tools such as SWIG.\nBut when Python is embedded, the structure isn\u2019t as obvious; because C is the enclosing\nlevel, there is no clear way to know what model the embedded Python code should fit.\nC may want to run objects fetched from modules, strings fetched from files or parsed\nout of documents, and so on. Instead of deciding what C can and cannot do, Python\nprovides a collection of general embedding interface tools, which you use and structure\naccording to your embedding goals.\nMost of these tools correspond to tools available to Python programs. Table 20-1 lists\nsome of the more common API calls used for embedding, as well as their Python equiv-\nalents. In general, if you can figure out how to accomplish your embedding goals in\npure Python code, you can probably find C API tools that achieve the same results.\nTable 20-1. Common API functions\nC API call\nPython equivalent\nPyImport_ImportModule\nimport module, __import__\nPyImport_GetModuleDict\nsys.modules\nPyModule_GetDict\nmodule.__dict__\nPyDict_GetItemString\ndict[key]\nPyDict_SetItemString\ndict[key]=val\nPyDict_New\ndict = {}\nEmbedding Python in C: Overview | 1515C API call\nPython equivalent\nPyObject_GetAttrString\ngetattr(obj, attr)\nPyObject_SetAttrString\nsetattr(obj, attr, val)\nPyObject_CallObject\nfuncobj(*argstuple)\nPyEval_CallObject\nfuncobj(*argstuple)\nPyRun_String\neval(exprstr), exec(stmtstr)\nPyRun_File\nexec(open(filename().read())\nBecause embedding relies on API call selection, becoming familiar with the Python C\nAPI is fundamental to the embedding task. This chapter presents a handful of repre-\nsentative embedding examples and discusses common API calls, but it does not provide\na comprehensive list of all tools in the API. Once you\u2019ve mastered the examples here,\nyou\u2019ll probably need to consult Python\u2019s integration manuals for more details on avail-\nable calls in this domain. As mentioned previously, Python offers two standard manuals\nfor C/C++ integration programmers: Extending and Embedding, an integration tutorial;\nand Python/C API, the Python runtime library reference.\nYou can find the most recent releases of these manuals at http://www.python.org, and\npossibly installed on your computer alongside Python itself. Beyond this chapter, these\nmanuals are likely to be your best resource for up-to-date and complete Python API\ntool information.\nWhat Is Embedded Code?\nBefore we jump into details, let\u2019s get a handle on some of the core ideas in the embed-\nding domain. When this book speaks of \u201cembedded\u201d Python code, it simply means\nany Python program structure that can be executed from C with a direct in-process\nfunction call interface. Generally speaking, embedded Python code can take a variety\nof forms:\nCode strings\nC programs can represent Python programs as character strings and run them as\neither expressions or statements (much like using the eval and exec built-in func-\ntions in Python).\nCallable objects\nC programs can load or reference Python callable objects such as functions, meth-\nods, and classes, and call them with argument list objects (much like func(*pargs,\n*kargs) Python syntax).\nCode files\nC programs can execute entire Python program files by importing modules and\nrunning script files through the API or general system calls (e.g., popen).\n1516 | Chapter 20:\u2002Python/C IntegrationThe Python binary library is usually what is physically embedded and linked in the C\nprogram. The actual Python code run from C can come from a wide variety of sources:\n\u2022 Code strings might be loaded from files, obtained from an interactive user at a\nconsole or GUI, fetched from persistent databases and shelves, parsed out of\nHTML or XML files, read over sockets, built or hardcoded in a C program, passed\nto C extension functions from Python registration code, and so on.\n\u2022 Callable objects might be fetched from Python modules, returned from other\nPython API calls, passed to C extension functions from Python registration code,\nand so on.\n\u2022 Code files simply exist as files, modules, and executable scripts in the filesystem.\nRegistration is a technique commonly used in callback scenarios that we will explore\nin more detail later in this chapter. But especially for strings of code, there are as many\npossible sources as there are for C character strings in general. For example, C programs\ncan construct arbitrary Python code dynamically by building and running strings.\nFinally, once you have some Python code to run, you need a way to communicate with\nit: the Python code may need to use inputs passed in from the C layer and may want\nto generate outputs to communicate results back to C. In fact, embedding generally\nbecomes interesting only when the embedded code has access to the enclosing C layer.\nUsually, the form of the embedded code suggests its communication media:\n\u2022 Code strings that are Python expressions return an expression result as their out-\nput. In addition, both inputs and outputs can take the form of global variables in\nthe namespace in which a code string is run; C may set variables to serve as input,\nrun Python code, and fetch variables as the code\u2019s result. Inputs and outputs can\nalso be passed with exported C extension function calls\u2014Python code may use C\nmodule or type interfaces that we met earlier in this chapter to get or set variables\nin the enclosing C layer. Communications schemes are often combined; for in-\nstance, C may preassign global names to objects that export both state and interface\nfunctions for use in the embedded Python code.*\n\u2022 Callable objects may accept inputs as function arguments and produce results as\nfunction return values. Passed-in mutable arguments (e.g., lists, dictionaries, class\ninstances) can be used as both input and output for the embedded code\u2014changes\nmade in Python are retained in objects held by C. Objects can also make use of the\nglobal variable and C extension functions interface techniques described for strings\nto communicate with C.\n* For a concrete example, consider the discussion of server-side templating languages in the Internet part of\nthis book. Such systems usually fetch Python code embedded in an HTML web page file, assign global\nvariables in a namespace to objects that give access to the web browser\u2019s environment, and run the Python\ncode in the namespace where the objects were assigned. I worked on a project where we did something\nsimilar, but Python code was embedded in XML documents, and objects that were preassigned to globals in\nthe code\u2019s namespace represented widgets in a GUI. At the bottom, it was simply Python code embedded in\nand run by C code.\nEmbedding Python in C: Overview | 1517\u2022 Code files can communicate with most of the same techniques as code strings;\nwhen run as separate programs, files can also employ Inter-Process Communica-\ntion (IPC) techniques.\nNaturally, all embedded code forms can also communicate with C using general system-\nlevel tools: files, sockets, pipes, and so on. These techniques are generally less direct\nand slower, though. Here, we are still interested in in-process function call integration.\nBasic Embedding Techniques\nAs you can probably tell from the preceding overview, there is much flexibility in the\nembedding domain. To illustrate common embedding techniques in action, this section\npresents a handful of short C programs that run Python code in one form or another.\nMost of these examples will make use of the simple Python module file shown in\nExample 20-22.\nExample 20-22. PP4E\\Integrate\\Embed\\Basics\\usermod.py\n\"\"\"\n#############################################################\nC code runs Python code in this module in embedded mode.\nSuch a file can be changed without changing the C layer.\nThis is just standard Python code (C handles conversions).\nMust be on the Python module search path if imported by C.\nC can also run code in standard library modules like string.\n#############################################################\n\"\"\"\nmessage = 'The meaning of life...'\ndef transform(input):\n    input = input.replace('life', 'Python')\n    return input.upper()\nIf you know any Python at all, you probably know that this file defines a string and a\nfunction; the function returns whatever it is passed with string substitution and up-\npercase conversions applied. It\u2019s easy to use from Python:\n.../PP4E/Integrate/Embed/Basics$ python\n>>> import usermod                                      # import a module\n>>> usermod.message                                     # fetch a string\n'The meaning of life...'\n>>> usermod.transform(usermod.message)                  # call a function\n'THE MEANING OF PYTHON...'\nWith a little Python API wizardry, it\u2019s not much more difficult to use this module the\nsame way in C.\n1518 | Chapter 20:\u2002Python/C IntegrationRunning Simple Code Strings\nPerhaps the simplest way to run Python code from C is by calling the PyRun_Simple\nString API function. With it, C programs can execute Python programs represented as\nC character string arrays. This call is also very limited: all code runs in the same name-\nspace (the module __main__), the code strings must be Python statements (not expres-\nsions), and there is no direct way to communicate inputs or outputs with the Python\ncode run.\nStill, it\u2019s a simple place to start. Moreover, when augmented with an imported C ex-\ntension module that the embedded Python code can use to communicate with the\nenclosing C layer, this technique can satisfy many embedding goals. To demonstrate\nthe basics, the C program in Example 20-23 runs Python code to accomplish the same\nresults as the Python interactive session listed in the prior section.\nExample 20-23. PP4E\\Integrate\\Embed\\Basics\\embed-simple.c\n/*******************************************************\n * simple code strings: C acts like the interactive\n * prompt, code runs in __main__, no output sent to C;\n *******************************************************/\n#include <Python.h>    /* standard API def */\nmain() {\n    printf(\"embed-simple\\n\");\n    Py_Initialize();\n    PyRun_SimpleString(\"import usermod\");                /* load .py file */\n    PyRun_SimpleString(\"print(usermod.message)\");        /* on Python path */\n    PyRun_SimpleString(\"x = usermod.message\");           /* compile and run */\n    PyRun_SimpleString(\"print(usermod.transform(x))\");\n    Py_Finalize();\n}\nThe first thing you should notice here is that when Python is embedded, C programs\nalways call Py_Initialize to initialize linked-in Python libraries before using any other\nAPI functions and normally call Py_Finalize to shut the interpreter down.\nThe rest of this code is straightforward\u2014C submits hardcoded strings to Python that\nare roughly what we typed interactively. In fact, we could concatenate all the Python\ncode strings here with \\n characters between, and submit it once as a single string.\nInternally, PyRun_SimpleString invokes the Python compiler and interpreter to run the\nstrings sent from C; as usual, the Python compiler is always available in systems that\ncontain Python.\nCompiling and running\nTo build a standalone executable from this C source file, you need to link its compiled\nform with the Python library file. In this chapter, \u201clibrary\u201d usually means the binary\nBasic Embedding Techniques | 1519library file that is generated when Python is compiled, not the Python source code\nstandard library.\nToday, everything in Python that you need in C is compiled into a single Python library\nfile when the interpreter is built (e.g., libpython3.1.dll on Cygwin). The program\u2019s\nmain function comes from your C code, and depending on your platform and the ex-\ntensions installed in your Python, you may also need to link any external libraries ref-\nerenced by the Python library.\nAssuming no extra extension libraries are needed, Example 20-24 is a minimal makefile\nfor building the C program in Example 20-23 under Cygwin on Windows. Again,\nmakefile details vary per platform, but see Python manuals for hints. This makefile uses\nthe Python include-files path to find Python.h in the compile step and adds the Python\nlibrary file to the final link step to make API calls available to the C program.\nExample 20-24. PP4E\\Integrate\\Embed\\Basics\\makefile.1\n# a Cygwin makefile that builds a C executable that embeds\n# Python, assuming no external module libs must be linked in;\n# uses Python header files, links in the Python lib file;\n# both may be in other dirs (e.g., /usr) in your install;\nPYLIB = /usr/local/bin\nPYINC = /usr/local/include/python3.1\nembed-simple: embed-simple.o\n        gcc embed-simple.o -L$(PYLIB) -lpython3.1 -g -o embed-simple\nembed-simple.o: embed-simple.c\n        gcc embed-simple.c -c -g -I$(PYINC)\nTo build a program with this file, launch make on it as usual (as before, make sure\nindentation in rules is tabs in your copy of this makefile):\n.../PP4E/Integrate/Embed/Basics$ make -f makefile.1\ngcc embed-simple.c -c -g -I/usr/local/include/python3.1\ngcc embed-simple.o -L/usr/local/bin -lpython3.1 -g -o embed-simple\nThings may not be quite this simple in practice, though, at least not without some\ncoaxing. The makefile in Example 20-25 is the one I actually used to build all of this\nsection\u2019s C programs on Cygwin.\nExample 20-25. PP4E\\Integrate\\Embed\\Basics\\makefile.basics\n# cygwin makefile to build all 5 basic embedding examples at once\nPYLIB = /usr/local/bin\nPYINC = /usr/local/include/python3.1\nBASICS = embed-simple.exe   \\\n         embed-string.exe   \\\n         embed-object.exe   \\\n         embed-dict.exe     \\\n1520 | Chapter 20:\u2002Python/C Integrationembed-bytecode.exe\nall:    $(BASICS)\nembed%.exe: embed%.o\n        gcc embed$*.o -L$(PYLIB) -lpython3.1 -g -o $@\nembed%.o: embed%.c\n        gcc embed$*.c -c -g -I$(PYINC)\nclean:\n        rm -f *.o *.pyc $(BASICS) core\nOn some platforms, you may need to also link in other libraries because the Python\nlibrary file used may have been built with external dependencies enabled and required.\nIn fact, you may have to link in arbitrarily many more externals for your Python library,\nand frankly, chasing down all the linker dependencies can be tedious. Required libraries\nmay vary per platform and Python install, so there isn\u2019t a lot of advice I can offer to\nmake this process simple (this is C, after all). The standard C development techniques\nwill apply.\nOne hint here: if you\u2019re going to do much embedding work and you run into external\ndependency issues, on some platforms you might want to build Python on your ma-\nchine from its source with all unnecessary extensions disabled in its build configuration\nfiles (see the Python source package for details). This produces a Python library with\nminimal external requirements, which may links more easily.\nOnce you\u2019ve gotten the makefile to work, run it to build all of this section\u2019s C programs\nat once with Python libraries linked in:\n.../PP4E/Integrate/Embed/Basics$ make -f makefile.basics clean\nrm -f *.o *.pyc embed-simple.exe embed-string.exe embed-object.exe\nembed-dict.exe embed-bytecode.exe core\n.../PP4E/Integrate/Embed/Basics$ make -f makefile.basics\ngcc embed-simple.c -c -g -I/usr/local/include/python3.1\ngcc embed-simple.o -L/usr/local/bin -lpython3.1 -g -o embed-simple.exe\ngcc embed-string.c -c -g -I/usr/local/include/python3.1\ngcc embed-string.o -L/usr/local/bin -lpython3.1 -g -o embed-string.exe\ngcc embed-object.c -c -g -I/usr/local/include/python3.1\ngcc embed-object.o -L/usr/local/bin -lpython3.1 -g -o embed-object.exe\ngcc embed-dict.c -c -g -I/usr/local/include/python3.1\ngcc embed-dict.o -L/usr/local/bin -lpython3.1 -g -o embed-dict.exe\ngcc embed-bytecode.c -c -g -I/usr/local/include/python3.1\ngcc embed-bytecode.o -L/usr/local/bin -lpython3.1 -g -o embed-bytecode.exe\nrm embed-dict.o embed-object.o embed-simple.o embed-bytecode.o embed-string.o\nAfter building with either makefile, you can run the resulting C program as usual:\n.../PP4E/Integrate/Embed/Basics$ ./embed-simple\nembed-simple\nThe meaning of life...\nTHE MEANING OF PYTHON...\nBasic Embedding Techniques | 1521Most of this output is produced by Python print statements sent from C to the linked-\nin Python library. It\u2019s as if C has become an interactive Python programmer.\nNaturally, strings of Python code run by C probably would not be hardcoded in a C\nprogram file like this. They might instead be loaded from a text file or GUI, extracted\nfrom HTML or XML files, fetched from a persistent database or socket, and so on.\nWith such external sources, the Python code strings that are run from C could be\nchanged arbitrarily without having to recompile the C program that runs them. They\nmay even be changed on site, and by end users of a system. To make the most of code\nstrings, though, we need to move on to more flexible API tools.\nPragmatic details: Under Python 3.1 and Cygwin on Windows, I had to\nfirst set my PYTHONPATH to include the current directory in order to run\nthe embedding examples, with the shell command export PYTHON\nPATH=.. I also had to use the shell command ./embed-simple to execute\nthe program because . was also not on my system path setting and isn\u2019t\ninitially when you install Cygwin.\nYour mileage may vary; but if you have trouble, try running the embed-\nded Python commands import sys and print sys.path from C to see\nwhat Python\u2019s path looks like, and take a look at the Python/C API\nmanual for more on path configuration for embedded applications.\nRunning Code Strings with Results and Namespaces\nExample 20-26 uses the following API calls to run code strings that return expression\nresults back to C:\nPy_Initialize\nInitializes linked-in Python libraries as before\nPyImport_ImportModule\nImports a Python module and returns a pointer to it\nPyModule_GetDict\nFetches a module\u2019s attribute dictionary object\nPyRun_String\nRuns a string of code in explicit namespaces\nPyObject_SetAttrString\nAssigns an object attribute by namestring\nPyArg_Parse\nConverts a Python return value object to C form\nThe import calls are used to fetch the namespace of the usermod module listed in Ex-\nample 20-22 so that code strings can be run there directly and will have access to names\ndefined in that module without qualifications. Py_Import_ImportModule is like a Python\nimport statement, but the imported module object is returned to C; it is not assigned\n1522 | Chapter 20:\u2002Python/C Integrationto a Python variable name. As a result, it\u2019s probably more similar to the Python\n__import__ built-in function.\nThe PyRun_String call is the one that actually runs code here, though. It takes a code\nstring, a parser mode flag, and dictionary object pointers to serve as the global and local\nnamespaces for running the code string. The mode flag can be Py_eval_input to run an\nexpression or Py_file_input to run a statement; when running an expression, the result\nof evaluating the expression is returned from this call (it comes back as a PyObject*\nobject pointer). The two namespace dictionary pointer arguments allow you to distin-\nguish global and local scopes, but they are typically passed the same dictionary such\nthat code runs in a single namespace.\nExample 20-26. PP4E\\Integrate\\Embed\\Basics\\embed-string.c\n/* code-strings with results and namespaces */\n#include <Python.h>\nmain() {\n    char *cstr;\n    PyObject *pstr, *pmod, *pdict;\n    printf(\"embed-string\\n\");\n    Py_Initialize();\n    /* get usermod.message */\n    pmod  = PyImport_ImportModule(\"usermod\");\n    pdict = PyModule_GetDict(pmod);\n    pstr  = PyRun_String(\"message\", Py_eval_input, pdict, pdict);\n    /* convert to C */\n    PyArg_Parse(pstr, \"s\", &cstr);\n    printf(\"%s\\n\", cstr);\n    /* assign usermod.X */\n    PyObject_SetAttrString(pmod, \"X\", pstr);\n    /* print usermod.transform(X) */\n    (void) PyRun_String(\"print(transform(X))\", Py_file_input, pdict, pdict);\n    Py_DECREF(pmod);\n    Py_DECREF(pstr);\n    Py_Finalize();\n}\nWhen compiled and run, this file produces the same result as its predecessor:\n.../PP4E/Integrate/Embed/Basics$ ./embed-string\nembed-string\nThe meaning of life...\nTHE MEANING OF PYTHON...\nHowever, very different work goes into producing this output. This time, C fetches,\nconverts, and prints the value of the Python module\u2019s message attribute directly by\nBasic Embedding Techniques | 1523running a string expression and assigning a global variable (X) within the module\u2019s\nnamespace to serve as input for a Python print statement string.\nBecause the string execution call in this version lets you specify namespaces, you can\nbetter partition the embedded code your system runs\u2014each grouping can have a dis-\ntinct namespace to avoid overwriting other groups\u2019 variables. And because this call\nreturns a result, you can better communicate with the embedded code; expression\nresults are outputs, and assignments to globals in the namespace in which code runs\ncan serve as inputs.\nBefore we move on, I need to explain three coding issues here. First, this program also\ndecrements the reference count on objects passed to it from Python, using the\nPy_DECREF call described in Python\u2019s C API manuals. These calls are not strictly needed\nhere (the objects\u2019 space is reclaimed when the programs exits anyhow), but they dem-\nonstrate how embedding interfaces must manage reference counts when Python passes\nobject ownership to C. If this was a function called from a larger system, for instance,\nyou would generally want to decrement the count to allow Python to reclaim the\nobjects.\nSecond, in a realistic program, you should generally test the return values of all the API\ncalls in this program immediately to detect errors (e.g., import failure). Error tests are\nomitted in this section\u2019s example to keep the code simple, but they should be included\nin your programs to make them more robust.\nAnd third, there is a related function that lets you run entire files of code, but it is not\ndemonstrated in this chapter: PyRun_File. Because you can always load a file\u2019s text and\nrun it as a single code string with PyRun_String, the PyRun_File call\u2019s main advantage\nis to avoid allocating memory for file content. In such multiline code strings, the \\n\ncharacter terminates lines and indentation group blocks as usual.\nCalling Python Objects\nThe last two sections dealt with running strings of code, but it\u2019s easy for C programs\nto deal in terms of Python objects, too. Example 20-27 accomplishes the same task as\nExamples 20-23 and 20-26, but it uses other API tools to interact with objects in the\nPython module directly:\nPyImport_ImportModule\nImports the module from C as before\nPyObject_GetAttrString\nFetches an object\u2019s attribute value by name\nPyEval_CallObject\nCalls a Python function (or class or method)\nPyArg_Parse\nConverts Python objects to C values\n1524 | Chapter 20:\u2002Python/C IntegrationPy_BuildValue\nConverts C values to Python objects\nWe used both of the data conversion functions earlier in this chapter in extension\nmodules. The PyEval_CallObject call in this version of the example is the key point\nhere: it runs the imported function with a tuple of arguments, much like the Python\nfunc(*args) call syntax. The Python function\u2019s return value comes back to C as a\nPyObject*, a generic Python object pointer.\nExample 20-27. PP4E\\Integrate\\Embed\\Basics\\embed-object.c\n/* fetch and call objects in modules */\n#include <Python.h>\nmain() {\n    char *cstr;\n    PyObject *pstr, *pmod, *pfunc, *pargs;\n    printf(\"embed-object\\n\");\n    Py_Initialize();\n    /* get usermod.message */\n    pmod = PyImport_ImportModule(\"usermod\");\n    pstr = PyObject_GetAttrString(pmod, \"message\");\n    /* convert string to C */\n    PyArg_Parse(pstr, \"s\", &cstr);\n    printf(\"%s\\n\", cstr);\n    Py_DECREF(pstr);\n    /* call usermod.transform(usermod.message) */\n    pfunc = PyObject_GetAttrString(pmod, \"transform\");\n    pargs = Py_BuildValue(\"(s)\", cstr);\n    pstr  = PyEval_CallObject(pfunc, pargs);\n    PyArg_Parse(pstr, \"s\", &cstr);\n    printf(\"%s\\n\", cstr);\n    /* free owned objects */\n    Py_DECREF(pmod);\n    Py_DECREF(pstr);\n    Py_DECREF(pfunc);        /* not really needed in main() */\n    Py_DECREF(pargs);        /* since all memory goes away  */\n    Py_Finalize();\n}\nWhen compiled and run, the result is the same again:\n.../PP4E/Integrate/Embed/Basics$ ./embed-object\nembed-object\nThe meaning of life...\nTHE MEANING OF PYTHON...\nHowever, this output is generated by C this time\u2014first, by fetching the Python mod-\nule\u2019s message attribute value, and then by fetching and calling the module\u2019s transform\nBasic Embedding Techniques | 1525function object directly and printing its return value that is sent back to C. Input to the\ntransform function is a function argument here, not a preset global variable. Notice\nthat message is fetched as a module attribute this time, instead of by running its name\nas a code string; as this shows, there is often more than one way to accomplish the same\ngoals with different API calls.\nRunning functions in modules like this is a simple way to structure embedding; code\nin the module file can be changed arbitrarily without having to recompile the C program\nthat runs it. It also provides a direct communication model: inputs and outputs to\nPython code can take the form of function arguments and return values.\nRunning Strings in Dictionaries\nWhen we used PyRun_String earlier to run expressions with results, code was executed\nin the namespace of an existing Python module. Sometimes, though, it\u2019s more con-\nvenient to create a brand-new namespace for running code strings that is independent\nof any existing module files. The C file in Example 20-28 shows how; the new name-\nspace is created as a new Python dictionary object, and a handful of new API calls are\nemployed in the process:\nPyDict_New\nMakes a new empty dictionary object\nPyDict_SetItemString\nAssigns to a dictionary\u2019s key\nPyDict_GetItemString\nFetches (indexes) a dictionary value by key\nPyRun_String\nRuns a code string in namespaces, as before\nPyEval_GetBuiltins\nGets the built-in scope\u2019s module\nThe main trick here is the new dictionary. Inputs and outputs for the embedded code\nstrings are mapped to this dictionary by passing it as the code\u2019s namespace dictionaries\nin the PyRun_String call. The net effect is that the C program in Example 20-28 works\njust like this Python code:\n >>> d = {}\n >>> d['Y'] = 2\n >>> exec('X = 99', d, d)\n >>> exec('X = X + Y', d, d)\n >>> print(d['X'])\n 101\nBut here, each Python operation is replaced by a C API call.\n1526 | Chapter 20:\u2002Python/C IntegrationExample 20-28. PP4E\\Integrate\\Embed\\Basics\\embed-dict.c\n/* make a new dictionary for code string namespace */\n#include <Python.h>\nmain() {\n    int cval;\n    PyObject *pdict, *pval;\n    printf(\"embed-dict\\n\");\n    Py_Initialize();\n    /* make a new namespace */\n    pdict = PyDict_New();\n    PyDict_SetItemString(pdict, \"__builtins__\", PyEval_GetBuiltins());\n    PyDict_SetItemString(pdict, \"Y\", PyLong_FromLong(2));  /* dict['Y'] = 2   */\n    PyRun_String(\"X = 99\",  Py_file_input, pdict, pdict);  /* run statements  */\n    PyRun_String(\"X = X+Y\", Py_file_input, pdict, pdict);  /* same X and Y    */\n    pval = PyDict_GetItemString(pdict, \"X\");               /* fetch dict['X'] */\n    PyArg_Parse(pval, \"i\", &cval);                         /* convert to C */\n    printf(\"%d\\n\", cval);                                  /* result=101 */\n    Py_DECREF(pdict);\n    Py_Finalize();\n}\nWhen compiled and run, this C program creates this sort of output, tailored for this\nuse case:\n.../PP4E/Integrate/Embed/Basics$ ./embed-dict\nembed-dict\n101\nThe output is different this time: it reflects the value of the Python variable X assigned\nby the embedded Python code strings and fetched by C. In general, C can fetch module\nattributes either by calling PyObject_GetAttrString with the module or by using\nPyDict_GetItemString to index the module\u2019s attribute dictionary (expression strings\nwork, too, but they are less direct). Here, there is no module at all, so dictionary in-\ndexing is used to access the code\u2019s namespace in C.\nBesides allowing you to partition code string namespaces independent of any Python\nmodule files on the underlying system, this scheme provides a natural communication\nmechanism. Values that are stored in the new dictionary before code is run serve as\ninputs, and names assigned by the embedded code can later be fetched out of the dic-\ntionary to serve as code outputs. For instance, the variable Y in the second string run\nrefers to a name set to 2 by C; X is assigned by the Python code and fetched later by C\ncode as the printed result.\nBasic Embedding Techniques | 1527There is one subtlety in this embedding mode: dictionaries that serve as namespaces\nfor running code are generally required to have a __builtins__ link to the built-in scope\nsearched last for name lookups, set with code of this form:\nPyDict_SetItemString(pdict, \"__builtins__\", PyEval_GetBuiltins());\nThis is esoteric, and it is normally handled by Python internally for modules and built-\nins like the exec function. For raw dictionaries used as namespaces, though, we are\nresponsible for setting the link manually if we expect to reference built-in names. This\nstill holds true in Python 3.X.\nPrecompiling Strings to Bytecode\nFinally, when you call Python function objects from C, you are actually running the\nalready compiled bytecode associated with the object (e.g., a function body), normally\ncreated when the enclosing module is imported. When running strings, Python must\ncompile the string before running it. Because compilation is a slow process, this can be\na substantial overhead if you run a code string more than once. Instead, precompile\nthe string to a bytecode object to be run later, using the API calls illustrated in\nExample 20-29:\nPy_CompileString\nCompiles a string of code and returns a bytecode object\nPyEval_EvalCode\nRuns a compiled bytecode object\nThe first of these takes the mode flag that is normally passed to PyRun_String, as well\nas a second string argument that is used only in error messages. The second takes two\nnamespace dictionaries. These two API calls are used in Example 20-29 to compile and\nexecute three strings of Python code in turn.\nExample 20-29. PP4E\\Integrate\\Embed\\Basics\\embed-bytecode.c\n/* precompile code strings to bytecode objects */\n#include <Python.h>\n#include <compile.h>\n#include <eval.h>\nmain() {\n    int i;\n    char *cval;\n    PyObject *pcode1, *pcode2, *pcode3, *presult, *pdict;\n    char *codestr1, *codestr2, *codestr3;\n    printf(\"embed-bytecode\\n\");\n    Py_Initialize();\n    codestr1 = \"import usermod\\nprint(usermod.message)\";    /* statements */\n    codestr2 = \"usermod.transform(usermod.message)\";        /* expression */\n    codestr3 = \"print('%d:%d' % (X, X ** 2), end=' ')\";     /* use input X */\n1528 | Chapter 20:\u2002Python/C Integration/* make new namespace dictionary */\n    pdict = PyDict_New();\n    if (pdict == NULL) return \u22121;\n    PyDict_SetItemString(pdict, \"__builtins__\", PyEval_GetBuiltins());\n    /* precompile strings of code to bytecode objects */\n    pcode1 = Py_CompileString(codestr1, \"<embed>\", Py_file_input);\n    pcode2 = Py_CompileString(codestr2, \"<embed>\", Py_eval_input);\n    pcode3 = Py_CompileString(codestr3, \"<embed>\", Py_file_input);\n    /* run compiled bytecode in namespace dict */\n    if (pcode1 && pcode2 && pcode3) {\n        (void)    PyEval_EvalCode((PyCodeObject *)pcode1, pdict, pdict);\n        presult = PyEval_EvalCode((PyCodeObject *)pcode2, pdict, pdict);\n        PyArg_Parse(presult, \"s\", &cval);\n        printf(\"%s\\n\", cval);\n        Py_DECREF(presult);\n        /* rerun code object repeatedly */\n        for (i = 0; i <= 10; i++) {\n            PyDict_SetItemString(pdict, \"X\", PyLong_FromLong(i));\n            (void) PyEval_EvalCode((PyCodeObject *)pcode3, pdict, pdict);\n        }\n        printf(\"\\n\");\n    }\n    /* free referenced objects */\n    Py_XDECREF(pdict);\n    Py_XDECREF(pcode1);\n    Py_XDECREF(pcode2);\n    Py_XDECREF(pcode3);\n    Py_Finalize();\n}\nThis program combines a variety of techniques that we\u2019ve already seen. The namespace\nin which the compiled code strings run, for instance, is a newly created dictionary (not\nan existing module object), and inputs for code strings are passed as preset variables\nin the namespace. When built and executed, the first part of the output is similar to\nprevious examples in this section, but the last line represents running the same pre-\ncompiled code string 11 times:\n.../PP4E/Integrate/Embed/Basics$ embed-bytecode\nembed-bytecode\nThe meaning of life...\nTHE MEANING OF PYTHON...\n0:0 1:1 2:4 3:9 4:16 5:25 6:36 7:49 8:64 9:81 10:100\nIf your system executes Python code strings multiple times, it is a major speedup to\nprecompile to bytecode in this fashion. This step is not required in other contexts that\ninvoke callable Python objects\u2014including the common embedding use case presented\nin the next section.\nBasic Embedding Techniques | 1529Registering Callback Handler Objects\nIn the embedding examples thus far, C has been running and calling Python code from\na standard main program flow of control. Things are not always so simple, though; in\nsome cases, programs are modeled on an event-driven architecture in which code is\nexecuted only in response to some sort of event. The event might be an end user clicking\na button in a GUI, the operating system delivering a signal, or simply software running\nan action associated with an entry in a table.\nIn any event (pun accidental), program code in such an architecture is typically struc-\ntured as callback handlers\u2014units of code invoked by event-processing dispatch logic.\nIt\u2019s easy to use embedded Python code to implement callback handlers in such a system;\nin fact, the event-processing layer can simply use the embedded-call API tools we saw\nearlier in this chapter to run Python handlers.\nThe only new trick in this model is how to make the C layer know what code should\nbe run for each event. Handlers must somehow be registered to C to associate them\nwith future events. In general, there is a wide variety of ways to achieve this code/event\nassociation. For instance, C programs can:\n\u2022 Fetch and call functions by event name from one or more module files\n\u2022 Fetch and run code strings associated with event names in a database\n\u2022 Extract and run code associated with event tags in HTML or XML\n\u2022 Run Python code that calls back to C to tell it what should be run\nAnd so on. Really, any place you can associate objects or strings with identifiers is a\npotential callback registration mechanism. Some of these techniques have advantages\nall their own. For instance, callbacks fetched from module files support dynamic re-\nloading (imp.reload works on modules but does not update objects held directly). And\nnone of the first three schemes require users to code special Python programs that do\nnothing but register handlers to be run later.\nIt is perhaps more common, though, to register callback handlers with the last\napproach\u2014letting Python code register handlers with C by calling back to C through\nextension interfaces. Although this scheme is not without trade-offs, it can provide a\nnatural and direct model in scenarios where callbacks are associated with a large num-\nber of objects.\nFor instance, consider a GUI constructed by building a tree of widget objects in Python\nscripts. If each widget object in the tree can have an associated event handler, it may\nbe easier to register handlers by simply calling methods of widgets in the tree. Associ-\nating handlers with widget objects in a separate structure such as a module file or an\nXML file requires extra cross-reference work to keep the handlers in sync with the tree.\nIn fact, if you\u2019re looking for a more realistic example of Python callback handlers,\nconsider the tkinter GUI system we\u2019ve used extensively in this book. tkinter uses both\n1530 | Chapter 20:\u2002Python/C Integrationextending and embedding. Its extending interface (widget objects) is used to register\nPython callback handlers, which are later run with embedding interfaces in response to\nGUI events. You can study tkinter\u2019s implementation in the Python source distribution\nfor more details; its Tk library interface logic makes it a somewhat challenging read,\nbut the basic model it employs is straightforward.\nRegistration Implementation\nThis section\u2019s C and Python files demonstrate the coding techniques used to implement\nexplicitly registered callback handlers. First, the C file in Example 20-30 implements\ninterfaces for registering Python handlers, as well as code to run those handlers in\nresponse to later events:\nEvent router\nThe Route_Event function responds to an event by calling a Python function object\npreviously passed from Python to C.\nCallback registration\nThe Register_Handler function saves a passed-in Python function object pointer\nin a C global variable. Python scripts call Register_Handler through a simple\ncregister C extension module created by this file.\nEvent trigger\nTo simulate real-world events, the Trigger_Event function can be called from\nPython through the generated C module to trigger an event.\nIn other words, this example uses both the embedding and the extending interfaces\nwe\u2019ve already met to register and invoke Python event handler code. Study Exam-\nple 20-30 for more on its operation.\nExample 20-30. PP4E\\Integrate\\Embed\\Regist\\cregister.c\n#include <Python.h>\n#include <stdlib.h>\n/***********************************************/\n/* 1) code to route events to Python object    */\n/* note that we could run strings here instead */\n/***********************************************/\nstatic PyObject *Handler = NULL;     /* keep Python object in C */\nvoid Route_Event(char *label, int count)\n{\n    char *cres;\n    PyObject *args, *pres;\n    /* call Python handler */\n    args = Py_BuildValue(\"(si)\", label, count);   /* make arg-list */\n    pres = PyEval_CallObject(Handler, args);      /* apply: run a call */\n    Py_DECREF(args);                              /* add error checks */\nRegistering Callback Handler Objects | 1531if (pres != NULL) {\n        /* use and decref handler result */\n        PyArg_Parse(pres, \"s\", &cres);\n        printf(\"%s\\n\", cres);\n        Py_DECREF(pres);\n    }\n}\n/*****************************************************/\n/* 2) python extension module to register handlers   */\n/* python imports this module to set handler objects */\n/*****************************************************/\nstatic PyObject *\nRegister_Handler(PyObject *self, PyObject *args)\n{\n    /* save Python callable object */\n    Py_XDECREF(Handler);                 /* called before? */\n    PyArg_Parse(args, \"(O)\", &Handler);  /* one argument */\n    Py_XINCREF(Handler);                 /* add a reference */\n    Py_INCREF(Py_None);                  /* return 'None': success */\n    return Py_None;\n}\nstatic PyObject *\nTrigger_Event(PyObject *self, PyObject *args)\n{\n    /* let Python simulate event caught by C */\n    static count = 0;\n    Route_Event(\"spam\", count++);\n    Py_INCREF(Py_None);\n    return Py_None;\n}\nstatic PyMethodDef cregister_methods[] = {\n    {\"setHandler\",    Register_Handler, METH_VARARGS, \"\"},  /* name, &func,... */\n    {\"triggerEvent\",  Trigger_Event,    METH_VARARGS, \"\"},\n    {NULL, NULL, 0, NULL}                                   /* end of table */\n};\nstatic struct PyModuleDef cregistermodule = {\n   PyModuleDef_HEAD_INIT,\n   \"cregister\",       /* name of module */\n   \"cregister mod\",   /* module documentation, may be NULL */\n   \u22121,                /* size of per-interpreter module state, \u22121=in global vars */\n   cregister_methods  /* link to methods table */\n};\nPyMODINIT_FUNC\nPyInit_cregister()                      /* called on first import */\n{\n    return PyModule_Create(&cregistermodule);\n}\n1532 | Chapter 20:\u2002Python/C IntegrationUltimately, this C file is an extension module for Python, not a standalone C program\nthat embeds Python (though C could just as well be on top). To compile it into a\ndynamically loaded module file, run the makefile in Example 20-31 on Cygwin (and\nuse something similar on other platforms). As we learned earlier in this chapter, the\nresulting cregister.dll file will be loaded when first imported by a Python script if it is\nplaced in a directory on Python\u2019s module search path (e.g., in . or PYTHONPATH settings).\nExample 20-31. PP4E\\Integrate\\Embed\\Regist\\makefile.regist\n######################################################################\n# Cygwin makefile that builds cregister.dll. a dynamically loaded\n# C extension module (shareable), which is imported by register.py\n######################################################################\nPYLIB = /usr/local/bin\nPYINC = /usr/local/include/python3.1\nCMODS = cregister.dll\nall: $(CMODS)\ncregister.dll: cregister.c\n        gcc cregister.c -g -I$(PYINC) -shared -L$(PYLIB) -lpython3.1 -o $@\nclean:\n        rm -f *.pyc $(CMODS)\nNow that we have a C extension module set to register and dispatch Python handlers,\nall we need are some Python handlers. The Python module shown in Example 20-32\ndefines two callback handler functions and imports the C extension module to register\nhandlers and trigger events.\nExample 20-32. PP4E\\Integrate\\Embed\\Regist\\register.py\n\"\"\"\n#########################################################################\nin Python, register for and handle event callbacks from the C language;\ncompile and link the C code, and launch this with 'python register.py'\n#########################################################################\n\"\"\"\n####################################\n# C calls these Python functions;\n# handle an event, return a result\n####################################\ndef callback1(label, count):\n    return 'callback1 => %s number %i' % (label, count)\ndef callback2(label, count):\n    return 'callback2 => ' +  label * count\nRegistering Callback Handler Objects | 1533#######################################\n# Python calls a C extension module\n# to register handlers, trigger events\n#######################################\nimport cregister\nprint('\\nTest1:')\ncregister.setHandler(callback1)      # register callback function\nfor i in range(3):\n    cregister.triggerEvent()         # simulate events caught by C layer\nprint('\\nTest2:')\ncregister.setHandler(callback2)\nfor i in range(3):\n    cregister.triggerEvent()         # routes these events to callback2\nThat\u2019s it\u2014the Python/C callback integration is set to go. To kick off the system, run\nthe Python script; it registers one handler function, forces three events to be triggered,\nand then changes the event handler and does it again:\n.../PP4E/Integrate/Embed/Regist$ make -f makefile.regist\ngcc cregister.c -g -I/usr/local/include/python3.1 -shared -L/usr/local/bin\n-lpython3.1 -o cregister.dll\n.../PP4E/Integrate/Embed/Regist$ python register.py\nTest1:\ncallback1 => spam number 0\ncallback1 => spam number 1\ncallback1 => spam number 2\nTest2:\ncallback2 => spamspamspam\ncallback2 => spamspamspamspam\ncallback2 => spamspamspamspamspam\nThis output is printed by the C event router function, but its content is the return values\nof the handler functions in the Python module. Actually, something pretty wild is going\non under the hood. When Python forces an event to trigger, control flows between\nlanguages like this:\n1. From Python to the C event router function\n2. From the C event router function to the Python handler function\n3. Back to the C event router function (where the output is printed)\n4. And finally back to the Python script\nThat is, we jump from Python to C to Python and back again. Along the way, control\npasses through both extending and embedding interfaces. When the Python callback\nhandler is running, two Python levels are active, and one C level in the middle. Luckily,\nthis just works; Python\u2019s API is reentrant, so you don\u2019t need to be concerned about\n1534 | Chapter 20:\u2002Python/C Integrationhaving multiple Python interpreter levels active at the same time. Each level runs dif-\nferent code and operates independently.\nTrace through this example\u2019s output and code for more illumination. Here, we\u2019re\nmoving on to the last quick example we have time and space to explore\u2014in the name\nof symmetry, using Python classes from C.\nUsing Python Classes in C\nEarlier in this chapter, we learned how to use C++ classes in Python by wrapping them\nwith SWIG. But what about going the other way\u2014using Python classes from other\nlanguages? It turns out that this is really just a matter of applying interfaces already\nshown.\nRecall that Python scripts generate class instance objects by calling class objects as\nthough they were functions. To do this from C (or C++), simply follow the same steps:\nimport a class from a module, build an arguments tuple, and call it to generate an\ninstance using the same C API tools you use to call Python functions. Once you\u2019ve got\nan instance, you can fetch its attributes and methods with the same tools you use to\nfetch globals out of a module. Callables and attributes work the same everywhere they\nlive.\nTo illustrate how this works in practice, Example 20-33 defines a simple Python class\nin a module that we can utilize from C.\nExample 20-33. PP4E\\Integrate\\Embed\\Pyclasss\\module.py\n# call this class from C to make objects\nclass klass:\n    def method(self, x, y):\n        return \"brave %s %s\" % (x, y)     # run me from C\nThis is nearly as simple as it gets, but it\u2019s enough to illustrate the basics. As usual, make\nsure that this module is on your Python search path (e.g., in the current directory, or\none listed on your PYTHONPATH setting), or else the import call to access it from C will\nfail, just as it would in a Python script. As you surely know if you\u2019ve gotten this far in\nthis book, you can make always use of this Python class from a Python program as\nfollows:\n...\\PP4E\\Integrate\\Embed\\Pyclass$ python\n>>> import module                                   # import the file\n>>> object = module.klass()                         # make class instance\n>>> result = object.method('sir', 'robin')          # call class method\n>>> print(result)\nbrave sir robin\nUsing Python Classes in C | 1535This is fairly easy stuff in Python. You can do all of these operations in C, too, but it\ntakes a bit more code. The C file in Example 20-34 implements these steps by arranging\ncalls to the appropriate Python API tools.\nExample 20-34. PP4E\\Integrate\\Embed\\Pyclass\\objects.c\n#include <Python.h>\n#include <stdio.h>\nmain() {\n  /* run objects with low-level calls */\n  char *arg1=\"sir\", *arg2=\"robin\", *cstr;\n  PyObject *pmod, *pclass, *pargs, *pinst, *pmeth, *pres;\n  /* instance = module.klass() */\n  Py_Initialize();\n  pmod   = PyImport_ImportModule(\"module\");         /* fetch module */\n  pclass = PyObject_GetAttrString(pmod, \"klass\");   /* fetch module.class */\n  Py_DECREF(pmod);\n  pargs  = Py_BuildValue(\"()\");\n  pinst  = PyEval_CallObject(pclass, pargs);        /* call class() */\n  Py_DECREF(pclass);\n  Py_DECREF(pargs);\n  /* result = instance.method(x,y) */\n  pmeth  = PyObject_GetAttrString(pinst, \"method\"); /* fetch bound method */\n  Py_DECREF(pinst);\n  pargs  = Py_BuildValue(\"(ss)\", arg1, arg2);       /* convert to Python */\n  pres   = PyEval_CallObject(pmeth, pargs);         /* call method(x,y) */\n  Py_DECREF(pmeth);\n  Py_DECREF(pargs);\n  PyArg_Parse(pres, \"s\", &cstr);                    /* convert to C */\n  printf(\"%s\\n\", cstr);\n  Py_DECREF(pres);\n}\nStep through this source file for more details; it\u2019s mostly a matter of figuring out how\nyou would accomplish the task in Python, and then calling equivalent C functions in\nthe Python API. To build this source into a C executable program, run the makefile in\nthis file\u2019s directory in the book examples package (it\u2019s analogous to makefiles we\u2019ve\nalready seen, so we\u2019ll omit it here). After compiling, run it as you would any other C\nprogram:\n.../PP4E/Integrate/Embed/Pyclass$ ./objects\nbrave sir robin\nThis output might seem anticlimactic, but it actually reflects the return values sent back\nto C by the Python class method in file module.py. C did a lot of work to get this little\nstring\u2014it imported the module, fetched the class, made an instance, and fetched and\ncalled the instance method with a tuple of arguments, performing data conversions and\n1536 | Chapter 20:\u2002Python/C Integrationreference count management every step of the way. In return for all the work, C gets\nto use the techniques shown in this file to reuse any Python class.\nOf course, this example could be more complex in practice. As mentioned earlier, you\ngenerally need to check the return value of every Python API call to make sure it didn\u2019t\nfail. The module import call in this C code, for instance, can fail easily if the module\nisn\u2019t on the search path; if you don\u2019t trap the NULL pointer result, your program will\nalmost certainly crash when it tries to use the pointer (at least eventually). Exam-\nple 20-35 is a recoding of Example 20-34 with full error-checking; it\u2019s big, but it\u2019s\nrobust.\nExample 20-35. PP4E\\Integrate\\Embed\\Pyclasss\\objects-err.c\n#include <Python.h>\n#include <stdio.h>\n#define error(msg) do { printf(\"%s\\n\", msg); exit(1); } while (1)\nmain() {\n  /* run objects with low-level calls and full error checking */\n  char *arg1=\"sir\", *arg2=\"robin\", *cstr;\n  PyObject *pmod, *pclass, *pargs, *pinst, *pmeth, *pres;\n  /* instance = module.klass() */\n  Py_Initialize();\n  pmod = PyImport_ImportModule(\"module\");           /* fetch module */\n  if (pmod == NULL)\n      error(\"Can't load module\");\n  pclass = PyObject_GetAttrString(pmod, \"klass\");   /* fetch module.class */\n  Py_DECREF(pmod);\n  if (pclass == NULL)\n      error(\"Can't get module.klass\");\n  pargs = Py_BuildValue(\"()\");\n  if (pargs == NULL) {\n      Py_DECREF(pclass);\n      error(\"Can't build arguments list\");\n  }\n  pinst = PyEval_CallObject(pclass, pargs);         /* call class() */\n  Py_DECREF(pclass);\n  Py_DECREF(pargs);\n  if (pinst == NULL)\n      error(\"Error calling module.klass()\");\n  /* result = instance.method(x,y) */\n  pmeth  = PyObject_GetAttrString(pinst, \"method\"); /* fetch bound method */\n  Py_DECREF(pinst);\n  if (pmeth == NULL)\n      error(\"Can't fetch klass.method\");\n  pargs = Py_BuildValue(\"(ss)\", arg1, arg2);        /* convert to Python */\n  if (pargs == NULL) {\n      Py_DECREF(pmeth);\n      error(\"Can't build arguments list\");\nUsing Python Classes in C | 1537}\n  pres = PyEval_CallObject(pmeth, pargs);           /* call method(x,y) */\n  Py_DECREF(pmeth);\n  Py_DECREF(pargs);\n  if (pres == NULL)\n      error(\"Error calling klass.method\");\n  if (!PyArg_Parse(pres, \"s\", &cstr))               /* convert to C */\n     error(\"Can't convert klass.method result\");\n  printf(\"%s\\n\", cstr);\n  Py_DECREF(pres);\n}\nThese 53 lines of C code (not counting its makefile) achieve the same results as the\n4 lines of interactive Python we ran earlier\u2014not exactly a stellar result from a developer\nproductivity perspective! Nevertheless, the model it uses allows C and C++ to leverage\nPython in the same way that Python can employ C and C++. As I\u2019ll discuss in this\nbook\u2019s conclusion in a moment, such combinations can often be more powerful than\ntheir individual parts.\nOther Integration Topics\nIn this chapter, the term integration has largely meant mixing Python with components\nwritten in C or C++ (or other C-compatible languages) in extending and embedding\nmodes. But from a broader perspective, integration also includes any other technology\nthat lets us mix Python components into larger, heterogeneous systems. To wrap up\nthis chapter, this last section briefly summarizes a handful of commonly used integra-\ntion technologies beyond the C API tools we\u2019ve explored.\nJython: Java integration\nWe first met Jython in Chapter 12 and it was discussed earlier in this chapter in\nthe context of extending. Really, though, Jython is a broader integration platform.\nJython compiles Python code to Java bytecode for execution on the JVM. The\nresulting Java-based system directly supports two kinds of integration:\n\u2022 Extending: Jython uses Java\u2019s reflection API to allow Python programs to call\nout to Java class libraries automatically. The Java reflection API provides Java\ntype information at runtime and serves the same purpose as the glue code we\u2019ve\ngenerated to plug C libraries into Python in this part of the book. In Jython,\nhowever, this runtime type information allows largely automated resolution of\nJava calls in Python scripts\u2014no glue code has to be written or generated.\n\u2022 Embedding: Jython also provides a Java PythonInterpreter class API that allows\nJava programs to run Python code in a namespace, much like the C API tools\nwe\u2019ve used to run Python code strings from C programs. In addition, because\nJython implements all Python objects as instances of a Java PyObject class, it is\nstraightforward for the Java layer that encloses embedded Python code to proc-\ness Python objects.\n1538 | Chapter 20:\u2002Python/C IntegrationIn other words, Jython allows Python to be both extended and embedded in Java,\nmuch like the C integration strategies we\u2019ve seen in this part of the book. By adding\na simpler scripting language to Java applications, Jython serves many of the same\nroles as the C integration tools we\u2019ve studied.\nOn the downside, Jython tends to lag behind CPython developments, and its re-\nliance on Java class libraries and execution environments introduces Java depend-\nencies that may be a factor in some Python-oriented development scenarios. Nev-\nertheless, Jython provides a remarkably seamless integration model and serves as\nan ideal scripting language for Java applications. For more on Jython, check it out\nonline at http://www.jython.org and search the Web at large.\nIronPython: C#/.NET integration\nAlso mentioned earlier, IronPython does for C#/.NET what Jython does for Java\n(and in fact shares a common inventor)\u2014it provides seamless integration between\nPython code and software components written for the .NET framework, as well as\nits Mono implementation on Linux. Like Jython, IronPython compiles Python\nsource code to the .NET system\u2019s bytecode format and runs programs on the sys-\ntem\u2019s runtime engine. As a result, integration with external components is similarly\nseamless. Also like Jython, the net effect is to turn Python into an easy-to-use\nscripting language for C#/.NET-based applications and a general-purpose rapid\ndevelopment tool that complements C#. For more details on IronPython, visit\nhttp://www.ironpython.org or your friendly neighborhood search engine.\nCOM integration on Windows\nCOM defines a standard and language-neutral object model with which compo-\nnents written in a variety of programming languages may integrate and commu-\nnicate. Python\u2019s PyWin32 Windows extension package allows Python programs\nto implement both server and client in the COM interface model. As such, it pro-\nvides an automated way to integrate Python programs with programs written in\nother COM-aware languages such as Visual Basic. Python scripts can also use COM\ncalls to script Microsoft applications such as Word and Excel, because these sys-\ntems register COM object interfaces. On the other hand, COM implies a level of\ndispatch indirection overhead and is not as platform agnostic as other approaches\nlisted here. For more information on COM support and other Windows exten-\nsions, see the Web and refer to O\u2019Reilly\u2019s Python Programming on Win32, by Mark\nHammond and Andy Robinson.\nCORBA integration\nThere is also much open source support for using Python in the context of a\nCORBA-based application. CORBA stands for the Common Object Request\nBroker; it\u2019s a language-neutral way to distribute systems among communicating\ncomponents, which speak through an object model architecture. As such, it rep-\nresents another way to integrate Python components into a larger system. Python\u2019s\nCORBA support includes public domain systems such OmniORB. Like COM,\nOther Integration Topics | 1539CORBA is a large system\u2014too large for us to even scratch the surface in this text.\nFor more details, search the Web.\nOther languages\nAs we discussed at the end of our extending coverage, you\u2019ll also find direct support\nfor mixing Python with other languages, including FORTRAN, Objective-C, and\nothers. Many support both extending (calling out to the integrated languages) as\nwell as embedding (handling calls from the integrated language). See the prior\ndiscussion and the Web for more details. Some observers might also include the\nemerging pyjamas system in this category\u2014by compiling Python code to JavaScript\ncode, it allows Python programs to access AJAX and web browser\u2013based APIs in\nthe context of the Rich Internet Applications discussed earlier in this book; see\nChapters 7, 12, and 16.\nNetwork-based integration protocols\nFinally, there is also support in the Python world for Internet-based data transport\nprotocols, including SOAP, and XML-RPC. By routing calls across networks such\nsystems support distributed architectures, and give rise to the notion of web serv-\nices. XML-RPC is supported by a standard library module in Python, but search\nthe Web for more details on these protocols.\nAs you can see, there are many options in the integration domain. Perhaps the best\nparting advice I can give you is simply that different tools are meant for different tasks.\nC extension modules and types are ideal at optimizing systems and integrating libraries,\nbut frameworks offer other ways to integrate components\u2014Jython and IronPython for\nusing Java and .NETs, COM for reusing and publishing objects on Windows, XML-\nRPC for distributed services, and so on. As always, the best tools for your programs\nwill almost certainly be the best tools for your programs.\n1540 | Chapter 20:\u2002Python/C IntegrationPART VI\nThe End\nLike the first part of this book, this last part is a single chapter, this time a short one to \nprovide some parting context:\nChapter 21 \nThis chapter discusses Python\u2019s roles and scope. It explores some of the broader \nideas of Python\u2019s common roles, with the added perspective afforded by the rest \nof the book. Much of this chapter is philosophical in nature, but it underscores \nsome of the main reasons for using a tool like Python.\nNote that there are no reference appendixes here. For additional reference resources, \nconsult the Python standard manuals available online or commercially published ref-\nerence books, such as O\u2019Reilly\u2019s Python Pocket Reference and others you can find in \nthe usual places on the Web.\nFor additional Python core language material, see O\u2019Reilly\u2019s Learning Python. Among \nother things, the Fourth Edition of that book also explores more advanced API con-\nstruction tools such as properties, descriptors, decorators, and metaclasses, which we \nskipped here because they fall into the core language category. That book also explores \nUnicode text in more depth than we did here, since it\u2019s an inherent part of Python 3.\nAnd for help on other Python-related topics, see the resources available at Python\u2019s \nofficial website, http://www.python.org, or search the Web using your favorite search \nengine."}