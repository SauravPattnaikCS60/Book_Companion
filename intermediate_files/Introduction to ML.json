{"0": "INTRODUCTION\nTO\nMACHINE LEARNING\nAN EARLY DRAFT OF A PROPOSED\nTEXTBOOK\nNils J. Nilsson\nRobotics Laboratory\nDepartment of Computer Science\nStanford University\nStanford, CA 94305\ne-mail: nilsson@cs.stanford.edu\nNovember 3, 1998\nCopyright c\n\u20dd2005 Nils J. Nilsson\nThis material may not be copied, reproduced, or distributed without the\nwritten permission of the copyright holder.iiContents\n1\nPreliminaries\n1\n1.1\nIntroduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n1\n1.1.1\nWhat is Machine Learning? . . . . . . . . . . . . . . . . .\n1\n1.1.2\nWellsprings of Machine Learning . . . . . . . . . . . . . .\n3\n1.1.3\nVarieties of Machine Learning . . . . . . . . . . . . . . . .\n4\n1.2\nLearning Input-Output Functions . . . . . . . . . . . . . . . . . .\n5\n1.2.1\nTypes of Learning\n. . . . . . . . . . . . . . . . . . . . . .\n5\n1.2.2\nInput Vectors . . . . . . . . . . . . . . . . . . . . . . . . .\n7\n1.2.3\nOutputs . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n8\n1.2.4\nTraining Regimes . . . . . . . . . . . . . . . . . . . . . . .\n8\n1.2.5\nNoise\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n9\n1.2.6\nPerformance Evaluation . . . . . . . . . . . . . . . . . . .\n9\n1.3\nLearning Requires Bias . . . . . . . . . . . . . . . . . . . . . . . .\n9\n1.4\nSample Applications . . . . . . . . . . . . . . . . . . . . . . . . .\n11\n1.5\nSources\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n13\n1.6\nBibliographical and Historical Remarks\n. . . . . . . . . . . . . .\n13\n2\nBoolean Functions\n15\n2.1\nRepresentation . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n15\n2.1.1\nBoolean Algebra . . . . . . . . . . . . . . . . . . . . . . .\n15\n2.1.2\nDiagrammatic Representations . . . . . . . . . . . . . . .\n16\n2.2\nClasses of Boolean Functions\n. . . . . . . . . . . . . . . . . . . .\n17\n2.2.1\nTerms and Clauses . . . . . . . . . . . . . . . . . . . . . .\n17\n2.2.2\nDNF Functions . . . . . . . . . . . . . . . . . . . . . . . .\n18\n2.2.3\nCNF Functions . . . . . . . . . . . . . . . . . . . . . . . .\n21\n2.2.4\nDecision Lists . . . . . . . . . . . . . . . . . . . . . . . . .\n22\n2.2.5\nSymmetric and Voting Functions . . . . . . . . . . . . . .\n23\n2.2.6\nLinearly Separable Functions . . . . . . . . . . . . . . . .\n23\n2.3\nSummary\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n24\n2.4\nBibliographical and Historical Remarks\n. . . . . . . . . . . . . .\n25\niii3\nUsing Version Spaces for Learning\n27\n3.1\nVersion Spaces and Mistake Bounds\n. . . . . . . . . . . . . . . .\n27\n3.2\nVersion Graphs . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n29\n3.3\nLearning as Search of a Version Space\n. . . . . . . . . . . . . . .\n32\n3.4\nThe Candidate Elimination Method\n. . . . . . . . . . . . . . . .\n32\n3.5\nBibliographical and Historical Remarks\n. . . . . . . . . . . . . .\n34\n4\nNeural Networks\n35\n4.1\nThreshold Logic Units . . . . . . . . . . . . . . . . . . . . . . . .\n35\n4.1.1\nDe\ufb01nitions and Geometry . . . . . . . . . . . . . . . . . .\n35\n4.1.2\nSpecial Cases of Linearly Separable Functions . . . . . . .\n37\n4.1.3\nError-Correction Training of a TLU\n. . . . . . . . . . . .\n38\n4.1.4\nWeight Space . . . . . . . . . . . . . . . . . . . . . . . . .\n40\n4.1.5\nThe Widrow-Ho\ufb00Procedure . . . . . . . . . . . . . . . . .\n42\n4.1.6\nTraining a TLU on Non-Linearly-Separable Training Sets\n44\n4.2\nLinear Machines\n. . . . . . . . . . . . . . . . . . . . . . . . . . .\n44\n4.3\nNetworks of TLUs\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n46\n4.3.1\nMotivation and Examples . . . . . . . . . . . . . . . . . .\n46\n4.3.2\nMadalines . . . . . . . . . . . . . . . . . . . . . . . . . . .\n49\n4.3.3\nPiecewise Linear Machines . . . . . . . . . . . . . . . . . .\n50\n4.3.4\nCascade Networks\n. . . . . . . . . . . . . . . . . . . . . .\n51\n4.4\nTraining Feedforward Networks by Backpropagation . . . . . . .\n52\n4.4.1\nNotation . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n52\n4.4.2\nThe Backpropagation Method . . . . . . . . . . . . . . . .\n53\n4.4.3\nComputing Weight Changes in the Final Layer . . . . . .\n56\n4.4.4\nComputing Changes to the Weights in Intermediate Layers 58\n4.4.5\nVariations on Backprop\n. . . . . . . . . . . . . . . . . . .\n59\n4.4.6\nAn Application: Steering a Van . . . . . . . . . . . . . . .\n60\n4.5\nSynergies Between Neural Network and Knowledge-Based Methods 61\n4.6\nBibliographical and Historical Remarks\n. . . . . . . . . . . . . .\n61\n5\nStatistical Learning\n63\n5.1\nUsing Statistical Decision Theory . . . . . . . . . . . . . . . . . .\n63\n5.1.1\nBackground and General Method . . . . . . . . . . . . . .\n63\n5.1.2\nGaussian (or Normal) Distributions\n. . . . . . . . . . . .\n65\n5.1.3\nConditionally Independent Binary Components . . . . . .\n68\n5.2\nLearning Belief Networks\n. . . . . . . . . . . . . . . . . . . . . .\n70\n5.3\nNearest-Neighbor Methods . . . . . . . . . . . . . . . . . . . . . .\n70\n5.4\nBibliographical and Historical Remarks\n. . . . . . . . . . . . . .\n72\niv6\nDecision Trees\n73\n6.1\nDe\ufb01nitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n73\n6.2\nSupervised Learning of Univariate Decision Trees . . . . . . . . .\n74\n6.2.1\nSelecting the Type of Test . . . . . . . . . . . . . . . . . .\n75\n6.2.2\nUsing Uncertainty Reduction to Select Tests\n. . . . . . .\n75\n6.2.3\nNon-Binary Attributes . . . . . . . . . . . . . . . . . . . .\n79\n6.3\nNetworks Equivalent to Decision Trees . . . . . . . . . . . . . . .\n79\n6.4\nOver\ufb01tting and Evaluation\n. . . . . . . . . . . . . . . . . . . . .\n80\n6.4.1\nOver\ufb01tting\n. . . . . . . . . . . . . . . . . . . . . . . . . .\n80\n6.4.2\nValidation Methods\n. . . . . . . . . . . . . . . . . . . . .\n81\n6.4.3\nAvoiding Over\ufb01tting in Decision Trees . . . . . . . . . . .\n82\n6.4.4\nMinimum-Description Length Methods . . . . . . . . . . .\n83\n6.4.5\nNoise in Data . . . . . . . . . . . . . . . . . . . . . . . . .\n84\n6.5\nThe Problem of Replicated Subtrees . . . . . . . . . . . . . . . .\n84\n6.6\nThe Problem of Missing Attributes . . . . . . . . . . . . . . . . .\n86\n6.7\nComparisons\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n86\n6.8\nBibliographical and Historical Remarks\n. . . . . . . . . . . . . .\n87\n7\nInductive Logic Programming\n89\n7.1\nNotation and De\ufb01nitions . . . . . . . . . . . . . . . . . . . . . . .\n90\n7.2\nA Generic ILP Algorithm . . . . . . . . . . . . . . . . . . . . . .\n91\n7.3\nAn Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n94\n7.4\nInducing Recursive Programs . . . . . . . . . . . . . . . . . . . .\n98\n7.5\nChoosing Literals to Add\n. . . . . . . . . . . . . . . . . . . . . . 100\n7.6\nRelationships Between ILP and Decision Tree Induction . . . . . 101\n7.7\nBibliographical and Historical Remarks\n. . . . . . . . . . . . . . 104\n8\nComputational Learning Theory\n107\n8.1\nNotation and Assumptions for PAC Learning Theory . . . . . . . 107\n8.2\nPAC Learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n8.2.1\nThe Fundamental Theorem . . . . . . . . . . . . . . . . . 109\n8.2.2\nExamples . . . . . . . . . . . . . . . . . . . . . . . . . . . 111\n8.2.3\nSome Properly PAC-Learnable Classes . . . . . . . . . . . 112\n8.3\nThe Vapnik-Chervonenkis Dimension . . . . . . . . . . . . . . . . 113\n8.3.1\nLinear Dichotomies . . . . . . . . . . . . . . . . . . . . . . 113\n8.3.2\nCapacity\n. . . . . . . . . . . . . . . . . . . . . . . . . . . 115\n8.3.3\nA More General Capacity Result . . . . . . . . . . . . . . 116\n8.3.4\nSome Facts and Speculations About the VC Dimension\n. 117\n8.4\nVC Dimension and PAC Learning\n. . . . . . . . . . . . . . . . . 118\n8.5\nBibliographical and Historical Remarks\n. . . . . . . . . . . . . . 118\nv9\nUnsupervised Learning\n119\n9.1\nWhat is Unsupervised Learning? . . . . . . . . . . . . . . . . . . 119\n9.2\nClustering Methods . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n9.2.1\nA Method Based on Euclidean Distance . . . . . . . . . . 120\n9.2.2\nA Method Based on Probabilities . . . . . . . . . . . . . . 124\n9.3\nHierarchical Clustering Methods\n. . . . . . . . . . . . . . . . . . 125\n9.3.1\nA Method Based on Euclidean Distance . . . . . . . . . . 125\n9.3.2\nA Method Based on Probabilities . . . . . . . . . . . . . . 126\n9.4\nBibliographical and Historical Remarks\n. . . . . . . . . . . . . . 130\n10 Temporal-Di\ufb00erence Learning\n131\n10.1 Temporal Patterns and Prediction Problems . . . . . . . . . . . . 131\n10.2 Supervised and Temporal-Di\ufb00erence Methods . . . . . . . . . . . 131\n10.3 Incremental Computation of the (\u2206W)i . . . . . . . . . . . . . . 134\n10.4 An Experiment with TD Methods\n. . . . . . . . . . . . . . . . . 135\n10.5 Theoretical Results . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n10.6 Intra-Sequence Weight Updating . . . . . . . . . . . . . . . . . . 138\n10.7 An Example Application: TD-gammon . . . . . . . . . . . . . . . 140\n10.8 Bibliographical and Historical Remarks\n. . . . . . . . . . . . . . 141\n11 Delayed-Reinforcement Learning\n143\n11.1 The General Problem\n. . . . . . . . . . . . . . . . . . . . . . . . 143\n11.2 An Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n11.3 Temporal Discounting and Optimal Policies . . . . . . . . . . . . 145\n11.4 Q-Learning\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147\n11.5 Discussion, Limitations, and Extensions of Q-Learning . . . . . . 150\n11.5.1 An Illustrative Example . . . . . . . . . . . . . . . . . . . 150\n11.5.2 Using Random Actions\n. . . . . . . . . . . . . . . . . . . 152\n11.5.3 Generalizing Over Inputs\n. . . . . . . . . . . . . . . . . . 153\n11.5.4 Partially Observable States . . . . . . . . . . . . . . . . . 154\n11.5.5 Scaling Problems . . . . . . . . . . . . . . . . . . . . . . . 154\n11.6 Bibliographical and Historical Remarks\n. . . . . . . . . . . . . . 155\nvi12 Explanation-Based Learning\n157\n12.1 Deductive Learning . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n12.2 Domain Theories . . . . . . . . . . . . . . . . . . . . . . . . . . . 158\n12.3 An Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159\n12.4 Evaluable Predicates . . . . . . . . . . . . . . . . . . . . . . . . . 162\n12.5 More General Proofs . . . . . . . . . . . . . . . . . . . . . . . . . 164\n12.6 Utility of EBL\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . 164\n12.7 Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164\n12.7.1 Macro-Operators in Planning . . . . . . . . . . . . . . . . 164\n12.7.2 Learning Search Control Knowledge\n. . . . . . . . . . . . 167\n12.8 Bibliographical and Historical Remarks\n. . . . . . . . . . . . . . 168\nviiviiiPreface\nThese notes are in the process of becoming a textbook. The process is quite\nun\ufb01nished, and the author solicits corrections, criticisms, and suggestions from\nstudents and other readers. Although I have tried to eliminate errors, some un-\ndoubtedly remain\u2014caveat lector. Many typographical infelicities will no doubt\npersist until the \ufb01nal version. More material has yet to be added. Please let\nSome of my plans for additions and\nother reminders are mentioned in\nmarginal notes.\nme have your suggestions about topics that are too important to be left out.\nI hope that future versions will cover Hop\ufb01eld nets, Elman nets and other re-\ncurrent nets, radial basis functions, grammar and automata learning, genetic\nalgorithms, and Bayes networks . . .. I am also collecting exercises and project\nsuggestions which will appear in future versions.\nMy intention is to pursue a middle ground between a theoretical textbook\nand one that focusses on applications. The book concentrates on the important\nideas in machine learning. I do not give proofs of many of the theorems that I\nstate, but I do give plausibility arguments and citations to formal proofs. And, I\ndo not treat many matters that would be of practical importance in applications;\nthe book is not a handbook of machine learning practice. Instead, my goal is\nto give the reader su\ufb03cient preparation to make the extensive literature on\nmachine learning accessible.\nStudents in my Stanford courses on machine learning have already made\nseveral useful suggestions, as have my colleague, Pat Langley, and my teaching\nassistants, Ron Kohavi, Karl P\ufb02eger, Robert Allen, and Lise Getoor.\nixChapter 1\nPreliminaries\n1.1\nIntroduction\n1.1.1\nWhat is Machine Learning?\nLearning, like intelligence, covers such a broad range of processes that it is dif-\n\ufb01cult to de\ufb01ne precisely. A dictionary de\ufb01nition includes phrases such as \u201cto\ngain knowledge, or understanding of, or skill in, by study, instruction, or expe-\nrience,\u201d and \u201cmodi\ufb01cation of a behavioral tendency by experience.\u201d Zoologists\nand psychologists study learning in animals and humans. In this book we fo-\ncus on learning in machines. There are several parallels between animal and\nmachine learning. Certainly, many techniques in machine learning derive from\nthe e\ufb00orts of psychologists to make more precise their theories of animal and\nhuman learning through computational models. It seems likely also that the\nconcepts and techniques being explored by researchers in machine learning may\nilluminate certain aspects of biological learning.\nAs regards machines, we might say, very broadly, that a machine learns\nwhenever it changes its structure, program, or data (based on its inputs or in\nresponse to external information) in such a manner that its expected future\nperformance improves. Some of these changes, such as the addition of a record\nto a data base, fall comfortably within the province of other disciplines and are\nnot necessarily better understood for being called learning. But, for example,\nwhen the performance of a speech-recognition machine improves after hearing\nseveral samples of a person\u2019s speech, we feel quite justi\ufb01ed in that case to say\nthat the machine has learned.\nMachine learning usually refers to the changes in systems that perform tasks\nassociated with arti\ufb01cial intelligence (AI). Such tasks involve recognition, diag-\nnosis, planning, robot control, prediction, etc. The \u201cchanges\u201d might be either\nenhancements to already performing systems or ab initio synthesis of new sys-\ntems. To be slightly more speci\ufb01c, we show the architecture of a typical AI\n1", "1": "Chapter 1\nPreliminaries\n1.1\nIntroduction\n1.1.1\nWhat is Machine Learning?\nLearning, like intelligence, covers such a broad range of processes that it is dif-\n\ufb01cult to de\ufb01ne precisely. A dictionary de\ufb01nition includes phrases such as \u201cto\ngain knowledge, or understanding of, or skill in, by study, instruction, or expe-\nrience,\u201d and \u201cmodi\ufb01cation of a behavioral tendency by experience.\u201d Zoologists\nand psychologists study learning in animals and humans. In this book we fo-\ncus on learning in machines. There are several parallels between animal and\nmachine learning. Certainly, many techniques in machine learning derive from\nthe e\ufb00orts of psychologists to make more precise their theories of animal and\nhuman learning through computational models. It seems likely also that the\nconcepts and techniques being explored by researchers in machine learning may\nilluminate certain aspects of biological learning.\nAs regards machines, we might say, very broadly, that a machine learns\nwhenever it changes its structure, program, or data (based on its inputs or in\nresponse to external information) in such a manner that its expected future\nperformance improves. Some of these changes, such as the addition of a record\nto a data base, fall comfortably within the province of other disciplines and are\nnot necessarily better understood for being called learning. But, for example,\nwhen the performance of a speech-recognition machine improves after hearing\nseveral samples of a person\u2019s speech, we feel quite justi\ufb01ed in that case to say\nthat the machine has learned.\nMachine learning usually refers to the changes in systems that perform tasks\nassociated with arti\ufb01cial intelligence (AI). Such tasks involve recognition, diag-\nnosis, planning, robot control, prediction, etc. The \u201cchanges\u201d might be either\nenhancements to already performing systems or ab initio synthesis of new sys-\ntems. To be slightly more speci\ufb01c, we show the architecture of a typical AI\n12\nCHAPTER 1. PRELIMINARIES\n\u201cagent\u201d in Fig. 1.1. This agent perceives and models its environment and com-\nputes appropriate actions, perhaps by anticipating their e\ufb00ects. Changes made\nto any of the components shown in the \ufb01gure might count as learning. Di\ufb00erent\nlearning mechanisms might be employed depending on which subsystem is being\nchanged. We will study several di\ufb00erent learning methods in this book.\nSensory signals\nPerception\nActions\nAction\nComputation\nModel\nPlanning and\nReasoning\nGoals\nFigure 1.1: An AI System\nOne might ask \u201cWhy should machines have to learn? Why not design ma-\nchines to perform as desired in the \ufb01rst place?\u201d There are several reasons why\nmachine learning is important. Of course, we have already mentioned that the\nachievement of learning in machines might help us understand how animals and\nhumans learn. But there are important engineering reasons as well. Some of\nthese are:\n\u2022 Some tasks cannot be de\ufb01ned well except by example; that is, we might be\nable to specify input/output pairs but not a concise relationship between\ninputs and desired outputs. We would like machines to be able to adjust\ntheir internal structure to produce correct outputs for a large number of\nsample inputs and thus suitably constrain their input/output function to\napproximate the relationship implicit in the examples.\n\u2022 It is possible that hidden among large piles of data are important rela-\ntionships and correlations. Machine learning methods can often be used\nto extract these relationships (data mining).1.1. INTRODUCTION\n3\n\u2022 Human designers often produce machines that do not work as well as\ndesired in the environments in which they are used. In fact, certain char-\nacteristics of the working environment might not be completely known\nat design time.\nMachine learning methods can be used for on-the-job\nimprovement of existing machine designs.\n\u2022 The amount of knowledge available about certain tasks might be too large\nfor explicit encoding by humans.\nMachines that learn this knowledge\ngradually might be able to capture more of it than humans would want to\nwrite down.\n\u2022 Environments change over time. Machines that can adapt to a changing\nenvironment would reduce the need for constant redesign.\n\u2022 New knowledge about tasks is constantly being discovered by humans.\nVocabulary changes.\nThere is a constant stream of new events in the\nworld. Continuing redesign of AI systems to conform to new knowledge is\nimpractical, but machine learning methods might be able to track much\nof it.\n1.1.2\nWellsprings of Machine Learning\nWork in machine learning is now converging from several sources. These dif-\nferent traditions each bring di\ufb00erent methods and di\ufb00erent vocabulary which\nare now being assimilated into a more uni\ufb01ed discipline. Here is a brief listing\nof some of the separate disciplines that have contributed to machine learning;\nmore details will follow in the the appropriate chapters:\n\u2022 Statistics: A long-standing problem in statistics is how best to use sam-\nples drawn from unknown probability distributions to help decide from\nwhich distribution some new sample is drawn. A related problem is how\nto estimate the value of an unknown function at a new point given the\nvalues of this function at a set of sample points.\nStatistical methods\nfor dealing with these problems can be considered instances of machine\nlearning because the decision and estimation rules depend on a corpus of\nsamples drawn from the problem environment. We will explore some of\nthe statistical methods later in the book. Details about the statistical the-\nory underlying these methods can be found in statistical textbooks such\nas [Anderson, 1958].\n\u2022 Brain\nModels:\nNon-linear\nelements\nwith\nweighted\ninputs\nhave\nbeen\nsuggested\nas\nsimple\nmodels\nof\nbiological\nneu-\nrons.\nNetworks\nof\nthese\nelements\nhave\nbeen\nstudied\nby\nsev-\neral\nresearchers\nincluding\n[McCulloch & Pitts, 1943,\nHebb, 1949,\nRosenblatt, 1958] and,\nmore recently by [Gluck & Rumelhart, 1989,\nSejnowski, Koch, & Churchland, 1988].\nBrain modelers are interested\nin how closely these networks approximate the learning phenomena of4\nCHAPTER 1. PRELIMINARIES\nliving brains.\nWe shall see that several important machine learning\ntechniques are based on networks of nonlinear elements\u2014often called\nneural networks.\nWork inspired by this school is sometimes called\nconnectionism, brain-style computation, or sub-symbolic processing.\n\u2022 Adaptive Control Theory: Control theorists study the problem of con-\ntrolling a process having unknown parameters which must be estimated\nduring operation. Often, the parameters change during operation, and the\ncontrol process must track these changes. Some aspects of controlling a\nrobot based on sensory inputs represent instances of this sort of problem.\nFor an introduction see [Bollinger & Du\ufb03e, 1988].\n\u2022 Psychological Models: Psychologists have studied the performance of\nhumans in various learning tasks. An early example is the EPAM net-\nwork for storing and retrieving one member of a pair of words when\ngiven another [Feigenbaum, 1961].\nRelated work led to a number of\nearly decision tree [Hunt, Marin, & Stone, 1966] and semantic network\n[Anderson & Bower, 1973] methods.\nMore recent work of this sort has\nbeen in\ufb02uenced by activities in arti\ufb01cial intelligence which we will be pre-\nsenting.\nSome of the work in reinforcement learning can be traced to e\ufb00orts to\nmodel how reward stimuli in\ufb02uence the learning of goal-seeking behavior in\nanimals [Sutton & Barto, 1987]. Reinforcement learning is an important\ntheme in machine learning research.\n\u2022 Arti\ufb01cial Intelligence: From the beginning, AI research has been con-\ncerned with machine learning. Samuel developed a prominent early pro-\ngram that learned parameters of a function for evaluating board posi-\ntions in the game of checkers [Samuel, 1959].\nAI researchers have also\nexplored the role of analogies in learning [Carbonell, 1983] and how fu-\nture actions and decisions can be based on previous exemplary cases\n[Kolodner, 1993].\nRecent work has been directed at discovering rules\nfor expert systems using decision-tree methods [Quinlan, 1990] and in-\nductive logic programming [Muggleton, 1991, Lavra\u02c7\nc & D\u02c7\nzeroski, 1994].\nAnother theme has been saving and generalizing the results of prob-\nlem solving using explanation-based learning [DeJong & Mooney, 1986,\nLaird, et al., 1986, Minton, 1988, Etzioni, 1993].\n\u2022 Evolutionary Models:\nIn nature, not only do individual animals learn to perform better, but\nspecies evolve to be better \ufb01t in their individual niches. Since the distinc-\ntion between evolving and learning can be blurred in computer systems,\ntechniques that model certain aspects of biological evolution have been\nproposed as learning methods to improve the performance of computer\nprograms. Genetic algorithms [Holland, 1975] and genetic programming\n[Koza, 1992, Koza, 1994] are the most prominent computational tech-\nniques for evolution.1.2. LEARNING INPUT-OUTPUT FUNCTIONS\n5\n1.1.3\nVarieties of Machine Learning\nOrthogonal to the question of the historical source of any learning technique is\nthe more important question of what is to be learned. In this book, we take it\nthat the thing to be learned is a computational structure of some sort. We will\nconsider a variety of di\ufb00erent computational structures:\n\u2022 Functions\n\u2022 Logic programs and rule sets\n\u2022 Finite-state machines\n\u2022 Grammars\n\u2022 Problem solving systems\nWe will present methods both for the synthesis of these structures from examples\nand for changing existing structures.\nIn the latter case, the change to the\nexisting structure might be simply to make it more computationally e\ufb03cient\nrather than to increase the coverage of the situations it can handle. Much of\nthe terminology that we shall be using throughout the book is best introduced\nby discussing the problem of learning functions, and we turn to that matter\n\ufb01rst.\n1.2\nLearning Input-Output Functions\nWe use Fig. 1.2 to help de\ufb01ne some of the terminology used in describing the\nproblem of learning a function. Imagine that there is a function, f, and the task\nof the learner is to guess what it is. Our hypothesis about the function to be\nlearned is denoted by h. Both f and h are functions of a vector-valued input\nX = (x1, x2, . . . , xi, . . . , xn) which has n components. We think of h as being\nimplemented by a device that has X as input and h(X) as output. Both f and\nh themselves may be vector-valued. We assume a priori that the hypothesized\nfunction, h, is selected from a class of functions H. Sometimes we know that\nf also belongs to this class or to a subset of this class. We select h based on a\ntraining set, \u039e, of m input vector examples. Many important details depend on\nthe nature of the assumptions made about all of these entities.\n1.2.1\nTypes of Learning\nThere are two major settings in which we wish to learn a function. In one,\ncalled supervised learning, we know (sometimes only approximately) the values\nof f for the m samples in the training set, \u039e. We assume that if we can \ufb01nd\na hypothesis, h, that closely agrees with f for the members of \u039e, then this\nhypothesis will be a good guess for f\u2014especially if \u039e is large.6\nCHAPTER 1. PRELIMINARIES\nh(X)\nh\nU = {X1, X2, . . . Xi, . . ., Xm}\nTraining Set:\nX =\nx1\n.\n.\n.\nxi\n.\n.\n.\nxn\nh D H\nFigure 1.2: An Input-Output Function\nCurve-\ufb01tting is a simple example of supervised learning of a function. Sup-\npose we are given the values of a two-dimensional function, f, at the four sample\npoints shown by the solid circles in Fig. 1.3. We want to \ufb01t these four points\nwith a function, h, drawn from the set, H, of second-degree functions. We show\nthere a two-dimensional parabolic surface above the x1, x2 plane that \ufb01ts the\npoints. This parabolic function, h, is our hypothesis about the function, f, that\nproduced the four samples. In this case, h = f at the four samples, but we need\nnot have required exact matches.\nIn the other setting, termed unsupervised learning, we simply have a train-\ning set of vectors without function values for them. The problem in this case,\ntypically, is to partition the training set into subsets, \u039e1, . . . , \u039eR, in some ap-\npropriate way. (We can still regard the problem as one of learning a function;\nthe value of the function is the name of the subset to which an input vector be-\nlongs.) Unsupervised learning methods have application in taxonomic problems\nin which it is desired to invent ways to classify data into meaningful categories.\nWe shall also describe methods that are intermediate between supervised\nand unsupervised learning.\nWe might either be trying to \ufb01nd a new function, h, or to modify an existing\none. An interesting special case is that of changing an existing function into an\nequivalent one that is computationally more e\ufb03cient. This type of learning is\nsometimes called speed-up learning. A very simple example of speed-up learning\ninvolves deduction processes. From the formulas A \u2283B and B \u2283C, we can\ndeduce C if we are given A. From this deductive process, we can create the\nformula A \u2283C\u2014a new formula but one that does not sanction any more con-1.2. LEARNING INPUT-OUTPUT FUNCTIONS\n7\n-10\n-5\n0\n5\n10-10\n-5\n0\n5\n10\n0\n500\n1000\n1500\n-10\n-5\n0\n5\n10-10\n-5\n0\n5\n10\n0\n00\n00\n0\nx1\nx2\nh\nsample f-value\nFigure 1.3: A Surface that Fits Four Points\nclusions than those that could be derived from the formulas that we previously\nhad. But with this new formula we can derive C more quickly, given A, than\nwe could have done before. We can contrast speed-up learning with methods\nthat create genuinely new functions\u2014ones that might give di\ufb00erent results after\nlearning than they did before. We say that the latter methods involve inductive\nlearning. As opposed to deduction, there are no correct inductions\u2014only useful\nones.\n1.2.2\nInput Vectors\nBecause machine learning methods derive from so many di\ufb00erent traditions, its\nterminology is rife with synonyms, and we will be using most of them in this\nbook. For example, the input vector is called by a variety of names. Some\nof these are: input vector, pattern vector, feature vector, sample, example, and\ninstance. The components, xi, of the input vector are variously called features,\nattributes, input variables, and components.\nThe values of the components can be of three main types.\nThey might\nbe real-valued numbers, discrete-valued numbers, or categorical values. As an\nexample illustrating categorical values, information about a student might be\nrepresented by the values of the attributes class, major, sex, adviser. A par-\nticular student would then be represented by a vector such as: (sophomore,\nhistory, male, higgins). Additionally, categorical values may be ordered (as in\n{small, medium, large}) or unordered (as in the example just given). Of course,\nmixtures of all these types of values are possible.\nIn all cases, it is possible to represent the input in unordered form by listing\nthe names of the attributes together with their values. The vector form assumes\nthat the attributes are ordered and given implicitly by a form. As an example\nof an attribute-value representation, we might have: (major: history, sex: male,8\nCHAPTER 1. PRELIMINARIES\nclass: sophomore, adviser: higgins, age: 19). We will be using the vector form\nexclusively.\nAn important specialization uses Boolean values, which can be regarded as\na special case of either discrete numbers (1,0) or of categorical variables (True,\nFalse).\n1.2.3\nOutputs\nThe output may be a real number, in which case the process embodying the\nfunction, h, is called a function estimator, and the output is called an output\nvalue or estimate.\nAlternatively, the output may be a categorical value, in which case the pro-\ncess embodying h is variously called a classi\ufb01er, a recognizer, or a categorizer,\nand the output itself is called a label, a class, a category, or a decision. Classi-\n\ufb01ers have application in a number of recognition problems, for example in the\nrecognition of hand-printed characters. The input in that case is some suitable\nrepresentation of the printed character, and the classi\ufb01er maps this input into\none of, say, 64 categories.\nVector-valued outputs are also possible with components being real numbers\nor categorical values.\nAn important special case is that of Boolean output values. In that case,\na training pattern having value 1 is called a positive instance, and a training\nsample having value 0 is called a negative instance. When the input is also\nBoolean, the classi\ufb01er implements a Boolean function. We study the Boolean\ncase in some detail because it allows us to make important general points in\na simpli\ufb01ed setting. Learning a Boolean function is sometimes called concept\nlearning, and the function is called a concept.\n1.2.4\nTraining Regimes\nThere are several ways in which the training set, \u039e, can be used to produce a\nhypothesized function. In the batch method, the entire training set is available\nand used all at once to compute the function, h. A variation of this method\nuses the entire training set to modify a current hypothesis iteratively until an\nacceptable hypothesis is obtained. By contrast, in the incremental method, we\nselect one member at a time from the training set and use this instance alone\nto modify a current hypothesis. Then another member of the training set is\nselected, and so on. The selection method can be random (with replacement)\nor it can cycle through the training set iteratively. If the entire training set\nbecomes available one member at a time, then we might also use an incremental\nmethod\u2014selecting and using training set members as they arrive. (Alterna-\ntively, at any stage all training set members so far available could be used in a\n\u201cbatch\u201d process.) Using the training set members as they become available is\ncalled an online method. Online methods might be used, for example, when the1.3. LEARNING REQUIRES BIAS\n9\nnext training instance is some function of the current hypothesis and the previ-\nous instance\u2014as it would be when a classi\ufb01er is used to decide on a robot\u2019s next\naction given its current set of sensory inputs. The next set of sensory inputs\nwill depend on which action was selected.\n1.2.5\nNoise\nSometimes the vectors in the training set are corrupted by noise. There are two\nkinds of noise. Class noise randomly alters the value of the function; attribute\nnoise randomly alters the values of the components of the input vector. In either\ncase, it would be inappropriate to insist that the hypothesized function agree\nprecisely with the values of the samples in the training set.\n1.2.6\nPerformance Evaluation\nEven though there is no correct answer in inductive learning, it is important\nto have methods to evaluate the result of learning. We will discuss this matter\nin more detail later, but, brie\ufb02y, in supervised learning the induced function is\nusually evaluated on a separate set of inputs and function values for them called\nthe testing set . A hypothesized function is said to generalize when it guesses\nwell on the testing set. Both mean-squared-error and the total number of errors\nare common measures.\n1.3\nLearning Requires Bias\nLong before now the reader has undoubtedly asked why is learning a function\npossible at all? Certainly, for example, there are an uncountable number of\ndi\ufb00erent functions having values that agree with the four samples shown in Fig.\n1.3. Why would a learning procedure happen to select the quadratic one shown\nin that \ufb01gure? In order to make that selection we had at least to limit a priori\nthe set of hypotheses to quadratic functions and then to insist that the one we\nchose passed through all four sample points. This kind of a priori information\nis called bias, and useful learning without bias is impossible.\nWe can gain more insight into the role of bias by considering the special case\nof learning a Boolean function of n dimensions. There are 2n di\ufb00erent Boolean\ninputs possible. Suppose we had no bias; that is H is the set of all 22n Boolean\nfunctions, and we have no preference among those that \ufb01t the samples in the\ntraining set. In this case, after being presented with one member of the training\nset and its value we can rule out precisely one-half of the members of H\u2014those\nBoolean functions that would misclassify this labeled sample. The remaining\nfunctions constitute what is called a \u201cversion space;\u201d we\u2019ll explore that concept\nin more detail later. As we present more members of the training set, the graph\nof the number of hypotheses not yet ruled out as a function of the number of\ndi\ufb00erent patterns presented is as shown in Fig. 1.4. At any stage of the process,10\nCHAPTER 1. PRELIMINARIES\nhalf of the remaining Boolean functions have value 1 and half have value 0 for\nany training pattern not yet seen. No generalization is possible in this case\nbecause the training patterns give no clue about the value of a pattern not yet\nseen. Only memorization is possible here, which is a trivial sort of learning.\nlog2|Hv|\n2n\n2n\nj = no. of labeled\npatterns already seen\n0\n0\n2n < j\n(generalization is not possible)\n|Hv| = no. of functions not ruled out\nFigure 1.4: Hypotheses Remaining as a Function of Labeled Patterns Presented\nBut suppose we limited H to some subset, Hc, of all Boolean functions.\nDepending on the subset and on the order of presentation of training patterns,\na curve of hypotheses not yet ruled out might look something like the one\nshown in Fig. 1.5. In this case it is even possible that after seeing fewer than\nall 2n labeled samples, there might be only one hypothesis that agrees with\nthe training set. Certainly, even if there is more than one hypothesis remaining,\nmost of them may have the same value for most of the patterns not yet seen! The\ntheory of Probably Approximately Correct (PAC) learning makes this intuitive\nidea precise. We\u2019ll examine that theory later.\nLet\u2019s look at a speci\ufb01c example of how bias aids learning. A Boolean function\ncan be represented by a hypercube each of whose vertices represents a di\ufb00erent\ninput pattern. We show a 3-dimensional version in Fig. 1.6. There, we show a\ntraining set of six sample patterns and have marked those having a value of 1 by\na small square and those having a value of 0 by a small circle. If the hypothesis\nset consists of just the linearly separable functions\u2014those for which the positive\nand negative instances can be separated by a linear surface, then there is only\none function remaining in this hypothsis set that is consistent with the training\nset. So, in this case, even though the training set does not contain all possible\npatterns, we can already pin down what the function must be\u2014given the bias.1.4. SAMPLE APPLICATIONS\n11\nlog2|Hv|\n2n\n2n\nj = no. of labeled\npatterns already seen\n0\n0\n|Hv| = no. of functions not ruled out\ndepends on order\nof presentation\nlog2|Hc|\nFigure 1.5: Hypotheses Remaining From a Restricted Subset\nMachine learning researchers have identi\ufb01ed two main varieties of bias, ab-\nsolute and preference. In absolute bias (also called restricted hypothesis-space\nbias), one restricts H to a de\ufb01nite subset of functions. In our example of Fig. 1.6,\nthe restriction was to linearly separable Boolean functions. In preference bias,\none selects that hypothesis that is minimal according to some ordering scheme\nover all hypotheses. For example, if we had some way of measuring the complex-\nity of a hypothesis, we might select the one that was simplest among those that\nperformed satisfactorily on the training set. The principle of Occam\u2019s razor,\nused in science to prefer simple explanations to more complex ones, is a type\nof preference bias. (William of Occam, 1285-?1349, was an English philosopher\nwho said: \u201cnon sunt multiplicanda entia praeter necessitatem,\u201d which means\n\u201centities should not be multiplied unnecessarily.\u201d)\n1.4\nSample Applications\nOur main emphasis in this book is on the concepts of machine learning\u2014not\non its applications. Nevertheless, if these concepts were irrelevant to real-world\nproblems they would probably not be of much interest. As motivation, we give\na short summary of some areas in which machine learning techniques have been\nsuccessfully applied. [Langley, 1992] cites some of the following applications and\nothers:\na. Rule discovery using a variant of ID3 for a printing industry problem12\nCHAPTER 1. PRELIMINARIES\nx1\nx2\nx3\nFigure 1.6: A Training Set That Completely Determines a Linearly Separable\nFunction\n[Evans & Fisher, 1992].\nb. Electric power load forecasting using a k-nearest-neighbor rule system\n[Jabbour, K., et al., 1987].\nc. Automatic\n\u201chelp\ndesk\u201d\nassistant\nusing\na\nnearest-neighbor\nsystem\n[Acorn & Walden, 1992].\nd. Planning and scheduling for a steel mill using ExpertEase, a marketed\n(ID3-like) system [Michie, 1992].\ne. Classi\ufb01cation of stars and galaxies [Fayyad, et al., 1993].\nMany application-oriented papers are presented at the annual conferences\non Neural Information Processing Systems. Among these are papers on: speech\nrecognition, dolphin echo recognition, image processing, bio-engineering, diag-\nnosis, commodity trading, face recognition, music composition, optical character\nrecognition, and various control applications [Various Editors, 1989-1994].\nAs additional examples, [Hammerstrom, 1993] mentions:\na. Sharp\u2019s Japanese kanji character recognition system processes 200 char-\nacters per second with 99+% accuracy. It recognizes 3000+ characters.\nb. NeuroForecasting Centre\u2019s (London Business School and University Col-\nlege London) trading strategy selection network earned an average annual\npro\ufb01t of 18% against a conventional system\u2019s 12.3%.1.5. SOURCES\n13\nc. Fujitsu\u2019s (plus a partner\u2019s) neural network for monitoring a continuous\nsteel casting operation has been in successful operation since early 1990.\nIn summary, it is rather easy nowadays to \ufb01nd applications of machine learn-\ning techniques. This fact should come as no surprise inasmuch as many machine\nlearning techniques can be viewed as extensions of well known statistical meth-\nods which have been successfully applied for many years.\n1.5\nSources\nBesides\nthe\nrich\nliterature\nin\nmachine\nlearning\n(a\nsmall\npart\nof\nwhich\nis\nreferenced\nin\nthe\nBibliography),\nthere\nare\nseveral\ntext-\nbooks\nthat\nare\nworth\nmentioning\n[Hertz, Krogh, & Palmer, 1991,\nWeiss & Kulikowski, 1991,\nNatarjan, 1991,\nFu, 1994,\nLangley, 1996].\n[Shavlik & Dietterich, 1990,\nBuchanan & Wilkins, 1993]\nare\nedited\nvol-\numes containing some of the most important papers.\nA survey paper by\n[Dietterich, 1990] gives a good overview of many important topics. There are\nalso well established conferences and publications where papers are given and\nappear including:\n\u2022 The Annual Conferences on Advances in Neural Information Processing\nSystems\n\u2022 The Annual Workshops on Computational Learning Theory\n\u2022 The Annual International Workshops on Machine Learning\n\u2022 The Annual International Conferences on Genetic Algorithms\n(The Proceedings of the above-listed four conferences are published by\nMorgan Kaufmann.)\n\u2022 The journal Machine Learning (published by Kluwer Academic Publish-\ners).\nThere is also much information, as well as programs and datasets, available over\nthe Internet through the World Wide Web.\n1.6\nBibliographical and Historical Remarks\nTo be added. Every chapter will\ncontain a brief survey of the history\nof the material covered in that\nchapter.14\nCHAPTER 1. PRELIMINARIES", "2": "Chapter 2\nBoolean Functions\n2.1\nRepresentation\n2.1.1\nBoolean Algebra\nMany important ideas about learning of functions are most easily presented\nusing the special case of Boolean functions. There are several important sub-\nclasses of Boolean functions that are used as hypothesis classes for function\nlearning. Therefore, we digress in this chapter to present a review of Boolean\nfunctions and their properties. (For a more thorough treatment see, for example,\n[Unger, 1989].)\nA Boolean function, f(x1, x2, . . . , xn) maps an n-tuple of (0,1) values to\n{0, 1}. Boolean algebra is a convenient notation for representing Boolean func-\ntions. Boolean algebra uses the connectives \u00b7, +, and\n. For example, the and\nfunction of two variables is written x1 \u00b7 x2. By convention, the connective, \u201c\u00b7\u201d\nis usually suppressed, and the and function is written x1x2. x1x2 has value 1 if\nand only if both x1 and x2 have value 1; if either x1 or x2 has value 0, x1x2 has\nvalue 0. The (inclusive) or function of two variables is written x1 + x2. x1 + x2\nhas value 1 if and only if either or both of x1 or x2 has value 1; if both x1 and\nx2 have value 0, x1 + x2 has value 0. The complement or negation of a variable,\nx, is written x. x has value 1 if and only if x has value 0; if x has value 1, x has\nvalue 0.\nThese de\ufb01nitions are compactly given by the following rules for Boolean\nalgebra:\n1 + 1 = 1, 1 + 0 = 1, 0 + 0 = 0,\n1 \u00b7 1 = 1, 1 \u00b7 0 = 0, 0 \u00b7 0 = 0, and\n1 = 0, 0 = 1.\nSometimes the arguments and values of Boolean functions are expressed in\nterms of the constants T (True) and F (False) instead of 1 and 0, respectively.\n1516\nCHAPTER 2. BOOLEAN FUNCTIONS\nThe connectives \u00b7 and + are each commutative and associative. Thus, for\nexample, x1(x2x3) = (x1x2)x3, and both can be written simply as x1x2x3.\nSimilarly for +.\nA Boolean formula consisting of a single variable, such as x1 is called an\natom. One consisting of either a single variable or its complement, such as x1,\nis called a literal.\nThe operators \u00b7 and + do not commute between themselves. Instead, we\nhave DeMorgan\u2019s laws (which can be veri\ufb01ed by using the above de\ufb01nitions):\nx1x2 = x1 + x2, and\nx1 + x2 = x1 x2.\n2.1.2\nDiagrammatic Representations\nWe saw in the last chapter that a Boolean function could be represented by\nlabeling the vertices of a cube. For a function of n variables, we would need\nan n-dimensional hypercube. In Fig. 2.1 we show some 2- and 3-dimensional\nexamples. Vertices having value 1 are labeled with a small square, and vertices\nhaving value 0 are labeled with a small circle.\nx1\nx2\nx1\nx2\nx1\nx2\nand\nor\nxor (exclusive or)\nx1x2\nx1 + x2\nx1x2  +  x1x2\neven parity function\nx1\nx2\nx3\nx1x2x3  +  x1x2x3\n+ x1x2x3 + x1x2x3\nFigure 2.1: Representing Boolean Functions on Cubes\nUsing the hypercube representations, it is easy to see how many Boolean\nfunctions of n dimensions there are. A 3-dimensional cube has 23 = 8 vertices,\nand each may be labeled in two di\ufb00erent ways; thus there are 2(23) = 2562.2. CLASSES OF BOOLEAN FUNCTIONS\n17\ndi\ufb00erent Boolean functions of 3 variables. In general, there are 22n Boolean\nfunctions of n variables.\nWe will be using 2- and 3-dimensional cubes later to provide some intuition\nabout the properties of certain Boolean functions. Of course, we cannot visualize\nhypercubes (for n > 3), and there are many surprising properties of higher\ndimensional spaces, so we must be careful in using intuitions gained in low\ndimensions. One diagrammatic technique for dimensions slightly higher than\n3 is the Karnaugh map. A Karnaugh map is an array of values of a Boolean\nfunction in which the horizontal rows are indexed by the values of some of\nthe variables and the vertical columns are indexed by the rest. The rows and\ncolumns are arranged in such a way that entries that are adjacent in the map\ncorrespond to vertices that are adjacent in the hypercube representation. We\nshow an example of the 4-dimensional even parity function in Fig. 2.2. (An\neven parity function is a Boolean function that has value 1 if there are an even\nnumber of its arguments that have value 1; otherwise it has value 0.) Note\nthat all adjacent cells in the table correspond to inputs di\ufb00ering in only one\ncomponent.\nAlso describe general logic\ndiagrams, [Wnek, et al., 1990].\n00 01\n10\n11\n00\n01\n10\n11\n1\n1\n1\n1\n1\n1\n1\n1\n0\n0\n0\n0\n0\n0\n0\n0\nx1,x2\nx3,x4\nFigure 2.2: A Karnaugh Map\n2.2\nClasses of Boolean Functions\n2.2.1\nTerms and Clauses\nTo use absolute bias in machine learning, we limit the class of hypotheses. In\nlearning Boolean functions, we frequently use some of the common sub-classes of\nthose functions. Therefore, it will be important to know about these subclasses.\nOne basic subclass is called terms. A term is any function written in the\nform l1l2 \u00b7 \u00b7 \u00b7 lk, where the li are literals. Such a form is called a conjunction of\nliterals. Some example terms are x1x7 and x1x2x4. The size of a term is the\nnumber of literals it contains. The examples are of sizes 2 and 3, respectively.\n(Strictly speaking, the class of conjunctions of literals is called the monomials,18\nCHAPTER 2. BOOLEAN FUNCTIONS\nand a conjunction of literals itself is called a term. This distinction is a \ufb01ne one\nwhich we elect to blur here.)\nIt is easy to show that there are exactly 3n possible terms of n variables.\nThe number of terms of size k or less is bounded from above by Pk\ni=0 C(2n, i) =\nO(nk), where C(i, j) =\ni!\n(i\u2212j)!j! is the binomial coe\ufb03cient.\nProbably I\u2019ll put in a simple\nterm-learning algorithm here\u2014so\nwe can get started on learning!\nAlso for DNF functions and\ndecision lists\u2014as they are de\ufb01ned\nin the next few pages.\nA clause is any function written in the form l1 +l2 +\u00b7 \u00b7 \u00b7+lk, where the li are\nliterals. Such a form is called a disjunction of literals. Some example clauses\nare x3 + x5 + x6 and x1 + x4. The size of a clause is the number of literals it\ncontains. There are 3n possible clauses and fewer than Pk\ni=0 C(2n, i) clauses of\nsize k or less. If f is a term, then (by De Morgan\u2019s laws) f is a clause, and vice\nversa. Thus, terms and clauses are duals of each other.\nIn psychological experiments, conjunctions of literals seem easier for humans\nto learn than disjunctions of literals.\n2.2.2\nDNF Functions\nA Boolean function is said to be in disjunctive normal form (DNF) if it can be\nwritten as a disjunction of terms. Some examples in DNF are: f = x1x2+x2x3x4\nand f = x1x3 + x2 x3 + x1x2x3. A DNF expression is called a k-term DNF\nexpression if it is a disjunction of k terms; it is in the class k-DNF if the size of\nits largest term is k. The examples above are 2-term and 3-term expressions,\nrespectively. Both expressions are in the class 3-DNF.\nEach term in a DNF expression for a function is called an implicant because\nit \u201cimplies\u201d the function (if the term has value 1, so does the function). In\ngeneral, a term, t, is an implicant of a function, f, if f has value 1 whenever\nt does. A term, t, is a prime implicant of f if the term, t\u2032, formed by taking\nany literal out of an implicant t is no longer an implicant of f. (The implicant\ncannot be \u201cdivided\u201d by any term and remain an implicant.)\nThus, both x2x3 and x1 x3 are prime implicants of f = x2x3+x1 x3+x2x1x3,\nbut x2x1x3 is not.\nThe relationship between implicants and prime implicants can be geometri-\ncally illustrated using the cube representation for Boolean functions. Consider,\nfor example, the function f = x2x3 + x1 x3 + x2x1x3. We illustrate it in Fig.\n2.3.\nNote that each of the three planes in the \ufb01gure \u201ccuts o\ufb00\u201d a group of\nvertices having value 1, but none cuts o\ufb00any vertices having value 0. These\nplanes are pictorial devices used to isolate certain lower dimensional subfaces\nof the cube. Two of them isolate one-dimensional edges, and the third isolates\na zero-dimensional vertex. Each group of vertices on a subface corresponds to\none of the implicants of the function, f, and thus each implicant corresponds\nto a subface of some dimension. A k-dimensional subface corresponds to an\n(n \u2212k)-size implicant term. The function is written as the disjunction of the\nimplicants\u2014corresponding to the union of all the vertices cut o\ufb00by all of the\nplanes. Geometrically, an implicant is prime if and only if its corresponding\nsubface is the largest dimensional subface that includes all of its vertices and2.2. CLASSES OF BOOLEAN FUNCTIONS\n19\nno other vertices having value 0. Note that the term x2x1x3 is not a prime\nimplicant of f. (In this case, we don\u2019t even have to include this term in the\nfunction because the vertex cut o\ufb00by the plane corresponding to x2x1x3 is\nalready cut o\ufb00by the plane corresponding to x2x3.) The other two implicants\nare prime because their corresponding subfaces cannot be expanded without\nincluding vertices having value 0.\nx2\nx1\nx3\n1, 0, 0\n1, 0, 1\n1, 1, 1\n0, 0, 1\nf = x2x3 + x1x3 + x2x1x3\n   = x2x3 + x1x3\nx2x3 and  x1x3 are prime implicants\nFigure 2.3: A Function and its Implicants\nNote that all Boolean functions can be represented in DNF\u2014trivially by\ndisjunctions of terms of size n where each term corresponds to one of the vertices\nwhose value is 1. Whereas there are 22n functions of n dimensions in DNF (since\nany Boolean function can be written in DNF), there are just 2O(nk) functions\nin k-DNF.\nAll Boolean functions can also be represented in DNF in which each term is\na prime implicant, but that representation is not unique, as shown in Fig. 2.4.\nIf we can express a function in DNF form, we can use the consensus method\nto \ufb01nd an expression for the function in which each term is a prime implicant.\nThe consensus method relies on two results:\nWe may replace this section with\none describing the\nQuine-McCluskey method instead.\n\u2022 Consensus:20\nCHAPTER 2. BOOLEAN FUNCTIONS\nx2\nx1\nx3\n1, 0, 0\n1, 0, 1\n1, 1, 1\n0, 0, 1\nf = x2x3 + x1x3 + x1x2\n   = x1x2 + x1x3\nAll of the terms are prime implicants, but there\nis not a unique representation\nFigure 2.4: Non-Uniqueness of Representation by Prime Implicants\nxi \u00b7 f1 + xi \u00b7 f2 = xi \u00b7 f1 + xi \u00b7 f2 + f1 \u00b7 f2\nwhere f1 and f2 are terms such that no literal appearing in f1 appears\ncomplemented in f2.\nf1 \u00b7 f2 is called the consensus of xi \u00b7 f1 and xi \u00b7\nf2. Readers familiar with the resolution rule of inference will note that\nconsensus is the dual of resolution.\nExamples: x1 is the consensus of x1x2 and x1x2. The terms x1x2 and x1x2\nhave no consensus since each term has more than one literal appearing\ncomplemented in the other.\n\u2022 Subsumption:\nxi \u00b7 f1 + f1 = f1\nwhere f1 is a term. We say that f1 subsumes xi \u00b7 f1.\nExample: x1 x4x5 subsumes x1 x4 x2x52.2. CLASSES OF BOOLEAN FUNCTIONS\n21\nThe consensus method for \ufb01nding a set of prime implicants for a function,\nf, iterates the following operations on the terms of a DNF expression for f until\nno more such operations can be applied:\na. initialize the process with the set, T , of terms in the DNF expression of\nf,\nb. compute the consensus of a pair of terms in T and add the result to T ,\nc. eliminate any terms in T that are subsumed by other terms in T .\nWhen this process halts, the terms remaining in T are all prime implicants of\nf.\nExample: Let f = x1x2 + x1 x2x3 + x1 x2 x3 x4x5. We show a derivation of\na set of prime implicants in the consensus tree of Fig. 2.5. The circled numbers\nadjoining the terms indicate the order in which the consensus and subsumption\noperations were performed. Shaded boxes surrounding a term indicate that it\nwas subsumed. The \ufb01nal form of the function in which all terms are prime\nimplicants is: f = x1x2 +x1x3 +x1 x4x5. Its terms are all of the non-subsumed\nterms in the consensus tree.\n x1x2\nx1x2x3\nx1x2x3x4x5\n x1x3\nx1x2x4x5\nx1x4x5\nf =  x1x2 +\n+\n x1x3\nx1x4x5\n1\n2\n6\n4\n5\n3\nFigure 2.5: A Consensus Tree\n2.2.3\nCNF Functions\nDisjunctive normal form has a dual: conjunctive normal form (CNF). A Boolean\nfunction is said to be in CNF if it can be written as a conjunction of clauses.22\nCHAPTER 2. BOOLEAN FUNCTIONS\nAn example in CNF is: f = (x1 +x2)(x2 +x3 +x4). A CNF expression is called\na k-clause CNF expression if it is a conjunction of k clauses; it is in the class\nk-CNF if the size of its largest clause is k. The example is a 2-clause expression\nin 3-CNF. If f is written in DNF, an application of De Morgan\u2019s law renders f\nin CNF, and vice versa. Because CNF and DNF are duals, there are also 2O(nk)\nfunctions in k-CNF.\n2.2.4\nDecision Lists\nRivest has proposed a class of Boolean functions called decision lists [Rivest, 1987].\nA decision list is written as an ordered list of pairs:\n(tq, vq)\n(tq\u22121, vq\u22121)\n\u00b7 \u00b7 \u00b7\n(ti, vi)\n\u00b7 \u00b7 \u00b7\n(t2, v2)\n(T, v1)\nwhere the vi are either 0 or 1, the ti are terms in (x1, . . . , xn), and T is a term\nwhose value is 1 (regardless of the values of the xi). The value of a decision list\nis the value of vi for the \ufb01rst ti in the list that has value 1. (At least one ti will\nhave value 1, because the last one does; v1 can be regarded as a default value of\nthe decision list.) The decision list is of size k, if the size of the largest term in\nit is k. The class of decision lists of size k or less is called k-DL.\nAn example decision list is:\nf =\n(x1x2, 1)\n(x1 x2x3, 0)\nx2x3, 1)\n(1, 0)\nf has value 0 for x1 = 0, x2 = 0, and x3 = 1. It has value 1 for x1 = 1, x2 = 0,\nand x3 = 1. This function is in 3-DL.\nIt has been shown that the class k-DL is a strict superset of the union of\nk-DNF and k-CNF. There are 2O[nkk log(n)] functions in k-DL [Rivest, 1987].\nInteresting generalizations of decision lists use other Boolean functions in\nplace of the terms, ti. For example we might use linearly separable functions in\nplace of the ti (see below and [Marchand & Golea, 1993]).2.2. CLASSES OF BOOLEAN FUNCTIONS\n23\n2.2.5\nSymmetric and Voting Functions\nA Boolean function is called symmetric if it is invariant under permutations\nof the input variables. For example, any function that is dependent only on\nthe number of input variables whose values are 1 is a symmetric function. The\nparity functions, which have value 1 depending on whether or not the number\nof input variables with value 1 is even or odd is a symmetric function. (The\nexclusive or function, illustrated in Fig. 2.1, is an odd-parity function of two\ndimensions. The or and and functions of two dimensions are also symmetric.)\nAn important subclass of the symmetric functions is the class of voting func-\ntions (also called m-of-n functions). A k-voting function has value 1 if and only\nif k or more of its n inputs has value 1. If k = 1, a voting function is the same\nas an n-sized clause; if k = n, a voting function is the same as an n-sized term;\nif k = (n + 1)/2 for n odd or k = 1 + n/2 for n even, we have the majority\nfunction.\n2.2.6\nLinearly Separable Functions\nThe linearly separable functions are those that can be expressed as follows:\nf = thresh(\nn\nX\ni=1\nwixi, \u03b8)\nwhere wi, i = 1, . . . , n, are real-valued numbers called weights, \u03b8 is a real-valued\nnumber called the threshold, and thresh(\u03c3, \u03b8) is 1 if \u03c3 \u2265\u03b8 and 0 otherwise.\n(Note that the concept of linearly separable functions can be extended to non-\nBoolean inputs.) The k-voting functions are all members of the class of linearly\nseparable functions in which the weights all have unit value and the threshold\ndepends on k. Thus, terms and clauses are special cases of linearly separable\nfunctions.\nA convenient way to write linearly separable functions uses vector notation:\nf = thresh(X \u00b7 W, \u03b8)\nwhere X = (x1, . . . , xn) is an n-dimensional vector of input variables, W =\n(w1, . . . , wn) is an n-dimensional vector of weight values, and X \u00b7 W is the dot\n(or inner) product of the two vectors. Input vectors for which f has value 1 lie\nin a half-space on one side of (and on) a hyperplane whose orientation is normal\nto W and whose position (with respect to the origin) is determined by \u03b8. We\nsaw an example of such a separating plane in Fig. 1.6. With this idea in mind,\nit is easy to see that two of the functions in Fig. 2.1 are linearly separable, while\ntwo are not. Also note that the terms in Figs. 2.3 and 2.4 are linearly separable\nfunctions as evidenced by the separating planes shown.\nThere is no closed-form expression for the number of linearly separable func-\ntions of n dimensions, but the following table gives the numbers for n up to 6.24\nCHAPTER 2. BOOLEAN FUNCTIONS\nn\nBoolean\nLinearly Separable\nFunctions\nFunctions\n1\n4\n4\n2\n16\n14\n3\n256\n104\n4\n65,536\n1,882\n5\n\u22484.3 \u00d7 109\n94,572\n6\n\u22481.8 \u00d7 1019\n15,028,134\n[Muroga, 1971] has shown that (for n > 1) there are no more than 2n2 linearly\nseparable functions of n dimensions. (See also [Winder, 1961, Winder, 1962].)\n2.3\nSummary\nThe diagram in Fig. 2.6 shows some of the set inclusions of the classes of Boolean\nfunctions that we have considered. We will be confronting these classes again\nin later chapters.\nDNF\n(All)\nk-DL\nk-DNF\nk-size-\nterms\nterms\nlin sep\nFigure 2.6: Classes of Boolean Functions\nThe sizes of the various classes are given in the following table (adapted from\n[Dietterich, 1990, page 262]):2.4. BIBLIOGRAPHICAL AND HISTORICAL REMARKS\n25\nClass\nSize of Class\nterms\n3n\nclauses\n3n\nk-term DNF\n2O(kn)\nk-clause CNF\n2O(kn)\nk-DNF\n2O(nk)\nk-CNF\n2O(nk)\nk-DL\n2O[nkk log(n)]\nlin sep\n2O(n2)\nDNF\n22n\n2.4\nBibliographical and Historical Remarks\nTo be added.26\nCHAPTER 2. BOOLEAN FUNCTIONS", "3": "Chapter 3\nUsing Version Spaces for\nLearning\n3.1\nVersion Spaces and Mistake Bounds\nThe \ufb01rst learning methods we present are based on the concepts of version\nspaces and version graphs. These ideas are most clearly explained for the case\nof Boolean function learning. Given an initial hypothesis set H (a subset of\nall Boolean functions) and the values of f(X) for each X in a training set, \u039e,\nthe version space is that subset of hypotheses, Hv, that is consistent with these\nvalues. A hypothesis, h, is consistent with the values of X in \u039e if and only if\nh(X) = f(X) for all X in \u039e. We say that the hypotheses in H that are not\nconsistent with the values in the training set are ruled out by the training set.\nWe could imagine (conceptually only!) that we have devices for implement-\ning every function in H.\nAn incremental training procedure could then be\nde\ufb01ned which presented each pattern in \u039e to each of these functions and then\neliminated those functions whose values for that pattern did not agree with its\ngiven value. At any stage of the process we would then have left some subset\nof functions that are consistent with the patterns presented so far; this subset\nis the version space for the patterns already presented. This idea is illustrated\nin Fig. 3.1.\nConsider the following procedure for classifying an arbitrary input pattern,\nX: the pattern is put in the same class (0 or 1) as are the majority of the\noutputs of the functions in the version space. During the learning procedure,\nif this majority is not equal to the value of the pattern presented, we say a\nmistake is made, and we revise the version space accordingly\u2014eliminating all\nthose (majority of the) functions voting incorrectly. Thus, whenever a mistake\nis made, we rule out at least half of the functions remaining in the version space.\nHow many mistakes can such a procedure make? Obviously, we can make\nno more than log2(|H|) mistakes, where |H| is the number of hypotheses in the\n2728\nCHAPTER 3. USING VERSION SPACES FOR LEARNING\nh1\nh2\nhi\nhK\nX\nA Subset, H,  of all\nBoolean Functions\nRule out hypotheses not\nconsistent with training patterns\nhj\nHypotheses not ruled out\nconstitute the version space\nK = |H|\n1 or 0\nFigure 3.1: Implementing the Version Space\noriginal hypothesis set, H. (Note, though, that the number of training patterns\nseen before this maximum number of mistakes is made might be much greater.)\nThis theoretical (and very impractical!) result (due to [Littlestone, 1988]) is an\nexample of a mistake bound\u2014an important concept in machine learning theory.\nIt shows that there must exist a learning procedure that makes no more mistakes\nthan this upper bound. Later, we\u2019ll derive other mistake bounds.\nAs a special case, if our bias was to limit H to terms, we would make no\nmore than log2(3n) = n log2(3) = 1.585n mistakes before exhausting the version\nspace. This result means that if f were a term, we would make no more than\n1.585n mistakes before learning f, and otherwise we would make no more than\nthat number of mistakes before being able to decide that f is not a term.\nEven if we do not have su\ufb03cient training patterns to reduce the version\nspace to a single function, it may be that there are enough training patterns\nto reduce the version space to a set of functions such that most of them assign\nthe same values to most of the patterns we will see henceforth. We could select\none of the remaining functions at random and be reasonably assured that it\nwill generalize satisfactorily. We next discuss a computationally more feasible\nmethod for representing the version space.3.2. VERSION GRAPHS\n29\n3.2\nVersion Graphs\nBoolean functions can be ordered by generality. A Boolean function, f1, is more\ngeneral than a function, f2, (and f2 is more speci\ufb01c than f1), if f1 has value 1\nfor all of the arguments for which f2 has value 1, and f1 \u0338= f2. For example, x3\nis more general than x2x3 but is not more general than x3 + x2.\nWe can form a graph with the hypotheses, {hi}, in the version space as\nnodes. A node in the graph, hi, has an arc directed to node, hj, if and only if\nhj is more general than hi. We call such a graph a version graph. In Fig. 3.2,\nwe show an example of a version graph over a 3-dimensional input space for\nhypotheses restricted to terms (with none of them yet ruled out).\n0\nx1\nx2\nx3\nx2\nx3\n1\nx1x2 x3\nx1x2\nx1\nVersion Graph for Terms\nx1\nx2\nx3\n(for simplicity, only some arcs in the graph are shown)\n(none yet ruled out)\n(k = 1)\n(k = 2)\n(k = 3)\nx1 x3\nFigure 3.2: A Version Graph for Terms\nThat function, denoted here by \u201c1,\u201d which has value 1 for all inputs, corre-\nsponds to the node at the top of the graph. (It is more general than any other\nterm.) Similarly, the function \u201c0\u201d is at the bottom of the graph. Just below\n\u201c1\u201d is a row of nodes corresponding to all terms having just one literal, and just\nbelow them is a row of nodes corresponding to terms having two literals, and30\nCHAPTER 3. USING VERSION SPACES FOR LEARNING\nso on. There are 33 = 27 functions altogether (the function \u201c0,\u201d included in\nthe graph, is technically not a term). To make our portrayal of the graph less\ncluttered only some of the arcs are shown; each node in the actual graph has an\narc directed to all of the nodes above it that are more general.\nWe use this same example to show how the version graph changes as we\nconsider a set of labeled samples in a training set, \u039e. Suppose we \ufb01rst consider\nthe training pattern (1, 0, 1) with value 0. Some of the functions in the version\ngraph of Fig. 3.2 are inconsistent with this training pattern. These ruled out\nnodes are no longer in the version graph and are shown shaded in Fig. 3.3. We\nalso show there the three-dimensional cube representation in which the vertex\n(1, 0, 1) has value 0.\n0\nx1\nx2\nx3\nx2\nx3\n1\nx1x2 x3\nx1x2\nx1\nNew Version Graph\n1, 0, 1 has\nvalue 0\nx1x3\nx1x2\nx2x3\nx1x2x3\nx1\nx2\nx3\nx1x3\n(only some arcs in the graph are shown)\nruled out nodes\nFigure 3.3: The Version Graph Upon Seeing (1, 0, 1)\nIn a version graph, there are always a set of hypotheses that are maximally\ngeneral and a set of hypotheses that are maximally speci\ufb01c. These are called\nthe general boundary set (gbs) and the speci\ufb01c boundary set (sbs), respectively.\nIn Fig. 3.4, we have the version graph as it exists after learning that (1,0,1) has\nvalue 0 and (1, 0, 0) has value 1. The gbs and sbs are shown.3.2. VERSION GRAPHS\n31\n0\nx1\nx2\nx3\nx2\nx3\n1\nx1x2 x3\nx1\nx2x3\nx1x3\ngeneral boundary set\n(gbs)\nspecific boundary set (sbs)\nx1x2\nmore specific than gbs,\nmore general than sbs\n1, 0, 1 has\nvalue 0\nx1\nx2\nx3\n1, 0, 0 has\nvalue 1\nFigure 3.4: The Version Graph Upon Seeing (1, 0, 1) and (1, 0, 0)\nBoundary sets are important because they provide an alternative to repre-\nsenting the entire version space explicitly, which would be impractical. Given\nonly the boundary sets, it is possible to determine whether or not any hypoth-\nesis (in the prescribed class of Boolean functions we are using) is a member or\nnot of the version space. This determination is possible because of the fact that\nany member of the version space (that is not a member of one of the boundary\nsets) is more speci\ufb01c than some member of the general boundary set and is more\ngeneral than some member of the speci\ufb01c boundary set.\nIf we limit our Boolean functions that can be in the version space to terms,\nit is a simple matter to determine maximally general and maximally speci\ufb01c\nfunctions (assuming that there is some term that is in the version space). A\nmaximally speci\ufb01c one corresponds to a subface of minimal dimension that\ncontains all the members of the training set labelled by a 1 and no members\nlabelled by a 0. A maximally general one corresponds to a subface of maximal\ndimension that contains all the members of the training set labelled by a 1 and\nno members labelled by a 0. Looking at Fig. 3.4, we see that the subface of\nminimal dimension that contains (1, 0, 0) but does not contain (1, 0, 1) is just\nthe vertex (1, 0, 0) itself\u2014corresponding to the function x1x2 x3. The subface32\nCHAPTER 3. USING VERSION SPACES FOR LEARNING\nof maximal dimension that contains (1, 0, 0) but does not contain (1, 0, 1) is\nthe bottom face of the cube\u2014corresponding to the function x3. In Figs. 3.2\nthrough 3.4 the sbs is always singular. Version spaces for terms always have\nsingular speci\ufb01c boundary sets.\nAs seen in Fig.\n3.3, however, the gbs of a\nversion space for terms need not be singular.\n3.3\nLearning as Search of a Version Space\n[To be written.\nRelate to term learning algorithm presented in Chapter\nTwo. Also discuss best-\ufb01rst search methods. See Pat Langley\u2019s example us-\ning \u201cpseudo-cells\u201d of how to generate and eliminate hypotheses.]\nSelecting a hypothesis from the version space can be thought of as a search\nproblem. One can start with a very general function and specialize it through\nvarious specialization operators until one \ufb01nds a function that is consistent (or\nadequately so) with a set of training patterns.\nSuch procedures are usually\ncalled top-down methods. Or, one can start with a very special function and\ngeneralize it\u2014resulting in bottom-up methods. We shall see instances of both\nstyles of learning in this book.\nCompare this view of top-down\nversus bottom-up with the\ndivide-and-conquer and the\ncovering (or AQ) methods of\ndecision-tree induction.\n3.4\nThe Candidate Elimination Method\nThe candidate elimination method, is an incremental method for computing the\nboundary sets. Quoting from [Hirsh, 1994, page 6]:\n\u201cThe candidate-elimination algorithm manipulates the boundary-set\nrepresentation of a version space to create boundary sets that rep-\nresent a new version space consistent with all the previous instances\nplus the new one. For a positive exmple the algorithm generalizes\nthe elements of the [sbs] as little as possible so that they cover the\nnew instance yet remain consistent with past data, and removes\nthose elements of the [gbs] that do not cover the new instance. For\na negative instance the algorithm specializes elements of the [gbs]\nso that they no longer cover the new instance yet remain consis-\ntent with past data, and removes from the [sbs] those elements that\nmistakenly cover the new, negative instance.\u201d\nThe\nmethod\nuses\nthe\nfollowing\nde\ufb01nitions\n(adapted\nfrom\n[Genesereth & Nilsson, 1987]):\n\u2022 a hypothesis is called su\ufb03cient if and only if it has value 1 for all training\nsamples labeled by a 1,\n\u2022 a hypothesis is called necessary if and only if it has value 0 for all training\nsamples labeled by a 0.3.4. THE CANDIDATE ELIMINATION METHOD\n33\nHere is how to think about these de\ufb01nitions: A hypothesis implements a su\ufb03-\ncient condition that a training sample has value 1 if the hypothesis has value 1\nfor all of the positive instances; a hypothesis implements a necessary condition\nthat a training sample has value 1 if the hypothesis has value 0 for all of the\nnegative instances. A hypothesis is consistent with the training set (and thus is\nin the version space) if and only if it is both su\ufb03cient and necessary.\nWe start (before receiving any members of the training set) with the function\n\u201c0\u201d as the singleton element of the speci\ufb01c boundary set and with the function\n\u201c1\u201d as the singleton element of the general boundary set. Upon receiving a new\nlabeled input vector, the boundary sets are changed as follows:\na. If the new vector is labelled with a 1:\nThe new general boundary set is obtained from the previous one by ex-\ncluding any elements in it that are not su\ufb03cient. (That is, we exclude any\nelements that have value 0 for the new vector.)\nThe new speci\ufb01c boundary set is obtained from the previous one by re-\nplacing each element, hi, in it by all of its least generalizations.\nThe hypothesis hg is a least generalization\nof h if and only if: a) h is\nmore speci\ufb01c than hg, b) hg is su\ufb03cient, c) no function (including h) that\nis more speci\ufb01c than hg is su\ufb03cient, and d) hg is more speci\ufb01c than some\nmember of the new general boundary set. It might be that hg = h. Also,\nleast generalizations of two di\ufb00erent functions in the speci\ufb01c boundary set\nmay be identical.\nb. If the new vector is labelled with a 0:\nThe new speci\ufb01c boundary set is obtained from the previous one by ex-\ncluding any elements in it that are not necessary. (That is, we exclude\nany elements that have value 1 for the new vector.)\nThe new general boundary set is obtained from the previous one by re-\nplacing each element, hi, in it by all of its least specializations.\nThe hypothesis hs is a least specialization of h if and only if: a) h is more\ngeneral than hs, b) hs is necessary, c) no function (including h) that is\nmore general than hs is necessary, and d) hs is more general than some\nmember of the new speci\ufb01c boundary set. Again, it might be that hs = h,\nand least specializations of two di\ufb00erent functions in the general boundary\nset may be identical.\nAs an example, suppose we present the vectors in the following order:\nvector\nlabel\n(1, 0, 1)\n0\n(1, 0, 0)\n1\n(1, 1, 1)\n0\n(0, 0, 1)\n034\nCHAPTER 3. USING VERSION SPACES FOR LEARNING\nWe start with general boundary set, \u201c1\u201d, and speci\ufb01c boundary set, \u201c0.\u201d\nAfter seeing the \ufb01rst sample, (1, 0, 1), labeled with a 0, the speci\ufb01c boundary\nset stays at \u201c0\u201d (it is necessary), and we change the general boundary set to\n{x1, x2, x3}. Each of the functions, x1, x2, and x3, are least specializations of\n\u201c1\u201d (they are necessary, \u201c1\u201d is not, they are more general than \u201c0\u201d, and there\nare no functions that are more general than they and also necessary).\nThen, after seeing (1, 0, 0), labeled with a 1, the general boundary set\nchanges to {x3} (because x1 and x2 are not su\ufb03cient), and the speci\ufb01c boundary\nset is changed to {x1x2 x3}. This single function is a least generalization of \u201c0\u201d\n(it is su\ufb03cient, \u201c0\u201d is more speci\ufb01c than it, no function (including \u201c0\u201d) that is\nmore speci\ufb01c than it is su\ufb03cient, and it is more speci\ufb01c than some member of\nthe general boundary set.\nWhen we see (1, 1, 1), labeled with a 0, we do not change the speci\ufb01c\nboundary set because its function is still necessary.\nWe do not change the\ngeneral boundary set either because x3 is still necessary.\nFinally, when we see (0, 0, 1), labeled with a 0, we do not change the speci\ufb01c\nboundary set because its function is still necessary. We do not change the general\nboundary set either because x3 is still necessary.\nMaybe I\u2019ll put in an example of a\nversion graph for non-Boolean\nfunctions.\n3.5\nBibliographical and Historical Remarks\nThe concept of version spaces and their role in learning was \ufb01rst investigated\nby Tom Mitchell [Mitchell, 1982]. Although these ideas are not used in prac-\ntical machine learning procedures, they do provide insight into the nature of\nhypothesis selection. In order to accomodate noisy data, version spaces have\nbeen generalized by [Hirsh, 1994] to allow hypotheses that are not necessarily\nconsistent with the training set.\nMore to be added.", "4": "Chapter 4\nNeural Networks\nIn chapter two we de\ufb01ned several important subsets of Boolean functions. Sup-\npose we decide to use one of these subsets as a hypothesis set for supervised\nfunction learning. We next have the question of how best to implement the\nfunction as a device that gives the outputs prescribed by the function for arbi-\ntrary inputs. In this chapter we describe how networks of non-linear elements\ncan be used to implement various input-output functions and how they can be\ntrained using supervised learning methods.\nNetworks of non-linear elements, interconnected through adjustable weights,\nplay a prominent role in machine learning. They are called neural networks be-\ncause the non-linear elements have as their inputs a weighted sum of the outputs\nof other elements\u2014much like networks of biological neurons do. These networks\ncommonly use the threshold element which we encountered in chapter two in\nour study of linearly separable Boolean functions. We begin our treatment of\nneural nets by studying this threshold element and how it can be used in the\nsimplest of all networks, namely ones composed of a single threshold element.\n4.1\nThreshold Logic Units\n4.1.1\nDe\ufb01nitions and Geometry\nLinearly separable (threshold) functions are implemented in a straightforward\nway by summing the weighted inputs and comparing this sum to a threshold\nvalue as shown in Fig. 4.1. This structure we call a threshold logic unit (TLU).\nIts output is 1 or 0 depending on whether or not the weighted sum of its inputs is\ngreater than or equal to a threshold value, \u03b8. It has also been called an Adaline\n(for adaptive linear element) [Widrow, 1962, Widrow & Lehr, 1990], an LTU\n(linear threshold unit), a perceptron, and a neuron. (Although the word \u201cper-\nceptron\u201d is often used nowadays to refer to a single TLU, Rosenblatt originally\nde\ufb01ned it as a class of networks of threshold elements [Rosenblatt, 1958].)\n3536\nCHAPTER 4. NEURAL NETWORKS\n!\nx1\nx2\nxn+1 = 1\nxi\nw1\nw2\nwn+1\nwi\nwn\nX\nthreshold weight\nxn\nW\nthreshold  \"  = 0\nf\nf = thresh( ! wi xi,  0)\ni = 1\nn+1\nFigure 4.1: A Threshold Logic Unit (TLU)\nThe n-dimensional feature or input vector is denoted by X = (x1, . . . , xn).\nWhen we want to distinguish among di\ufb00erent feature vectors, we will attach\nsubscripts, such as Xi. The components of X can be any real-valued numbers,\nbut we often specialize to the binary numbers 0 and 1. The weights of a TLU\nare represented by an n-dimensional weight vector, W = (w1, . . . , wn).\nIts\ncomponents are real-valued numbers (but we sometimes specialize to integers).\nThe TLU has output 1 if Pn\ni=1 xiwi \u2265\u03b8; otherwise it has output 0.\nThe\nweighted sum that is calculated by the TLU can be simply represented as a\nvector dot product, X\u2022W. (If the pattern and weight vectors are thought of as\n\u201ccolumn\u201d vectors, this dot product is then sometimes written as XtW, where\nthe \u201crow\u201d vector Xt is the transpose of X.) Often, the threshold, \u03b8, of the TLU\nis \ufb01xed at 0; in that case, arbitrary thresholds are achieved by using (n + 1)-\ndimensional \u201caugmented\u201d vectors, Y, and V, whose \ufb01rst n components are the\nsame as those of X and W, respectively. The (n + 1)-st component, xn+1, of\nthe augmented feature vector, Y, always has value 1; the (n + 1)-st component,\nwn+1, of the augmented weight vector, V, is set equal to the negative of the\ndesired threshold value. (When we want to emphasize the use of augmented\nvectors, we\u2019ll use the Y,V notation; however when the context of the discussion\nmakes it clear about what sort of vectors we are talking about, we\u2019ll lapse back\ninto the more familiar X,W notation.) In the Y,V notation, the TLU has an\noutput of 1 if Y\u2022V \u22650. Otherwise, the output is 0.\nWe can give an intuitively useful geometric description of a TLU. A TLU\ndivides the input space by a hyperplane as sketched in Fig. 4.2. The hyperplane\nis the boundary between patterns for which X\u2022W + wn+1 > 0 and patterns\nfor which X\u2022W + wn+1 < 0. Thus, the equation of the hyperplane itself is\nX\u2022W+wn+1 = 0. The unit vector that is normal to the hyperplane is n =\nW\n|W|,\nwhere |W| =\np\n(w2\n1 + . . . + w2\nn) is the length of the vector W. (The normal4.1. THRESHOLD LOGIC UNITS\n37\nform of the hyperplane equation is X\u2022n +\nW\n|W| = 0.) The distance from the\nhyperplane to the origin is wn+1\n|W| , and the distance from an arbitrary point, X,\nto the hyperplane is X\u2022W+wn+1\n|W|\n. When the distance from the hyperplane to the\norigin is negative (that is, when wn+1 < 0), then the origin is on the negative\nside of the hyperplane (that is, the side for which X\u2022W + wn+1 < 0).\nX.W + wn+1 > 0\non this side\nW\nX\nW\nn =\nW\n|W|\nOrigin\nUnit vector normal\nto hyperplane\nW + wn+1 = 0\nX\nn +           = 0\nX\nEquations of hyperplane:\nwn+1\n|W|\nwn+1\nW + wn+1\nX\nX.W + wn+1 < 0\non this side\nFigure 4.2: TLU Geometry\nAdjusting the weight vector, W, changes the orientation of the hyperplane;\nadjusting wn+1 changes the position of the hyperplane (relative to the origin).\nThus, training of a TLU can be achieved by adjusting the values of the weights.\nIn this way the hyperplane can be moved so that the TLU implements di\ufb00erent\n(linearly separable) functions of the input.\n4.1.2\nSpecial Cases of Linearly Separable Functions\nTerms\nAny term of size k can be implemented by a TLU with a weight from each of\nthose inputs corresponding to variables occurring in the term. A weight of +1 is\nused from an input corresponding to a positive literal, and a weight of \u22121 is used\nfrom an input corresponding to a negative literal. (Literals not mentioned in\nthe term have weights of zero\u2014that is, no connection at all\u2014from their inputs.)\nThe threshold, \u03b8, is set equal to kp \u22121/2, where kp is the number of positive\nliterals in the term. Such a TLU implements a hyperplane boundary that is38\nCHAPTER 4. NEURAL NETWORKS\nparallel to a subface of dimension (n \u2212k) of the unit hypercube. We show a\nthree-dimensional example in Fig. 4.3. Thus, linearly separable functions are a\nsuperset of terms.\n(1,1,1)\n(1,1,0)\nx2\nx1\nx3\nf = x1x2\nx1 + x2 - 3/2 = 0\nEquation of plane is:\nFigure 4.3: Implementing a Term\nClauses\nThe negation of a clause is a term. For example, the negation of the clause\nf = x1 + x2 + x3 is the term f = x1 x2 x3. A hyperplane can be used to\nimplement this term.\nIf we \u201cinvert\u201d the hyperplane, it will implement the\nclause instead. Inverting a hyperplane is done by multiplying all of the TLU\nweights\u2014even wn+1\u2014by \u22121. This process simply changes the orientation of the\nhyperplane\u2014\ufb02ipping it around by 180 degrees and thus changing its \u201cpositive\nside.\u201d Therefore, linearly separable functions are also a superset of clauses. We\nshow an example in Fig. 4.4.\n4.1.3\nError-Correction Training of a TLU\nThere are several procedures that have been proposed for adjusting the weights\nof a TLU. We present next a family of incremental training procedures with\nparameter c. These methods make adjustments to the weight vector only when\nthe TLU being trained makes an error on a training pattern; they are called\nerror-correction procedures. We use augmented feature and weight vectors in\ndescribing them.\na. We start with a \ufb01nite training set, \u039e, of vectors, Yi , and their binary\nlabels.4.1. THRESHOLD LOGIC UNITS\n39\nf = x1 + x2 + x3\nx1\nx1 + x2 + x3 < 1/2 = 0\nf = x1x2x3\nEquation of plane is:\nx2\nx3\nFigure 4.4: Implementing a Clause\nb. Compose an in\ufb01nite training sequence, \u03a3, of vectors from \u039e and their\nlabels such that each member of \u039e occurs in\ufb01nitely often in \u03a3. Set the\ninitial weight values of an TLU to arbitrary values.\nc. Repeat forever:\nPresent the next vector, Yi, in \u03a3 to the TLU and note its response.\n(a) If the TLU responds correctly, make no change in the weight vector.\n(b) If Yi is supposed to produce an output of 0 and produces an output\nof 1 instead, modify the weight vector as follows:\nV \u2190\n\u2212V \u2212ciYi\nwhere ci is a positive real number called the learning rate parame-\nter (whose value is di\ufb00ererent in di\ufb00erent instances of this family of\nprocedures and may depend on i).\nNote that after this adjustment the new dot product will be (V \u2212\nciYi)\u2022Yi = V\u2022Yi \u2212ciYi\u2022Yi, which is smaller than it was before the\nweight adjustment.\n(c) If Yi is supposed to produce an output of 1 and produces an output\nof 0 instead, modify the weight vector as follows:\nV \u2190\n\u2212V + ciYi\nIn this case, the new dot product will be (V + ciYi)\u2022Yi = V\u2022Yi +\nciYi\u2022Yi, which is larger than it was before the weight adjustment.\nNote that all three of these cases can be combined in the following rule:40\nCHAPTER 4. NEURAL NETWORKS\nV \u2190\n\u2212V + ci(di \u2212fi)Yi\nwhere di is the desired response (1 or 0) for Yi , and fi is the actual\nresponse (1 or 0) for Yi.]\nNote also that because the weight vector V now includes the wn+1 thresh-\nold component, the threshold of the TLU is also changed by these adjust-\nments.\nWe identify two versions of this procedure:\n1) In the \ufb01xed-increment procedure, the learning rate parameter, ci, is the\nsame \ufb01xed, positive constant for all i. Depending on the value of this constant,\nthe weight adjustment may or may not correct the response to an erroneously\nclassi\ufb01ed feature vector.\n2) In the fractional-correction procedure, the parameter ci is set to \u03bb Yi\u2022V\nYi\u2022Yi ,\nwhere V is the weight vector before it is changed.\nNote that if \u03bb = 0, no\ncorrection takes place at all. If \u03bb = 1, the correction is just su\ufb03cient to make\nYi\u2022V = 0. If \u03bb > 1, the error will be corrected.\nIt can be proved that if there is some weight vector, V, that produces a\ncorrect output for all of the feature vectors in \u039e, then after a \ufb01nite number\nof feature vector presentations, the \ufb01xed-increment procedure will \ufb01nd such a\nweight vector and thus make no more weight changes. The same result holds\nfor the fractional-correction procedure if 1 < \u03bb \u22642.\nFor additional background, proofs, and examples of error-correction proce-\ndures, see [Nilsson, 1990].\nSee [Maass & Tur\u00b4\nan, 1994] for a\nhyperplane-\ufb01nding procedure that\nmakes no more than O(n2 log n)\nmistakes.\n4.1.4\nWeight Space\nWe can give an intuitive idea about how these procedures work by considering\nwhat happens to the augmented weight vector in \u201cweight space\u201d as corrections\nare made. We use augmented vectors in our discussion here so that the threshold\nfunction compares the dot product, Yi\u2022V, against a threshold of 0. A particular\nweight vector, V, then corresponds to a point in (n + 1)-dimensional weight\nspace.\nNow, for any pattern vector, Yi, consider the locus of all points in\nweight space corresponding to weight vectors yielding Yi\u2022V = 0. This locus is\na hyperplane passing through the origin of the (n + 1)-dimensional space. Each\npattern vector will have such a hyperplane corresponding to it. Weight points\nin one of the half-spaces de\ufb01ned by this hyperplane will cause the corresponding\npattern to yield a dot product less than 0, and weight points in the other half-\nspace will cause the corresponding pattern to yield a dot product greater than\n0.\nWe show a schematic representation of such a weight space in Fig.\n4.5.\nThere are four pattern hyperplanes, 1, 2, 3, 4 , corresponding to patterns Y1,4.1. THRESHOLD LOGIC UNITS\n41\nY2, Y3, Y4, respectively, and we indicate by an arrow the half-space for each\nin which weight vectors give dot products greater than 0. Suppose we wanted\nweight values that would give positive responses for patterns Y1, Y3, and Y4,\nand a negative response for pattern Y2. The weight point, V, indicated in the\n\ufb01gure is one such set of weight values.\n2\n3\n4\n1\nV\nFigure 4.5: Weight Space\nThe question of whether or not there exists a weight vector that gives desired\nresponses for a given set of patterns can be given a geometric interpretation. To\ndo so involves reversing the \u201cpolarity\u201d of those hyperplanes corresponding to\npatterns for which a negative response is desired. If we do that for our example\nabove, we get the weight space diagram shown in Fig. 4.6.\n2\n3\n4\n1\nV\n0\n1\n1\n2\n3\n2\n3\n4\nFigure 4.6: Solution Region in Weight Space42\nCHAPTER 4. NEURAL NETWORKS\nIf a weight vector exists that correctly classi\ufb01es a set of patterns, then the\nhalf-spaces de\ufb01ned by the correct responses for these patterns will have a non-\nempty intersection, called the solution region. The solution region will be a\n\u201chyper-wedge\u201d region whose vertex is at the origin of weight space and whose\ncross-section increases with increasing distance from the origin.\nThis region\nis shown shaded in Fig. 4.6. (The boxed numbers show, for later purposes,\nthe number of errors made by weight vectors in each of the regions.)\nThe\n\ufb01xed-increment error-correction procedure changes a weight vector by moving it\nnormal to any pattern hyperplane for which that weight vector gives an incorrect\nresponse. Suppose in our example that we present the patterns in the sequence\nY1, Y2, Y3, Y4, and start the process with a weight point V1, as shown in Fig.\n4.7. Starting at V1, we see that it gives an incorrect response for pattern Y1, so\nwe move V1 to V2 in a direction normal to plane 1. (That is what adding Y1 to\nV1 does.) Y2 gives an incorrect response for pattern Y2, and so on. Ultimately,\nthe responses are only incorrect for planes bounding the solution region. Some\nof the subsequent corrections may overshoot the solution region, but eventually\nwe work our way out far enough in the solution region that corrections (for\na \ufb01xed increment size) take us within it. The proofs for convergence of the\n\ufb01xed-increment rule make this intuitive argument precise.\n2\n3\n4\n1\nV\nV1\nV2\nV3\nV4\nV5\nV6\nFigure 4.7: Moving Into the Solution Region\n4.1.5\nThe Widrow-Ho\ufb00Procedure\nThe Widrow-Ho\ufb00procedure (also called the LMS or the delta procedure) at-\ntempts to \ufb01nd weights that minimize a squared-error function between the pat-\ntern labels and the dot product computed by a TLU. For this purpose, the\npattern labels are assumed to be either +1 or \u22121 (instead of 1 or 0).\nThe4.1. THRESHOLD LOGIC UNITS\n43\nsquared error for a pattern, Xi, with label di (for desired output) is:\n\u03b5i = (di \u2212\nn+1\nX\nj=1\nxijwj)2\nwhere xij is the j-th component of Xi. The total squared error (over all patterns\nin a training set, \u039e, containing m patterns) is then:\n\u03b5 =\nm\nX\ni=1\n(di \u2212\nn+1\nX\nj=1\nxijwj)2\nWe want to choose the weights wj to minimize this squared error. One way to\n\ufb01nd such a set of weights is to start with an arbitrary weight vector and move it\nalong the negative gradient of \u03b5 as a function of the weights. Since \u03b5 is quadratic\nin the wj, we know that it has a global minimum, and thus this steepest descent\nprocedure is guaranteed to \ufb01nd the minimum. Each component of the gradient\nis the partial derivative of \u03b5 with respect to one of the weights. One problem\nwith taking the partial derivative of \u03b5 is that \u03b5 depends on all the input vectors\nin \u039e. Often, it is preferable to use an incremental procedure in which we try the\nTLU on just one element, Xi, of \u039e at a time, compute the gradient of the single-\npattern squared error, \u03b5i, make the appropriate adjustment to the weights, and\nthen try another member of \u039e. Of course, the results of the incremental version\ncan only approximate those of the batch one, but the approximation is usually\nquite e\ufb00ective. We will be describing the incremental version here.\nThe j-th component of the gradient of the single-pattern error is:\n\u2202\u03b5i\n\u2202wj\n= \u22122(di \u2212\nn+1\nX\nj=1\nxijwj)xij\nAn adjustment in the direction of the negative gradient would then change each\nweight as follows:\nwj \u2190\n\u2212wj + ci(di \u2212fi)xij\nwhere fi = Pn+1\nj=1 xijwj, and ci governs the size of the adjustment. The entire\nweight vector (in augmented, or V, notation) is thus adjusted according to the\nfollowing rule:\nV \u2190\n\u2212V + ci(di \u2212fi)Yi\nwhere, as before, Yi is the i-th augmented pattern vector.\nThe Widrow-Ho\ufb00procedure makes adjustments to the weight vector when-\never the dot product itself, Yi\u2022V, does not equal the speci\ufb01ed desired target44\nCHAPTER 4. NEURAL NETWORKS\nvalue, di (which is either 1 or \u22121).\nThe learning-rate factor, ci, might de-\ncrease with time toward 0 to achieve asymptotic convergence. The Widrow-\nHo\ufb00formula for changing the weight vector has the same form as the standard\n\ufb01xed-increment error-correction formula. The only di\ufb00erence is that fi is the\nthresholded response of the TLU in the error-correction case while it is the dot\nproduct itself for the Widrow-Ho\ufb00procedure.\nFinding weight values that give the desired dot products corresponds to solv-\ning a set of linear equalities, and the Widrow-Ho\ufb00procedure can be interpreted\nas a descent procedure that attempts to minimize the mean-squared-error be-\ntween the actual and desired values of the dot product. (For more on Widrow-\nHo\ufb00and other related procedures, see [Duda & Hart, 1973, pp. 151\ufb00].)\nExamples of training curves for\nTLU\u2019s; performance on training\nset; performance on test set;\ncumulative number of corrections.\n4.1.6\nTraining a TLU on Non-Linearly-Separable Training\nSets\nWhen the training set is not linearly separable (perhaps because of noise or\nperhaps inherently), it may still be desired to \ufb01nd a \u201cbest\u201d separating hy-\nperplane. Typically, the error-correction procedures will not do well on non-\nlinearly-separable training sets because they will continue to attempt to correct\ninevitable errors, and the hyperplane will never settle into an acceptable place.\nSeveral methods have been proposed to deal with this case. First, we might\nuse the Widrow-Ho\ufb00procedure, which (although it will not converge to zero\nerror on non-linearly separable problems) will give us a weight vector that min-\nimizes the mean-squared-error. A mean-squared-error criterion often gives un-\nsatisfactory results, however, because it prefers many small errors to a few large\nones. As an alternative, error correction with a continuous decrease toward zero\nof the value of the learning rate constant, c, will result in ever decreasing changes\nto the hyperplane. Duda [Duda, 1966] has suggested keeping track of the average\nvalue of the weight vector during error correction and using this average to give a\nseparating hyperplane that performs reasonably well on non-linearly-separable\nproblems. Gallant [Gallant, 1986] proposed what he called the \u201cpocket algo-\nrithm.\u201d As described in [Hertz, Krogh, & Palmer, 1991, p. 160]:\n. . . the pocket algorithm . . . consists simply in storing (or \u201cputting\nin your pocket\u201d) the set of weights which has had the longest un-\nmodi\ufb01ed run of successes so far. The algorithm is stopped after some\nchosen time t . . .\nAfter stopping, the weights in the pocket are used as a set that should give a\nsmall number of errors on the training set. Error-correction proceeds as usual\nwith the ordinary set of weights.\nAlso see methods proposed by\n[John, 1995] and by\n[Marchand & Golea, 1993]. The\nlatter is claimed to outperform the\npocket algorithm.\n4.2\nLinear Machines\nThe natural generalization of a (two-category) TLU to an R-category classi\ufb01er\nis the structure, shown in Fig. 4.8, called a linear machine. Here, to use more4.2. LINEAR MACHINES\n45\nfamiliar notation, the Ws and X are meant to be augmented vectors (with an\n(n+1)-st component). Such a structure is also sometimes called a \u201ccompetitive\u201d\nnet or a \u201cwinner-take-all\u201d net.\nThe output of the linear machine is one of\nthe numbers, {1, . . . , R}, corresponding to which dot product is largest. Note\nthat when R = 2, the linear machine reduces to a TLU with weight vector\nW = (W1 \u2212W2).\nX\nW1\nWR\n. . .\nY\nY\nARGMAX\nW1.X\nWR.X\nFigure 4.8: A Linear Machine\nThe diagram in Fig. 4.9 shows the character of the regions in a 2-dimensional\nspace created by a linear machine for R = 5. In n dimensions, every pair of\nregions is either separated by a section of a hyperplane or is non-adjacent.\nR1\nR3\nR4\nR5\nX.W4 * X.Wi for i & 4\nR2\nIn this region:\nFigure 4.9: Regions For a Linear Machine\nTo train a linear machine, there is a straightforward generalization of the\n2-category error-correction rule. Assemble the patterns in the training set into\na sequence as before.\na. If the machine classi\ufb01es a pattern correctly, no change is made to any of46\nCHAPTER 4. NEURAL NETWORKS\nthe weight vectors.\nb. If the machine mistakenly classi\ufb01es a category u pattern, Xi, in category\nv (u \u0338= v), then:\nWu \u2190\n\u2212Wu + ciXi\nand\nWv \u2190\n\u2212Wv \u2212ciXi\nand all other weight vectors are not changed.\nThis correction increases the value of the u-th dot product and decreases the\nvalue of the v-th dot product. Just as in the 2-category \ufb01xed increment proce-\ndure, this procedure is guaranteed to terminate, for constant ci, if there exists\nweight vectors that make correct separations of the training set. Note that when\nR = 2, this procedure reduces to the ordinary TLU error-correction procedure.\nA proof that this procedure terminates is given in [Nilsson, 1990, pp. 88-90]\nand in [Duda & Hart, 1973, pp. 174-177].\n4.3\nNetworks of TLUs\n4.3.1\nMotivation and Examples\nLayered Networks\nTo classify correctly all of the patterns in non-linearly-separable training sets re-\nquires separating surfaces more complex than hyperplanes. One way to achieve\nmore complex surfaces is with networks of TLUs. Consider, for example, the 2-\ndimensional, even parity function, f = x1x2 + x1 x2. No single line through the\n2-dimensional square can separate the vertices (1,1) and (0,0) from the vertices\n(1,0) and (0,1)\u2014the function is not linearly separable and thus cannot be im-\nplemented by a single TLU. But, the network of three TLUs shown in Fig. 4.10\ndoes implement this function. In the \ufb01gure, we show the weight values along\ninput lines to each TLU and the threshold value inside the circle representing\nthe TLU.\nThe function implemented by a network of TLUs depends on its topology\nas well as on the weights of the individual TLUs. Feedforward networks have\nno cycles; in a feedforward network no TLU\u2019s input depends (through zero\nor more intermediate TLUs) on that TLU\u2019s output. (Networks that are not\nfeedforward are called recurrent networks). If the TLUs of a feedforward network\nare arranged in layers, with the elements of layer j receiving inputs only from\nTLUs in layer j \u22121, then we say that the network is a layered, feedforward4.3. NETWORKS OF TLUS\n47\nf\nx1\nx2\n1.5\n-0.5\n0.5\n1\n1\n-1\n-1\n1\n1\nFigure 4.10: A Network for the Even Parity Function\nnetwork. The network shown in Fig. 4.10 is a layered, feedforward network\nhaving two layers (of weights). (Some people count the layers of TLUs and\ninclude the inputs as a layer also; they would call this network a three-layer\nnetwork.) In general, a feedforward, layered network has the structure shown\nin Fig. 4.11. All of the TLUs except the \u201coutput\u201d units are called hidden units\n(they are \u201chidden\u201d from the output).\nX\nhidden units\noutput units\nFigure 4.11: A Layered, Feedforward Network\nImplementing DNF Functions by Two-Layer Networks\nWe have already de\ufb01ned k-term DNF functions\u2014they are DNF functions having\nk terms. A k-term DNF function can be implemented by a two-layer network\nwith k units in the hidden layer\u2014to implement the k terms\u2014and one output\nunit to implement the disjunction of these terms. Since any Boolean function\nhas a DNF form, any Boolean function can be implemented by some two-layer\nnetwork of TLUs. As an example, consider the function f = x1x2 + x2x3 +\nx1x3. The form of the network that implements this function is shown in Fig.\n4.12. (We leave it to the reader to calculate appropriate values of weights and48\nCHAPTER 4. NEURAL NETWORKS\nthresholds.) The 3-cube representation of the function is shown in Fig. 4.13.\nThe network of Fig. 4.12 can be designed so that each hidden unit implements\none of the planar boundaries shown in Fig. 4.13.\nx\nconjuncts\ndisjunct\nA Feedforward, 2-layer Network\nTLUs\ndisjunction\nof terms\nconjunctions\nof literals\n(terms)\nFigure 4.12: A Two-Layer Network\nx2\nx1\nx3\nf = x1x2 + x2x3 + x1x3\nFigure 4.13: Three Planes Implemented by the Hidden Units\nTo train a two-layer network that implements a k-term DNF function, we\n\ufb01rst note that the output unit implements a disjunction, so the weights in the\n\ufb01nal layer are \ufb01xed. The weights in the \ufb01rst layer (except for the \u201cthreshold\nweights\u201d) can all have values of 1, \u22121, or 0. Later, we will present a training\nprocedure for this \ufb01rst layer of weights.\nDiscuss half-space intersections,\nhalf-space unions, NP-hardness of\noptimal versions,\nsingle-side-error-hypeplane\nmethods, relation to \u201cAQ\u201d\nmethods.4.3. NETWORKS OF TLUS\n49\nImportant Comment About Layered Networks\nAdding additional layers cannot compensate for an inadequate \ufb01rst layer of\nTLUs. The \ufb01rst layer of TLUs partitions the feature space so that no two dif-\nferently labeled vectors are in the same region (that is, so that no two such\nvectors yield the same set of outputs of the \ufb01rst-layer units). If the \ufb01rst layer\ndoes not partition the feature space in this way, then regardless of what subse-\nquent layers do, the \ufb01nal outputs will not be consistent with the labeled training\nset.\nAdd diagrams showing the\nnon-linear transformation\nperformed by a layered network.\n4.3.2\nMadalines\nTwo-Category Networks\nAn interesting example of a layered, feedforward network is the two-layer one\nwhich has an odd number of hidden units, and a \u201cvote-taking\u201d TLU as the\noutput unit. Such a network was called a \u201cMadaline\u201d (for many adalines by\nWidrow. Typically, the response of the vote taking unit is de\ufb01ned to be the\nresponse of the majority of the hidden units, although other output logics are\npossible. Ridgway [Ridgway, 1962] proposed the following error-correction rule\nfor adjusting the weights of the hidden units of a Madaline:\n\u2022 If the Madaline correctly classi\ufb01es a pattern, Xi, no corrections are made\nto any of the hidden units\u2019 weight vectors,\n\u2022 If the Madaline incorrectly classi\ufb01es a pattern, Xi, then determine the\nminimum number of hidden units whose responses need to be changed\n(from 0 to 1 or from 1 to 0\u2014depending on the type of error) in order that\nthe Madaline would correctly classify Xi. Suppose that minimum number\nis ki. Of those hidden units voting incorrectly, change the weight vectors\nof those ki of them whose dot products are closest to 0 by using the error\ncorrection rule:\nW \u2190\n\u2212W + ci(di \u2212fi)Xi\nwhere di is the desired response of the hidden unit (0 or 1) and fi is the\nactual response (0 or 1). (We assume augmented vectors here even though\nwe are using X, W notation.)\nThat is, we perform error-correction on just enough hidden units to correct\nthe vote to a majority voting correctly, and we change those that are easiest to\nchange. There are example problems in which even though a set of weight values\nexists for a given Madaline structure such that it could classify all members of\na training set correctly, this procedure will fail to \ufb01nd them. Nevertheless, the\nprocedure works e\ufb00ectively in most experiments with it.\nWe leave it to the reader to think about how this training procedure could\nbe modi\ufb01ed if the output TLU implemented an or function (or an and function).50\nCHAPTER 4. NEURAL NETWORKS\nR-Category Madalines and Error-Correcting Output Codes\nIf there are k hidden units (k > 1) in a two-layer network, their responses\ncorrespond to vertices of a k-dimensional hypercube. The ordinary two-category\nMadaline identi\ufb01es two special points in this space, namely the vertex consisting\nof k 1\u2019s and the vertex consisting of k 0\u2019s. The Madaline\u2019s response is 1 if the\npoint in \u201chidden-unit-space\u201d is closer to the all 1\u2019s vertex than it is to the all\n0\u2019s vertex. We could design an R-category Madaline by identifying R vertices\nin hidden-unit space and then classifying a pattern according to which of these\nvertices the hidden-unit response is closest to. A machine using that idea was\nimplemented in the early 1960s at SRI [Brain, et al., 1962]. It used the fact\nthat the 2p so-called maximal-length shift-register sequences [Peterson, 1961, pp.\n147\ufb00] in a (2p \u22121)-dimensional Boolean space are mutually equidistant (for any\ninteger p). For similar, more recent work see [Dietterich & Bakiri, 1991].\n4.3.3\nPiecewise Linear Machines\nA two-category training set is linearly separable if there exists a threshold func-\ntion that correctly classi\ufb01es all members of the training set. Similarly, we can\nsay that an R-category training set is linearly separable if there exists a linear\nmachine that correctly classi\ufb01es all members of the training set. When an R-\ncategory problem is not linearly separable, we need a more powerful classi\ufb01er.\nA candidate is a structure called a piecewise linear (PWL) machine illustrated\nin Fig. 4.14.\nX\nW1\nW1\n. . .\nY\nY\nMAX\n. . .\nY\nY\nMAX\n. . .\nWR\nWR\nARG\nMAX\n1\nR\n1\nN1\n1\nNR\nFigure 4.14: A Piecewise Linear Machine4.3. NETWORKS OF TLUS\n51\nThe PWL machine groups its weighted summing units into R banks corre-\nsponding to the R categories. An input vector X is assigned to that category\ncorresponding to the bank with the largest weighted sum. We can use an error-\ncorrection training algorithm similar to that used for a linear machine. If a\npattern is classi\ufb01ed incorrectly, we subtract (a constant times) the pattern vec-\ntor from the weight vector producing the largest dot product (it was incorrectly\nthe largest) and add (a constant times) the pattern vector to that weight vector\nin the correct bank of weight vectors whose dot product is locally largest in\nthat bank. (Again, we use augmented vectors here.) Unfortunately, there are\nexample training sets that are separable by a given PWL machine structure\nbut for which this error-correction training method fails to \ufb01nd a solution. The\nmethod does appear to work well in some situations [Duda & Fossum, 1966], al-\nthough [Nilsson, 1965, page 89] observed that \u201cit is probably not a very e\ufb00ective\nmethod for training PWL machines having more than three [weight vectors] in\neach bank.\u201d\n4.3.4\nCascade Networks\nAnother interesting class of feedforward networks is that in which all of the TLUs\nare ordered and each TLU receives inputs from all of the pattern components\nand from all TLUs lower in the ordering. Such a network is called a cascade\nnetwork. An example is shown in Fig. 4.15 in which the TLUs are labeled by\nthe linearly separable functions (of their inputs) that they implement. Each\nTLU in the network implements a set of 2k parallel hyperplanes, where k is\nthe number of TLUs from which it receives inputs. (Each of the k preceding\nTLUs can have an output of 1 or 0; that\u2019s 2k di\ufb00erent combinations\u2014resulting\nin 2k di\ufb00erent positions for the parallel hyperplanes.) We show a 3-dimensional\nsketch for a network of two TLUs in Fig. 4.16. The reader might consider how\nthe n-dimensional parity function might be implemented by a cascade network\nhaving log2 n TLUs.\nx\nL1\nL2\noutput\nL3\nFigure 4.15: A Cascade Network52\nCHAPTER 4. NEURAL NETWORKS\nL1\nL2\nL2\nFigure 4.16: Planes Implemented by a Cascade Network with Two TLUs\nCascade networks might be trained by \ufb01rst training L1 to do as good a job\nas possible at separating all the training patterns (perhaps by using the pocket\nalgorithm, for example), then training L2 (including the weight from L1 to L2)\nalso to do as good a job as possible at separating all the training patterns,\nand so on until the resulting network classi\ufb01es the patterns in the training set\nsatisfactorily.\nAlso mention the\n\u201ccascade-correlation\u201d method of\n[Fahlman & Lebiere, 1990].\n4.4\nTraining Feedforward Networks by Back-\npropagation\n4.4.1\nNotation\nThe general problem of training a network of TLUs is di\ufb03cult. Consider, for\nexample, the layered, feedforward network of Fig. 4.11. If such a network makes\nan error on a pattern, there are usually several di\ufb00erent ways in which the error\ncan be corrected. It is di\ufb03cult to assign \u201cblame\u201d for the error to any particular\nTLU in the network. Intuitively, one looks for weight-adjusting procedures that\nmove the network in the correct direction (relative to the error) by making\nminimal changes. In this spirit, the Widrow-Ho\ufb00method of gradient descent\nhas been generalized to deal with multilayer networks.\nIn explaining this generalization, we use Fig. 4.17 to introduce some nota-\ntion. This network has only one output unit, but, of course, it is possible to have\nseveral TLUs in the output layer\u2014each implementing a di\ufb00erent function. Each\nof the layers of TLUs will have outputs that we take to be the components of\nvectors, just as the input features are components of an input vector. The j-th\nlayer of TLUs (1 \u2264j < k) will have as their outputs the vector X(j). The input\nfeature vector is denoted by X(0), and the \ufb01nal output (of the k-th layer TLU)\nis f. Each TLU in each layer has a weight vector (connecting it to its inputs)\nand a threshold; the i-th TLU in the j-th layer has a weight vector denoted by\nW(j)\ni . (We will assume that the \u201cthreshold weight\u201d is the last component of\nthe associated weight vector; we might have used V notation instead to include4.4. TRAINING FEEDFORWARD NETWORKS BY BACKPROPAGATION53\nthis threshold component, but we have chosen here to use the familiar X,W\nnotation, assuming that these vectors are \u201caugmented\u201d as appropriate.) We\ndenote the weighted sum input to the i-th threshold unit in the j-th layer by\ns(j)\ni . (That is, s(j)\ni\n= X(j\u22121)\u2022W(j)\ni .) The number of TLUs in the j-th layer is\ngiven by mj. The vector W(j)\ni\nhas components w(j)\nl,i for l = 1, . . . , m(j\u22121) + 1.\nX(0)\n. . .\n. . .\n. . .\n. . .\nWi(1)\nW(k)\nX(1)\nm1 TLUs\n. . .\nWi(j)\n. . .\nX(j)\n. . .\nWi(k-1)\nX(k-1)\nmj TLUs\nm(k-1) TLUs\nwli(j)\nwl(k)\nFirst Layer\nj-th Layer\n(k-1)-th Layer\nk-th Layer\n. . .\nf\nsi(1)\nsi(j)\nsi(k-1)\ns(k)\nFigure 4.17: A k-layer Network\n4.4.2\nThe Backpropagation Method\nA gradient descent method, similar to that used in the Widrow Ho\ufb00method,\nhas been proposed by various authors for training a multi-layer, feedforward\nnetwork.\nAs before, we de\ufb01ne an error function on the \ufb01nal output of the\nnetwork and we adjust each weight in the network so as to minimize the error.\nIf we have a desired response, di, for the i-th input vector, Xi, in the training\nset, \u039e, we can compute the squared error over the entire training set to be:\n\u03b5 =\nX\nXi \u03f5 \u039e\n(di \u2212fi)2\nwhere fi is the actual response of the network for input Xi. To do gradient\ndescent on this squared error, we adjust each weight in the network by an\namount proportional to the negative of the partial derivative of \u03b5 with respect\nto that weight. Again, we use a single-pattern error function so that we can\nuse an incremental weight adjustment procedure. The squared error for a single\ninput vector, X, evoking an output of f when the desired output is d is:54\nCHAPTER 4. NEURAL NETWORKS\n\u03b5 = (d \u2212f)2\nIt is convenient to take the partial derivatives of \u03b5 with respect to the various\nweights in groups corresponding to the weight vectors.\nWe de\ufb01ne a partial\nderivative of a quantity \u03c6, say, with respect to a weight vector, W(j)\ni , thus:\n\u2202\u03c6\n\u2202W(j)\ni\ndef\n=\n\"\n\u2202\u03c6\n\u2202w(j)\n1i\n, . . . ,\n\u2202\u03c6\n\u2202w(j)\nli\n, . . . ,\n\u2202\u03c6\n\u2202w(j)\nmj\u22121+1,i\n#\nwhere w(j)\nli\nis the l-th component of W(j)\ni . This vector partial derivative of \u03c6 is\ncalled the gradient of \u03c6 with respect to W and is sometimes denoted by \u2207W\u03c6.\nSince \u03b5\u2019s dependence on W(j)\ni\nis entirely through s(j)\ni , we can use the chain\nrule to write:\n\u2202\u03b5\n\u2202W(j)\ni\n=\n\u2202\u03b5\n\u2202s(j)\ni\n\u2202s(j)\ni\n\u2202W(j)\ni\nBecause s(j)\ni\n= X(j\u22121)\u2022W(j)\ni ,\n\u2202s(j)\ni\n\u2202W(j)\ni\n= X(j\u22121). Substituting yields:\n\u2202\u03b5\n\u2202W(j)\ni\n=\n\u2202\u03b5\n\u2202s(j)\ni\nX(j\u22121)\nNote that\n\u2202\u03b5\n\u2202s(j)\ni\n= \u22122(d \u2212f) \u2202f\n\u2202s(j)\ni\n. Thus,\n\u2202\u03b5\n\u2202W(j)\ni\n= \u22122(d \u2212f) \u2202f\n\u2202s(j)\ni\nX(j\u22121)\nThe quantity (d\u2212f) \u2202f\n\u2202s(j)\ni\nplays an important role in our calculations; we shall\ndenote it by \u03b4(j)\ni\n. Each of the \u03b4(j)\ni\n\u2019s tells us how sensitive the squared error of\nthe network output is to changes in the input to each threshold function. Since\nwe will be changing weight vectors in directions along their negative gradient,\nour fundamental rule for weight changes throughout the network will be:\nW(j)\ni\n\u2190W(j)\ni\n+ c(j)\ni \u03b4(j)\ni\nX(j\u22121)\nwhere c(j)\ni\nis the learning rate constant for this weight vector. (Usually, the\nlearning rate constants for all weight vectors in the network are the same.) We\nsee that this rule is quite similar to that used in the error correction procedure4.4. TRAINING FEEDFORWARD NETWORKS BY BACKPROPAGATION55\nfor a single TLU. A weight vector is changed by the addition of a constant times\nits vector of (unweighted) inputs.\nNow, we must turn our attention to the calculation of the \u03b4(j)\ni\n\u2019s. Using the\nde\ufb01nition, we have:\n\u03b4(j)\ni\n= (d \u2212f) \u2202f\n\u2202s(j)\ni\nWe have a problem, however, in attempting to carry out the partial deriva-\ntives of f with respect to the s\u2019s. The network output, f, is not continuously\ndi\ufb00erentiable with respect to the s\u2019s because of the presence of the threshold\nfunctions. Most small changes in these sums do not change f at all, and when\nf does change, it changes abruptly from 1 to 0 or vice versa.\nA way around this di\ufb03culty was proposed by Werbos [Werbos, 1974] and\n(perhaps independently) pursued by several other researchers, for example\n[Rumelhart, Hinton, & Williams, 1986].\nThe trick involves replacing all the\nthreshold functions by di\ufb00erentiable functions called sigmoids.1\nThe output\nof a sigmoid function, superimposed on that of a threshold function, is shown\nin Fig. 4.18. Usually, the sigmoid function used is f(s) =\n1\n1+e\u2212s , where s is\nthe input and f is the output.\nsigmoid\nthreshold function\nf (s)\ns\nf (s) = 1/[1 + e<s]\nFigure 4.18: A Sigmoid Function\n1[Russell & Norvig 1995, page 595] attributes the use of this idea to [Bryson & Ho 1969].56\nCHAPTER 4. NEURAL NETWORKS\nWe show the network containing sigmoid units in place of TLUs in Fig. 4.19.\nThe output of the i-th sigmoid unit in the j-th layer is denoted by f (j)\ni\n. (That\nis, f (j)\ni\n=\n1\n1+e\u2212s(j)\ni\n.)\nX(0)\n. . .\n. . .\n. . .\n. . .\nWi(1)\nsi(1)\nW(k)\nX(1)\nfi(1)\nm1 sigmoids\n. . .\nWi(j) fi(j)\nsi(j)\n. . .\nX(j)\n. . .\nWi(k-1)\nfi(k-1)\nsi(k-1)\nf(k)\ns(k)\nX(k-1)\nmj sigmoids\nm(k-1) sigmoids\nwli(j)\nwl(k)\nbi(j)\nbi(1)\nbi(k-1)\nb(k)\nFirst Layer\nj-th Layer\n(k-1)-th Layer\nk-th Layer\n. . .\nFigure 4.19: A Network with Sigmoid Units\n4.4.3\nComputing Weight Changes in the Final Layer\nWe \ufb01rst calculate \u03b4(k) in order to compute the weight change for the \ufb01nal sigmoid\nunit:4.4. TRAINING FEEDFORWARD NETWORKS BY BACKPROPAGATION57\n\u03b4(k) = (d \u2212f (k))\u2202f (k)\n\u2202s(k)\nGiven the sigmoid function that we are using, namely f(s) =\n1\n1+e\u2212s , we have\nthat \u2202f\n\u2202s = f(1 \u2212f). Substituting gives us:\n\u03b4(k) = (d \u2212f (k))f (k)(1 \u2212f (k))\nRewriting our general rule for weight vector changes, the weight vector in\nthe \ufb01nal layer is changed according to the rule:\nW(k) \u2190W(k) + c(k)\u03b4(k)X(k\u22121)\nwhere \u03b4(k) = (d \u2212f (k))f (k)(1 \u2212f (k))\nIt is interesting to compare backpropagation to the error-correction rule and\nto the Widrow-Ho\ufb00rule. The backpropagation weight adjustment for the single\nelement in the \ufb01nal layer can be written as:\nW \u2190\n\u2212W + c(d \u2212f)f(1 \u2212f)X\nWritten in the same format, the error-correction rule is:\nW \u2190\n\u2212W + c(d \u2212f)X\nand the Widrow-Ho\ufb00rule is:\nW \u2190\n\u2212W + c(d \u2212f)X\nThe only di\ufb00erence (except for the fact that f is not thresholded in Widrow-\nHo\ufb00) is the f(1 \u2212f) term due to the presence of the sigmoid function. With\nthe sigmoid function, f(1 \u2212f) can vary in value from 0 to 1. When f is 0,\nf(1 \u2212f) is also 0; when f is 1, f(1 \u2212f) is 0; f(1 \u2212f) obtains its maximum\nvalue of 1/4 when f is 1/2 (that is, when the input to the sigmoid is 0). The\nsigmoid function can be thought of as implementing a \u201cfuzzy\u201d hyperplane. For\na pattern far away from this fuzzy hyperplane, f(1 \u2212f) has value close to 0,\nand the backpropagation rule makes little or no change to the weight values\nregardless of the desired output. (Small changes in the weights will have little\ne\ufb00ect on the output for inputs far from the hyperplane.) Weight changes are\nonly made within the region of \u201cfuzz\u201d surrounding the hyperplane, and these\nchanges are in the direction of correcting the error, just as in the error-correction\nand Widrow-Ho\ufb00rules.58\nCHAPTER 4. NEURAL NETWORKS\n4.4.4\nComputing Changes to the Weights in Intermediate\nLayers\nUsing our expression for the \u03b4\u2019s, we can similarly compute how to change each\nof the weight vectors in the network. Recall:\n\u03b4(j)\ni\n= (d \u2212f) \u2202f\n\u2202s(j)\ni\nAgain we use a chain rule. The \ufb01nal output, f, depends on s(j)\ni\nthrough\neach of the summed inputs to the sigmoids in the (j + 1)-th layer. So:\n\u03b4(j)\ni\n= (d \u2212f) \u2202f\n\u2202s(j)\ni\n= (d \u2212f)\n\"\n\u2202f\n\u2202s(j+1)\n1\n\u2202s(j+1)\n1\n\u2202s(j)\ni\n+ \u00b7 \u00b7 \u00b7 +\n\u2202f\n\u2202s(j+1)\nl\n\u2202s(j+1)\nl\n\u2202s(j)\ni\n+ \u00b7 \u00b7 \u00b7 +\n\u2202f\n\u2202s(j+1)\nmj+1\n\u2202s(j+1)\nmj+1\n\u2202s(j)\ni\n#\n=\nmj+1\nX\nl=1\n(d \u2212f)\n\u2202f\n\u2202s(j+1)\nl\n\u2202s(j+1)\nl\n\u2202s(j)\ni\n=\nmj+1\nX\nl=1\n\u03b4(j+1)\nl\n\u2202s(j+1)\nl\n\u2202s(j)\ni\nIt remains to compute the\n\u2202s(j+1)\nl\n\u2202s(j)\ni\n\u2019s. To do that we \ufb01rst write:\ns(j+1)\nl\n= X(j)\u2022W(j+1)\nl\n=\nmj+1\nX\n\u03bd=1\nf (j)\n\u03bd w(j+1)\n\u03bdl\nAnd then, since the weights do not depend on the s\u2019s:\n\u2202s(j+1)\nl\n\u2202s(j)\ni\n=\n\u2202\nhPmj+1\n\u03bd=1\nf (j)\n\u03bd w(j+1)\n\u03bdl\ni\n\u2202s(j)\ni\n=\nmj+1\nX\n\u03bd=1\nw(j+1)\n\u03bdl\n\u2202f (j)\n\u03bd\n\u2202s(j)\ni\nNow, we note that \u2202f (j)\n\u03bd\n\u2202s(j)\ni\n= 0 unless \u03bd = i, in which case \u2202f (j)\n\u03bd\n\u2202s(j)\n\u03bd\n= f (j)\n\u03bd (1 \u2212f (j)\n\u03bd ).\nTherefore:\n\u2202s(j+1)\nl\n\u2202s(j)\ni\n= w(j+1)\nil\nf (j)\ni\n(1 \u2212f (j)\ni\n)4.4. TRAINING FEEDFORWARD NETWORKS BY BACKPROPAGATION59\nWe use this result in our expression for \u03b4(j)\ni\nto give:\n\u03b4(j)\ni\n= f (j)\ni\n(1 \u2212f (j)\ni\n)\nmj+1\nX\nl=1\n\u03b4(j+1)\nl\nw(j+1)\nil\nThe above equation is recursive in the \u03b4\u2019s. (It is interesting to note that\nthis expression is independent of the error function; the error function explicitly\na\ufb00ects only the computation of \u03b4(k).) Having computed the \u03b4(j+1)\ni\n\u2019s for layer\nj + 1, we can use this equation to compute the \u03b4(j)\ni\n\u2019s. The base case is \u03b4(k),\nwhich we have already computed:\n\u03b4(k) = (d \u2212f (k))f (k)(1 \u2212f (k))\nWe use this expression for the \u03b4\u2019s in our generic weight changing rule, namely:\nW(j)\ni\n\u2190W(j)\ni\n+ c(j)\ni \u03b4(j)\ni\nX(j\u22121)\nAlthough this rule appears complex, it has an intuitively reasonable explanation.\nThe quantity \u03b4(k) = (d \u2212f)f(1 \u2212f) controls the overall amount and sign of all\nweight adjustments in the network. (Adjustments diminish as the \ufb01nal output,\nf, approaches either 0 or 1, because they have vanishing e\ufb00ect on f then.) As\nthe recursion equation for the \u03b4\u2019s shows, the adjustments for the weights going\nin to a sigmoid unit in the j-th layer are proportional to the e\ufb00ect that such\nadjustments have on that sigmoid unit\u2019s output (its f (j)(1\u2212f (j)) factor). They\nare also proportional to a kind of \u201caverage\u201d e\ufb00ect that any change in the output\nof that sigmoid unit will have on the \ufb01nal output. This average e\ufb00ect depends\non the weights going out of the sigmoid unit in the j-th layer (small weights\nproduce little downstream e\ufb00ect) and the e\ufb00ects that changes in the outputs of\n(j + 1)-th layer sigmoid units will have on the \ufb01nal output (as measured by the\n\u03b4(j+1)\u2019s). These calculations can be simply implemented by \u201cbackpropagating\u201d\nthe \u03b4\u2019s through the weights in reverse direction (thus, the name backprop for\nthis algorithm).\n4.4.5\nVariations on Backprop\n[To be written: problem of local minima, simulated annealing, momemtum\n(Plaut, et al., 1986, see [Hertz, Krogh, & Palmer, 1991]), quickprop, regulariza-\ntion methods]\nSimulated Annealing\nTo apply simulated annealing, the value of the learning rate constant is gradually\ndecreased with time. If we fall early into an error-function valley that is not\nvery deep (a local minimum), it typically will neither be very broad, and soon60\nCHAPTER 4. NEURAL NETWORKS\na subsequent large correction will jostle us out of it. It is less likely that we will\nmove out of deep valleys, and at the end of the process (with very small values\nof the learning rate constant), we descend to its deepest point. The process\ngets its name by analogy with annealing in metallurgy, in which a material\u2019s\ntemperature is gradually decreased allowing its crystalline structure to reach a\nminimal energy state.\n4.4.6\nAn Application: Steering a Van\nA neural network system called ALVINN (Autonomous Land Vehicle in a Neural\nNetwork) has been trained to steer a Chevy van successfully on ordinary roads\nand highways at speeds of 55 mph [Pomerleau, 1991, Pomerleau, 1993]. The\ninput to the network is derived from a low-resolution (30 x 32) television image.\nThe TV camera is mounted on the van and looks at the road straight ahead.\nThis image is sampled and produces a stream of 960-dimensional input vectors\nto the neural network. The network is shown in Fig. 4.20.\n960 inputs\n30 x 32 retina\n. . .\n5 hidden\nunits connected\nto all 960 inputs\n30 output units\nconnected to all\nhidden units\n. . .\nsharp left\nsharp right\nstraight ahead\ncentroid\nof outputs\nsteers\nvehicle\nFigure 4.20: The ALVINN Network\nThe network has \ufb01ve hidden units in its \ufb01rst layer and 30 output units in the\nsecond layer; all are sigmoid units. The output units are arranged in a linear\norder and control the van\u2019s steering angle. If a unit near the top of the array\nof output units has a higher output than most of the other units, the van is\nsteered to the left; if a unit near the bottom of the array has a high output, the\nvan is steered to the right. The \u201ccentroid\u201d of the responses of all of the output4.5. SYNERGIES BETWEEN NEURAL NETWORK AND KNOWLEDGE-BASED METHODS61\nunits is computed, and the van\u2019s steering angle is set at a corresponding value\nbetween hard left and hard right.\nThe system is trained by a modi\ufb01ed on-line training regime. A driver drives\nthe van, and his actual steering angles are taken as the correct labels for the\ncorresponding inputs.\nThe network is trained incrementally by backprop to\nproduce the driver-speci\ufb01ed steering angles in response to each visual pattern\nas it occurs in real time while driving.\nThis simple procedure has been augmented to avoid two potential problems.\nFirst, since the driver is usually driving well, the network would never get any\nexperience with far-from-center vehicle positions and/or incorrect vehicle orien-\ntations. Also, on long, straight stretches of road, the network would be trained\nfor a long time only to produce straight-ahead steering angles; this training\nwould swamp out earlier training to follow a curved road. We wouldn\u2019t want\nto try to avoid these problems by instructing the driver to drive erratically\noccasionally, because the system would learn to mimic this erratic behavior.\nInstead, each original image is shifted and rotated in software to create 14\nadditional images in which the vehicle appears to be situated di\ufb00erently relative\nto the road. Using a model that tells the system what steering angle ought to\nbe used for each of these shifted images, given the driver-speci\ufb01ed steering angle\nfor the original image, the system constructs an additional 14 labeled training\npatterns to add to those encountered during ordinary driver training.\n4.5\nSynergies\nBetween\nNeural\nNetwork\nand\nKnowledge-Based Methods\nTo be written; discuss\nrule-generating procedures (such as\n[Towell & Shavlik, 1992]) and how\nexpert-provided rules can aid\nneural net training and vice-versa\n[Towell, Shavlik, & Noordweier, 1990].\n4.6\nBibliographical and Historical Remarks\nTo be added.62\nCHAPTER 4. NEURAL NETWORKS", "5": "Chapter 5\nStatistical Learning\n5.1\nUsing Statistical Decision Theory\n5.1.1\nBackground and General Method\nSuppose the pattern vector, X, is a random variable whose probability distri-\nbution for category 1 is di\ufb00erent than it is for category 2. (The treatment given\nhere can easily be generalized to R-category problems.) Speci\ufb01cally, suppose we\nhave the two probability distributions (perhaps probability density functions),\np(X | 1) and p(X | 2). Given a pattern, X, we want to use statistical tech-\nniques to determine its category\u2014that is, to determine from which distribution\nit was drawn. These techniques are based on the idea of minimizing the ex-\npected value of a quantity similar to the error function we used in deriving the\nweight-changing rules for backprop.\nIn developing a decision method, it is necessary to know the relative serious-\nness of the two kinds of mistakes that might be made. (We might decide that a\npattern really in category 1 is in category 2, and vice versa.) We describe this\ninformation by a loss function, \u03bb(i | j), for i, j = 1, 2. \u03bb(i | j) represents the loss\nincurred when we decide a pattern is in category i when really it is in category\nj. We assume here that \u03bb(1 | 1) and \u03bb(2 | 2) are both 0. For any given pattern,\nX, we want to decide its category in such a way that minimizes the expected\nvalue of this loss.\nGiven a pattern, X, if we decide category i, the expected value of the loss\nwill be:\nLX(i) = \u03bb(i | 1)p(1 | X) + \u03bb(i | 2)p(2 | X)\nwhere p(j | X) is the probability that given a pattern X, its category is j. Our\ndecision rule will be to decide that X belongs to category 1 if LX(1) \u2264LX(2),\nand to decide on category 2 otherwise.\n6364\nCHAPTER 5. STATISTICAL LEARNING\nWe can use Bayes\u2019 Rule to get expressions for p(j | X) in terms of p(X | j),\nwhich we assume to be known (or estimatible):\np(j | X) = p(X | j)p(j)\np(X)\nwhere p(j) is the (a priori) probability of category j (one category may be much\nmore probable than the other); and p(X) is the (a priori) probability of pattern\nX being the pattern we are asked to classify. Performing the substitutions given\nby Bayes\u2019 Rule, our decision rule becomes:\nDecide category 1 i\ufb00:\n\u03bb(1 | 1)p(X | 1)p(1)\np(X)\n+ \u03bb(1 | 2)p(X | 2)p(2)\np(X)\n\u2264\u03bb(2 | 1)p(X | 1)p(1)\np(X)\n+ \u03bb(2 | 2)p(X | 2)p(2)\np(X)\nUsing the fact that \u03bb(i | i) = 0, and noticing that p(X) is common to both\nexpressions, we obtain,\nDecide category 1 i\ufb00:\n\u03bb(1 | 2)p(X | 2)p(2) \u2264\u03bb(2 | 1)p(X | 1)p(1)\nIf \u03bb(1 | 2) = \u03bb(2 | 1) and if p(1) = p(2), then the decision becomes particu-\nlarly simple:\nDecide category 1 i\ufb00:\np(X | 2) \u2264p(X | 1)\nSince p(X | j) is called the likelihood of j with respect to X, this simple decision\nrule implements what is called a maximum-likelihood decision. More generally,\nif we de\ufb01ne k(i | j) as \u03bb(i | j)p(j), then our decision rule is simply,\nDecide category1 i\ufb00:\nk(1 | 2)p(X | 2) \u2264k(2 | 1)p(X | 1)\nIn any case, we need to compare the (perhaps weighted) quantities p(X | i) for\ni = 1 and 2. The exact decision rule depends on the the probability distributions\nassumed. We will treat two interesting distributions.5.1. USING STATISTICAL DECISION THEORY\n65\n5.1.2\nGaussian (or Normal) Distributions\nThe multivariate (n-dimensional) Gaussian distribution is given by the proba-\nbility density function:\np(X) =\n1\n(2\u03c0)n/2|\u03a3|1/2 e\n\u2212(X\u2212M)t\u03a3\n\u22121\n(X\u2212M)\n2\nwhere n is the dimension of the column vector X, the column vector M is called\nthe mean vector, (X \u2212M)t is the transpose of the vector (X \u2212M), \u03a3 is the\ncovariance matrix of the distribution (an n \u00d7 n symmetric, positive de\ufb01nite\nmatrix), \u03a3\u22121 is the inverse of the covariance matrix, and |\u03a3| is the determinant\nof the covariance matrix.\nThe mean vector, M, with components (m1, . . . , mn), is the expected value\nof X (using this distribution); that is, M = E[X].\nThe components of the\ncovariance matrix are given by:\n\u03c32\nij = E[(xi \u2212mi)(xj \u2212mj)]\nIn particular, \u03c32\nii is called the variance of xi.\nAlthough the formula appears complex, an intuitive idea for Gaussian dis-\ntributions can be given when n = 2.\nWe show a two-dimensional Gaussian\ndistribution in Fig. 5.1. A three-dimensional plot of the distribution is shown\nat the top of the \ufb01gure, and contours of equal probability are shown at the bot-\ntom. In this case, the covariance matrix, \u03a3, is such that the elliptical contours\nof equal probability are skewed. If the covariance matrix were diagonal, that is\nif all o\ufb00-diagonal terms were 0, then the major axes of the elliptical contours\nwould be aligned with the coordinate axes. In general the principal axes are\ngiven by the eigenvectors of \u03a3. In any case, the equi-probability contours are\nall centered on the mean vector, M, which in our \ufb01gure happens to be at the\norigin. In general, the formula in the exponent in the Gaussian distribution\nis a positive de\ufb01nite quadratic form (that is, its value is always positive); thus\nequi-probability contours are hyper-ellipsoids in n-dimensional space.\nSuppose we now assume that the two classes of pattern vectors that we\nwant to distinguish are each distributed according to a Gaussian distribution\nbut with di\ufb00erent means and covariance matrices. That is, one class tends to\nhave patterns clustered around one point in the n-dimensional space, and the\nother class tends to have patterns clustered around another point. We show a\ntwo-dimensional instance of this problem in Fig. 5.2. (In that \ufb01gure, we have\nplotted the sum of the two distributions.) What decision rule should we use to\nseparate patterns into the two appropriate categories?\nSubstituting the Gaussian distributions into our maximum likelihood for-\nmula yields:66\nCHAPTER 5. STATISTICAL LEARNING\n-5\n0\n5\n-5\n0\n5\n0\n0.25\n0.5\n0.75\n1\n-5\n0\n5\n-5\n0\n5\n0\n25\n.5\n75\n1\n-6\n-4\n-2\n0\n2\n4\n6\n-6\n-4\n-2\n0\n2\n4\n6\nx1\nx2\np(x1,x2)\n2\n4\n6\n2\n4\n6\nx1\nx2\nFigure 5.1: The Two-Dimensional Gaussian Distribution\nDecide category 1 i\ufb00:\n1\n(2\u03c0)n/2|\u03a32|1/2 e\u22121/2(X\u2212M2)t\u03a3\n\u22121\n2\n(X\u2212M2)\nis less than or equal to\n1\n(2\u03c0)n/2|\u03a31|1/2 e\u22121/2(X\u2212M1)t\u03a3\n\u22121\n1\n(X\u2212M1)\nwhere the category 1 patterns are distributed with mean and covariance M1\nand \u03a31, respectively, and the category 2 patterns are distributed with mean\nand covariance M2 and \u03a32.\nThe result of the comparison isn\u2019t changed if we compare logarithms instead.\nAfter some manipulation, our decision rule is then:5.1. USING STATISTICAL DECISION THEORY\n67\n-5\n0\n5\n10\n-5\n0\n5\n10\n0\n0.25\n0.5\n0.75\n1\n-5\n0\n5\n10\n-5\n0\n5\n10\n0\n25\n.5\n75\n1\nx1\nx2\np(x1,x2)\n-5\n-2.5\n0\n2.5\n5\n7.5\n10\n-5\n-2.5\n0\n2.5\n5\n7.5\n10\nFigure 5.2: The Sum of Two Gaussian Distributions\nDecide category 1 i\ufb00:\n(X \u2212M1)t\u03a3\u22121\n1 (X \u2212M1) < (X \u2212M2)t\u03a3\u22121\n2 (X \u2212M2) + B\nwhere B, a constant bias term, incorporates the logarithms of the fractions\npreceding the exponential, etc.\nWhen the quadratic forms are multiplied out and represented in terms of\nthe components xi, the decision rule involves a quadric surface (a hyperquadric)\nin n-dimensional space. The exact shape and position of this hyperquadric is\ndetermined by the means and the covariance matrices. The surface separates\nthe space into two parts, one of which contains points that will be assigned to\ncategory 1 and the other contains points that will be assigned to category 2.\nIt is interesting to look at a special case of this surface. If the covariance\nmatrices for each category are identical and diagonal, with all \u03c3ii equal to each\nother, then the contours of equal probability for each of the two distributions68\nCHAPTER 5. STATISTICAL LEARNING\nare hyperspherical. The quadric forms then become (1/|\u03a3|)(X\u2212Mi)t(X\u2212Mi),\nand the decision rule is:\nDecide category 1 i\ufb00:\n(X \u2212M1)t(X \u2212M1) < (X \u2212M2)t(X \u2212M2)\nMultiplying out yields:\nX\u2022X \u22122X\u2022M1 + M1\u2022M1 < X\u2022X \u22122X\u2022M2 + M2\u2022M2\nor \ufb01nally,\nDecide category 1 i\ufb00:\nX\u2022M1 \u2265X\u2022M2 + Constant\nor\nX\u2022(M1 \u2212M2) \u2265Constant\nwhere the constant depends on the lengths of the mean vectors.\nWe see that the optimal decision surface in this special case is a hyperplane.\nIn fact, the hyperplane is perpendicular to the line joining the two means. The\nweights in a TLU implementation are equal to the di\ufb00erence in the mean vectors.\nIf the parameters (Mi, \u03a3i) of the probability distributions of the categories\nare not known, there are various techniques for estimating them, and then using\nthose estimates in the decision rule. For example, if there are su\ufb03cient training\npatterns, one can use sample means and sample covariance matrices. (Caution:\nthe sample covariance matrix will be singular if the training patterns happen to\nlie on a subspace of the whole n-dimensional space\u2014as they certainly will, for\nexample, if the number of training patterns is less than n.)\n5.1.3\nConditionally Independent Binary Components\nSuppose the vector X is a random variable having binary (0,1) components.\nWe continue to denote the two probability distributions by p(X | 1) and p(X |\n2).\nFurther suppose that the components of these vectors are conditionally\nindependent given the category. By conditional independence in this case, we\nmean that the formulas for the distribution can be expanded as follows:5.1. USING STATISTICAL DECISION THEORY\n69\np(X | i) = p(x1 | i)p(x2 | i) \u00b7 \u00b7 \u00b7 p(xn | i)\nfor i = 1, 2\nRecall the minimum-average-loss decision rule,\nDecide category 1 i\ufb00:\n\u03bb(1 | 2)p(X | 2)p(2) \u2264\u03bb(2 | 1)p(X | 1)p(1)\nAssuming conditional independence of the components and that \u03bb(1 | 2) = \u03bb(2 |\n1), we obtain,\nDecide category 1 i\ufb00:\np(1)p(x1 | 1)p(x2 | 1) \u00b7 \u00b7 \u00b7 p(xn | 1) \u2265p(x1 | 2)p(x2 | 2) \u00b7 \u00b7 \u00b7 p(xn | 2)p(2)\nor i\ufb00:\np(x1 | 1)p(x2 | 1) . . . p(xn | 1)\np(x1 | 2)p(x2 | 2) . . . p(xn | 2) \u2265p(2)\np(1)\nor i\ufb00:\nlog p(x1 | 1)\np(x1 | 2) + log p(x2 | 1)\np(x2 | 2) + \u00b7 \u00b7 \u00b7 + log p(xn | 1)\np(xn | 2) + log p(1)\np(2) \u22650\nLet us de\ufb01ne values of the components of the distribution for speci\ufb01c values of\ntheir arguments, xi :\np(xi = 1 | 1) = pi\np(xi = 0 | 1) = 1 \u2212pi\np(xi = 1 | 2) = qi\np(xi = 0 | 2) = 1 \u2212qi\nNow, we note that since xi can only assume the values of 1 or 0:\nlog p(xi | 1)\np(xi | 2) = xi log pi\nqi\n+ (1 \u2212xi) log (1 \u2212pi)\n(1 \u2212qi)70\nCHAPTER 5. STATISTICAL LEARNING\n= xi log pi(1 \u2212qi)\nqi(1 \u2212pi) + log (1 \u2212pi)\n(1 \u2212qi)\nSubstituting these expressions into our decision rule yields:\nDecide category 1 i\ufb00:\nn\nX\ni=1\nxi log pi(1 \u2212qi)\nqi(1 \u2212pi) +\nn\nX\ni=1\nlog (1 \u2212pi)\n(1 \u2212qi) + log p(1)\np(2) \u22650\nWe see that we can achieve this decision with a TLU with weight values as\nfollows:\nwi = log pi(1 \u2212qi)\nqi(1 \u2212pi)\nfor i = 1, . . . , n, and\nwn+1 = log\np(1)\n1 \u2212p(1) +\nn\nX\ni=1\nlog (1 \u2212pi)\n(1 \u2212qi)\nIf we do not know the pi, qi and p(1), we can use a sample of labeled training\npatterns to estimate these parameters.\n5.2\nLearning Belief Networks\nTo be added.\n5.3\nNearest-Neighbor Methods\nAnother class of methods can be related to the statistical ones. These are called\nnearest-neighbor methods or, sometimes, memory-based methods. (A collection\nof papers on this subject is in [Dasarathy, 1991].) Given a training set \u039e of m\nlabeled patterns, a nearest-neighbor procedure decides that some new pattern,\nX, belongs to the same category as do its closest neighbors in \u039e. More precisely,\na k-nearest-neighbor method assigns a new pattern, X, to that category to which\nthe plurality of its k closest neighbors belong. Using relatively large values of\nk decreases the chance that the decision will be unduly in\ufb02uenced by a noisy\ntraining pattern close to X. But large values of k also reduce the acuity of the\nmethod. The k-nearest-neighbor method can be thought of as estimating the\nvalues of the probabilities of the classes given X. Of course the denser are the\npoints around X, and the larger the value of k, the better the estimate.5.3. NEAREST-NEIGHBOR METHODS\n71\nThe distance metric used in nearest-neighbor methods (for numerical at-\ntributes) can be simple Euclidean distance. That is, the distance between two\npatterns (x11, x12, . . . , x1n) and (x21, x22, . . . , x2n) is\nqPn\nj=1(x1j \u2212x2j)2. This\ndistance measure is often modi\ufb01ed by scaling the features so that the spread of\nattribute values along each dimension is approximately the same. In that case,\nthe distance between the two vectors would be\nqPn\nj=1 a2\nj(x1j \u2212x2j)2, where\naj is the scale factor for dimension j.\nAn example of a nearest-neighbor decision problem is shown in Fig. 5.3. In\nthe \ufb01gure the class of a training pattern is indicated by the number next to it.\nk = 8\nX (a pattern to be classified)\n1\n1\n1\n1\n1\n1\n1\n1\n2\n1\n2\n2\n2\n2\n2\n2\n2\n2\n3\n3\n3\n3\n3\n3\n3\n3\n3\ntraining pattern\nclass of training pattern\nfour patterns of category 1\ntwo patterns of category 2\ntwo patterns of category 3\nplurality are in category 1, so\ndecide X is in category 1\nFigure 5.3: An 8-Nearest-Neighbor Decision\nSee [Baum, 1994] for theoretical\nanalysis of error rate as a function\nof the number of training patterns\nfor the case in which points are\nrandomly distributed on the surface\nof a unit sphere and underlying\nfunction is linearly separable.\nNearest-neighbor methods are memory intensive because a large number of\ntraining patterns must be stored to achieve good generalization. Since memory\ncost is now reasonably low, the method and its derivatives have seen several\npractical applications.\n(See, for example, [Moore, 1992, Moore, et al., 1994].\nAlso, the distance calculations required to \ufb01nd nearest neighbors can often be\ne\ufb03ciently computed by kd-tree methods [Friedman, et al., 1977].\nA theorem by Cover and Hart [Cover & Hart, 1967] relates the performance\nof the 1-nearest-neighbor method to the performance of a minimum-probability-\nof-error classi\ufb01er. As mentioned earlier, the minimum-probability-of-error clas-\nsi\ufb01er would assign a new pattern X to that category that maximized p(i)p(X | i),\nwhere p(i) is the a priori probability of category i, and p(X | i) is the probability\n(or probability density function) of X given that X belongs to category i, for\ncategories i = 1, . . . , R. Suppose the probability of error in classifying patterns\nof such a minimum-probability-of-error classi\ufb01er is \u03b5.\nThe Cover-Hart theo-\nrem states that under very mild conditions (having to do with the smoothness72\nCHAPTER 5. STATISTICAL LEARNING\nof probability density functions) the probability of error, \u03b5nn, of a 1-nearest-\nneighbor classi\ufb01er is bounded by:\n\u03b5 \u2264\u03b5nn \u2264\u03b5\n\u0012\n2 \u2212\u03b5\nR\nR \u22121\n\u0013\n\u22642\u03b5\nwhere R is the number of categories.\nAlso see [Aha, 1991].\n5.4\nBibliographical and Historical Remarks\nTo be added.", "6": "Chapter 6\nDecision Trees\n6.1\nDe\ufb01nitions\nA decision tree (generally de\ufb01ned) is a tree whose internal nodes are tests (on\ninput patterns) and whose leaf nodes are categories (of patterns). We show an\nexample in Fig. 6.1. A decision tree assigns a class number (or output) to an\ninput pattern by \ufb01ltering the pattern down through the tests in the tree. Each\ntest has mutually exclusive and exhaustive outcomes. For example, test T2 in\nthe tree of Fig. 6.1 has three outcomes; the left-most one assigns the input\npattern to class 3, the middle one sends the input pattern down to test T4, and\nthe right-most one assigns the pattern to class 1. We follow the usual convention\nof depicting the leaf nodes by the class number.1 Note that in discussing decision\ntrees we are not limited to implementing Boolean functions\u2014they are useful for\ngeneral, categorically valued functions.\nThere are several dimensions along which decision trees might di\ufb00er:\na. The tests might be multivariate (testing on several features of the input\nat once) or univariate (testing on only one of the features).\nb. The tests might have two outcomes or more than two. (If all of the tests\nhave two outcomes, we have a binary decision tree.)\nc. The features or attributes might be categorical or numeric. (Binary-valued\nones can be regarded as either.)\n1One of the researchers who has done a lot of work on learning decision trees is Ross\nQuinlan. Quinlan distinguishes between classes and categories. He calls the subsets of patterns\nthat \ufb01lter down to each tip categories and subsets of patterns having the same label classes.\nIn Quinlan\u2019s terminology, our example tree has nine categories and three classes. We will not\nmake this distinction, however, but will use the words \u201ccategory\u201d and \u201cclass\u201d interchangeably\nto refer to what Quinlan calls \u201cclass.\u201d\n7374\nCHAPTER 6. DECISION TREES\nT1\nT2\nT3\nT4\nT4\nT4\n3\n1\n3\n2\n1\n2\n3\n2\n1\nFigure 6.1: A Decision Tree\nd. We might have two classes or more than two. If we have two classes and\nbinary inputs, the tree implements a Boolean function, and is called a\nBoolean decision tree.\nIt is straightforward to represent the function implemented by a univariate\nBoolean decision tree in DNF form. The DNF form implemented by such a tree\ncan be obtained by tracing down each path leading to a tip node corresponding\nto an output value of 1, forming the conjunction of the tests along this path,\nand then taking the disjunction of these conjunctions. We show an example in\nFig. 6.2. In drawing univariate decision trees, each non-leaf node is depicted by\na single attribute. If the attribute has value 0 in the input pattern, we branch\nleft; if it has value 1, we branch right.\nThe k-DL class of Boolean functions can be implemented by a multivariate\ndecision tree having the (highly unbalanced) form shown in Fig. 6.3. Each test,\nci, is a term of size k or less. The vi all have values of 0 or 1.\n6.2\nSupervised Learning of Univariate Decision\nTrees\nSeveral systems for learning decision trees have been proposed.\nProminent\namong these are ID3 and its new version, C4.5 [Quinlan, 1986, Quinlan, 1993],\nand CART [Breiman, et al., 1984] We discuss here only batch methods, al-\nthough incremental ones have also been proposed [Utgo\ufb00, 1989].6.2. SUPERVISED LEARNING OF UNIVARIATE DECISION TREES\n75\nx3\nx2\nx4\nx1\n1\n0\n1\n1\n0\n0\n0\n1\nx3x2\nx3x2\nx3x4\nx3x4x1\nx3x4x1\nf = x3x2 + x3x4x1\n1\n0\n0\n1\n0\nFigure 6.2: A Decision Tree Implementing a DNF Function\n6.2.1\nSelecting the Type of Test\nAs usual, we have n features or attributes. If the attributes are binary, the\ntests are simply whether the attribute\u2019s value is 0 or 1. If the attributes are\ncategorical, but non-binary, the tests might be formed by dividing the attribute\nvalues into mutually exclusive and exhaustive subsets. A decision tree with such\ntests is shown in Fig. 6.4. If the attributes are numeric, the tests might involve\n\u201cinterval tests,\u201d for example 7 \u2264xi \u226413.2.\n6.2.2\nUsing Uncertainty Reduction to Select Tests\nThe main problem in learning decision trees for the binary-attribute case is\nselecting the order of the tests.\nFor categorical and numeric attributes, we\nmust also decide what the tests should be (besides selecting the order). Several\ntechniques have been tried; the most popular one is at each stage to select that\ntest that maximally reduces an entropy-like measure.\nWe show how this technique works for the simple case of tests with binary\noutcomes. Extension to multiple-outcome tests is straightforward computation-\nally but gives poor results because entropy is always decreased by having more\noutcomes.\nThe entropy or uncertainty still remaining about the class of a pattern\u2014\nknowing that it is in some set, \u039e, of patterns is de\ufb01ned as:\nH(\u039e) = \u2212\nX\ni\np(i|\u039e) log2 p(i|\u039e)76\nCHAPTER 6. DECISION TREES\ncq\ncq-1\nci\n1\nvn\nvn-1\nvi\nv1\nFigure 6.3: A Decision Tree Implementing a Decision List\nwhere p(i|\u039e) is the probability that a pattern drawn at random from \u039e belongs\nto class i, and the summation is over all of the classes. We want to select tests at\neach node such that as we travel down the decision tree, the uncertainty about\nthe class of a pattern becomes less and less.\nSince we do not in general have the probabilities p(i|\u039e), we estimate them by\nsample statistics. Although these estimates might be errorful, they are never-\ntheless useful in estimating uncertainties. Let \u02c6\np(i|\u039e) be the number of patterns\nin \u039e belonging to class i divided by the total number of patterns in \u039e. Then an\nestimate of the uncertainty is:\n\u02c6\nH(\u039e) = \u2212\nX\ni\n\u02c6\np(i|\u039e) log2 \u02c6\np(i|\u039e)\nFor simplicity, from now on we\u2019ll drop the \u201chats\u201d and use sample statistics as\nif they were real probabilities.\nIf we perform a test, T, having k possible outcomes on the patterns in \u039e, we\nwill create k subsets, \u039e1, \u039e2, . . . , \u039ek. Suppose that ni of the patterns in \u039e are in\n\u039ei for i = 1, ..., k. (Some ni may be 0.) If we knew that T applied to a pattern\nin \u039e resulted in the j-th outcome (that is, we knew that the pattern was in \u039ej),\nthe uncertainty about its class would be:\nH(\u039ej) = \u2212\nX\ni\np(i|\u039ej) log2 p(i|\u039ej)\nand the reduction in uncertainty (beyond knowing only that the pattern was in\n\u039e) would be:6.2. SUPERVISED LEARNING OF UNIVARIATE DECISION TREES\n77\nx3 = a, b, c, or d \n{a, c}\n{b}\nx1 = e, b, or d \n{e,b}\n{d}\nx4 = a, e, f, or g\n{a, g}\n{e, f}\nx2 = a, or g\n{a}\n{g}\n1\n2\n1\n1\n2\n{d}\n2\nFigure 6.4: A Decision Tree with Categorical Attributes\nH(\u039e) \u2212H(\u039ej)\nOf course we cannot say that the test T is guaranteed always to produce that\namount of reduction in uncertainty because we don\u2019t know that the result of\nthe test will be the j-th outcome. But we can estimate the average uncertainty\nover all the \u039ej, by:\nE[HT (\u039e)] =\nX\nj\np(\u039ej)H(\u039ej)\nwhere by HT (\u039e) we mean the average uncertainty after performing test T on\nthe patterns in \u039e, p(\u039ej) is the probability that the test has outcome j, and the\nsum is taken from 1 to k. Again, we don\u2019t know the probabilities p(\u039ej), but we\ncan use sample values. The estimate \u02c6\np(\u039ej) of p(\u039ej) is just the number of those\npatterns in \u039e that have outcome j divided by the total number of patterns in\n\u039e. The average reduction in uncertainty achieved by test T (applied to patterns\nin \u039e) is then:\nRT (\u039e) = H(\u039e) \u2212E[HT (\u039e)]\nAn important family of decision tree learning algorithms selects for the root\nof the tree that test that gives maximum reduction of uncertainty, and then\napplies this criterion recursively until some termination condition is met (which\nwe shall discuss in more detail later). The uncertainty calculations are particu-\nlarly simple when the tests have binary outcomes and when the attributes have78\nCHAPTER 6. DECISION TREES\nbinary values. We\u2019ll give a simple example to illustrate how the test selection\nmechanism works in that case.\nSuppose we want to use the uncertainty-reduction method to build a decision\ntree to classify the following patterns:\npattern\nclass\n(0, 0, 0)\n0\n(0, 0, 1)\n0\n(0, 1, 0)\n0\n(0, 1, 1)\n0\n(1, 0, 0)\n0\n(1, 0, 1)\n1\n(1, 1, 0)\n0\n(1, 1, 1)\n1\nWhat single test, x1, x2, or x3, should be performed \ufb01rst? The illustration in\nFig. 6.5 gives geometric intuition about the problem.\nx1\nx2\nx3\nThe test x1\nFigure 6.5: Eight Patterns to be Classi\ufb01ed by a Decision Tree\nThe initial uncertainty for the set, \u039e, containing all eight points is:\nH(\u039e) = \u2212(6/8) log2(6/8) \u2212(2/8) log2(2/8) = 0.81\nNext, we calculate the uncertainty reduction if we perform x1 \ufb01rst. The left-\nhand branch has only patterns belonging to class 0 (we call them the set \u039el), and\nthe right-hand-branch (\u039er) has two patterns in each class. So, the uncertainty\nof the left-hand branch is:6.3. NETWORKS EQUIVALENT TO DECISION TREES\n79\nHx1(\u039el) = \u2212(4/4) log2(4/4) \u2212(0/4) log2(0/4) = 0\nAnd the uncertainty of the right-hand branch is:\nHx1(\u039er) = \u2212(2/4) log2(2/4) \u2212(2/4) log2(2/4) = 1\nHalf of the patterns \u201cgo left\u201d and half \u201cgo right\u201d on test x1. Thus, the average\nuncertainty after performing the x1 test is:\n1/2Hx1(\u039el) + 1/2Hx1(\u039er) = 0.5\nTherefore the uncertainty reduction on \u039e achieved by x1 is:\nRx1(\u039e) = 0.81 \u22120.5 = 0.31\nBy similar calculations, we see that the test x3 achieves exactly the same\nuncertainty reduction, but x2 achieves no reduction whatsoever.\nThus, our\n\u201cgreedy\u201d algorithm for selecting a \ufb01rst test would select either x1 or x3. Suppose\nx1 is selected. The uncertainty-reduction procedure would select x3 as the next\ntest. The decision tree that this procedure creates thus implements the Boolean\nfunction: f = x1x3.\nSee [Quinlan, 1986, sect. 4] for\nanother example.\n6.2.3\nNon-Binary Attributes\nIf the attributes are non-binary, we can still use the uncertainty-reduction tech-\nnique to select tests. But now, in addition to selecting an attribute, we must\nselect a test on that attribute. Suppose for example that the value of an at-\ntribute is a real number and that the test to be performed is to set a threshold\nand to test to see if the number is greater than or less than that threshold. In\nprinciple, given a set of labeled patterns, we can measure the uncertainty reduc-\ntion for each test that is achieved by every possible threshold (there are only\na \ufb01nite number of thresholds that give di\ufb00erent test results if there are only\na \ufb01nite number of training patterns). Similarly, if an attribute is categorical\n(with a \ufb01nite number of categories), there are only a \ufb01nite number of mutually\nexclusive and exhaustive subsets into which the values of the attribute can be\nsplit. We can calculate the uncertainty reduction for each split.\n6.3\nNetworks Equivalent to Decision Trees\nSince univariate Boolean decision trees are implementations of DNF functions,\nthey are also equivalent to two-layer, feedforward neural networks. We show\nan example in Fig. 6.6. The decision tree at the left of the \ufb01gure implements80\nCHAPTER 6. DECISION TREES\nthe same function as the network at the right of the \ufb01gure. Of course, when\nimplemented as a network, all of the features are evaluated in parallel for any\ninput pattern, whereas when implemented as a decision tree only those features\non the branch traveled down by the input pattern need to be evaluated. The\ndecision-tree induction methods discussed in this chapter can thus be thought of\nas particular ways to establish the structure and the weight values for networks.\nX\nx1\nx2\nx3\nx4\nterms\n-1\n+1\ndisjunction\nx3x2\nx3x4x1\n+1\n-1\n+1\nf\n1.5\n0.5\nx3\nx2\nx4\nx1\n1\n0\n1\n1\n0\n0\n0\n1\nx3x2\nx3x2\nx3x4\nx3x4x1\nx3x4x1\nf = x3x2 + x3x4x1\n1\n0\n0\n1\n0\nFigure 6.6: A Univariate Decision Tree and its Equivalent Network\nMultivariate decision trees with linearly separable functions at each node can\nalso be implemented by feedforward networks\u2014in this case three-layer ones. We\nshow an example in Fig. 6.7 in which the linearly separable functions, each im-\nplemented by a TLU, are indicated by L1, L2, L3, and L4. Again, the \ufb01nal layer\nhas \ufb01xed weights, but the weights in the \ufb01rst two layers must be trained. Dif-\nferent approaches to training procedures have been discussed by [Brent, 1990],\nby [John, 1995], and (for a special case) by [Marchand & Golea, 1993].\n6.4\nOver\ufb01tting and Evaluation\n6.4.1\nOver\ufb01tting\nIn supervised learning, we must choose a function to \ufb01t the training set from\namong a set of hypotheses.\nWe have already showed that generalization is\nimpossible without bias.\nWhen we know a priori that the function we are\ntrying to guess belongs to a small subset of all possible functions, then, even\nwith an incomplete set of training samples, it is possible to reduce the subset\nof functions that are consistent with the training set su\ufb03ciently to make useful\nguesses about the value of the function for inputs not in the training set. And,6.4. OVERFITTING AND EVALUATION\n81\nL1\nL2\nL3\nL4\n1\n0\n1\n1\n0\n0\n0\n1\n1\n0\n0\n1\n0\nX\nL1\nL2\nL3\nL4\nconjunctions\nL1L2\nL1 L3 L4\n<\n+\n+\n+\ndisjunction\n<\nf\nFigure 6.7: A Multivariate Decision Tree and its Equivalent Network\nthe larger the training set, the more likely it is that even a randomly selected\nconsistent function will have appropriate outputs for patterns not yet seen.\nHowever, even with bias, if the training set is not su\ufb03ciently large compared\nwith the size of the hypothesis space, there will still be too many consistent\nfunctions for us to make useful guesses, and generalization performance will be\npoor. When there are too many hypotheses that are consistent with the training\nset, we say that we are over\ufb01tting the training data. Over\ufb01tting is a problem\nthat we must address for all learning methods.\nSince a decision tree of su\ufb03cient size can implement any Boolean function\nthere is a danger of over\ufb01tting\u2014especially if the training set is small. That\nis, even if the decision tree is synthesized to classify all the members of the\ntraining set correctly, it might perform poorly on new patterns that were not\nused to build the decision tree. Several techniques have been proposed to avoid\nover\ufb01tting, and we shall examine some of them here. They make use of methods\nfor estimating how well a given decision tree might generalize\u2014methods we shall\ndescribe next.\n6.4.2\nValidation Methods\nThe most straightforward way to estimate how well a hypothesized function\n(such as a decision tree) performs on a test set is to test it on the test set! But,\nif we are comparing several learning systems (for example, if we are comparing\ndi\ufb00erent decision trees) so that we can select the one that performs the best on\nthe test set, then such a comparison amounts to \u201ctraining on the test data.\u201d\nTrue, training on the test data enlarges the training set, with a consequent ex-\npected improvement in generalization, but there is still the danger of over\ufb01tting\nif we are comparing several di\ufb00erent learning systems. Another technique is to82\nCHAPTER 6. DECISION TREES\nsplit the training set\u2014using (say) two-thirds for training and the other third\nfor estimating generalization performance. But splitting reduces the size of the\ntraining set and thereby increases the possibility of over\ufb01tting. We next describe\nsome validation techniques that attempt to avoid these problems.\nCross-Validation\nIn cross-validation, we divide the training set \u039e into K mutually exclusive and\nexhaustive equal-sized subsets: \u039e1, . . . , \u039eK. For each subset, \u039ei, train on the\nunion of all of the other subsets, and empirically determine the error rate, \u03b5i,\non \u039ei. (The error rate is the number of classi\ufb01cation errors made on \u039ei divided\nby the number of patterns in \u039ei.) An estimate of the error rate that can be\nexpected on new patterns of a classi\ufb01er trained on all the patterns in \u039e is then\nthe average of the \u03b5i.\nLeave-one-out Validation\nLeave-one-out validation is the same as cross validation for the special case in\nwhich K equals the number of patterns in \u039e, and each \u039ei consists of a single\npattern. When testing on each \u039ei, we simply note whether or not a mistake\nwas made.\nWe count the total number of mistakes and divide by K to get\nthe estimated error rate. This type of validation is, of course, more expensive\ncomputationally, but useful when a more accurate estimate of the error rate for\na classi\ufb01er is needed.\nDescribe \u201cbootstrapping\u201d also\n[Efron, 1982].\n6.4.3\nAvoiding Over\ufb01tting in Decision Trees\nNear the tips of a decision tree there may be only a few patterns per node.\nFor these nodes, we are selecting a test based on a very small sample, and thus\nwe are likely to be over\ufb01tting. This problem can be dealt with by terminating\nthe test-generating procedure before all patterns are perfectly split into their\nseparate categories. That is, a leaf node may contain patterns of more than one\nclass, but we can decide in favor of the most numerous class. This procedure\nwill result in a few errors but often accepting a small number of errors on the\ntraining set results in fewer errors on a testing set.\nThis behavior is illustrated in Fig. 6.8.\nOne can use cross-validation techniques to determine when to stop splitting\nnodes. If the cross validation error increases as a consequence of a node split,\nthen don\u2019t split. One has to be careful about when to stop, though, because\nunder\ufb01tting usually leads to more errors on test sets than does over\ufb01tting. There\nis a general rule that the lowest error-rate attainable by a sub-tree of a fully\nexpanded tree can be no less than 1/2 of the error rate of the fully expanded\ntree [Weiss & Kulikowski, 1991, page 126].6.4. OVERFITTING AND EVALUATION\n83\n(From Weiss, S., and Kulikowski, C., Computer Systems that Learn,\nMorgan Kaufmann, 1991)\ntraining errors\nvalidation errors\n1\n2\n3\n4\n5\n6\n7\n8\n9\n0.2\n0.4\n0.6\n0.8\n1.0\n0\n0\nError Rate\nNumber of Terminal\nNodes\nIris Data Decision Tree\nFigure 6.8: Determining When Over\ufb01tting Begins\nRather than stopping the growth of a decision tree, one might grow it to\nits full size and then prune away leaf nodes and their ancestors until cross-\nvalidation accuracy no longer increases. This technique is called post-pruning.\nVarious techniques for pruning are discussed in [Weiss & Kulikowski, 1991].\n6.4.4\nMinimum-Description Length Methods\nAn important tree-growing and pruning technique is based on the minimum-\ndescription-length (MDL) principle. (MDL is an important idea that extends\nbeyond decision-tree methods [Rissanen, 1978].) The idea is that the simplest\ndecision tree that can predict the classes of the training patterns is the best\none. Consider the problem of transmitting just the labels of a training set of\npatterns, assuming that the receiver of this information already has the ordered\nset of patterns.\nIf there are m patterns, each labeled by one of R classes,\none could transmit a list of m R-valued numbers. Assuming equally probable\nclasses, this transmission would require m log2 R bits. Or, one could transmit a\ndecision tree that correctly labelled all of the patterns. The number of bits that\nthis transmission would require depends on the technique for encoding decision\ntrees and on the size of the tree. If the tree is small and accurately classi\ufb01es\nall of the patterns, it might be more economical to transmit the tree than to\ntransmit the labels directly. In between these extremes, we might transmit a\ntree plus a list of labels of all the patterns that the tree misclassi\ufb01es.\nIn general, the number of bits (or description length of the binary encoded\nmessage) is t + d, where t is the length of the message required to transmit\nthe tree, and d is the length of the message required to transmit the labels of84\nCHAPTER 6. DECISION TREES\nthe patterns misclassi\ufb01ed by the tree. In a sense, that tree associated with the\nsmallest value of t + d is the best or most economical tree. The MDL method\nis one way of adhering to the Occam\u2019s razor principle.\nQuinlan and Rivest [Quinlan & Rivest, 1989] have proposed techniques for\nencoding decision trees and lists of exception labels and for calculating the\ndescription length (t+d) of these trees and labels. They then use the description\nlength as a measure of quality of a tree in two ways:\na. In growing a tree, they use the reduction in description length to select\ntests (instead of reduction in uncertainty).\nb. In pruning a tree after it has been grown to zero error, they prune away\nthose nodes (starting at the tips) that achieve a decrease in the description\nlength.\nThese techniques compare favorably with the uncertainty-reduction method,\nalthough they are quite sensitive to the coding schemes used.\n6.4.5\nNoise in Data\nNoise in the data means that one must inevitably accept some number of\nerrors\u2014depending on the noise level. Refusal to tolerate errors on the training\nset when there is noise leads to the problem of \u201c\ufb01tting the noise.\u201d Dealing with\nnoise, then, requires accepting some errors at the leaf nodes just as does the\nfact that there are a small number of patterns at leaf nodes.\n6.5\nThe Problem of Replicated Subtrees\nDecision trees are not the most economical means of implementing some Boolean\nfunctions. Consider, for example, the function f = x1x2 +x3x4. A decision tree\nfor this function is shown in Fig. 6.9. Notice the replicated subtrees shown\ncircled. The DNF-form equivalent to the function implemented by this decision\ntree is f = x1x2 + x1x2x3x4 + x1x3x4. This DNF form is non-minimal (in the\nnumber of disjunctions) and is equivalent to f = x1x2 + x3x4.\nThe need for replication means that it takes longer to learn the tree and\nthat subtrees replicated further down the tree must be learned using a smaller\ntraining subset. This problem is sometimes called the fragmentation problem.\nSeveral approaches might be suggested for dealing with fragmenta-\ntion.\nOne is to attempt to build a decision graph instead of a tree\n[Oliver, Dowe, & Wallace, 1992, Kohavi, 1994]. A decision graph that imple-\nments the same decisions as that of the decision tree of Fig. 6.9 is shown in Fig.\n6.10.\nAnother approach is to use multivariate (rather than univariate tests at each\nnode). In our example of learning f = x1x2 + x3x4, if we had a test for x1x26.6. THE PROBLEM OF MISSING ATTRIBUTES\n85\nx1\nx3\nx2\n1\n0\nx4\n0\n1\nx3\n0\nx4\n0\n1\nFigure 6.9: A Decision Tree with Subtree Replication\nand a test for x3x4, the decision tree could be much simpli\ufb01ed, as shown in Fig.\n6.11. Several researchers have proposed techniques for learning decision trees in\nwhich the tests at each node are linearly separable functions. [John, 1995] gives\na nice overview (with several citations) of learning such linear discriminant trees\nand presents a method based on \u201csoft entropy.\u201d\nA third method for dealing with the replicated subtree problem involves ex-\ntracting propositional \u201crules\u201d from the decision tree. The rules will have as an-\ntecedents the conjunctions that lead down to the leaf nodes, and as consequents\nthe name of the class at the corresponding leaf node. An example rule from the\ntree with the repeating subtree of our example would be: x1 \u2227\u00acx2 \u2227x3 \u2227x4 \u22831.\nQuinlan [Quinlan, 1987] discusses methods for reducing a set of rules to a sim-\npler set by 1) eliminating from the antecedent of each rule any \u201cunnecessary\u201d\nconjuncts, and then 2) eliminating \u201cunnecessary\u201d rules. A conjunct or rule is\ndetermined to be unnecessary if its elimination has little e\ufb00ect on classi\ufb01cation\naccuracy\u2014as determined by a chi-square test, for example. After a rule set is\nprocessed, it might be the case that more than one rule is \u201cactive\u201d for any given\npattern, and care must be taken that the active rules do not con\ufb02ict in their\ndecision about the class of a pattern.86\nCHAPTER 6. DECISION TREES\nx1\nx3\nx2\n1\n0\nx4\n0\n1\nFigure 6.10: A Decision Graph\n6.6\nThe Problem of Missing Attributes\nTo be added.\n6.7\nComparisons\nSeveral experimenters have compared decision-tree, neural-net, and nearest-\nneighbor classi\ufb01ers on a wide variety of problems.\nFor a comparison of\nneural nets versus decision trees, for example, see [Dietterich, et al., 1990,\nShavlik, Mooney, & Towell, 1991, Quinlan, 1994].\nIn their StatLog project,\n[Taylor, Michie, & Spiegalhalter, 1994] give thorough comparisons of several\nmachine learning algorithms on several di\ufb00erent types of problems. There seems\nx1x2\n1\n0\nx3x4\n1\nFigure 6.11: A Multivariate Decision Tree6.8. BIBLIOGRAPHICAL AND HISTORICAL REMARKS\n87\nto be no single type of classi\ufb01er that is best for all problems. And, there do\nnot seem to be any general conclusions that would enable one to say which\nclassi\ufb01er method is best for which sorts of classi\ufb01cation problems, although\n[Quinlan, 1994] does provide some intuition about properties of problems that\nmight render them ill suited for decision trees, on the one hand, or backpropa-\ngation, on the other.\n6.8\nBibliographical and Historical Remarks\nTo be added.88\nCHAPTER 6. DECISION TREES", "7": "Chapter 7\nInductive Logic\nProgramming\nThere are many di\ufb00erent representational forms for functions of input vari-\nables. So far, we have seen (Boolean) algebraic expressions, decision trees, and\nneural networks, plus other computational mechanisms such as techniques for\ncomputing nearest neighbors.\nOf course, the representation most important\nin computer science is a computer program. For example, a Lisp predicate of\nbinary-valued inputs computes a Boolean function of those inputs. Similarly, a\nlogic program (whose ordinary application is to compute bindings for variables)\ncan also be used simply to decide whether or not a predicate has value True\n(T) or False (F). For example, the Boolean exclusive-or (odd parity) function\nof two variables can be computed by the following logic program:\nParity(x,y) :- True(x), \u00ac True(y)\n:- True(y), \u00ac True(x)\nWe follow Prolog syntax (see, for example, [Mueller & Page, 1988]), except that\nour convention is to write variables as strings beginning with lower-case letters\nand predicates as strings beginning with upper-case letters. The unary function\n\u201cTrue\u201d returns T if and only if the value of its argument is T. (We now think\nof Boolean functions and arguments as having values of T and F instead of 0\nand 1.) Programs will be written in \u201ctypewriter\u201d font.\nIn this chapter, we consider the matter of learning logic programs given\na set of variable values for which the logic program should return T (the\npositive instances) and a set of variable values for which it should return\nF (the negative instances). The subspecialty of machine learning that deals\nwith learning logic programs is called inductive logic programming (ILP)\n[Lavra\u02c7\nc & D\u02c7\nzeroski, 1994]. As with any learning problem, this one can be quite\ncomplex and intractably di\ufb03cult unless we constrain it with biases of some sort.\n8990\nCHAPTER 7. INDUCTIVE LOGIC PROGRAMMING\nIn ILP, there are a variety of possible biases (called language biases). One might\nrestrict the program to Horn clauses, not allow recursion, not allow functions,\nand so on.\nAs an example of an ILP problem, suppose we are trying to induce a func-\ntion Nonstop(x,y), that is to have value T for pairs of cities connected by a\nnon-stop air \ufb02ight and F for all other pairs of cities. We are given a training set\nconsisting of positive and negative examples. As positive examples, we might\nhave (A,B), (A, A1), and some other pairs; as negative examples, we might\nhave (A1, A2), and some other pairs. In ILP, we usually have additional infor-\nmation about the examples, called \u201cbackground knowledge.\u201d In our air-\ufb02ight\nproblem, the background information might be such ground facts as Hub(A),\nHub(B), Satellite(A1,A), plus others. (Hub(A) is intended to mean that the\ncity denoted by A is a hub city, and Satellite(A1,A) is intended to mean that\nthe city denoted by A1 is a satellite of the city denoted by A.) From these train-\ning facts, we want to induce a program Nonstop(x,y), written in terms of the\nbackground relations Hub and Satellite, that has value T for all the positive\ninstances and has value F for all the negative instances. Depending on the exact\nset of examples, we might induce the program:\nNonstop(x,y) :- Hub(x), Hub(y)\n:- Satellite(x,y)\n:- Satellite(y,x)\nwhich would have value T if both of the two cities were hub cities or if one were\na satellite of the other. As with other learning problems, we want the induced\nprogram to generalize well; that is, if presented with arguments not represented\nin the training set (but for which we have the needed background knowledge),\nwe would like the function to guess well.\n7.1\nNotation and De\ufb01nitions\nIn evaluating logic programs in ILP, we implicitly append the background facts\nto the program and adopt the usual convention that a program has value T for\na set of inputs if and only if the program interpreter returns T when actually\nrunning the program (with background facts appended) on those inputs; oth-\nerwise it has value F. Using the given background facts, the program above\nwould return T for input (A, A1), for example. If a logic program, \u03c0, returns\nT for a set of arguments X, we say that the program covers the arguments and\nwrite covers(\u03c0, X). Following our terminology introduced in connection with\nversion spaces, we will say that a program is su\ufb03cient if it covers all of the\npositive instances and that it is necessary if it does not cover any of the neg-\native instances. (That is, a program implements a su\ufb03cient condition that a\ntraining instance is positive if it covers all of the positive training instances; it7.2. A GENERIC ILP ALGORITHM\n91\nimplements a necessary condition if it covers none of the negative instances.) In\nthe noiseless case, we want to induce a program that is both su\ufb03cient and nec-\nessary, in which case we will call it consistent. With imperfect (noisy) training\nsets, we might relax this criterion and settle for a program that covers all but\nsome fraction of the positive instances while allowing it to cover some fraction\nof the negative instances. We illustrate these de\ufb01nitions schematically in Fig.\n7.1.\n<\n<\n<\n<\n<\n<\n<\n/1 is a necessary program\n/2 is a sufficient program\n/3 is a consistent program\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n<\n<\nA positive instance\n covered by /2 and /3\nFigure 7.1: Su\ufb03cient, Necessary, and Consistent Programs\nAs in version spaces, if a program is su\ufb03cient but not necessary it can be\nmade to cover fewer examples by specializing it. Conversely, if it is necessary\nbut not su\ufb03cient, it can be made to cover more examples by generalizing it.\nSuppose we are attempting to induce a logic program to compute the relation\n\u03c1. The most general logic program, which is certainly su\ufb03cient, is the one that\nhas value T for all inputs, namely a single clause with an empty body, [\u03c1 :-\n], which is called a fact in Prolog. The most special logic program, which is\ncertainly necessary, is the one that has value F for all inputs, namely [\u03c1 :-\nF\n]. Two of the many di\ufb00erent ways to search for a consistent logic program\nare: 1) start with [\u03c1 :-\n] and specialize until the program is consistent, or 2)\nstart with [\u03c1 :- F\n] and generalize until the program is consistent. We will\nbe discussing a method that starts with [\u03c1 :-\n], specializes until the program\nis necessary (but might no longer be su\ufb03cient), then reachieves su\ufb03ciency in\nstages by generalizing\u2014ensuring within each stage that the program remains\nnecessary (by specializing).\n7.2\nA Generic ILP Algorithm\nSince the primary operators in our search for a consistent program are special-\nization and generalization, we must next discuss those operations. There are92\nCHAPTER 7. INDUCTIVE LOGIC PROGRAMMING\nthree major ways in which a logic program might be generalized:\na. Replace some terms in a program clause by variables. (Readers familiar\nwith substitutions in the predicate calculus will note that this process is\nthe inverse of substitution.)\nb. Remove literals from the body of a clause.\nc. Add a clause to the program\nAnalogously, there are three ways in which a logic program might be specialized:\na. Replace some variables in a program clause by terms (a substitution).\nb. Add literals to the body of a clause.\nc. Remove a clause from the program\nWe will be presenting an ILP learning method that adds clauses to a program\nwhen generalizing and that adds literals to the body of a clause when special-\nizing. When we add a clause, we will always add the clause [\u03c1 :- ] and then\nspecialize it by adding literals to the body. Thus, we need only describe the\nprocess for adding literals.\nClauses can be partially ordered by the specialization relation. In general,\nclause c1 is more special than clause c2 if c2 |\n= c1. A special case, which is what\nwe use here, is that a clause c1 is more special than a clause c2 if the set of\nliterals in the body of c2 is a subset of those in c1. This ordering relation can\nbe used in a structure of partially ordered clauses, called the re\ufb01nement graph,\nthat is similar to a version space. Clause c1 is an immediate successor of clause\nc2 in this graph if and only if clause c1 can be obtained from clause c2 by adding\na literal to the body of c2. A re\ufb01nement graph then tells us the ways in which\nwe can specialize a clause by adding a literal to it.\nOf course there are unlimited possible literals we might add to the body of\na clause. Practical ILP systems restrict the literals in various ways. Typical\nallowed additions are:\na. Literals used in the background knowledge.\nb. Literals whose arguments are a subset of those in the head of the clause.\nc. Literals that introduce a new distinct variable di\ufb00erent from those in the\nhead of the clause.\nd. A literal that equates a variable in the head of the clause with another\nsuch variable or with a term mentioned in the background knowledge.\n(This possibility is equivalent to forming a specialization by making a\nsubstitution.)7.2. A GENERIC ILP ALGORITHM\n93\ne. A literal that is the same (except for its arguments) as that in the head\nof the clause. (This possibility admits recursive programs, which are dis-\nallowed in some systems.)\nWe can illustrate these possibilities using our air-\ufb02ight example. We start\nwith the program [Nonstop(x,y) :-\n]. The literals used in the background\nknowledge are Hub and Satellite. Thus the literals that we might consider\nadding are:\nHub(x)\nHub(y)\nHub(z)\nSatellite(x,y)\nSatellite(y,x)\nSatellite(x,z)\nSatellite(z,y)\n(x = y)\n(If recursive programs are allowed, we could also add the literals Nonstop(x,z)\nand Nonstop(z,y).) These possibilities are among those illustrated in the re-\n\ufb01nement graph shown in Fig. 7.2. Whatever restrictions on additional literals\nare imposed, they are all syntactic ones from which the successors in the re\ufb01ne-\nment graph are easily computed. ILP programs that follow the approach we\nare discussing (of specializing clauses by adding a literal) thus have well de\ufb01ned\nmethods of computing the possible literals to add to a clause.\nNow we are ready to write down a simple generic algorithm for inducing a\nlogic program, \u03c0 for inducing a relation \u03c1. We are given a training set, \u039e of\nargument sets some known to be in the relation \u03c1 and some not in \u03c1; \u039e+ are\nthe positive instances, and \u039e\u2212are the negative instances. The algorithm has\nan outer loop in which it successively adds clauses to make \u03c0 more and more\nsu\ufb03cient. It has an inner loop for constructing a clause, c, that is more and\nmore necessary and in which it refers only to a subset, \u039ecur, of the training\ninstances. (The positive instances in \u039ecur will be denoted by \u039e+\ncur, and the\nnegative ones by \u039e\u2212\ncur.) The algorithm is also given background relations and\nthe means for adding literals to a clause. It uses a logic program interpreter to\ncompute whether or not the program it is inducing covers training instances.\nThe algorithm can be written as follows:\nGeneric ILP Algorithm\n(Adapted from [Lavra\u02c7\nc & D\u02c7\nzeroski, 1994, p. 60].)94\nCHAPTER 7. INDUCTIVE LOGIC PROGRAMMING\nNonstop(x,y) :-\nNonstop(x,y) :-\n   Hub(x)\nNonstop(x,y) :-\n   Satellite(x,y)\nNonstop(x,y) :-\n   (x = y)\n. . .\n. . .\n. . .\n. . .\nNonstop(x,y) :- Hub(x), Hub(y)\n. . .\n. . .\n. . .\nFigure 7.2: Part of a Re\ufb01nement Graph\nInitialize \u039ecur := \u039e.\nInitialize \u03c0 := empty set of clauses.\nrepeat [The outer loop works to make \u03c0 su\ufb03cient.]\nInitialize c := \u03c1 : \u2212.\nrepeat [The inner loop makes c necessary.]\nSelect a literal l to add to c. [This is a nondeterministic choice point.]\nAssign c := c, l.\nuntil c is necessary. [That is, until c covers no negative instances in \u039ecur.]\nAssign \u03c0 := \u03c0, c. [We add the clause c to the program.]\nAssign \u039ecur := \u039ecur \u2212(the positive instances in \u039ecur covered by \u03c0).\nuntil \u03c0 is su\ufb03cient.\n(The termination tests for the inner and outer loops can be relaxed as appro-\npriate for the case of noisy instances.)\n7.3\nAn Example\nWe illustrate how the algorithm works by returning to our example of airline\n\ufb02ights. Consider the portion of an airline route map, shown in Fig. 7.3. Cities\nA, B, and C are \u201chub\u201d cities, and we know that there are nonstop \ufb02ights between\nall hub cities (even those not shown on this portion of the route map). The other7.3. AN EXAMPLE\n95\ncities are \u201csatellites\u201d of one of the hubs, and we know that there are nonstop\n\ufb02ights between each satellite city and its hub. The learning program is given a\nset of positive instances, \u039e+, of pairs of cities between which there are nonstop\n\ufb02ights and a set of negative instances, \u039e\u2212, of pairs of cities between which there\nare not nonstop \ufb02ights. \u039e+ contains just the pairs:\n{< A, B >, < A, C >, < B, C >, < B, A >, < C, A >, < C, B >,\n< A, A1 >, < A, A2 >, < A1, A >, < A2, A >, < B, B1 >, < B, B2 >,\n< B1, B >, < B2, B >, < C, C1 >, < C, C2 >, < C1, C >, < C2, C >}\nFor our example, we will assume that \u039e\u2212contains all those pairs of cities shown\nin Fig. 7.3 that are not in \u039e+ (a type of closed-world assumption). These are:\n{< A, B1 >, < A, B2 >, < A, C1 >, < A, C2 >, < B, C1 >, < B, C2 >,\n< B, A1 >, < B, A2 >, < C, A1 >, < C, A2 >, < C, B1 >, < C, B2 >,\n< B1, A >, < B2, A >, < C1, A >, < C2, A >, < C1, B >, < C2, B >,\n< A1, B >, < A2, B >, < A1, C >, < A2, C >, < B1, C >, < B2, C >}\nThere may be other cities not shown on this map, so the training set does not\nnecessarily exhaust all the cities.\nA\nB\nC\nC1\nC2\nB1\nB2\nA1\nA2\nFigure 7.3: Part of an Airline Route Map\nWe want the learning program to induce a program for computing the value\nof the relation Nonstop. The training set, \u039e, can be thought of as a partial96\nCHAPTER 7. INDUCTIVE LOGIC PROGRAMMING\ndescription of this relation in extensional form\u2014it explicitly names some pairs\nin the relation and some pairs not in the relation.\nWe desire to learn the\nNonstop relation as a logic program in terms of the background relations, Hub\nand Satellite, which are also given in extensional form. Doing so will give us\na more compact, intensional, description of the relation, and this description\ncould well generalize usefully to other cities not mentioned in the map.\nWe assume the learning program has the following extensional de\ufb01nitions of\nthe relations Hub and Satellite:\nHub\n{< A >, < B >, < C >}\nAll other cities mentioned in the map are assumed not in the relation Hub. We\nwill use the notation Hub(x) to express that the city named x is in the relation\nHub.\nSatellite\n{< A1, A, >, < A2, A >, < B1, B >, < B2, B >, < C1, C >, < C2, C >}\nAll other pairs of cities mentioned in the map are not in the relation Satellite.\nWe will use the notation Satellite(x,y) to express that the pair < x, y > is\nin the relation Satellite.\nKnowing that the predicate Nonstop is a two-place predicate, the inner loop\nof our algorithm initializes the \ufb01rst clause to Nonstop(x,y) :-\n. This clause\nis not necessary because it covers all the negative examples (since it covers all\nexamples). So we must add a literal to its (empty) body. Suppose (selecting\na literal from the re\ufb01nement graph) the algorithm adds Hub(x). The following\npositive instances in \u039e are covered by Nonstop(x,y) :- Hub(x):\n{< A, B >, < A, C >, < B, C >, < B, A >, < C, A >, < C, B >,\n< A, A1 >, < A, A2 >, < B, B1 >, < B, B2 >, < C, C1 >, < C, C2 >}\nTo compute this covering, we interpret the logic program Nonstop(x,y) :-\nHub(x) for all pairs of cities in \u039e, using the pairs given in the background\nrelation Hub as ground facts. The following negative instances are also covered:7.3. AN EXAMPLE\n97\n{< A, B1 >, < A, B2 >, < A, C1 >, < A, C2 >, < C, A1 >, < C, A2 >,\n< C, B1 >, < C, B2 >, < B, A1 >, < B, A2 >, < B, C1 >, < B, C2 >}\nThus, the clause is not yet necessary and another literal must be added. Sup-\npose we next add Hub(y).\nThe following positive instances are covered by\nNonstop(x,y) :- Hub(x), Hub(y):\n{< A, B >, < A, C >, < B, C >, < B, A >, < C, A >, < C, B >}\nThere are no longer any negative instances in \u039e covered so the clause\nNonstop(x,y) :- Hub(x), Hub(y) is necessary, and we can terminate the \ufb01rst\npass through the inner loop.\nBut the program, \u03c0, consisting of just this clause is not su\ufb03cient. These\npositive instances are not covered by the clause:\n{< A, A1 >, < A, A2 >, < A1, A >, < A2, A >, < B, B1 >, < B, B2 >,\n< B1, B >, < B2, B >, < C, C1 >, < C, C2 >, < C1, C >, < C2, C >}\nThe positive instances that were covered by Nonstop(x,y) :- Hub(x), Hub(y)\nare removed from \u039e to form the \u039ecur to be used in the next pass through the\ninner loop. \u039ecur consists of all the negative instances in \u039e plus the positive\ninstances (listed above) that are not yet covered. In order to attempt to cover\nthem, the inner loop creates another clause c, initially set to Nonstop(x,y)\n:- . This clause covers all the negative instances, and so we must add liter-\nals to make it necessary. Suppose we add the literal Satellite(x,y). The\nclause Nonstop(x,y) :- Satellite(x,y) covers no negative instances, so it is\nnecessary. It does cover the following positive instances in \u039ecur:\n{< A1, A >, < A2, A >, < B1, B >, < B2, B >, < C1, C >, < C2, C >}\nThese instances are removed from \u039ecur for the next pass through the inner loop.\nThe program now contains two clauses:\nNonstop(x,y) :- Hub(x), Hub(y)\n:- Satellite(x,y)\nThis program is not yet su\ufb03cient since it does not cover the following positive\ninstances:\n{< A, A1 >, < A, A2 >, < B, B1 >, < B, B2 >, < C, C1 >, < C, C2 >}98\nCHAPTER 7. INDUCTIVE LOGIC PROGRAMMING\nDuring the next pass through the inner loop, we add the clause Nonstop(x,y)\n:- Satellite(y,x). This clause is necessary, and since the program containing\nall three clauses is now su\ufb03cient, the procedure terminates with:\nNonstop(x,y) :- Hub(x), Hub(y)\n:- Satellite(x,y)\n:- Satellite(y,x)\nSince each clause is necessary, and the whole program is su\ufb03cient, the pro-\ngram is also consistent with all instances of the training set. Note that this\nprogram can be applied (perhaps with good generalization) to other cities be-\nsides those in our partial map\u2014so long as we can evaluate the relations Hub and\nSatellite for these other cities. In the next section, we show how the technique\ncan be extended to use recursion on the relation we are inducing. With that\nextension, the method can be used to induce more general logic programs.\n7.4\nInducing Recursive Programs\nTo induce a recursive program, we allow the addition of a literal having the\nsame predicate letter as that in the head of the clause. Various mechanisms\nmust be used to ensure that such a program will terminate; one such is to make\nsure that the new literal has di\ufb00erent variables than those in the head literal.\nThe process is best illustrated with another example. Our example continues\nthe one using the airline map, but we make the map somewhat simpler in order\nto reduce the size of the extensional relations used. Consider the map shown\nin Fig. 7.4. Again, B and C are hub cities, B1 and B2 are satellites of B, C1\nand C2 are satellites of C. We have introduced two new cities, B3 and C3. No\n\ufb02ights exist between these cities and any other cities\u2014perhaps there are only\nbus routes as shown by the grey lines in the map.\nWe now seek to learn a program for Canfly(x,y) that covers only those\npairs of cities that can be reached by one or more nonstop \ufb02ights. The relation\nCanfly is satis\ufb01ed by the following pairs of postive instances:\n{< B1, B >, < B1, B2 >, < B1, C >, < B1, C1 >, < B1, C2 >,\n< B, B1 >, < B2, B1 >, < C, B1 >, < C1, B1 >, < C2, B1 >,\n< B2, B >, < B2, C >, < B2, C1 >, < B2, C2 >, < B, B2 >,\n< C, B2 >, < C1, B2 >, < C2, B2 >, < B, C >, < B, C1 >,\n< B, C2 >, < C, B >, < C1, B >, < C2, B >, < C, C1 >,\n< C, C2 >, < C1, C >, < C2, C >, < C1, C2 >, < C2, C1 >}7.4. INDUCING RECURSIVE PROGRAMS\n99\nB\nC\nC1\nC2\nB1\nB2\nB3\nC3\nFigure 7.4: Another Airline Route Map\nUsing a closed-world assumption on our map, we take the negative instances of\nCanfly to be:\n{< B3, B2 >, < B3, B >, < B3, B1 >, < B3, C >, < B3, C1 >,\n< B3, C2 >, < B3, C3 >, < B2, B3 >, < B, B3 >, < B1, B3 >,\n< C, B3 >, < C1, B3 >, < C2, B3 >, < C3, B3 >, < C3, B2 >,\n< C3, B >, < C3, B1 >, < C3, C >, < C3, C1 >, < C3, C2 >,\n< B2, C3 >, < B, C3 >, < B1, C3 >, < C, C3 >, < C1, C3 >,\n< C2, C3 >}\nWe will induce Canfly(x,y) using the extensionally de\ufb01ned background\nrelation Nonstop given earlier (modi\ufb01ed as required for our reduced airline map)\nand Canfly itself (recursively).\nAs before, we start with the empty program and proceed to the inner loop\nto construct a clause that is necessary. Suppose that the inner loop adds the\nbackground literal Nonstop(x,y). The clause Canfly(x,y) :- Nonstop(x,y)\nis necessary; it covers no negative instances. But it is not su\ufb03cient because it\ndoes not cover the following positive instances:\n{< B1, B2 >, < B1, C >, < B1, C1 >, < B1, C2 >, < B2, B1 >,\n< C, B1 >, < C1, B1 >, < C2, B1 >, < B2, C >, < B2, C1 >,\n< B2, C2 >, < C, B2 >, < C1, B2 >, < C2, B2 >, < B, C1 >,100\nCHAPTER 7. INDUCTIVE LOGIC PROGRAMMING\n< B, C2 >, < C1, B >, < C2, B >, < C1, C2 >, < C2, C1 >}\nThus, we must add another clause to the program. In the inner loop, we \ufb01rst\ncreate the clause Canfly(x,y) :- Nonstop(x,z) which introduces the new\nvariable z. We digress brie\ufb02y to describe how a program containing a clause\nwith unbound variables in its body is interpreted.\nSuppose we try to inter-\npret it for the positive instance Canfly(B1,B2). The interpreter attempts to\nestablish Nonstop(B1,z) for some z. Since Nonstop(B1, B), for example, is\na background fact, the interpreter returns T\u2014which means that the instance\n< B1, B2 > is covered.\nSuppose now, we attempt to interpret the clause\nfor the negative instance Canfly(B3,B). The interpreter attempts to estab-\nlish Nonstop(B3,z) for some z. There are no background facts that match, so\nthe clause does not cover < B3, B >. Using the interpreter, we see that the\nclause Canfly(x,y) :- Nonstop(x,z) covers all of the positive instances not\nalready covered by the \ufb01rst clause, but it also covers many negative instances\nsuch as < B2, B3 >, and < B, B3 >. So the inner loop must add another literal.\nThis time, suppose it adds Canfly(z,y) to yield the clause Canfly(x,y) :-\nNonstop(x,z), Canfly(z,y). This clause is necessary; no negative instances\nare covered. The program is now su\ufb03cient and consistent; it is:\nCanfly(x,y) :- Nonstop(x,y)\n:- Nonstop(x,z), Canfly(z,y)\n7.5\nChoosing Literals to Add\nOne of the \ufb01rst practical ILP systems was Quinlan\u2019s FOIL [Quinlan, 1990]. A\nmajor problem involves deciding how to select a literal to add in the inner loop\n(from among the literals that are allowed). In FOIL, Quinlan suggested that\ncandidate literals can be compared using an information-like measure\u2014similar\nto the measures used in inducing decision trees. A measure that gives the same\ncomparison as does Quinlan\u2019s is based on the amount by which adding a literal\nincreases the odds that an instance drawn at random from those covered by the\nnew clause is a positive instance beyond what these odds were before adding\nthe literal.\nLet p be an estimate of the probability that an instance drawn at random\nfrom those covered by a clause before adding the literal is a positive instance.\nThat is, p =(number of positive instances covered by the clause)/(total number\nof instances covered by the clause). It is convenient to express this probability\nin \u201codds form.\u201d The odds, o, that a covered instance is positive is de\ufb01ned to\nbe o = p/(1 \u2212p). Expressing the probability in terms of the odds, we obtain\np = o/(1 + o).7.6. RELATIONSHIPS BETWEEN ILP AND DECISION TREE INDUCTION101\nAfter selecting a literal, l, to add to a clause, some of the instances previously\ncovered are still covered; some of these are positive and some are negative. Let\npl denote the probability that an instance drawn at random from the instances\ncovered by the new clause (with l added) is positive. The odds will be denoted\nby ol.\nWe want to select a literal, l, that gives maximal increase in these\nodds.\nThat is, if we de\ufb01ne \u03bbl = ol/o, we want a literal that gives a high\nvalue of \u03bbl. Specializing the clause in such a way that it fails to cover many of\nthe negative instances previously covered but still covers most of the positive\ninstances previously covered will result in a high value of \u03bbl. (It turns out that\nthe value of Quinlan\u2019s information theoretic measure increases monotonically\nwith \u03bbl, so we could just as well use the latter instead.)\nBesides \ufb01nding a literal with a high value of \u03bbl, Quinlan\u2019s FOIL system also\nrestricts the choice to literals that:\na) contain at least one variable that has already been used,\nb) place further restrictions on the variables if the literal selected has the\nsame predicate letter as the literal being induced (in order to prevent in\ufb01nite\nrecursion), and\nc) survive a pruning test based on the values of \u03bbl for those literals selected\nso far.\nWe refer the reader to Quinlan\u2019s paper for further discussion of these points.\nQuinlan also discusses post-processing pruning methods and presents experi-\nmental results of the method applied to learning recursive relations on lists, on\nlearning rules for chess endgames and for the card game Eleusis, and for some\nother standard tasks mentioned in the machine learning literature.\nThe\nreader\nshould\nalso\nrefer\nto\n[Pazzani & Kibler, 1992,\nLavra\u02c7\nc & D\u02c7\nzeroski, 1994, Muggleton, 1991, Muggleton, 1992].\nDiscuss preprocessing,\npostprocessing, bottom-up\nmethods, and LINUS.\n7.6\nRelationships Between ILP and Decision\nTree Induction\nThe generic ILP algorithm can also be understood as a type of decision tree\ninduction.\nRecall the problem of inducing decision trees when the values of\nattributes are categorical.\nWhen splitting on a single variable, the split at\neach node involves asking to which of several mutually exclusive and exhaustive\nsubsets the value of a variable belongs. For example, if a node tested the variable\nxi, and if xi could have values drawn from {A, B, C, D, E, F}, then one possible\nsplit (among many) might be according to whether the value of xi had as value\none of {A, B, C} or one of {D, E, F}.\nIt is also possible to make a multi-variate split\u2014testing the values of two or\nmore variables at a time. With categorical variables, an n-variable split would\nbe based on which of several n-ary relations the values of the variables satis\ufb01ed.\nFor example, if a node tested the variables xi and xj, and if xi and xj both\ncould have values drawn from {A, B, C, D, E, F}, then one possible binary split102\nCHAPTER 7. INDUCTIVE LOGIC PROGRAMMING\n(among many) might be according to whether or not < xi, xj > satis\ufb01ed the\nrelation {< A, C >, < C, D >}. (Note that our subset method of forming single-\nvariable splits could equivalently have been framed using 1-ary relations\u2014which\nare usually called properties.)\nIn this framework, the ILP problem is as follows: We are given a training set,\n\u039e, of positively and negatively labeled patterns whose components are drawn\nfrom a set of variables {x, y, z, . . .}. The positively labeled patterns in \u039e form an\nextensional de\ufb01nition of a relation, R. We are also given background relations,\nR1, . . . , Rk, on various subsets of these variables. (That is, we are given sets\nof tuples that are in these relations.)\nWe desire to construct an intensional\nde\ufb01nition of R in terms of the R1, . . . , Rk, such that all of the positively labeled\npatterns in \u039e are satis\ufb01ed by R and none of the negatively labeled patterns\nare. The intensional de\ufb01nition will be in terms of a logic program in which the\nrelation R is the head of a set of clauses whose bodies involve the background\nrelations.\nThe generic ILP algorithm can be understood as decision tree induction,\nwhere each node of the decision tree is itself a sub-decision tree, and each sub-\ndecision tree consists of nodes that make binary splits on several variables using\nthe background relations, Ri. Thus we will speak of a top-level decision tree\nand various sub-decision trees. (Actually, our decision trees will be decision\nlists\u2014a special case of decision trees, but we will refer to them as trees in our\ndiscussions.)\nIn broad outline, the method for inducing an intensional version of the rela-\ntion R is illustrated by considering the decision tree shown in Fig. 7.5. In this\ndiagram, the patterns in \u039e are \ufb01rst \ufb01ltered through the decision tree in top-\nlevel node 1. The background relation R1 is satis\ufb01ed by some of these patterns;\nthese are \ufb01ltered to the right (to relation R2), and the rest are \ufb01ltered to the\nleft (more on what happens to these later). Right-going patterns are \ufb01ltered\nthrough a sequence of relational tests until only positively labeled patterns sat-\nisfy the last relation\u2014in this case R3. That is, the subset of patterns satisfying\nall the relations, R1, R2, and R3 contains only positive instances from \u039e. (We\nmight say that this combination of tests is necessary. They correspond to the\nclause created in the \ufb01rst pass through the inner loop of the generic ILP algo-\nrithm.) Let us call the subset of patterns satisfying these relations, \u039e1; these\nsatisfy Node 1 at the top level. All other patterns, that is {\u039e \u2212\u039e1} = \u039e2 are\n\ufb01ltered to the left by Node 1.\n\u039e2 is then \ufb01ltered by top-level Node 2 in much the same manner, so that\nNode 2 is satis\ufb01ed only by the positively labeled samples in \u039e2. We continue\n\ufb01ltering through top-level nodes until only the negatively labeled patterns fail to\nsatisfy a top node. In our example, \u039e4 contains only negatively labeled patterns\nand the union of \u039e1 and \u039e3 contains all the positively labeled patterns. The\nrelation, R, that distinguishes positive from negative patterns in \u039e is then given\nin terms of the following logic program:\nR :- R1, R2, R37.6. RELATIONSHIPS BETWEEN ILP AND DECISION TREE INDUCTION103\nR1\nR2\nR3\nT\nT\nT\nF\nF\nF\nT\nF\nR4\nR5\nT\nT\nF\nF\nT\nF\nU\nU1\nU2 = U < U1\nU3\nU4= U2 < U3\nNode 1\nNode 2\n(only positive\ninstances\nsatisfy all three\ntests)\n(only positivel\ninstances satisfy\nthese two tests)\n(only negative\ninstances)\nFigure 7.5: A Decision Tree for ILP\n:- R4, R5\nIf we apply this sort of decision-tree induction procedure to the problem\nof generating a logic program for the relation Nonstop (refer to Fig. 7.3), we\nobtain the decision tree shown in Fig. 7.6. The logic program resulting from\nthis decision tree is the same as that produced by the generic ILP algorithm.\nIn setting up the problem, the training set, \u039e can be expressed as a set of 2-\ndimensional vectors with components x and y. The values of these components\nrange over the cities {A, B, C, A1, A2, B1, B2, C1, C2} except (for simplicity)\nwe do not allow patterns in which x and y have the same value. As before, the\nrelation, Nonstop, contains the following pairs of cities, which are the positive\ninstances:\n{< A, B >, < A, C >, < B, C >, < B, A >, < C, A >, < C, B >,\n< A, A1 >, < A, A2 >, < A1, A >, < A2, A >, < B, B1 >, < B, B2 >,\n< B1, B >, < B2, B >, < C, C1 >, < C, C2 >, < C1, C >, < C2, C >}\nAll other pairs of cities named in the map of Fig. 7.3 (using the closed world\nassumption) are not in the relation Nonstop and thus are negative instances.\nBecause the values of x and y are categorical, decision-tree induction would\nbe a very di\ufb03cult task\u2014involving as it does the need to invent relations on104\nCHAPTER 7. INDUCTIVE LOGIC PROGRAMMING\nx and y to be used as tests. But with the background relations, Ri (in this\ncase Hub and Satellite), the problem is made much easier. We select these\nrelations in the same way that we select literals; from among the available tests,\nwe make a selection based on which leads to the largest value of \u03bbRi.\n7.7\nBibliographical and Historical Remarks\nTo be added.7.7. BIBLIOGRAPHICAL AND HISTORICAL REMARKS\n105\nHub(x)\nT\nF\nU\nNode 1\n(top level)\n{<A,B>, <A,C>,\n<B,C>, <B,A>,\n<C,A>, <C,B>}\nHub(y)\nT\nT\nF\nNode 2\n(top level)\nSatellite(x,y)\nF\nT\nT\n{<A1,A>, <A2,A>, <B1,B>,\n<B2,B>, <C1,C>, <C2,C>}\nF\n{<A,A1>, <A,A2>,<B,B1>,\n<B,B2>,  <C,C1>, <C,C2>}\nSatellite(y,x)\nF\nF\nT\nNode 3\n(top level)\nT\n{Only negative instances}\n(Only positive instances)\n(Only positive instances)\n(Only positive instances)\nF\nFigure 7.6: A Decision Tree for the Airline Route Problem106\nCHAPTER 7. INDUCTIVE LOGIC PROGRAMMING", "8": "Chapter 8\nComputational Learning\nTheory\nIn chapter one we posed the problem of guessing a function given a set of\nsample inputs and their values. We gave some intuitive arguments to support\nthe claim that after seeing only a small fraction of the possible inputs (and\ntheir values) that we could guess almost correctly the values of most subsequent\ninputs\u2014if we knew that the function we were trying to guess belonged to an\nappropriately restricted subset of functions. That is, a given training set of\nsample patterns might be adequate to allow us to select a function, consistent\nwith the labeled samples, from among a restricted set of hypotheses such that\nwith high probability the function we select will be approximately correct (small\nprobability of error) on subsequent samples drawn at random according to the\nsame distribution from which the labeled samples were drawn.\nThis insight\nled to the theory of probably approximately correct (PAC) learning\u2014initially\ndeveloped by Leslie Valiant [Valiant, 1984]. We present here a brief description\nof the theory for the case of Boolean functions. [Dietterich, 1990, Haussler, 1988,\nHaussler, 1990] give nice surveys of the important results.\nOther overviews?\n8.1\nNotation and Assumptions for PAC Learn-\ning Theory\nWe assume a training set \u039e of n-dimensional vectors, Xi, i = 1, . . . , m, each\nlabeled (by 1 or 0) according to a target function, f, which is unknown to\nthe learner. The probability of any given vector X being in \u039e, or later being\npresented to the learner, is P(X).\nThe probability distribution, P, can be\narbitrary. (In the literature of PAC learning theory, the target function is usually\ncalled the target concept and is denoted by c, but to be consistent with our\nprevious notation we will continue to denote it by f.) Our problem is to guess\n107108\nCHAPTER 8. COMPUTATIONAL LEARNING THEORY\na function, h(X), based on the labeled samples in \u039e. In PAC theory such a\nguessed function is called the hypothesis. We assume that the target function\nis some element of a set of functions, C. We also assume that the hypothesis,\nh, is an element of a set, H, of hypotheses, which includes the set, C, of target\nfunctions. H is called the hypothesis space.\nIn general, h won\u2019t be identical to f, but we can strive to have the value of\nh(X) = the value of f(X) for most X\u2019s. That is, we want h to be approximately\ncorrect. To quantify this notion, we de\ufb01ne the error of h, \u03b5h, as the probability\nthat an X drawn randomly according to P will be misclassi\ufb01ed:\n\u03b5h =\nX\n[X:h(X)\u0338=f(X)]\nP(X)\nBoldface symbols need to be\nsmaller when they are subscripts in\nmath environments.\nWe say that h is approximately (except for \u03b5 ) correct if \u03b5h \u2264\u03b5, where \u03b5 is the\naccuracy parameter.\nSuppose we are able to \ufb01nd an h that classi\ufb01es all m randomly drawn training\nsamples correctly; that is, h is consistent with this randomly selected training\nset, \u039e.\nIf m is large enough, will such an h be approximately correct (and\nfor what value of \u03b5)? On some training occasions, using m randomly drawn\ntraining samples, such an h might turn out to be approximately correct (for a\ngiven value of \u03b5), and on others it might not. We say that h is probably (except\nfor \u03b4) approximately correct (PAC) if the probability that it is approximately\ncorrect is greater than 1\u2212\u03b4, where \u03b4 is the con\ufb01dence parameter. We shall show\nthat if m is greater than some bound whose value depends on \u03b5 and \u03b4, such an\nh is guaranteed to be probably approximately correct.\nIn general, we say that a learning algorithm PAC-learns functions from C in\nterms of H i\ufb00for every function f\u03f5 C, it outputs a hypothesis h\u03f5 H, such that\nwith probability at least (1 \u2212\u03b4), \u03b5h \u2264\u03b5. Such a hypothesis is called probably\n(except for \u03b4) approximately (except for \u03b5) correct.\nWe want learning algorithms that are tractable, so we want an algorithm\nthat PAC-learns functions in polynomial time. This can only be done for certain\nclasses of functions. If there are a \ufb01nite number of hypotheses in a hypothesis\nset (as there are for many of the hypothesis sets we have considered), we could\nalways produce a consistent hypothesis from this set by testing all of them\nagainst the training data. But if there are an exponential number of hypotheses,\nthat would take exponential time.\nWe seek training methods that produce\nconsistent hypotheses in less time. The time complexities for various hypothesis\nsets have been determined, and these are summarized in a table to be presented\nlater.\nA class, C, is polynomially PAC learnable in terms of H provided there exists\na polynomial-time learning algorithm (polynomial in the number of samples\nneeded, m, in the dimension, n, in 1/\u03b5, and in 1/\u03b4) that PAC-learns functions\nin C in terms of H.\nInitial work on PAC assumed H = C, but it was later shown that some func-\ntions cannot be polynomially PAC-learned under such an assumption (assuming8.2. PAC LEARNING\n109\nP \u0338= NP)\u2014but can be polynomially PAC-learned if H is a strict superset of C!\nAlso our de\ufb01nition does not specify the distribution, P, from which patterns\nare drawn nor does it say anything about the properties of the learning algo-\nrithm. Since C and H do not have to be identical, we have the further restrictive\nde\ufb01nition:\nA properly PAC-learnable class is a class C for which there exists an algorithm\nthat polynomially PAC-learns functions from C in terms of C.\n8.2\nPAC Learning\n8.2.1\nThe Fundamental Theorem\nSuppose our learning algorithm selects some h randomly from among those that\nare consistent with the values of f on the m training patterns. The probability\nthat the error of this randomly selected h is greater than some \u03b5, with h consis-\ntent with the values of f(X) for m instances of X (drawn according to arbitrary\nP), is less than or equal to |H|e\u2212\u03b5m, where |H| is the number of hypotheses in\nH. We state this result as a theorem [Blumer, et al., 1987]:\nTheorem 8.1 (Blumer, et al.) Let H be any set of hypotheses, \u039e be a set of\nm \u22651 training examples drawn independently according to some distribution\nP, f be any classi\ufb01cation function in H, and \u03b5 > 0. Then, the probability that\nthere exists a hypothesis h consistent with f for the members of \u039e but with error\ngreater than \u03b5 is at most |H|e\u2212\u03b5m.\nProof:\nConsider the set of all hypotheses, {h1, h2, . . . , hi, . . . , hS}, in H, where S =\n|H|. The error for hi is \u03b5hi= the probability that hi will classify a pattern in\nerror (that is, di\ufb00erently than f would classify it). The probability that hi will\nclassify a pattern correctly is (1\u2212\u03b5hi). A subset, HB, of H will have error greater\nthan \u03b5. We will call the hypotheses in this subset bad. The probability that any\nparticular one of these bad hypotheses, say hb, would classify a pattern correctly\nis (1\u2212\u03b5hb). Since \u03b5hb > \u03b5, the probability that hb (or any other bad hypothesis)\nwould classify a pattern correctly is less than (1 \u2212\u03b5). The probability that it\nwould classify all m independently drawn patterns correctly is then less than\n(1 \u2212\u03b5)m.\nThat is,\nprob[hb classi\ufb01es all m patterns correctly |hb \u03f5 HB] \u2264(1 \u2212\u03b5)m.\nprob[some h \u03f5 HB classi\ufb01es all m patterns correctly]\n= P\nhb \u03f5 HB prob[hb classi\ufb01es all m patterns correctly |hb \u03f5 HB]\n\u2264K(1 \u2212\u03b5)m, where K = |HB|.110\nCHAPTER 8. COMPUTATIONAL LEARNING THEORY\nThat is,\nprob[there is a bad hypothesis that classi\ufb01es all m patterns correctly]\n\u2264K(1 \u2212\u03b5)m.\nSince K \u2264|H| and (1 \u2212\u03b5)m \u2264e\u2212\u03b5m, we have:\nprob[there is a bad hypothesis that classi\ufb01es all m patterns correctly]\n= prob[there is a hypothesis with error > \u03b5 and that classi\ufb01es all m patterns\ncorrectly] \u2264|H|e\u2212\u03b5m.\nQED\nA corollary of this theorem is:\nCorollary 8.2 Given m \u2265(1/\u03b5)(ln |H| + ln(1/\u03b4)) independent samples, the\nprobability that there exists a hypothesis in H that is consistent with f on these\nsamples and has error greater than \u03b5 is at most \u03b4.\nProof: We are to \ufb01nd a bound on m that guarantees that\nprob[there is a hypothesis with error > \u03b5 and that classi\ufb01es all m patterns\ncorrectly] \u2264\u03b4.\nThus, using the result of the theorem, we must show that\n|H|e\u2212\u03b5m \u2264\u03b4. Taking the natural logarithm of both sides yields:\nln |H| \u2212\u03b5m \u2264ln \u03b4\nor\nm \u2265(1/\u03b5)(ln |H| + ln(1/\u03b4))\nQED\nThis corollary is important for two reasons. First it clearly states that we\ncan select any hypothesis consistent with the m samples and be assured that\nwith probability (1 \u2212\u03b4) its error will be less than \u03b5. Also, it shows that in\norder for m to increase no more than polynomially with n, |H| can be no larger\nthan 2O(nk). No class larger than that can be guaranteed to be properly PAC\nlearnable.\nHere is a possible point of confusion: The bound given in the corollary is\nan upper bound on the value of m needed to guarantee polynomial probably ap-\nproximately correct learning. Values of m greater than that bound are su\ufb03cient\n(but might not be necessary). We will present a lower (necessary) bound later\nin the chapter.8.2. PAC LEARNING\n111\n8.2.2\nExamples\nTerms\nLet H be the set of terms (conjunctions of literals). Then, |H| = 3n, and\nm \u2265(1/\u03b5)(ln(3n) + ln(1/\u03b4))\n\u2265(1/\u03b5)(1.1n + ln(1/\u03b4))\nNote that the bound on m increases only polynomially with n, 1/\u03b5, and 1/\u03b4.\nFor n = 50, \u03b5 = 0.01 and \u03b4 = 0.01, m \u22655, 961 guarantees PAC learnability.\nIn order to show that terms are properly PAC learnable, we additionally\nhave to show that one can \ufb01nd in time polynomial in m and n a hypothesis\nh consistent with a set of m patterns labeled by the value of a term.\nThe\nfollowing procedure for \ufb01nding such a consistent hypothesis requires O(nm)\nsteps (adapted from [Dietterich, 1990, page 268]):\nWe are given a training sequence, \u039e, of m examples. Find the \ufb01rst pattern,\nsay X1, in that list that is labeled with a 1.\nInitialize a Boolean function,\nh, to the conjunction of the n literals corresponding to the values of the n\ncomponents of X1. (Components with value 1 will have corresponding positive\nliterals; components with value 0 will have corresponding negative literals.) If\nthere are no patterns labeled by a 1, we exit with the null concept (h \u22610 for\nall patterns). Then, for each additional pattern, Xi, that is labeled with a 1,\nwe delete from h any Boolean variables appearing in Xi with a sign di\ufb00erent\nfrom their sign in h. After processing all the patterns labeled with a 1, we check\nall of the patterns labeled with a 0 to make sure that none of them is assigned\nvalue 1 by h. If, at any stage of the algorithm, any patterns labeled with a 0\nare assigned a 1 by h, then there exists no term that consistently classi\ufb01es the\npatterns in \u039e, and we exit with failure. Otherwise, we exit with h.\nChange this paragraph if this\nalgorithm was presented in Chapter\nThree.\nAs an example, consider the following patterns, all labeled with a 1 (from\n[Dietterich, 1990]):\n(0, 1, 1, 0)\n(1, 1, 1, 0)\n(1, 1, 0, 0)\nAfter processing the \ufb01rst pattern, we have h = x1x2x3x4; after processing the\nsecond pattern, we have h = x2x3x4; \ufb01nally, after the third pattern, we have\nh = x2x4.\nLinearly Separable Functions\nLet H be the set of all linearly separable functions. Then, |H| \u22642n2, and112\nCHAPTER 8. COMPUTATIONAL LEARNING THEORY\nm \u2265(1/\u03b5)\n\u0000n2 ln 2 + ln(1/\u03b4)\n\u0001\nAgain, note that the bound on m increases only polynomially with n, 1/\u03b5, and\n1/\u03b4.\nFor n = 50, \u03b5 = 0.01 and \u03b4 = 0.01, m \u2265173, 748 guarantees PAC learnabil-\nity.\nTo show that linearly separable functions are properly PAC learnable, we\nwould have additionally to show that one can \ufb01nd in time polynomial in m and\nn a hypothesis h consistent with a set of m labeled linearly separable patterns.\nLinear programming is polynomial.\n8.2.3\nSome Properly PAC-Learnable Classes\nSome properly PAC-learnable classes of functions are given in the following\ntable. (Adapted from [Dietterich, 1990,\npages 262 and 268] which also gives\nreferences to proofs of some of the time complexities.)\nH\n|H|\nTime Complexity\nP. Learnable?\nterms\n3n\npolynomial\nyes\nk-term DNF\n2O(kn)\nNP-hard\nno\n(k disjunctive terms)\nk-DNF\n2O(nk)\npolynomial\nyes\n(a disjunction of k-sized terms)\nk-CNF\n2O(nk)\npolynomial\nyes\n(a conjunction of k-sized clauses)\nk-DL\n2O(nkk lg n)\npolynomial\nyes\n(decision lists with k-sized terms)\nlin. sep.\n2O(n2)\npolynomial\nyes\nlin. sep. with (0,1) weights\n?\nNP-hard\nno\nk-2NN\n?\nNP-hard\nno\nDNF\n22n\npolynomial\nno\n(all Boolean functions)\n(Members of the class k-2NN are two-layer, feedforward neural networks with\nexactly k hidden units and one output unit.)\nSummary:\nIn order to show that a class of functions is Properly PAC-\nLearnable :\na. Show that there is an algorithm that produces a consistent hypothesis on\nm n-dimensional samples in time polynomial in m and n.\nb. Show that the sample size, m, needed to ensure PAC learnability is polyno-\nmial (or better) in (1/\u03b5), (1/\u03b4), and n by showing that ln |H| is polynomial\nor better in the number of dimensions.8.3. THE VAPNIK-CHERVONENKIS DIMENSION\n113\nAs hinted earlier, sometimes enlarging the class of hypotheses makes learning\neasier. For example, the table above shows that k-CNF is PAC learnable, but\nk-term-DNF is not. And yet, k-term-DNF is a subclass of k-CNF! So, even if\nthe target function were in k-term-DNF, one would be able to \ufb01nd a hypothesis\nin k-CNF that is probably approximately correct for the target function. Sim-\nilarly, linearly separable functions implemented by TLUs whose weight values\nare restricted to 0 and 1 are not properly PAC learnable, whereas unrestricted\nlinearly separable functions are. It is possible that enlarging the space of hy-\npotheses makes \ufb01nding one that is consistent with the training examples easier.\nAn interesting question is whether or not the class of functions in k-2NN is poly-\nnomially PAC learnable if the hypotheses are drawn from k\u2032-2NN with k\u2032 > k.\n(At the time of writing, this matter is still undecided.)\nAlthough PAC learning theory is a powerful analytic tool, it (like complexity\ntheory) deals mainly with worst-case results. The fact that the class of two-\nlayer, feedforward neural networks is not polynomially PAC learnable is more an\nattack on the theory than it is on the networks, which have had many successful\napplications. As [Baum, 1994, page 416-17] says: \u201c . . . humans are capable of\nlearning in the natural world. Therefore, a proof within some model of learning\nthat learning is not feasible is an indictment of the model. We should examine\nthe model to see what constraints can be relaxed and made more realistic.\u201d\n8.3\nThe Vapnik-Chervonenkis Dimension\n8.3.1\nLinear Dichotomies\nConsider a set, H, of functions, and a set, \u039e, of (unlabeled) patterns.\nOne\nmeasure of the expressive power of a set of hypotheses, relative to \u039e, is its\nability to make arbitrary classi\ufb01cations of the patterns in \u039e.1 If there are m\npatterns in \u039e, there are 2m di\ufb00erent ways to divide these patterns into two\ndisjoint and exhaustive subsets. We say there are 2m di\ufb00erent dichotomies of\n\u039e. If \u039e were to include all of the 2n Boolean patterns, for example, there are\n22n ways to dichotomize them, and (of course) the set of all possible Boolean\nfunctions dichotomizes them in all of these ways. But a subset, H, of the Boolean\nfunctions might not be able to dichotomize an arbitrary set, \u039e, of m Boolean\npatterns in all 2m ways. In general (that is, even in the non-Boolean case), we\nsay that if a subset, H, of functions can dichotomize a set, \u039e, of m patterns in\nall 2m ways, then H shatters \u039e.\nAs an example, consider a set \u039e of m patterns in the n-dimensional space,\nRn. (That is, the n components of these patterns are real numbers.) We de\ufb01ne\na linear dichotomy as one implemented by an (n\u22121)-dimensional hyperplane in\nthe n-dimensional space. How many linear dichotomies of m patterns in n di-\nmensions are there? For example, as shown in Fig. 8.1, there are 14 dichotomies\n1And, of course, if a hypothesis drawn from a set that could make arbitrary classi\ufb01cations\nof a set of training patterns, there is little likelihood that such a hypothesis will generalize\nwell beyond the training set.114\nCHAPTER 8. COMPUTATIONAL LEARNING THEORY\nof four points in two dimensions (each separating line yields two dichotomies\ndepending on whether the points on one side of the line are classi\ufb01ed as 1 or 0).\n(Note that even though there are an in\ufb01nite number of hyperplanes, there are,\nnevertheless, only a \ufb01nite number of ways in which hyperplanes can dichotomize\na \ufb01nite number of patterns. Small movements of a hyperplane typically do not\nchange the classi\ufb01cations of any patterns.)\n1\n2\n3\n4\n14 dichotomies of 4 points in 2 dimensions\n5\n6\n7\nFigure 8.1: Dichotomizing Points in Two Dimensions\nThe number of dichotomies achievable by hyperplanes depends on how the\npatterns are disposed.\nFor the maximum number of linear dichotomies, the\npoints must be in what is called general position. For m > n, we say that a set\nof m points is in general position in an n-dimensional space if and only if no\nsubset of (n+1) points lies on an (n\u22121)-dimensional hyperplane. When m \u2264n,\na set of m points is in general position if no (m \u22122)-dimensional hyperplane\ncontains the set. Thus, for example, a set of m \u22654 points is in general position\nin a three-dimensional space if no four of them lie on a (two-dimensional) plane.\nWe will denote the number of linear dichotomies of m points in general position\nin an n-dimensional space by the expression \u03a0L(m, n).\nIt is not too di\ufb03cult to verify that:\nInclude the derivation.\n\u03a0L(m, n) = 2\nn\nX\ni=0\nC(m \u22121, i)\nfor m > n, and\n= 2m\nfor m \u2264n8.3. THE VAPNIK-CHERVONENKIS DIMENSION\n115\nwhere C(m \u22121, i) is the binomial coe\ufb03cient\n(m\u22121)!\n(m\u22121\u2212i)!i!.\nThe table below shows some values for \u03a0L(m, n).\nm\nn\n(no. of patterns)\n(dimension)\n1\n2\n3\n4\n5\n1\n2\n2\n2\n2\n2\n2\n4\n4\n4\n4\n4\n3\n6\n8\n8\n8\n8\n4\n8\n14\n16\n16\n16\n5\n10\n22\n30\n32\n32\n6\n12\n32\n52\n62\n64\n7\n14\n44\n84\n114\n126\n8\n16\n58\n128\n198\n240\nNote that the class of linear dichotomies shatters the m patterns if m \u2264n + 1.\nThe bold-face entries in the table correspond to the highest values of m for\nwhich linear dichotomies shatter m patterns in n dimensions.\n8.3.2\nCapacity\nLet Pm,n = \u03a0L(m,n)\n2m\n= the probability that a randomly selected dichotomy (out\nof the 2m possible dichotomies of m patterns in n dimensions) will be linearly\nseparable. In Fig. 8.2 we plot P\u03bb(n+1),n versus \u03bb and n, where \u03bb = m/(n + 1).\nNote that for large n (say n > 30) how quickly Pm,n falls from 1 to 0 as\nm goes above 2(n + 1). For m < 2(n + 1), any dichotomy of the m points is\nalmost certainly linearly separable. But for m > 2(n + 1), a randomly selected\ndichotomy of the m points is almost certainly not linearly separable. For this\nreason m = 2(n + 1) is called the capacity of a TLU [Cover, 1965]. Unless the\nnumber of training patterns exceeds the capacity, the fact that a TLU separates\nthose training patterns according to their labels means nothing in terms of how\nwell that TLU will generalize to new patterns. There is nothing special about\na separation found for m < 2(n + 1) patterns\u2014almost any dichotomy of those\npatterns would have been linearly separable. To make sure that the separation\nfound is forced by the training set and thus generalizes well, it has to be the\ncase that there are very few linearly separable functions that would separate\nthe m training patterns.\nAnalogous results about the generalizing abilities of neural networks have\nbeen developed by [Baum & Haussler, 1989] and given intuitive and experimen-\ntal justi\ufb01cation in [Baum, 1994, page 438]:\n\u201cThe results seemed to indicate the following heuristic rule holds. If\nM examples [can be correctly classi\ufb01ed by] a net with W weights (for\nM >> W), the net will make a fraction \u03b5 of errors on new examples\nchosen from the same [uniform] distribution where \u03b5 = W/M.\u201d116\nCHAPTER 8. COMPUTATIONAL LEARNING THEORY\n0\n1\n2\n3\n4\n10\n20\n30\n40\n50\n0\n0.25\n0.5\n0.75\n1\n0\n1\n2\n3\n4\n10\n20\n30\n40\n50\n0\n25\n.5\n75\n1\nPh(n + 1), n\nh\nn\nFigure 8.2: Probability that a Random Dichotomy is Linearly Separable\n8.3.3\nA More General Capacity Result\nCorollary 7.2 gave us an expression for the number of training patterns su\ufb03cient\nto guarantee a required level of generalization\u2014assuming that the function we\nwere guessing was a function belonging to a class of known and \ufb01nite cardinality.\nThe capacity result just presented applies to linearly separable functions for non-\nbinary patterns. We can extend these ideas to general dichotomies of non-binary\npatterns.\nIn general, let us denote the maximum number of dichotomies of any set\nof m n-dimensional patterns by hypotheses in H as \u03a0H(m, n). The number of\ndichotomies will, of course, depend on the disposition of the m points in the\nn-dimensional space; we take \u03a0H(m, n) to be the maximum over all possible\narrangements of the m points. (In the case of the class of linearly separable\nfunctions, the maximum number is achieved when the m points are in general\nposition.) For each class, H, there will be some maximum value of m for which\n\u03a0H(m, n) = 2m, that is, for which H shatters the m patterns. This maximum\nnumber is called the Vapnik-Chervonenkis (VC) dimension and is denoted by\nVCdim(H) [Vapnik & Chervonenkis, 1971].\nWe saw that for the class of linear dichotomies, VCdim(Linear) = (n + 1).\nAs another example, let us calculate the VC dimension of the hypothesis space\nof single intervals on the real line\u2014used to classify points on the real line. We\nshow an example of how points on the line might be dichotomized by a single\ninterval in Fig. 8.3. The set \u039e could be, for example, {0.5, 2.5, - 2.3, 3.14}, and\none of the hypotheses in our set would be [1, 4.5]. This hypothesis would label\nthe points 2.5 and 3.14 with a 1 and the points - 2.3 and 0.5 with a 0. This8.3. THE VAPNIK-CHERVONENKIS DIMENSION\n117\nset of hypotheses (single intervals on the real line) can arbitrarily classify any\ntwo points. But no single interval can classify three points such that the outer\ntwo are classi\ufb01ed as 1 and the inner one as 0. Therefore the VC dimension of\nsingle intervals on the real line is 2. As soon as we have many more than 2\ntraining patterns on the real line and provided we know that the classi\ufb01cation\nfunction we are trying to guess is a single interval, then we begin to have good\ngeneralization.\nFigure 8.3: Dichotomizing Points by an Interval\nThe VC dimension is a useful measure of the expressive power of a hypothesis\nset. Since any dichotomy of VCdim(H) or fewer patterns in general position in n\ndimensions can be achieved by some hypothesis in H, we must have many more\nthan VCdim(H) patterns in the training set in order that a hypothesis consistent\nwith the training set is su\ufb03ciently constrained to imply good generalization.\nOur examples have shown that the concept of VC dimension is not restricted\nto Boolean functions.\n8.3.4\nSome Facts and Speculations About the VC Dimen-\nsion\n\u2022 If there are a \ufb01nite number, |H|, of hypotheses in H, then:\nVCdim(H) \u2264log(|H|)\n\u2022 The VC dimension of terms in n dimensions is n.\n\u2022 Suppose we generalize our example that used a hypothesis set of single\nintervals on the real line. Now let us consider an n-dimensional feature\nspace and tests of the form Li \u2264xi \u2264Hi. We allow only one such test per\ndimension. A hypothesis space consisting of conjunctions of these tests\n(called axis-parallel hyper-rectangles) has VC dimension bounded by:\nn \u2264VCdim \u22642n\n\u2022 As we have already seen, TLUs with n inputs have a VC dimension of\nn + 1.\n\u2022 [Baum, 1994, page 438] gives experimental evidence for the proposition\nthat \u201c . . . multilayer [neural] nets have a VC dimension roughly equal to\ntheir total number of [adjustable] weights.\u201d118\nCHAPTER 8. COMPUTATIONAL LEARNING THEORY\n8.4\nVC Dimension and PAC Learning\nThere are two theorems that connect the idea of VC dimension with PAC learn-\ning [Blumer, et al., 1990]. We state these here without proof.\nTheorem 8.3 (Blumer, et al.) A hypothesis space H is PAC learnable i\ufb00it\nhas \ufb01nite VC dimension.\nTheorem 8.4 A set of hypotheses, H, is properly PAC learnable if:\na. m \u2265(1/\u03b5) max [4 lg(2/\u03b4), 8 VCdim lg(13/\u03b5)], and\nb. if there is an algorithm that outputs a hypothesis h \u03f5 H consistent with the\ntraining set in polynomial (in m and n) time.\nThe second of these two theorems improves the bound on the number of\ntraining patterns needed for linearly separable functions to one that is linear\nin n. In our previous example of how many training patterns were needed to\nensure PAC learnability of a linearly separable function if n = 50, \u03b5 = 0.01, and\n\u03b4 = 0.01, we obtained m \u2265173, 748. Using the Blumer, et al. result we would\nget m \u226552, 756.\nAs another example of the second theorem, let us take H to be the set of\nclosed intervals on the real line. The VC dimension is 2 (as shown previously).\nWith n = 50, \u03b5 = 0.01, and \u03b4 = 0.01, m \u226516, 551 ensures PAC learnability.\nThere is also a theorem that gives a lower (necessary) bound on the number\nof training patterns required for PAC learning [Ehrenfeucht, et al., 1988]:\nTheorem 8.5 Any\nPAC\nlearning\nalgorithm\nmust\nexamine\nat\nleast\n\u2126(1/\u03b5 lg(1/\u03b4) + VCdim(H)) training patterns.\nThe\ndi\ufb00erence\nbetween\nthe\nlower\nand\nupper\nbounds\nis\nO(log(1/\u03b5)VCdim(H)/\u03b5).\n8.5\nBibliographical and Historical Remarks\nTo be added.", "9": "Chapter 9\nUnsupervised Learning\n9.1\nWhat is Unsupervised Learning?\nConsider the various sets of points in a two-dimensional space illustrated in Fig.\n9.1. The \ufb01rst set (a) seems naturally partitionable into two classes, while the\nsecond (b) seems di\ufb03cult to partition at all, and the third (c) is problematic.\nUnsupervised learning uses procedures that attempt to \ufb01nd natural partitions\nof patterns. There are two stages:\n\u2022 Form an R-way partition of a set \u039e of unlabeled training patterns (where\nthe value of R, itself, may need to be induced from the patterns). The\npartition separates \u039e into R mutually exclusive and exhaustive subsets,\n\u039e1, . . . , \u039eR, called clusters.\n\u2022 Design a classi\ufb01er based on the labels assigned to the training patterns by\nthe partition.\nWe will explain shortly various methods for deciding how many clusters there\nshould be and for separating a set of patterns into that many clusters. We can\nbase some of these methods, and their motivation, on minimum-description-\nlength (MDL) principles. In that setting, we assume that we want to encode\na description of a set of points, \u039e, into a message of minimal length.\nOne\nencoding involves a description of each point separately; other, perhaps shorter,\nencodings might involve a description of clusters of points together with how\neach point in a cluster can be described given the cluster it belongs to. The\nspeci\ufb01c techniques described in this chapter do not explicitly make use of MDL\nprinciples, but the MDL method has been applied with success. One of the\nMDL-based methods, Autoclass II [Cheeseman, et al., 1988] discovered a new\nclassi\ufb01cation of stars based on the properties of infrared sources.\nAnother type of unsupervised learning involves \ufb01nding hierarchies of par-\ntitionings or clusters of clusters. A hierarchical partition is one in which \u039e is\n119120\nCHAPTER 9. UNSUPERVISED LEARNING\na)  two clusters\nb) one cluster\nc) ?\nFigure 9.1: Unlabeled Patterns\ndivided into mutually exclusive and exhaustive subsets, \u039e1, . . . , \u039eR; each set,\n\u039ei, (i = 1, . . . , R) is divided into mutually exclusive and exhaustive subsets,\nand so on. We show an example of such a hierarchical partition in Fig. 9.2.\nThe hierarchical form is best displayed as a tree, as shown in Fig. 9.3. The tip\nnodes of the tree can further be expanded into their individual pattern elements.\nOne application of such hierarchical partitions is in organizing individuals into\ntaxonomic hierarchies such as those used in botany and zoology.\n9.2\nClustering Methods\n9.2.1\nA Method Based on Euclidean Distance\nMost of the unsupervised learning methods use a measure of similarity between\npatterns in order to group them into clusters. The simplest of these involves\nde\ufb01ning a distance between patterns. For patterns whose features are numeric,\nthe distance measure can be ordinary Euclidean distance between two points in\nan n-dimensional space.\nThere is a simple, iterative clustering method based on distance.\nIt can\nbe described as follows. Suppose we have R randomly chosen cluster seekers,\nC1, . . . , CR. These are points in an n-dimensional space that we want to adjust\nso that they each move toward the center of one of the clusters of patterns.\nWe present the (unlabeled) patterns in the training set, \u039e, to the algorithm9.2. CLUSTERING METHODS\n121\nU11\nU12\nU21\nU22\nU23\nU31\nU32\nU11 F U12 = U1\nU21 F U22 F U23 = U2\nU31 F U32 = U3\nU1 F U2 F U3 = U\nFigure 9.2: A Hierarchy of Clusters\none-by-one. For each pattern, Xi, presented, we \ufb01nd that cluster seeker, Cj,\nthat is closest to Xi and move it closer to Xi:\nCj \u2190\n\u2212(1 \u2212\u03b1j)Cj + \u03b1jXi\nwhere \u03b1j is a learning rate parameter for the j-th cluster seeker; it determines\nhow far Cj is moved toward Xi.\nRe\ufb01nements on this procedure make the cluster seekers move less far as\ntraining proceeds. Suppose each cluster seeker, Cj, has a mass, mj, equal to\nthe number of times that it has moved. As a cluster seeker\u2019s mass increases it\nmoves less far towards a pattern. For example, we might set \u03b1j = 1/(1 + mj)\nand use the above rule together with mj \u2190\n\u2212mj +1. With this adjustment rule,\na cluster seeker is always at the center of gravity (sample mean) of the set of\npatterns toward which it has so far moved. Intuitively, if a cluster seeker ever\ngets within some reasonably well clustered set of patterns (and if that cluster\nseeker is the only one so located), it will converge to the center of gravity of\nthat cluster.122\nCHAPTER 9. UNSUPERVISED LEARNING\nU\nU2\nU11\nU12\nU31\nU32\nU21\nU22\nU23\nU1\nU3\nFigure 9.3: Displaying a Hierarchy as a Tree\nOnce the cluster seekers have converged, the classi\ufb01er implied by the now-\nlabeled patterns in \u039e can be based on a Voronoi partitioning of the space (based\non distances to the various cluster seekers). This kind of classi\ufb01cation, an ex-\nample of which is shown in Fig. 9.4, can be implemented by a linear machine.\nGeorgy Fedoseevich Voronoi, was a\nRussian mathematician who lived\nfrom 1868 to 1909.\nWhen basing partitioning on distance, we seek clusters whose patterns are\nas close together as possible. We can measure the badness, V , of a cluster of\npatterns, {Xi}, by computing its sample variance de\ufb01ned by:\nV = (1/K)\nX\ni\n(Xi \u2212M)2\nwhere M is the sample mean of the cluster, which is de\ufb01ned to be:\nM = (1/K)\nX\ni\nXi\nand K is the number of points in the cluster.\nWe would like to partition a set of patterns into clusters such that the sum of\nthe sample variances (badnesses) of these clusters is small. Of course if we have\none cluster for each pattern, the sample variances will all be zero, so we must\narrange that our measure of the badness of a partition must increase with the\nnumber of clusters. In this way, we can seek a trade-o\ufb00between the variances of9.2. CLUSTERING METHODS\n123\nC1\nC2\nC3\nSeparating boundaries\nFigure 9.4: Minimum-Distance Classi\ufb01cation\nthe clusters and the number of them in a way somewhat similar to the principle\nof minimal description length discussed earlier.\nElaborations of our basic cluster-seeking procedure allow the number of clus-\nter seekers to vary depending on the distances between them and depending on\nthe sample variances of the clusters. For example, if the distance, dij, between\ntwo cluster seekers, Ci and Cj, ever falls below some threshold \u03b5, then we can\nreplace them both by a single cluster seeker placed at their center of gravity\n(taking into account their respective masses). In this way we can decrease the\noverall badness of a partition by reducing the number of clusters for compara-\ntively little penalty in increased variance.\nOn the other hand, if any of the cluster seekers, say Ci, de\ufb01nes a cluster\nwhose sample variance is larger than some amount \u03b4, then we can place a new\ncluster seeker, Cj, at some random location somewhat adjacent to Ci and reset\nthe masses of both Ci and Cj to zero. In this way the badness of the par-\ntition might ultimately decrease by decreasing the total sample variance with\ncomparatively little penalty for the additional cluster seeker. The values of the\nparameters \u03b5 and \u03b4 are set depending on the relative weights given to sample\nvariances and numbers of clusters.\nIn distance-based methods, it is important to scale the components of the\npattern vectors. The variation of values along some dimensions of the pattern\nvector may be much di\ufb00erent than that of other dimensions. One commonly\nused technique is to compute the standard deviation (i.e., the square root of the\nvariance) of each of the components over the entire training set and normalize\nthe values of the components so that their adjusted standard deviations are\nequal.124\nCHAPTER 9. UNSUPERVISED LEARNING\n9.2.2\nA Method Based on Probabilities\nSuppose we have a partition of the training set, \u039e, into R mutually exclusive\nand exhaustive clusters, C1, . . . , CR. We can decide to which of these clusters\nsome arbitrary pattern, X, should be assigned by selecting the Ci for which\nthe probability, p(Ci|X), is largest, providing p(Ci|X) is larger than some \ufb01xed\nthreshold, \u03b4. As we saw earlier, we can use Bayes rule and base our decision on\nmaximizing p(X|Ci)p(Ci). Assuming conditional independence of the pattern\ncomponents, xi, the quantity to be maximized is:\nS(X, Ci) = p(x1|Ci)p(x2|Ci) \u00b7 \u00b7 \u00b7 p(xn|Ci)p(Ci)\nThe p(xj|Ci) can be estimated from the sample statistics of the patterns in the\nclusters and then used in the above expression. (Recall the linear form that this\nformula took in the case of binary-valued components.)\nWe call S(X, Ci) the similarity of X to a cluster, Ci, of patterns. Thus, we\nassign X to the cluster to which it is most similar, providing the similarity is\nlarger than \u03b4.\nJust as before, we can de\ufb01ne the sample mean of a cluster, Ci, to be:\nMi = (1/Ki)\nX\nXj\u03f5 Ci\nXj\nwhere Ki is the number of patterns in Ci.\nWe can base an iterative clustering algorithm on this measure of similarity\n[Mahadevan & Connell, 1992]. It can be described as follows:\na. Begin with a set of unlabeled patterns \u039e and an empty list, L, of clusters.\nb. For the next pattern, X, in \u039e, compute S(X, Ci) for each cluster, Ci.\n(Initially, these similarities are all zero.)\nSuppose the largest of these\nsimilarities is S(X, Cmax).\n(a) If S(X, Cmax) > \u03b4, assign X to Cmax. That is,\nCmax \u2190\n\u2212Cmax \u222a{X}\nUpdate the sample statistics p(x1|Cmax), p(x2|Cmax), . . . , p(xn|Cmax),\nand p(Cmax) to take the new pattern into account. Go to 3.\n(b) If S(X, Cmax) \u2264\u03b4, create a new cluster, Cnew = {X} and add Cnew\nto L. Go to 3.\nc. Merge any existing clusters, Ci and Cj if (Mi \u2212Mj)2 < \u03b5. Compute\nnew sample statistics p(x1|Cmerge), p(x2|Cmerge), . . . , p(xn|Cmerge), and\np(Cmerge) for the merged cluster, Cmerge = Ci \u222aCj.9.3. HIERARCHICAL CLUSTERING METHODS\n125\nd. If the sample statistics of the clusters have not changed during an entire\niteration through \u039e, then terminate with the clusters in L; otherwise go\nto 2.\nThe value of the parameter \u03b4 controls the number of clusters. If \u03b4 is high,\nthere will be a large number of clusters with few patterns in each cluster. For\nsmall values of \u03b4, there will be a small number of clusters with many patterns in\neach cluster. Similarly, the larger the value of \u03b5, the smaller the number clusters\nthat will be found.\nDesigning a classi\ufb01er based on the patterns labeled by the partitioning is\nstraightforward. We assign any pattern, X, to that category that maximizes\nS(X, Ci).\nMention \u201ck-means and \u201cEM\u201d\nmethods.\n9.3\nHierarchical Clustering Methods\n9.3.1\nA Method Based on Euclidean Distance\nSuppose we have a set, \u039e, of unlabeled training patterns. We can form a hi-\nerarchical classi\ufb01cation of the patterns in \u039e by a simple agglomerative method.\n(The description of this algorithm is based on an unpublished manuscript by\nPat Langley.) Our description here gives the general idea; we leave it to the\nreader to generate a precise algorithm.\nWe \ufb01rst compute the Euclidean distance between all pairs of patterns in \u039e.\n(Again, appropriate scaling of the dimensions is assumed.) Suppose the smallest\ndistance is between patterns Xi and Xj. We collect Xi and Xj into a cluster,\nC, eliminate Xi and Xj from \u039e and replace them by a cluster vector, C, equal\nto the average of Xi and Xj. Next we compute the Euclidean distance again\nbetween all pairs of points in \u039e. If the smallest distance is between pairs of\npatterns, we form a new cluster, C, as before and replace the pair of patterns\nin \u039e by their average. If the shortest distance is between a pattern, Xi, and\na cluster vector, Cj (representing a cluster, Cj), we form a new cluster, C,\nconsisting of the union of Cj and {Xi}. In this case, we replace Cj and Xi\nin \u039e by their (appropriately weighted) average and continue. If the shortest\ndistance is between two cluster vectors, Ci and Cj, we form a new cluster, C,\nconsisting of the union of Ci and Cj. In this case, we replace Ci and Cj by their\n(appropriately weighted) average and continue. Since we reduce the number of\npoints in \u039e by one each time, we ultimately terminate with a tree of clusters\nrooted in the cluster containing all of the points in the original training set.\nAn example of how this method aggregates a set of two dimensional patterns\nis shown in Fig. 9.5. The numbers associated with each cluster indicate the order\nin which they were formed. These clusters can be organized hierarchically in a\nbinary tree with cluster 9 as root, clusters 7 and 8 as the two descendants of the\nroot, and so on. A ternary tree could be formed instead if one searches for the\nthree points in \u039e whose triangle de\ufb01ned by those patterns has minimal area.126\nCHAPTER 9. UNSUPERVISED LEARNING\n1\n2\n3\n5\n4\n6\n7\n8\n9\nFigure 9.5: Agglommerative Clustering\n9.3.2\nA Method Based on Probabilities\nA probabilistic quality measure for partitions\nWe can develop a measure of the goodness of a partitioning based on how\naccurately we can guess a pattern given only what partition it is in. Suppose\nwe are given a partitioning of \u039e into R classes, C1, . . . , CR. As before, we can\ncompute the sample statistics p(xi|Ck) which give probability values for each\ncomponent given the class assigned to it by the partitioning.\nSuppose each\ncomponent xi of X can take on the values vij, where the index j steps over the\ndomain of that component. We use the notation pi(vij|Ck) = probability(xi =\nvij|Ck).\nSuppose we use the following probabilistic guessing rule about the values\nof the components of a vector X given only that it is in class k. Guess that\nxi = vij with probability pi(vij|Ck). Then, the probability that we guess the\ni-th component correctly is:\nX\nj\nprobability(guess is vij)pi(vij|Ck) =\nX\nj\n[pi(vij|Ck)]2\nThe average number of (the n) components whose values are guessed correctly\nby this method is then given by the sum of these probabilities over all of the\ncomponents of X:\nX\ni\nX\nj\n[pi(vij|Ck)]29.3. HIERARCHICAL CLUSTERING METHODS\n127\nGiven our partitioning into R classes, the goodness measure, G, of this parti-\ntioning is the average of the above expression over all classes:\nG =\nX\nk\np(Ck)\nX\ni\nX\nj\n[pi(vij|Ck)]2\nwhere p(Ck) is the probability that a pattern is in class Ck. In order to penalize\nthis measure for having a large number of classes, we divide it by R to get an\noverall \u201cquality\u201d measure of a partitioning:\nZ = (1/R)\nX\nk\np(Ck)\nX\ni\nX\nj\n[pi(vij|Ck)]2\nWe give an example of the use of this measure for a trivially simple\nclustering of the four three-dimensional patterns shown in Fig.\n9.6.\nThere\nare several di\ufb00erent partitionings.\nLet\u2019s evaluate Z values for the follow-\ning ones: P1 = {a, b, c, d}, P2 = {{a, b}, {c, d}}, P3 = {{a, c}, {b, d}}, and\nP4 = {{a}, {b}, {c}, {d}}. The \ufb01rst, P1, puts all of the patterns into a single\ncluster. The sample probabilities pi(vi1 = 1) and pi(vi0 = 0) are all equal to 1/2\nfor each of the three components. Summing over the values of the components\n(0 and 1) gives (1/2)2 + (1/2)2 = 1/2. Summing over the three components\ngives 3/2. Averaging over all of the clusters (there is just one) also gives 3/2.\nFinally, dividing by the number of clusters produces the \ufb01nal Z value of this\npartition, Z(P1) = 3/2.\nThe second partition, P2, gives the following sample probabilities:\np1(v11 = 1|C1) = 1\np2(v21 = 1|C1) = 1/2\np3(v31 = 1|C1) = 1\nSumming over the values of the components (0 and 1) gives (1)2 + (0)2 = 1 for\ncomponent 1, (1/2)2 + (1/2)2 = 1/2 for component 2, and (1)2 + (0)2 = 1 for\ncomponent 3. Summing over the three components gives 2 1/2 for class 1. A\nsimilar calculation also gives 2 1/2 for class 2. Averaging over the two clusters\nalso gives 2 1/2. Finally, dividing by the number of clusters produces the \ufb01nal\nZ value of this partition, Z(P2) = 1 1/4, not quite as high as Z(P1).\nSimilar calculations yield Z(P3) = 1 and Z(P4) = 3/4, so this method of\nevaluating partitions would favor placing all patterns in a single cluster.128\nCHAPTER 9. UNSUPERVISED LEARNING\nx2\nx3\nx1\na\nb\nc\nd\nFigure 9.6: Patterns in 3-Dimensional Space\nAn iterative method for hierarchical clustering\nEvaluating all partitionings of m patterns and then selecting the best would be\ncomputationally intractable. The following iterative method is based on a hi-\nerarchical clustering procedure called COBWEB [Fisher, 1987]. The procedure\ngrows a tree each node of which is labeled by a set of patterns. At the end\nof the process, the root node contains all of the patterns in \u039e. The successors\nof the root node will contain mutually exclusive and exhaustive subsets of \u039e.\nIn general, the successors of a node, \u03b7, are labeled by mutually exclusive and\nexhaustive subsets of the pattern set labelling node \u03b7. The tips of the tree will\ncontain singleton sets. The method uses Z values to place patterns at the vari-\nous nodes; sample statistics are used to update the Z values whenever a pattern\nis placed at a node. The algorithm is as follows:\na. We start with a tree whose root node contains all of the patterns in \u039e\nand a single empty successor node. We arrange that at all times dur-\ning the process every non-empty node in the tree has (besides any other\nsuccessors) exactly one empty successor.\nb. Select a pattern Xi in \u039e (if there are no more patterns to select, terminate).\nc. Set \u00b5 to the root node.\nd. For each of the successors of \u00b5 (including the empty successor!), calculate\nthe best host for Xi. A best host is determined by tentatively placing\nXi in one of the successors and calculating the resulting Z value for each9.3. HIERARCHICAL CLUSTERING METHODS\n129\none of these ways of accomodating Xi. The best host corresponds to the\nassignment with the highest Z value.\ne. If the best host is an empty node, \u03b7, we place Xi in \u03b7, generate an empty\nsuccessor node of \u03b7, generate an empty sibling node of \u03b7, and go to 2.\nf. If the best host is a non-empty, singleton (tip) node, \u03b7, we place Xi in \u03b7,\ncreate one successor node of \u03b7 containing the singleton pattern that was\nin \u03b7, create another successor node of \u03b7 containing Xi, create an empty\nsuccessor node of \u03b7, create empty successor nodes of the new non-empty\nsuccessors of \u03b7, and go to 2.\ng. If the best host is a non-empty, non-singleton node, \u03b7, we place Xi in \u03b7,\nset \u00b5 to \u03b7, and go to 4.\nThis process is rather sensitive to the order in which patterns are presented.\nTo make the \ufb01nal classi\ufb01cation tree less order dependent, the COBWEB proce-\ndure incorporates node merging and splitting.\nNode merging:\nIt may happen that two nodes having the same parent could be merged with\nan overall increase in the quality of the resulting classi\ufb01cation performed by the\nsuccessors of that parent. Rather than try all pairs to merge, a good heuristic\nis to attempt to merge the two best hosts. When such a merging improves the\nZ value, a new node containing the union of the patterns in the merged nodes\nreplaces the merged nodes, and the two nodes that were merged are installed\nas successors of the new node.\nNode splitting:\nA heuristic for node splitting is to consider replacing the best host among a\ngroup of siblings by that host\u2019s successors. This operation is performed only if\nit increases the Z value of the classi\ufb01cation performed by a group of siblings.\nExample results from COBWEB\nWe mention two experiments with COBWEB. In the \ufb01rst, the program at-\ntempted to \ufb01nd two categories (we will call them Class 1 and Class 2) of United\nStates Senators based on their votes (yes or no) on six issues. After the clus-\nters were established, the majority vote in each class was computed. These are\nshown in the table below.\nIssue\nClass 1\nClass 2\nToxic Waste\nyes\nno\nBudget Cuts\nyes\nno\nSDI Reduction\nno\nyes\nContra Aid\nyes\nno\nLine-Item Veto\nyes\nno\nMX Production\nyes\nno130\nCHAPTER 9. UNSUPERVISED LEARNING\nIn the second experiment, the program attempted to classify soybean dis-\neases based on various characteristics. COBWEB grouped the diseases in the\ntaxonomy shown in Fig. 9.7.\nN0\nsoybean\ndiseases\nN1\n  Diaporthe\nStem Canker\nN2\nCharcoal\n     Rot\nN3\nN31\nRhizoctonia\n       Rot\nN32\nPhytophthora\n       Rot\nFigure 9.7: Taxonomy Induced for Soybean Diseases\n9.4\nBibliographical and Historical Remarks\nTo be added.", "10": "Chapter 10\nTemporal-Di\ufb00erence\nLearning\n10.1\nTemporal Patterns and Prediction Prob-\nlems\nIn this chapter, we consider problems in which we wish to learn to predict the\nfuture value of some quantity, say z, from an n-dimensional input pattern, X.\nIn many of these problems, the patterns occur in temporal sequence, X1, X2,\n.\n.\n., Xi, Xi+1, . . ., Xm, and are generated by a dynamical process.\nThe\ncomponents of Xi are features whose values are available at time, t = i. We\ndistinguish two kinds of prediction problems. In one, we desire to predict the\nvalue of z at time t = i + 1 based on input Xi for every i. For example, we\nmight wish to predict some aspects of tomorrow\u2019s weather based on a set of\nmeasurements made today. In the other kind of prediction problem, we desire\nto make a sequence of predictions about the value of z at some \ufb01xed time, say\nt = m + 1, based on each of the Xi, i = 1, . . . , m. For example, we might wish\nto make a series of predictions about some aspect of the weather on next New\nYear\u2019s Day, based on measurements taken every day before New Year\u2019s. Sutton\n[Sutton, 1988] has called this latter problem, multi-step prediction, and that is\nthe problem we consider here. In multi-step prediction, we might expect that\nthe prediction accuracy should get better and better as i increases toward m.\n10.2\nSupervised and Temporal-Di\ufb00erence Meth-\nods\nA training method that naturally suggests itself is to use the actual value of\nz at time m + 1 (once it is known) in a supervised learning procedure using a\n131132\nCHAPTER 10. TEMPORAL-DIFFERENCE LEARNING\nsequence of training patterns, {X1, X2, . . ., Xi, Xi+1, . . ., Xm}. That is, we\nseek to learn a function, f, such that f(Xi) is as close as possible to z for each i.\nTypically, we would need a training set, \u039e, consisting of several such sequences.\nWe will show that a method that is better than supervised learning for some\nimportant problems is to base learning on the di\ufb00erence between f(Xi+1) and\nf(Xi) rather than on the di\ufb00erence between z and f(Xi). Such methods involve\nwhat is called temporal-di\ufb00erence (TD) learning.\nWe assume that our prediction, f(X), depends on a vector of modi\ufb01able\nweights, W. To make that dependence explicit, we write f(X, W).\nFor su-\npervised learning, we consider procedures of the following type: For each Xi,\nthe prediction f(Xi, W) is computed and compared to z, and the learning rule\n(whatever it is) computes the change, (\u2206Wi), to be made to W. Then, taking\ninto account the weight changes for each pattern in a sequence all at once after\nhaving made all of the predictions with the old weight vector, we change W as\nfollows:\nW \u2190\n\u2212W +\nm\nX\ni=1\n(\u2206W)i\nWhenever we are attempting to minimize the squared error between z and\nf(Xi, W) by gradient descent, the weight-changing rule for each pattern is:\n(\u2206W)i = c(z \u2212fi) \u2202fi\n\u2202W\nwhere c is a learning rate parameter, fi is our prediction of z, f(Xi, W),\nat time t = i, and\n\u2202fi\n\u2202W is, by de\ufb01nition, the vector of partial derivatives\n( \u2202fi\n\u2202w1 , . . . , \u2202fi\n\u2202wi , . . . , \u2202fi\n\u2202wn ) in which the wi are the individual components of W.\n(The expression\n\u2202fi\n\u2202W is sometimes written \u2207Wfi.) The reader will recall that\nwe used an equivalent expression for (\u2206W)i in deriving the backpropagation\nformulas used in training multi-layer neural networks.\nThe Widrow-Ho\ufb00rule results when f(X, W) = X \u2022 W. Then:\n(\u2206W)i = c(z \u2212fi)Xi\nAn interesting form for (\u2206W)i can be developed if we note that\n(z \u2212fi) =\nm\nX\nk=i\n(fk+1 \u2212fk)\nwhere we de\ufb01ne fm+1 = z. Substituting in our formula for (\u2206W)i yields:\n(\u2206W)i = c(z \u2212fi) \u2202fi\n\u2202W10.2. SUPERVISED AND TEMPORAL-DIFFERENCE METHODS\n133\n= c \u2202fi\n\u2202W\nm\nX\nk=i\n(fk+1 \u2212fk)\nIn this form, instead of using the di\ufb00erence between a prediction and the value\nof z, we use the di\ufb00erences between successive predictions\u2014thus the phrase\ntemporal-di\ufb00erence (TD) learning.\nIn the case when f(X, W) = X \u2022 W, the temporal di\ufb00erence form of the\nWidrow-Ho\ufb00rule is:\n(\u2206W)i = cXi\nm\nX\nk=i\n(fk+1 \u2212fk)\nOne reason for writing (\u2206W)i in temporal-di\ufb00erence form is to permit an\ninteresting generalization as follows:\n(\u2206W)i = c \u2202fi\n\u2202W\nm\nX\nk=i\n\u03bb(k\u2212i)(fk+1 \u2212fk)\nwhere 0 < \u03bb \u22641. Here, the \u03bb term gives exponentially decreasing weight to\ndi\ufb00erences later in time than t = i. When \u03bb = 1, we have the same rule with\nwhich we began\u2014weighting all di\ufb00erences equally, but as \u03bb \u21920, we weight only\nthe (fi+1 \u2212fi) di\ufb00erence. With the \u03bb term, the method is called TD(\u03bb).\nIt is interesting to compare the two extreme cases:\nFor TD(0):\n(\u2206W)i = c(fi+1 \u2212fi) \u2202fi\n\u2202W\nFor TD(1):\n(\u2206W)i = c(z \u2212fi) \u2202fi\n\u2202W\nBoth extremes can be handled by the same learning mechanism; only the error\nterm is di\ufb00erent. In TD(0), the error is the di\ufb00erence between successive predic-\ntions, and in TD(1), the error is the di\ufb00erence between the \ufb01nally revealed value\nof z and the prediction. Intermediate values of \u03bb take into account di\ufb00erently\nweighted di\ufb00erences between future pairs of successive predictions.\nOnly TD(1) can be considered a pure supervised learning procedure, sensitive\nto the \ufb01nal value of z provided by the teacher. For \u03bb < 1, we have various degrees\nof unsupervised learning, in which the prediction function strives to make each\nprediction more like successive ones (whatever they might be). We shall soon\nsee that these unsupervised procedures result in better learning than do the\nsupervised ones for an important class of problems.134\nCHAPTER 10. TEMPORAL-DIFFERENCE LEARNING\n10.3\nIncremental Computation of the (\u2206W)i\nWe can rewrite our formula for (\u2206W)i, namely\n(\u2206W)i = c \u2202fi\n\u2202W\nm\nX\nk=i\n\u03bb(k\u2212i)(fk+1 \u2212fk)\nto allow a type of incremental computation. First we write the expression for\nthe weight change rule that takes into account all of the (\u2206W)i:\nW \u2190\n\u2212W +\nm\nX\ni=1\nc \u2202fi\n\u2202W\nm\nX\nk=i\n\u03bb(k\u2212i)(fk+1 \u2212fk)\nInterchanging the order of the summations yields:\nW \u2190\n\u2212W +\nm\nX\nk=1\nc\nk\nX\ni=1\n\u03bb(k\u2212i)(fk+1 \u2212fk) \u2202fi\n\u2202W\n= W +\nm\nX\nk=1\nc(fk+1 \u2212fk)\nk\nX\ni=1\n\u03bb(k\u2212i) \u2202fi\n\u2202W\nInterchanging the indices k and i \ufb01nally yields:\nW \u2190\n\u2212W +\nm\nX\ni=1\nc(fi+1 \u2212fi)\ni\nX\nk=1\n\u03bb(i\u2212k) \u2202fk\n\u2202W\nIf, as earlier, we want to use an expression of the form W \u2190\n\u2212W+Pm\ni=1(\u2206W)i,\nwe see that we can write:\n(\u2206W)i = c(fi+1 \u2212fi)\ni\nX\nk=1\n\u03bb(i\u2212k) \u2202fk\n\u2202W\nNow, if we let ei = Pi\nk=1 \u03bb(i\u2212k) \u2202fk\n\u2202W, we can develop a computationally e\ufb03cient\nrecurrence equation for ei+1 as follows:\nei+1 =\ni+1\nX\nk=1\n\u03bb(i+1\u2212k) \u2202fk\n\u2202W\n= \u2202fi+1\n\u2202W +\ni\nX\nk=1\n\u03bb(i+1\u2212k) \u2202fk\n\u2202W10.4. AN EXPERIMENT WITH TD METHODS\n135\n= \u2202fi+1\n\u2202W + \u03bbei\nRewriting (\u2206W)i in these terms, we obtain:\n(\u2206W)i = c(fi+1 \u2212fi)ei\nwhere:\ne1 = \u2202f1\n\u2202W\ne2 = \u2202f2\n\u2202W + \u03bbe1\netc.\nQuoting Sutton [Sutton, 1988, page 15] (about a di\ufb00erent equation, but the\nquote applies equally well to this one):\n\u201c. . . this equation can be computed incrementally, because each\n(\u2206W)i depends only on a pair of successive predictions and on the\n[weighted] sum of all past values for \u2202fi\n\u2202W. This saves substantially on\nmemory, because it is no longer necessary to individually remember\nall past values of\n\u2202fi\n\u2202W.\u201d\n10.4\nAn Experiment with TD Methods\nTD prediction methods [especially TD(0)] are well suited to situations in which\nthe patterns are generated by a dynamic process. In that case, sequences of\ntemporally presented patterns contain important information that is ignored\nby a conventional supervised method such as the Widrow-Ho\ufb00rule.\nSutton\n[Sutton, 1988, page 19] gives an interesting example involving a random walk,\nwhich we repeat here. In Fig. 10.1, sequences of vectors, X, are generated as\nfollows: We start with vector XD; the next vector in the sequence is equally\nlikely to be one of the adjacent vectors in the diagram. If the next vector is\nXC (or XE), the next one after that is equally likely to be one of the vectors\nadjacent to XC (or XE). When XB is in the sequence, it is equally likely that\nthe sequence terminates with z = 0 or that the next vector is XC. Similarly,\nwhen XF is in the sequence, it is equally likely that the sequence terminates\nwith z = 1 or that the next vector is XE. Thus the sequences are random, but\nthey always start with XD. Some sample sequences are shown in the \ufb01gure.136\nCHAPTER 10. TEMPORAL-DIFFERENCE LEARNING\n1\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n1\nz = 0\nz = 1\nXB\nXC\nXD\nXE\nXF\nTypical Sequences:\nXDXCXDXEXF  1\nXDXCXBXCXDXEXDXEXF  1\nXDXEXDXCXB  0\nFigure 10.1: A Markov Process\nThis random walk is an example of a Markov process; transitions from state i\nto state j occur with probabilities that depend only on i and j.\nGiven a set of sequences generated by this process as a training set, we want\nto be able to predict the value of z for each X in a test sequence. We assume\nthat the learning system does not know the transition probabilities.\nFor his experiments with this process, Sutton used a linear predictor, that\nis f(X, W) = X \u2022 W. The learning problem is to \ufb01nd a weight vector, W, that\nminimizes the mean-squared error between z and the predicted value of z. Given\nthe \ufb01ve di\ufb00erent values that X can take on, we have the following predictions:\nf(XB) = w1, f(XC) = w2, f(XD) = w3, f(XE) = w4, f(XF ) = w5, where\nwi is the i-th component of the weight vector. (Note that the values of the\npredictions are not limited to 1 or 0\u2014even though z can only have one of\nthose values\u2014because we are minimizing mean-squared error.) After training,\nthese predictions will be compared with the optimal ones\u2014given the transition\nprobabilities.\nThe experimental setup was as follows: ten random sequences were generated\nusing the transition probabilities. Each of these sequences was presented in turn\nto a TD(\u03bb) method for various values of \u03bb. Weight vector increments, (\u2206W)i,\nwere computed after each pattern presentation but no weight changes were\nmade until all ten sequences were presented. The weight vector increments were\nsummed after all ten sequences were presented, and this sum was used to change\nthe weight vector to be used for the next pass through the ten sequences. This\nprocess was repeated over and over (using the same training sequences) until\n(quoting Sutton) \u201cthe procedure no longer produced any signi\ufb01cant changes in\nthe weight vector. For small c, the weight vector always converged in this way,10.4. AN EXPERIMENT WITH TD METHODS\n137\nand always to the same \ufb01nal value [for 100 di\ufb00erent training sets of ten random\nsequences], independent of its initial value.\u201d (Even though, for \ufb01xed, small c,\nthe weight vector always converged to the same vector, it might converge to a\nsomewhat di\ufb00erent vector for di\ufb00erent values of c.)\nAfter convergence, the predictions made by the \ufb01nal weight vector are com-\npared with the optimal predictions made using the transition probabilities.\nThese optimal predictions are simply p(z = 1|X). We can compute these proba-\nbilities to be 1/6, 1/3, 1/2, 2/3, and 5/6 for XB, XC, XD, XE, XF , respectively.\nThe root-mean-squared di\ufb00erences between the best learned predictions (over\nall c) and these optimal ones are plotted in Fig. 10.2 for seven di\ufb00erent values\nof \u03bb. (For each data point, the standard error is approximately \u03c3 = 0.01.)\n0.10\n0.12\n0.14\n0.16\n0.18\n0.20\n0.0 0.1\n0.3\n0.5\n0.7\n0.9 1.0\nh\nError using\nbest c\nWidrow-Hoff\nTD(1)\nTD(0)\n(Adapted from Sutton, p. 20, 1988)\nFigure 10.2: Prediction Errors for TD(\u03bb)\nNotice that the Widrow-Ho\ufb00procedure does not perform as well as other\nversions of TD(\u03bb) for \u03bb < 1! Quoting [Sutton, 1988, page 21]:\n\u201cThis result contradicts conventional wisdom. It is well known that,\nunder repeated presentations, the Widrow-Ho\ufb00procedure minimizes\nthe RMS error between its predictions and the actual outcomes in\nthe training set ([Widrow & Stearns, 1985]). How can it be that this\noptimal method peformed worse than all the TD methods for \u03bb <\n1? The answer is that the Widrow-Ho\ufb00procedure only minimizes\nerror on the training set; it does not necessarily minimize error for\nfuture experience. [Later] we prove that in fact it is linear TD(0)\nthat converges to what can be considered the optimal estimates for138\nCHAPTER 10. TEMPORAL-DIFFERENCE LEARNING\nmatching future experience\u2014those consistent with the maximum-\nlikelihood estimate of the underlying Markov process.\u201d\n10.5\nTheoretical Results\nIt is possible to analyze the performance of the linear-prediction TD(\u03bb) methods\non Markov processes. We state some theorems here without proof.\nTheorem 10.1 (Sutton, page 24, 1988) For any absorbing Markov chain,\nand for any linearly independent set of observation vectors {Xi} for the non-\nterminal states, there exists an \u03b5 > 0 such that for all positive c < \u03b5 and for any\ninitial weight vector, the predictions of linear TD(0) (with weight updates after\neach sequence) converge in expected value to the optimal (maximum likelihood)\npredictions of the true process.\nEven though the expected values of the predictions converge, the predictions\nthemselves do not converge but vary around their expected values depending on\ntheir most recent experience. Sutton conjectures that if c is made to approach\n0 as training progresses, the variance of the predictions will approach 0 also.\nDayan [Dayan, 1992] has extended the result of Theorem 9.1 to TD(\u03bb) for\narbitrary \u03bb between 0 and 1. (Also see [Dayan & Sejnowski, 1994].)\n10.6\nIntra-Sequence Weight Updating\nOur standard weight updating rule for TD(\u03bb) methods is:\nW \u2190\n\u2212W +\nm\nX\ni=1\nc(fi+1 \u2212fi)\ni\nX\nk=1\n\u03bb(i\u2212k) \u2202fk\n\u2202W\nwhere the weight update occurs after an entire sequence is observed. To make\nthe method truly incremental (in analogy with weight updating rules for neural\nnets), it would be desirable to change the weight vector after every pattern\npresentation. The obvious extension is:\nWi+1 \u2190\n\u2212Wi + c(fi+1 \u2212fi)\ni\nX\nk=1\n\u03bb(i\u2212k) \u2202fk\n\u2202W\nwhere fi+1 is computed before making the weight change; that is, fi+1 =\nf(Xi+1, Wi). But that would make fi = f(Xi, Wi\u22121), and such a rule would\nmake the prediction di\ufb00erence, namely (fi+1 \u2212fi), sensitive both to changes in\nX and changes in W and could lead to instabilities. Instead, we modify the rule\nso that, for every pair of predictions, fi+1 = f(Xi+1, Wi) and fi = f(Xi, Wi).\nThis version of the rule has been used in practice with excellent results.10.6. INTRA-SEQUENCE WEIGHT UPDATING\n139\nFor TD(0) and linear predictors, the rule is:\nWi+1 = Wi + c(fi+1 \u2212fi)Xi\nThe rule is implemented as follows:\na. Initialize the weight vector, W, arbitrarily.\nb. For i = 1, ..., m, do:\n(a) fi \u2190\n\u2212Xi \u2022 W\n(We compute fi anew each time through rather than use the value\nof fi+1 the previous time through.)\n(b) fi+1 \u2190\n\u2212Xi+1 \u2022 W\n(c) di+1 \u2190\n\u2212fi+1 \u2212fi\n(d) W \u2190\n\u2212W + c di+1Xi\n(If fi were computed again with this changed weight vector, its value\nwould be closer to fi+1 as desired.)\nThe linear TD(0) method can be regarded as a technique for training a\nvery simple network consisting of a single dot product unit (and no threshold\nor sigmoid function). TD methods can also be used in combination with back-\npropagation to train neural networks. For TD(0) we change the network weights\naccording to the expression:\nWi+1 = Wi + c(fi+1 \u2212fi) \u2202fi\n\u2202W\nThe only change that must be made to the standard backpropagation weight-\nchanging rule is that the di\ufb00erence term between the desired output and the\noutput of the unit in the \ufb01nal (k-th) layer, namely (d \u2212f (k)), must be replaced\nby a di\ufb00erence term between successive outputs, (fi+1 \u2212fi). This change has a\ndirect e\ufb00ect only on the expression for \u03b4(k) which becomes:\n\u03b4(k) = 2(f \u2032(k) \u2212f (k))f (k)(1 \u2212f (k))\nwhere f \u2032(k) and f (k) are two successive outputs of the network.\nThe weight changing rule for the i-th weight vector in the j-th layer of weights\nhas the same form as before, namely:\nW(j)\ni\n\u2190\n\u2212W(j)\ni\n+ c\u03b4(j)\ni\nX(j\u22121)\nwhere the \u03b4(j)\ni\nare given recursively by:\n\u03b4(j)\ni\n= f (j)\ni\n(1 \u2212f (j)\ni\n)\nmj+1\nX\nl=1\n\u03b4(j+1)\nl\nw(j+1)\nil\nand w(j+1)\nil\nis the l-th component of the i-th weight vector in the (j +1)-th layer\nof weights. Of course, here also it is assumed that f \u2032(k) and f (k) are computed\nusing the same weights and then the weights are changed. In the next section\nwe shall see an interesting example of this application of TD learning.140\nCHAPTER 10. TEMPORAL-DIFFERENCE LEARNING\n10.7\nAn Example Application: TD-gammon\nA program called TD-gammon [Tesauro, 1992] learns to play backgammon by\ntraining a neural network via temporal-di\ufb00erence methods. The structure of\nthe neural net, and its coding is as shown in Fig. 10.3. The network is trained\nto minimize the error between actual payo\ufb00and estimated payo\ufb00, where the\nactual payo\ufb00is de\ufb01ned to be df = p1 + 2p2 \u2212p3 \u22122p4, and the pi are the actual\nprobabilities of the various outcomes as de\ufb01ned in the \ufb01gure.\n. . .\np3 = pr(black wins)\np4 = pr(black gammons)\np1 = pr(white wins)\np2 = pr(white gammons)\nestimated payoff:\nd = p1 + 2p2 < p3 < 2p4\nno. of white\non cell 1\nno. on bar,\noff board,\nand who\nmoves\n198 inputs\n1\n2\n3\n# > 3\n. . .\nup to 40 hidden units\n2 x 24\ncells\n4 output units\nhidden and output units are sigmoids\nlearning rate:  c = 0.1; initial weights chosen\nrandomly between <0.5 and +0.5.\nestimated probabilities:\nFigure 10.3: The TD-gammon Network\nTD-gammon learned by using the network to select that move that results\nin the best predicted payo\ufb00. That is, at any stage of the game some \ufb01nite set of\nmoves is possible and these lead to the set, {X}, of new board positions. Each\nmember of this set is evaluated by the network, and the one with the largest10.8. BIBLIOGRAPHICAL AND HISTORICAL REMARKS\n141\npredicted payo\ufb00is selected if it is white\u2019s move (and the smallest if it is black\u2019s).\nThe move is made, and the network weights are adjusted to make the predicted\npayo\ufb00from the original position closer to that of the resulting position.\nThe weight adjustment procedure combines temporal-di\ufb00erence (TD(\u03bb))\nlearning with backpropagation.\nIf dt is the network\u2019s estimate of the payo\ufb00\nat time t (before a move is made), and dt+1 is the estimate at time t + 1 (after\na move is made), the weight adjustment rule is:\n\u2206Wt = c(dt+1 \u2212dt)\nt\nX\nk=1\n\u03bbt\u2212k \u2202dk\n\u2202W\nwhere Wt is a vector of all weights in the network at time t, and\n\u2202dk\n\u2202W is the\ngradient of dk in this weight space. (For a layered, feedforward network, such\nas that of TD-gammon, the weight changes for the weight vectors in each layer\ncan be expressed in the usual manner.)\nTo make the special cases clear, recall that for TD(0), the network would be\ntrained so that, for all t, its output, dt, for input Xt tended toward its expected\noutput, dt+1, for input Xt+1. For TD(1), the network would be trained so that,\nfor all t, its output, dt, for input Xt tended toward the expected \ufb01nal payo\ufb00,\ndf, given that input. The latter case is the same as the Widrow-Ho\ufb00rule.\nAfter about 200,000 games the following results were obtained. TD-gammon\n(with 40 hidden units, \u03bb = 0.7, and c = 0.1) won 66.2% of 10,000 games against\nSUN Microsystems Gammontool and 55% of 10,000 games against a neural\nnetwork trained using expert moves. Commenting on a later version of TD-\ngammon, incorporating special features as inputs, Tesauro said: \u201cIt appears to\nbe the strongest program ever seen by this author.\u201d\n10.8\nBibliographical and Historical Remarks\nTo be added.142\nCHAPTER 10. TEMPORAL-DIFFERENCE LEARNING", "11": "Chapter 11\nDelayed-Reinforcement\nLearning\n11.1\nThe General Problem\nImagine a robot that exists in an environment in which it can sense and act.\nSuppose (as an extreme case) that it has no idea about the e\ufb00ects of its actions.\nThat is, it doesn\u2019t know how acting will change its sensory inputs. Along with\nits sensory inputs are \u201crewards,\u201d which it occasionally receives. How should it\nchoose its actions so as to maximize its rewards over the long run? To maximize\nrewards, it will need to be able to predict how actions change inputs, and in\nparticular, how actions lead to rewards.\nWe formalize the problem in the following way: The robot exists in an\nenvironment consisting of a set, S, of states. We assume that the robot\u2019s sensory\napparatus constructs an input vector, X, from the environment, which informs\nthe robot about which state the environment is in. For the moment, we will\nassume that the mapping from states to vectors is one-to-one, and, in fact, will\nuse the notation X to refer to the state of the environment as well as to the\ninput vector. When presented with an input vector, the robot decides which\naction from a set, A, of actions to perform. Performing the action produces an\ne\ufb00ect on the environment\u2014moving it to a new state. The new state results in\nthe robot perceiving a new input vector, and the cycle repeats. We assume a\ndiscrete time model; the input vector at time t = i is Xi, the action taken at\nthat time is ai, and the expected reward, ri, received at t = i depends on the\naction taken and on the state, that is ri = r(Xi, ai). The learner\u2019s goal is to \ufb01nd\na policy, \u03c0(X), that maps input vectors to actions in such a way that maximizes\nrewards accumulated over time. This type of learning is called reinforcement\nlearning. The learner must \ufb01nd the policy by trial and error; it has no initial\nknowledge of the e\ufb00ects of its actions. The situation is as shown in Fig. 11.1.\n143144\nCHAPTER 11. DELAYED-REINFORCEMENT LEARNING\nXi\nri\nLearner\nEnvironment\n(reward)\n(state)\n(action)\nai\nFigure 11.1: Reinforcement Learning\n11.2\nAn Example\nA \u201cgrid world,\u201d such as the one shown in Fig. 11.2 is often used to illustrate\nreinforcement learning. Imagine a robot initially in cell (2,3). The robot receives\ninput vector (x1, x2) telling it what cell it is in; it is capable of four actions,\nn, e, s, w moving the robot one cell up, right, down, or left, respectively. It is\nrewarded one negative unit whenever it bumps into the wall or into the blocked\ncells. For example, if the input to the robot is (1,3), and the robot chooses\naction w, the next input to the robot is still (1,3) and it receives a reward of\n\u22121. If the robot lands in the cell marked G (for goal), it receives a reward of\n+10. Let\u2019s suppose that whenever the robot lands in the goal cell and gets its\nreward, it is immediately transported out to some random cell, and the quest\nfor reward continues.\nA policy for our robot is a speci\ufb01cation of what action to take for every one\nof its inputs, that is, for every one of the cells in the grid. For example, a com-\nponent of such a policy would be \u201cwhen in cell (3,1), move right.\u201d An optimal\npolicy is a policy that maximizes long-term reward. One way of displaying a\npolicy for our grid-world robot is by an arrow in each cell indicating the direc-\ntion the robot should move when in that cell. In Fig. 11.3, we show an optimal\npolicy displayed in this manner. In this chapter we will describe methods for\nlearning optimal policies based on reward values received by the learner.11.3. TEMPORAL DISCOUNTING AND OPTIMAL POLICIES\n145\nR\nG\n1 2 3 4\n5 6 7\n1\n2\n3\n4\n5\n6\n7\n8\nFigure 11.2: A Grid World\n11.3\nTemporal Discounting and Optimal Poli-\ncies\nIn delayed reinforcement learning, one often assumes that rewards in the distant\nfuture are not as valuable as are more immediate rewards. This preference can\nbe accomodated by a temporal discount factor, 0 \u2264\u03b3 < 1. The present value of\na reward, ri, occuring i time units in the future, is taken to be \u03b3iri. Suppose\nwe have a policy \u03c0(X) that maps input vectors into actions, and let r\u03c0(X)\ni\nbe\nthe reward that will be received on the i-th time step after one begins executing\npolicy \u03c0 starting in state X. Then the total reward accumulated over all time\nsteps by policy \u03c0 beginning in state X is:\nV \u03c0(X) =\n\u221e\nX\ni=0\n\u03b3ir\u03c0(X)\ni\nOne reason for using a temporal discount factor is so that the above sum will\nbe \ufb01nite. An optimal policy is one that maximizes V \u03c0(X) for all inputs, X.\nIn general, we want to consider the case in which the rewards, ri, are random\nvariables and in which the e\ufb00ects of actions on environmental states are random.\nIn Markovian environments, for example, the probability that action a in state\nXi will lead to state Xj is given by a transition probability p[Xj|Xi, a]. Then,\nwe will want to maximize expected future reward and would de\ufb01ne V \u03c0(X) as:\nV \u03c0(X) = E\n\" \u221e\nX\ni=0\n\u03b3ir\u03c0(X)\ni\n#\nIn either case, we call V \u03c0(X) the value of policy \u03c0 for input X.146\nCHAPTER 11. DELAYED-REINFORCEMENT LEARNING\nR\nG\n1 2 3 4\n5 6 7\n1\n2\n3\n4\n5\n6\n7\n8\nFigure 11.3: An Optimal Policy in the Grid World\nIf the action prescribed by \u03c0 taken in state X leads to state X\u2032 (randomly\naccording to the transition probabilities), then we can write V \u03c0(X) in terms of\nV \u03c0(X\u2032) as follows:\nV \u03c0(X) = r[X, \u03c0(X)] + \u03b3\nX\nX\u2032\np[X\u2032|X, \u03c0(X)]V \u03c0(X\u2032)\nwhere (in summary):\n\u03b3 = the discount factor,\nV \u03c0(X) = the value of state X under policy \u03c0,\nr[X, \u03c0(X)] = the expected immediate reward received when we execute the\naction prescribed by \u03c0 in state X, and\np[X\u2032|X, \u03c0(X)] = the probability that the environment transitions to state\nX\u2032 when we execute the action prescribed by \u03c0 in state X.\nIn other words, the value of state X under policy \u03c0 is the expected value of\nthe immediate reward received when executing the action recommended by \u03c0\nplus the average value (under \u03c0) of all of the states accessible from X.\nFor an optimal policy, \u03c0\u2217(and no others!), we have the famous \u201coptimality\nequation:\u201d\nV \u03c0\u2217(X) = max\na\n\"\nr(X, a) + \u03b3\nX\nX\u2032\np[X\u2032|X, a]V \u03c0\u2217(X\u2032)\n#\nThe theory of dynamic programming (DP) [Bellman, 1957, Ross, 1983] assures\nus that there is at least one optimal policy, \u03c0\u2217, that satis\ufb01es this equation. DP11.4. Q-LEARNING\n147\nalso provides methods for calculating V \u03c0\u2217(X) and at least one \u03c0\u2217, assuming\nthat we know the average rewards and the transition probabilities. If we knew\nthe transition probabilities, the average rewards, and V \u03c0\u2217(X) for all X and a,\nthen it would be easy to implement an optimal policy. We would simply select\nthat a that maximizes r(X, a) + \u03b3 P\nX\u2032 p[X\u2032|X, a]V \u03c0\u2217(X\u2032). That is,\n\u03c0\u2217(X) = arg max\na\n\"\nr(X, a) + \u03b3\nX\nX\u2032\np[X\u2032|X, a]V \u03c0\u2217(X\u2032)\n#\nBut, of course, we are assuming that we do not know these average rewards nor\nthe transition probabilities, so we have to \ufb01nd a method that e\ufb00ectively learns\nthem.\nIf we had a model of actions, that is, if we knew for every state, X, and\naction a, which state, X\u2032 resulted, then we could use a method called value\niteration to \ufb01nd an optimal policy. Value iteration works as follows: We begin\nby assigning, randomly, an estimated value \u02c6\nV (X) to every state, X. On the i-th\nstep of the process, suppose we are at state Xi (that is, our input on the i-th\nstep is Xi), and that the estimated value of state Xi on the i-th step is \u02c6\nVi(Xi).\nWe then select that action a that maximizes the estimated value of the predicted\nsubsequent state. Suppose this subsequent state having the highest estimated\nvalue is X\u2032\ni. Then we update the estimated value, \u02c6\nVi(Xi), of state Xi as follows:\n\u02c6\nVi(X) = (1 \u2212ci) \u02c6\nVi\u22121(X) + ci\nh\nri + \u03b3 \u02c6\nVi\u22121(X\u2032\ni)\ni\nif X = Xi,\n= \u02c6\nVi\u22121(X)\notherwise.\nWe see that this adjustment moves the value of \u02c6\nVi(Xi) an increment (depend-\ning on ci) closer to\nh\nri + \u03b3 \u02c6\nVi(X\u2032\ni)\ni\n. Assuming that \u02c6\nVi(X\u2032\ni) is a good estimate for\nVi(X\u2032\ni), then this adjustment helps to make the two estimates more consistent.\nProviding that 0 < ci < 1 and that we visit each state in\ufb01nitely often, this\nprocess of value iteration will converge to the optimal values.\nDiscuss synchronous dynamic\nprogramming, asynchronous\ndynamic programming, and policy\niteration.\n11.4\nQ-Learning\nWatkins [Watkins, 1989] has proposed a technique that he calls incremental\ndynamic programming. Let a; \u03c0 stand for the policy that chooses action a once,\nand thereafter chooses actions according to policy \u03c0. We de\ufb01ne:\nQ\u03c0(X, a) = V a;\u03c0(X)148\nCHAPTER 11. DELAYED-REINFORCEMENT LEARNING\nThen the optimal value from state X is given by:\nV \u03c0\u2217(X) = max\na\nQ\u03c0\u2217(X, a)\nThis equation holds only for an optimal policy, \u03c0\u2217. The optimal policy is given\nby:\n\u03c0\u2217(X) = arg max\na\nQ\u03c0\u2217(X, a)\nNote that if an action a makes Q\u03c0(X, a) larger than V \u03c0(X), then we can improve\n\u03c0 by changing it so that \u03c0(X) = a. Making such a change is the basis for a\npowerful learning rule that we shall describe shortly.\nSuppose action a in state X leads to state X\u2032. Then using the de\ufb01nitions of\nQ and V , it is easy to show that:\nQ\u03c0(X, a) = r(X, a) + \u03b3E[V \u03c0(X\u2032)]\nwhere r(X, a) is the average value of the immediate reward received when we\nexecute action a in state X. For an optimal policy (and no others), we have\nanother version of the optimality equation in terms of Q values:\nQ\u03c0\u2217(X, a) = max\na\nh\nr(X, a) + \u03b3E\nh\nQ\u03c0\u2217(X\u2032, a)\nii\nfor all actions, a, and states, X. Now, if we had the optimal Q values (for all\na and X), then we could implement an optimal policy simply by selecting that\naction that maximized r(X, a) + \u03b3E\n\u0002\nQ\u03c0\u2217(X\u2032, a)\n\u0003\n.\nThat is,\n\u03c0\u2217(X) = arg max\na\nh\nr(X, a) + \u03b3E\nh\nQ\u03c0\u2217(X\u2032, a)\nii\nWatkins\u2019 proposal amounts to a TD(0) method of learning the Q values.\nWe quote (with minor notational changes) from [Watkins & Dayan, 1992, page\n281]:\n\u201cIn Q-Learning, the agent\u2019s experience consists of a sequence of dis-\ntinct stages or episodes. In the i-th episode, the agent:\n\u2022 observes its current state Xi,\n\u2022 selects [using the method described below] and performs an\naction ai,\n\u2022 observes the subsequent state X\u2032\ni,\n\u2022 receives an immediate reward ri, and11.4. Q-LEARNING\n149\n\u2022 adjusts its Qi\u22121 values using a learning factor ci, according to:\nQi(X, a) = (1 \u2212ci)Qi\u22121(X, a) + ci[ri + \u03b3Vi\u22121(X\u2032\ni)]\nif X = Xi and a = ai,\n= Qi\u22121(X, a)\notherwise,\nwhere\nVi\u22121(X\u2032) = max\nb\n[Qi\u22121(X\u2032, b)]\nis the best the agent thinks it can do from state X\u2032. . . . The\ninitial Q values, Q0(X, a), for all states and actions are assumed\ngiven.\u201d\nUsing the current Q values, Qi(X, a), the agent always selects that action\nthat maximizes Qi(X, a).\nNote that only the Q value corresponding to the\nstate just exited and the action just taken is adjusted. And that Q value is\nadjusted so that it is closer (by an amount determined by ci) to the sum of\nthe immediate reward plus the discounted maximum (over all actions) of the Q\nvalues of the state just entered. If we imagine the Q values to be predictions of\nultimate (in\ufb01nite horizon) total reward, then the learning procedure described\nabove is exactly a TD(0) method of learning how to predict these Q values.\nQ learning strengthens the usual TD methods, however, because TD (applied\nto reinforcement problems using value iteration) requires a one-step lookahead,\nusing a model of the e\ufb00ects of actions, whereas Q learning does not.\nA convenient notation (proposed by [Schwartz, 1993]) for representing the\nchange in Q value is:\nQ(X, a)\n\u03b2\n\u2190\n\u2212r + \u03b3V (X\u2032)\nwhere Q(X, a) is the new Q value for input X and action a, r is the immediate\nreward when action a is taken in response to input X, V (X\u2032) is the maximum\n(over all actions) of the Q value of the state next reached when action a is taken\nfrom state X, and \u03b2 is the fraction of the way toward which the new Q value,\nQ(X, a), is adjusted to equal r + \u03b3V (X\u2032).\nWatkins and Dayan [Watkins & Dayan, 1992] prove that, under certain con-\nditions, the Q values computed by this learning procedure converge to optimal\nones (that is, to ones on which an optimal policy can be based).\nWe de\ufb01ne ni(X, a) as the index (episode number) of the i-th time that action\na is tried in state X. Then, we have:150\nCHAPTER 11. DELAYED-REINFORCEMENT LEARNING\nTheorem 11.1 (Watkins and Dayan) For Markov problems with states {X}\nand actions {a}, and given bounded rewards |rn| \u2264R, learning rates 0 \u2264cn < 1,\nand\n\u221e\nX\ni=0\ncni(X,a) = \u221e,\n\u221e\nX\ni=0\n\u0002\ncni(X,a)\n\u00032 < \u221e\nfor all X and a, then\nQn(X, a) \u2192Q\u2217\nn(X, a) as n \u2192\u221e, for all X and a, with probability 1, where\nQ\u2217\nn(X, a) corresponds to the Q values of an optimal policy.\nAgain, we quote from [Watkins & Dayan, 1992, page 281]:\n\u201cThe most important condition implicit in the convergence theorem\n. . . is that the sequence of episodes that forms the basis of learning\nmust include an in\ufb01nite number of episodes for each starting state\nand action. This may be considered a strong condition on the way\nstates and actions are selected\u2014however, under the stochastic con-\nditions of the theorem, no method could be guaranteed to \ufb01nd an\noptimal policy under weaker conditions. Note, however, that the\nepisodes need not form a continuous sequence\u2014that is the X\u2032 of one\nepisode need not be the X of the next episode.\u201d\nThe relationships among Q learning, dynamic programming, and control\nare very well described in [Barto, Bradtke, & Singh, 1994]. Q learning is best\nthought of as a stochastic approximation method for calculating the Q values.\nAlthough the de\ufb01nition of the optimal Q values for any state depends recursively\non expected values of the Q values for subsequent states (and on the expected\nvalues of rewards), no expected values are explicitly computed by the procedure.\nInstead, these values are approximated by iterative sampling using the actual\nstochastic mechanism that produces successor states.\n11.5\nDiscussion, Limitations, and Extensions of\nQ-Learning\n11.5.1\nAn Illustrative Example\nThe Q-learning procedure requires that we maintain a table of Q(X, a) values\nfor all state-action pairs. In the grid world that we described earlier, such a\ntable would not be excessively large. We might start with random entries in the\ntable; a portion of such an intial table might be as follows:11.5. DISCUSSION, LIMITATIONS, AND EXTENSIONS OF Q-LEARNING151\nX\na\nQ(X, a)\nr(X, a)\n(2,3)\nw\n7\n0\n(2,3)\nn\n4\n0\n(2,3)\ne\n3\n0\n(2,3)\ns\n6\n0\n(1,3)\nw\n4\n-1\n(1,3)\nn\n5\n0\n(1,3)\ne\n2\n0\n(1,3)\ns\n4\n0\nSuppose the robot is in cell (2,3). The maximum Q value occurs for a = w, so the\nrobot moves west to cell (1,3)\u2014receiving no immediate reward. The maximum\nQ value in cell (1,3) is 5, and the learning mechanism attempts to make the\nvalue of Q((2, 3), w) closer to the discounted value of 5 plus the immediate\nreward (which was 0 in this case). With a learning rate parameter c = 0.5\nand \u03b3 = 0.9, the Q value of Q((2, 3), w) is adjusted from 7 to 5.75. No other\nchanges are made to the table at this episode. The reader might try this learning\nprocedure on the grid world with a simple computer program. Notice that an\noptimal policy might not be discovered if some cells are not visited nor some\nactions not tried frequently enough.\nThe learning problem faced by the agent is to associate speci\ufb01c actions with\nspeci\ufb01c input patterns. Q learning gradually reinforces those actions that con-\ntribute to positive rewards by increasing the associated Q values. Typically, as\nin this example, rewards occur somewhat after the actions that lead to them\u2014\nhence the phrase delayed-reinforcement learning. One can imagine that better\nand better approximations to the optimal Q values gradually propagate back\nfrom states producing rewards toward all of the other states that the agent fre-\nquently visits. With random Q values to begin, the agent\u2019s actions amount to a\nrandom walk through its space of states. Only when this random walk happens\nto stumble into rewarding states does Q learning begin to produce Q values\nthat are useful, and, even then, the Q values have to work their way outward\nfrom these rewarding states. The general problem of associating rewards with\nstate-action pairs is called the temporal credit assignment problem\u2014how should\ncredit for a reward be apportioned to the actions leading up to it? Q learning is,\nto date, the most successful technique for temporal credit assignment, although\na related method, called the bucket brigade algorithm, has been proposed by\n[Holland, 1986].\nLearning problems similar to that faced by the agent in our grid world have\nbeen thoroughly studied by Sutton who has proposed an architecture, called\nDYNA, for solving them [Sutton, 1990]. DYNA combines reinforcement learning\nwith planning. Sutton characterizes planning as learning in a simulated world\nthat models the world that the agent inhabits. The agent\u2019s model of the world\nis obtained by Q learning in its actual world, and planning is accomplished by\nQ learning in its model of the world.\nWe should note that the learning problem faced by our grid-world robot152\nCHAPTER 11. DELAYED-REINFORCEMENT LEARNING\ncould be modi\ufb01ed to have several places in the grid that give positive rewards.\nThis possibility presents an interesting way to generalize the classical notion of\na \u201cgoal\u201d in AI planning systems\u2014even in those that do no learning. Instead of\nrepresenting a goal as a condition to be achieved, we represent a \u201cgoal struc-\nture\u201d as a set of rewards to be given for achieving various conditions. Then,\nthe generalized \u201cgoal\u201d becomes maximizing discounted future reward instead of\nsimply achieving some particular condition. This generalization can be made to\nencompass so-called goals of maintenance and goals of avoidance. The exam-\nple presented above included avoiding bumping into the grid-world boundary.\nA goal of maintenance, of a particular state, could be expressed in terms of a\nreward that was earned whenever the agent was in that state and performed an\naction that transitioned back to that state in one step.\n11.5.2\nUsing Random Actions\nWhen the next pattern presentation in a sequence of patterns is the one caused\nby the agent\u2019s own action in response to the last pattern, we have what is called\nan on-line learning method. In Watkins and Dayan\u2019s terminology, in on-line\nlearning the episodes form a continous sequence. As already mentioned, the\nconvergence theorem for Q learning does not require on-line learning; indeed,\nspecial precautions must be taken to ensure that on-line learning meets the\nconditions of the theorem.\nIf on-line learning discovers some good paths to\nrewards, the agent may \ufb01xate on these and never discover a policy that leads\nto a possibly greater long-term reward. In reinforcement learning phraseology,\nthis problem is referred to as the problem of exploitation (of already learned\nbehavior) versus exploration (of possibly better behavior).\nOne way to force exploration is to perform occasional random actions (in-\nstead of that single action prescribed by the current Q values). For example,\nin the grid-world problem, one could imagine selecting an action randomly ac-\ncording to a probability distribution over the actions (n, e, s, and w).\nThis\ndistribution, in turn, could depend on the Q values. For example, we might\n\ufb01rst \ufb01nd that action prescribed by the Q values and then choose that action\nwith probability 1/2, choose the two orthogonal actions with probability 3/16\neach, and choose the opposite action with probability 1/8. This policy might be\nmodi\ufb01ed by \u201csimulated annealing\u201d which would gradually increase the probabil-\nity of the action prescribed by the Q values more and more as time goes on. This\nstrategy would favor exploration at the beginning of learning and exploitation\nlater.\nOther methods, also, have been proposed for dealing with exploration, in-\ncluding making unvisited states intrinsically rewarding and using an \u201cinterval\nestimate,\u201d which is related to the uncertainty in the estimate of a state\u2019s value\n[Kaelbling, 1993].11.5. DISCUSSION, LIMITATIONS, AND EXTENSIONS OF Q-LEARNING153\n11.5.3\nGeneralizing Over Inputs\nFor large problems it would be impractical to maintain a table like that used\nin our grid-world example. Various researchers have suggested mechanisms for\ncomputing Q values, given pattern inputs and actions. One method that sug-\ngests itself is to use a neural network. For example, consider the simple linear\nmachine shown in Fig. 11.4.\nX\n. . .\n. . .\nY\nY\nY\ntrainable weights\nY\nWi\nR dot product units\nQ(ai, X) = X . Wi\nQ(a1, X)\nQ(a2, X)\nQ(aR, X)\nFigure 11.4: A Net that Computes Q Values\nSuch a neural net could be used by an agent that has R actions to select\nfrom. The Q values (as a function of the input pattern X and the action ai) are\ncomputed as dot products of weight vectors (one for each action) and the input\nvector. Weight adjustments are made according to a TD(0) procedure to bring\nthe Q value for the action last selected closer to the sum of the immediate reward\n(if any) and the (discounted) maximum Q value for the next input pattern.\nIf the optimum Q values for the problem (whatever they might be) are more\ncomplex than those that can be computed by a linear machine, a layered neural\nnetwork might be used. Sigmoid units in the \ufb01nal layer would compute Q values\nin the range 0 to 1. The TD(0) method for updating Q values would then have to\nbe combined with a multi-layer weight-changing rule, such as backpropagation.\nNetworks of this sort are able to aggregate di\ufb00erent input vectors into regions\nfor which the same action should be performed. This kind of aggregation is an\nexample of what has been called structural credit assignment. Combining TD(\u03bb)\nand backpropagation is a method for dealing with both the temporal and the\nstructural credit assignment problems.154\nCHAPTER 11. DELAYED-REINFORCEMENT LEARNING\nInteresting examples of delayed-reinforcement training of simulated and\nactual robots requiring structural credit assignment have been reported by\n[Lin, 1992, Mahadevan & Connell, 1992].\n11.5.4\nPartially Observable States\nSo far, we have identi\ufb01ed the input vector, X, with the actual state of the envi-\nronment. When the input vector results from an agent\u2019s perceptual apparatus\n(as we assume it does), there is no reason to suppose that it uniquely identi\ufb01es\nthe environmental state. Because of inevitable perceptual limitations, several\ndi\ufb00erent environmental states might give rise to the same input vector. This\nphenomenon has been referred to as perceptual aliasing. With perceptual alias-\ning, we can no longer guarantee that Q learning will result in even useful action\npolicies, let alone optimal ones. Several researchers have attempted to deal with\nthis problem using a variety of methods including attempting to model \u201chid-\nden\u201d states by using internal memory [Lin, 1993]. That is, if some aspect of\nthe environment cannot be sensed currently, perhaps it was sensed once and\ncan be remembered by the agent. When such is the case, we no longer have a\nMarkov problem; that is, the next X vector, given any action, may depend on\na sequence of previous ones rather than just the immediately preceding one. It\nmight be possible to reinstate a Markov framework (over the X\u2019s) if X includes\nnot only current sensory precepts but information from the agent\u2019s memory.\n11.5.5\nScaling Problems\nSeveral di\ufb03culties have so far prohibited wide application of reinforcement learn-\ning to large problems. (The TD-gammon program, mentioned in the last chap-\nter, is probably unique in terms of success on a high-dimensional problem.)\nWe have already touched on some di\ufb03culties; these and others are summarized\nbelow with references to attempts to overcome them.\na. Exploration versus exploitation.\n\u2022 use random actions\n\u2022 favor states not visited recently\n\u2022 separate the learning phase from the use phase\n\u2022 employ a teacher to guide exploration\nb. Slow time to convergence\n\u2022 combine learning with prior knowledge; use estimates of Q values\n(rather than random values) initially\n\u2022 use a hierarchy of actions; learn primitive actions \ufb01rst and freeze the\nuseful sequences into macros and then learn how to use the macros11.6. BIBLIOGRAPHICAL AND HISTORICAL REMARKS\n155\n\u2022 employ a teacher; use graded \u201clessons\u201d\u2014starting near the rewards\nand then backing away, and use examples of good behavior [Lin, 1992]\n\u2022 use more e\ufb03cient computations; e.g. do several updates per episode\n[Moore & Atkeson, 1993]\nc. Large state spaces\n\u2022 use hand-coded features\n\u2022 use neural networks\n\u2022 use nearest-neighbor methods [Moore, 1990]\nd. Temporal discounting problems. Using small \u03b3 can make the learner too\ngreedy for present rewards and indi\ufb00erent to the future; but using large \u03b3\nslows down learning.\n\u2022 use a learning method based on average rewards [Schwartz, 1993]\ne. No \u201ctransfer\u201d of learning . What is learned depends on the reward struc-\nture; if the rewards change, learning has to start over.\n\u2022 Separate the learning into two parts: learn an \u201caction model\u201d which\npredicts how actions change states (and is constant over all prob-\nlems), and then learn the \u201cvalues\u201d of states by reinforcement learn-\ning for each di\ufb00erent set of rewards. Sometimes the reinforcement\nlearning part can be replaced by a \u201cplanner\u201d that uses the action\nmodel to produce plans to achieve goals.\nAlso see other articles in the special issue on reinforcement learning: Machine\nLearning, 8, May, 1992.\n11.6\nBibliographical and Historical Remarks\nTo be added.156\nCHAPTER 11. DELAYED-REINFORCEMENT LEARNING"}